# AstraWeave vs. Unreal Engine 5 - Capability Parity Matrix

This document provides a comprehensive gap analysis of the AstraWeave engine against Unreal Engine 5, outlining the path to feature parity and identifying opportunities for AI-native differentiation.

## 1. Rendering & Scene

| Capability | UE5 Feature | AstraWeave Status | Technical Notes & Code Links | Work Needed | Complexity | Dependencies | Acceptance Criteria | Owner (TBD) |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **Global Illumination** | **Lumen** | ‚ùå | The engine currently uses a simple forward renderer with basic lighting. No GI solution is implemented. See `astraweave-render/src/lighting.rs`. | Implement a real-time GI solution. Start with a probe-based system (DDGI) and evaluate SDF-based or RT-based approaches. | L | `astraweave-render`, `wgpu` RT support | A Cornell Box scene demonstrates convincing multi-bounce indirect lighting. Dynamic lights update GI correctly. | |
| **Virtualized Geometry** | **Nanite** | ‚ùå | Meshes are loaded and rendered directly. No meshlet-based rendering, virtualized geometry, or HLOD system exists. See `astraweave-render/src/mesh.rs`. | Design and implement a meshlet-based rendering pipeline. This includes a pre-processing step to generate meshlets, a visibility buffer, and a material-aware rasterization pass. | L | `astraweave-render`, `astraweave-asset` | A scene with millions of polygons renders at interactive framerates. Mesh complexity is decoupled from performance. | |
| **Temporal Upscaling** | **TSR / DLSS / FSR** | ‚ùå | The renderer outputs to a swapchain directly. No temporal anti-aliasing or upscaling is implemented. | Integrate a temporal anti-aliasing solution (TAA) first. Then, add hooks for vendor-specific upscalers like DLSS and FSR 2+. | M | `astraweave-render` | Jittered rendering with motion vectors produces a stable, anti-aliased image. Upscaling from a lower resolution produces a high-quality result. | |
| **Advanced Shading** | **Material System** | ‚ö†Ô∏è | A basic PBR material system exists (`astraweave-render/src/material.rs`). It supports albedo, normal, and MRA textures. It lacks support for clearcoat, anisotropy, subsurface scattering, and other advanced shading models. | Extend the material system and shader library to support a wider range of PBR shading models. Implement a more flexible material definition format. | M | `astraweave-render`, `astraweave-asset` | A material showcase scene demonstrates all supported shading models correctly. | |
| **Scene Composition** | **Sequencer** | ‚ùå | No timeline-based animation or scene composition tool exists. Cinematics are currently handled via hardcoded scripts. | Create a `Sequencer`-like tool. This involves a data model for tracks, sections, and keyframes, an editor UI, and a runtime evaluation engine. | L | `astraweave-cinematics`, `aw_editor` | A short cinematic with camera cuts, animated characters, and VFX can be created and played back in-engine. | |
| **World Building** | **World Partition** | ‚ùå | The engine loads entire scenes at once. No support for level streaming, world partitioning, or data layers. | Implement a grid-based world partitioning system. Assets and entities are associated with grid cells, which are streamed in and out based on camera position. | L | `astraweave-scene`, `astraweave-asset` | A large open world can be explored seamlessly without loading screens. Memory usage remains bounded. | |

## 2. Physics & Simulation

| Capability | UE5 Feature | AstraWeave Status | Technical Notes & Code Links | Work Needed | Complexity | Dependencies | Acceptance Criteria | Owner (TBD) |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| **Rigid Body Dynamics** | **Chaos Physics** | ‚úÖ | The engine uses `rapier3d` for rigid body simulation, which is a capable and modern physics engine. See `astraweave-physics/src/lib.rs`. | The foundation is solid. Work is needed to expose more advanced features of Rapier, like more joint types and solver settings. | S | `astraweave-physics` | A physics stress test scene with many interacting objects runs at a stable framerate. | |
| **Character Controller** | **CharacterMovementComponent** | ‚ö†Ô∏è | A custom character controller is implemented in `astraweave-physics/src/lib.rs`. It handles basic movement, but lacks features like network prediction, fluid movement on complex terrain, and integration with an ability system. | Enhance the character controller to support networked prediction, a wider range of movement states (swimming, flying), and better interaction with dynamic objects. | M | `astraweave-physics`, `astraweave-net` | The character can smoothly navigate a complex environment with slopes, stairs, and dynamic obstacles. Movement feels responsive in a networked game. | |
| **Cloth & Soft Body** | **Chaos Cloth** | ‚ùå | No cloth or soft body simulation is implemented. `rapier3d` has some support for soft bodies, but it's not integrated. | Integrate `rapier3d`'s soft-body simulation. Implement a cloth authoring pipeline for skinning cloth to characters. | L | `astraweave-physics`, `astraweave-asset` | A character with a flowing cape runs and jumps correctly, with the cloth colliding with the character's body and the world. | |
| **Destruction** | **Chaos Destruction** | ‚ùå | Stub functions for destructibles exist (`add_destructible_box`), but there is no implementation for fracturing meshes or handling geometry collections. | Implement a system for fracturing meshes into destructible chunks (e.g., using Voronoi diagrams). Create a `GeometryCollection`-like component that manages the fractured state. | L | `astraweave-physics`, `astraweave-asset` | A wall can be fractured and destroyed by a projectile, with the resulting debris interacting realistically with the physics world. | |
| **Vehicles** | **Chaos Vehicles** | ‚ùå | No vehicle simulation is implemented. | Implement a vehicle simulation model using `rapier3d`'s joint and suspension features. Create a component for authoring vehicle properties (e.g., engine, wheels, suspension). | M | `astraweave-physics` | A simple car can be driven around a test track, with realistic suspension and tire physics. | |

## 3. World Systems

| Capability | UE5 Feature | AstraWeave Status | Technical Notes & Work Needed | Complexity | Dependencies | Acceptance Criteria | Owner (TBD) |
| --- | --- | --- | --- | --- | --- | --- | --- |
| **World Partitioning** | World Partition, Data Layers | ‚ùå | **Status**: No equivalent system. `astraweave-terrain` has a `ChunkManager` for procedural terrain streaming, but it's not a generic solution. **Work**: Design a generic spatial partitioning system to manage loading/unloading of *all* entity types, not just terrain. Implement data layers for fine-grained streaming control. | L | `astraweave-core` (ECS), `astraweave-asset` | 1. Editor can define spatial grids and data layers. 2. Entities are streamed in/out based on player position. 3. Headless tests validate streaming logic. | |
| **Level Streaming & HLODs** | Level Streaming, HLOD Generation | ‚ùå | **Status**: No support for streaming discrete levels or generating HLODs. **Work**: 1. Implement an async asset loader in `astraweave-asset`. 2. Create a `Level` or `Sub-scene` concept. 3. Develop a system to generate simplified mesh and material proxies for distant objects (HLODs). This could start with mesh merging and texture atlasing. | L | `astraweave-render`, `astraweave-asset` | 1. Load/unload scenes asynchronously. 2. Distant objects are replaced by HLODs. 3. Golden image tests validate HLOD correctness. | |
| **Terrain & Foliage** | Landscape Editor, Foliage Mode | ‚ö†Ô∏è | **Status**: `astraweave-terrain` provides strong procedural generation but no manual tools. **Work**: 1. Create an editor-facing terrain tool for sculpting and painting heightmaps. 2. Develop a foliage painting tool that interacts with the terrain system. 3. Integrate procedural generation with manual edits, allowing artists to refine generated landscapes. | M | `aw_editor`, `astraweave-terrain` | 1. Editor has tools for terrain sculpting/painting. 2. Artists can paint foliage instances onto the terrain. 3. Changes are saved and correctly loaded. | |
| **Navigation** | NavMesh Generation, Dynamic Updates | ‚ö†Ô∏è | **Status**: `astraweave-nav` has A* pathfinding on a static, manually-fed navmesh. **Work**: 1. Integrate `NavMesh::bake` with `astraweave-terrain` and `astraweave-render` to generate navmeshes from world geometry automatically. 2. Implement dynamic navmesh updates using a library like `recast-rs` or by tracking dynamic obstacles. 3. Add support for different agent sizes. | M | `astraweave-physics`, `astraweave-terrain` | 1. Navmesh is automatically generated for scenes. 2. Agents can pathfind around dynamic obstacles. 3. Tests validate pathing for different agent sizes. | |
| **Asset Management** | Asset Manager, Reference Viewer | ‚ùå | **Status**: Assets are loaded directly from file paths. No central management. **Work**: Create an `AssetManager` to track asset dependencies, handle hot-reloading, and manage asset metadata. Implement a reference viewer in the editor. | M | `astraweave-asset`, `aw_editor` | 1. Assets are loaded via a central manager. 2. Changes to assets on disk are hot-reloaded in-editor. 3. Editor can visualize asset dependencies. | |

### 4. VFX & Rendering

| Capability | Unreal Engine 5 Feature | AstraWeave Equivalent | Parity Status | Gap Analysis & Execution Plan |
| :--- | :--- | :--- | :--- | :--- |
| **Core Pipeline** | Deferred Renderer, Nanite, Virtual Shadow Maps | `wgpu`-based Forward Renderer | üîª **Major Gap** | **Gap**: UE5 uses a deferred renderer optimized for many lights, plus Nanite for virtualized geometry and VSMs for high-res shadows. AstraWeave has a traditional forward renderer with basic shadow mapping. <br> **Plan**: This is the largest gap. A near-term plan is to implement a Deferred Rendering pipeline. A longer-term R&D effort (`EPIC-VGEOM`) should be initiated to explore bindless rendering and mesh shaders for a Nanite-like system. |
| **Shading & Materials** | Node-Based Material Editor, Material Layers, Instancing | TOML-defined `MaterialPackDesc`, GPU Texture Arrays | üîª **Major Gap** | **Gap**: UE5's artist-friendly node editor allows for infinite shader complexity. AstraWeave's TOML-based system is rigid, efficient, but programmer-centric. <br> **Plan**: Create a visual node-based material editor (`TASK-MAT-EDITOR`) that compiles graphs into AstraWeave's `MaterialPackDesc` format. This bridges the authoring gap while retaining the efficient runtime model. |
| **Lighting** | Lumen Global Illumination & Reflections, Sky Atmosphere | IBL, Single Directional Light w/ 2-Cascade CSM | üîª **Major Gap** | **Gap**: Lumen provides fully dynamic, real-time global illumination. AstraWeave has a basic lighting model (one sun + IBL). Placeholders for clustered lighting exist but are not used. <br> **Plan**: Implement Clustered Forward Rendering (`TASK-LIGHT-CLUSTER`) to support thousands of point lights efficiently. Integrate a Voxel-based GI (VXGI) or SDF-based GI solution as a medium-term goal (`EPIC-LIGHT-GI`) to approach Lumen's quality. |
| **Post-Processing** | Post Process Volumes, Tone Mapping, Bloom, DoF, AO, SSR | `BloomPipeline`, ACES Tonemapper, Placeholders for SSAO/SSR | üü† **Moderate Gap** | **Gap**: AstraWeave has a solid foundation with a `wgpu` post-processing chain, including a quality bloom effect. However, it lacks the comprehensive, easily configurable suite of effects in UE5. <br> **Plan**: Implement the placeholder SSAO and SSR effects (`TASK-POSTFX-SSAO`, `TASK-POSTFX-SSR`). Create a `PostProcessVolume` component (`TASK-POSTFX-VOL`) to control settings spatially. |
| **VFX & Particles** | Niagara Visual Effects System (CPU/GPU Particles, Fluids) | Basic CPU-based weather particle system (`WeatherFx`) | üîª **Major Gap** | **Gap**: Niagara is a deeply integrated, programmable VFX powerhouse. AstraWeave's system is a simple, special-purpose weather effect. <br> **Plan**: Design and implement a component-based GPU particle system (`EPIC-VFX-GPU`). Expose it to the scripting engine to allow for dynamic, gameplay-driven effects. |
| **Animation** | Skeletal Mesh, Control Rig, Animation Blueprints | GPU Skinning (`skinning_gpu` feature), `awc` for cinematics | üü† **Moderate Gap** | **Gap**: AstraWeave has the fundamentals of GPU-driven skeletal animation. It lacks UE5's advanced authoring tools like Control Rig and state machine-based Animation Blueprints. <br> **Plan**: Develop an in-engine Animation State Machine (`TASK-ANIM-SM`) that can be defined in Rhai scripts. This provides a flexible, AI-native alternative to UE5's Animation Blueprints. |

### 5. Audio

| Capability | Unreal Engine 5 Feature | AstraWeave Equivalent | Parity Status | Gap Analysis & Execution Plan |
| :--- | :--- | :--- | :--- | :--- |
| **Core Engine** | MetaSounds, Quartz, Sound Cues, Middleware (Wwise/FMOD) | `rodio`-based `AudioEngine` | üîª **Major Gap** | **Gap**: UE5's MetaSounds is a fully programmable DSP engine. AstraWeave uses a simple playback library (`rodio`) with no real-time effects (reverb, EQ, compression). <br> **Plan**: This is a significant gap. A near-term win is to integrate a library like `kira` for more robust channel management and basic effects (`TASK-AUDIO-KIRA`). A long-term goal (`EPIC-AUDIO-DSP`) is to design a minimal, graph-based sound processing system inspired by MetaSounds. |
| **Spatialization** | HRTF, Object-Based Audio, Attenuation Curves, Reverb Volumes | `rodio::SpatialSink` per-emitter, Listener Pose | üü† **Moderate Gap** | **Gap**: AstraWeave has functional 3D audio with emitter/listener positioning. It lacks UE5's advanced features like volumetric reverb, complex attenuation curves, and HRTF for realistic binaural audio. <br> **Plan**: Expose attenuation settings in the `SpatialSink` management (`TASK-AUDIO-ATTEN`). Implement a simple reverb system using convolution with impulse responses (`TASK-AUDIO-REVERB`). |
| **Music System** | Quartz for sample-accurate scheduling, interactive music | `MusicChannel` with crossfading | üü† **Moderate Gap** | **Gap**: The music system is basic but functional for linear playback and crossfading. It lacks a robust event-based system for interactive music that can react to gameplay states. <br> **Plan**: Enhance the `MusicChannel` to be a state machine that can transition between segments based on gameplay events sent from the scripting engine (`TASK-AUDIO-MUSIC-SM`). |
| **Dialogue & Voice** | Dialogue Waves, Localization tools | `DialoguePlayer`, `VoiceBank`, `TtsAdapter` | ‚úÖ **At Parity** | **Gap**: None. AstraWeave's system is arguably *more flexible* for an AI-native engine. The data-driven `VoiceBank`, explicit overrides, and pluggable TTS adapter provide a powerful and robust pipeline for both pre-recorded and dynamically generated dialogue. <br> **Plan**: No action needed. This is a model of good design. |
| **Authoring** | In-editor Sound Cue editor, MetaSounds graph editor | TOML files (`voices.toml`, `dialogue_audio_map.toml`) | üîª **Major Gap** | **Gap**: All audio configuration is done in text files. UE5 provides rich, visual in-editor tools. <br> **Plan**: As part of the `EPIC-AUDIO-DSP` initiative, create a simple node-based editor for the future sound graph system. For now, the TOML-based approach is sufficient for the current feature set. |

### 6. Gameplay & Scripting

| Capability | Unreal Engine 5 Feature | AstraWeave Equivalent | Parity Status | Gap Analysis & Execution Plan |
| :--- | :--- | :--- | :--- | :--- |
| **Gameplay Framework** | Gameplay Ability System (GAS), Gameplay Tags | ECS Components & Systems (`astraweave-gameplay`) | üü† **Moderate Gap** | **Gap**: UE5's GAS is a highly-structured, networked framework for abilities and attributes. AstraWeave uses a more fundamental ECS approach with components like `CAttackState`, `CQuestLog`, and `CCraftingQueue`. It's flexible but lacks the built-in structure and network prediction of GAS. <br> **Plan**: For an AI-native, single-player focused engine, this is an acceptable gap. The current ECS model is clean and sufficient. A future `EPIC-GAMEPLAY-ABILITIES` could be planned if complex, networked multiplayer becomes a priority. |
| **Core Mechanics** | CharacterMovementComponent, Standard RPG systems via Marketplace | `combat.rs`, `crafting.rs`, `quests.rs` | ‚úÖ **At Parity** | **Gap**: None. AstraWeave provides solid, built-in implementations for core RPG mechanics: a combo-based combat system, resource-based crafting, and a flexible quest system. This is a strength, as it doesn't rely on external packages. <br> **Plan**: No action needed. These systems are well-designed and serve as a strong foundation. |
| **World-Altering Gameplay** | Level Scripting, Sequencer | **Weaving System** (`weaving.rs`) | üü¢ **Surpasses** | **Gap**: AstraWeave surpasses typical UE5 capabilities here. The "Weaving" system is a first-class mechanic for AI (or players) to enact large-scale, systemic world changes (e.g., `CollapseBridge`, `RedirectWind`) with explicit budgets and consequences. This is a core differentiator. <br> **Plan**: This is a key feature to lean into. Expand the library of `WeaveOp`s (`TASK-WEAVE-EXPAND`) and expose the `WeaveBudget` and `WeaveConsequence` systems more directly to AI agents. |
| **Scripting** | Blueprints Visual Scripting, C++ | Rhai Scripting, Rust | üü† **Moderate Gap** | **Gap**: Blueprints are a mature, artist-friendly visual scripting language. Rhai is a capable embedded text-based language, but it lacks the discoverability and ease of use of a node-based system. <br> **Plan**: The choice of Rhai is solid for a Rust-native engine. The gap is in tooling. Create a Visual Studio Code extension (`TASK-RHAI-TOOLS`) that provides better syntax highlighting, autocompletion for engine APIs, and in-editor documentation for Rhai scripts. |
| **AI Authoring** | Behavior Trees, Environment Query System (EQS) | `astraweave-ai` (Planner, Orchestrator), Rhai | üü¢ **Surpasses** | **Gap**: AstraWeave's AI-first architecture is a paradigm shift. Instead of bolting on Behavior Trees, its core loop is built around Perception->Reasoning->Planning->Action. The `Orchestrator` and `PlanIntent` system is more flexible and powerful for emergent, goal-oriented AI than traditional BTs. <br> **Plan**: This is the engine's core strength. Continue to build on this foundation. Enhance the `WorldSnapshot` system to provide richer perceptual data to agents (`TASK-AI-PERCEPTION`). |

### 7. Networking

| Capability | Unreal Engine 5 Feature | AstraWeave Equivalent | Parity Status | Gap Analysis & Execution Plan |
| :--- | :--- | :--- | :--- | :--- |
| **Core Architecture** | Replication System (Replicated Properties & RPCs), Client-Side Prediction | `astraweave-net` crate (Snapshot/Delta Sync, Interest Management) | üü† **Moderate Gap** | **Gap**: UE5 has a mature, battle-tested replication system with built-in client-side prediction and lag compensation for many standard components (`CharacterMovementComponent`). AstraWeave has a strong foundation for state synchronization but lacks a generic, out-of-the-box client-side prediction framework. <br> **Plan**: The current delta-sync system is excellent for state replication. The next step is to implement a generic client-side prediction and reconciliation system (`EPIC-NET-PREDICT`). This would involve running a client-side `World` simulation and rolling it back when server corrections arrive. |
| **State Synchronization** | Property Replication | Snapshot/Delta system with `EntityState` and `EntityDelta` | ‚úÖ **At Parity** | **Gap**: None. AstraWeave's approach is functionally equivalent and well-suited to an ECS architecture. The server computes snapshots, and the `diff_snapshots` function generates efficient deltas by comparing against the client's last known state. |
| **Relevancy & Scalability** | Replication Graph, Net Cull Distance | **Interest Management** (`RadiusTeamInterest`, `FovInterest`, `FovLosInterest`) | üü¢ **Surpasses** | **Gap**: AstraWeave's Interest Management is more granular and powerful than UE5's default distance-based culling. The `FovLosInterest` policy, which includes line-of-sight checks, is a sophisticated feature that ensures clients only receive data they can possibly see, significantly improving scalability in complex environments. <br> **Plan**: This is a major strength. Continue to refine and optimize the LOS checks. |
| **Determinism & Debugging** | Replay System (DemoNetDriver) | `ReplayEvent` log and `replay_from` function | ‚úÖ **At Parity** | **Gap**: None. AstraWeave's replay system is excellent. By logging deterministic `PlanIntent` inputs and re-simulating them with the `replay_from` function, it provides a robust mechanism for debugging, testing, and cheat detection, which is on par with UE5's replay capabilities. <br> **Plan**: No action needed. |
| **Transport** | UDP (Unreal Datagram Protocol) | WebSockets (`tokio-tungstenite`) | ‚ö†Ô∏è **Philosophical Difference** | **Gap**: UE5 uses UDP, the standard for low-latency, real-time games. AstraWeave uses WebSockets (which are TCP-based). This choice prioritizes ease of use and web compatibility over raw performance. For the AI-native, potentially less twitch-focused games AstraWeave is designed for, this is an acceptable trade-off. <br> **Plan**: Monitor performance. If latency becomes a critical issue for certain game types, plan a migration to a UDP-based transport layer like `laminar` or `webrtc` (`TASK-NET-UDP`). |

### 8. Tooling & Authoring

| Capability | AstraWeave | Unreal Engine 5 | Parity Status | Gap Analysis & Execution Plan |
| :--- | :--- | :--- | :--- | :--- |
| **Editor** | <ul><li>**AstraWeave Editor**: A comprehensive, multi-pane editor built with `egui`. It provides integrated visual tools for many engine systems.</li><li>**Asset Pipeline CLI**: A sophisticated, rule-based command-line tool (`aw_asset_cli`) for processing, compressing, and packaging assets.</li><li>**Scripting**: `rhai` scripting is used for authoring dynamic encounter logic (`astraweave-author`).</li></ul> | <ul><li>**Unreal Editor**: A mature, world-class editor with a vast array of integrated tools.</li><li>**Blueprints**: A powerful visual scripting system that is deeply integrated into all engine systems.</li><li>**Asset Management**: Robust, integrated asset manager with support for virtual assets and a marketplace.</li></ul> | <ul><li>**Visual Scripting**: AstraWeave lacks a Blueprint-equivalent. `astraweave-author` is script-file-based, not visual or node-based.</li><li>**Editor Maturity**: The `aw_editor` is functional but lacks the polish, feature depth, and extensibility of the Unreal Editor. It is a collection of panels rather than a seamlessly integrated environment.</li><li>**Material Authoring**: The material editor is for instance parameters only; it cannot create new shaders graphically. UE has a full-featured node-based material and shader graph editor.</li></ul> | <ul><li>**Phase 1: Foundational Tooling (Current)**: The `aw_asset_cli` is already very strong and can be considered near-parity for its purpose. The `aw_editor` provides essential visualization and editing for core systems (dialogue, behavior, quests).</li><li>**Phase 2: Editor Integration & Polish**: Focus on making the `aw_editor` more robust. Implement a "selection" model to link the scene hierarchy to the inspector. Add gizmos for manipulating objects in a 3D viewport. Improve the layout and docking system.</li><li>**Phase 3: Visual Scripting (Blueprint Equivalent)**: This is the largest gap. Design a node-based visual scripting system that can operate on the ECS. This would involve creating a graph representation, a UI (`egui`-based), and a compiler that translates the graph into executable code or ECS components. This would likely replace or supplement the `rhai`-based authoring.</li><li>**Phase 4: Advanced Authoring**: Develop a graphical shader/material editor that can generate WGSL code. Build a more advanced world-building toolset, moving beyond the simple terrain painter to support procedural placement and complex scene composition.</li></ul> |

### 9. Platforms & Packaging

| Capability | AstraWeave | Unreal Engine 5 | Parity Status | Gap Analysis & Execution Plan |
| :--- | :--- | :--- | :--- | :--- |
| **Build & Packaging** | <ul><li>**Build System**: Standard Cargo and Rust toolchain.</li><li>**Platform Support**: Core logic is platform-agnostic Rust. Rendering via `wgpu` supports Vulkan, Metal, DX12.</li><li>**Packaging**: The `aw_asset_cli` creates a signed, compressed asset bundle, but there is no integrated application packager.</li></ul> | <ul><li>**Unreal Build Tool (UBT)**: A custom C++ build system.</li><li>**Multi-Platform Packaging**: One-click packaging and deployment for a huge range of platforms (consoles, mobile, desktop, VR).</li><li>**Patching & DLC**: Advanced support for creating patches and managing downloadable content.</li></ul> | <ul><li>**Application Packaging**: AstraWeave has no built-in tools for creating a final, distributable application (e.g., an `.exe` with all assets). This is a manual process.</li><li>**Console/Mobile Support**: While `wgpu` has the backend potential, significant work is needed for platform-specific SDK integration, input handling, and performance optimization for consoles and mobile devices.</li><li>**Patching/DLC**: No infrastructure exists for patching or content delivery. The signed manifest from the asset pipeline is a good foundation but is not a full solution.</li></ul> | <ul><li>**Phase 1: Desktop Packaging**: Create a build script (e.g., in `xtask`) that automates the process of building the release binary, running the asset pipeline, and bundling the executable and the `assets` directory into a distributable `.zip` file for each desktop platform (Windows, macOS, Linux).</li><li>**Phase 2: Foundational Mobile/Web Support**: Target WebAssembly first via `wasm-bindgen` and `wgpu`'s WebGL/WebGPU backends. Create a minimal web-based application shell to host the engine. This proves out the cross-platform packaging workflow.</li><li>**Phase 3: Console Integration**: This is a major undertaking requiring platform-specific SDKs. Focus on one console platform first. Abstract platform-specific APIs behind a new `astraweave-platform` crate. The goal is to get a minimal application running, handling input and graphics context creation.</li><li>**Phase 4: Advanced Content Delivery**: Design a system for managing DLC and patches. This would involve extending the asset manifest system to support multiple, layered manifests and a runtime system for loading asset bundles on demand.</li></ul> |
