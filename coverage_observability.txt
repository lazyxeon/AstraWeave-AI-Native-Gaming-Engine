C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\archetype.rs:
    1|       |//! AstraWeave ECS — Production-grade, AI-native ECS for game development.
    2|       |
    3|       |use std::any::TypeId;
    4|       |use std::collections::{BTreeMap, HashMap};
    5|       |
    6|       |#[cfg(feature = "profiling")]
    7|       |use astraweave_profiling::span;
    8|       |
    9|       |use crate::sparse_set::SparseSet;
   10|       |use crate::{Component, Entity};
   11|       |
   12|       |/// Unique identifier for an archetype (set of component types)
   13|       |#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
   14|       |pub struct ArchetypeId(u64);
   15|       |
   16|       |/// Describes the component layout of an archetype
   17|       |#[derive(Clone, Debug, PartialEq, Eq, Hash)]
   18|       |pub struct ArchetypeSignature {
   19|       |    /// Sorted list of component TypeIds for deterministic comparison
   20|       |    pub components: Vec<TypeId>,
   21|       |}
   22|       |
   23|       |impl ArchetypeSignature {
   24|      0|    pub fn new(mut components: Vec<TypeId>) -> Self {
   25|      0|        components.sort_unstable();
   26|      0|        components.dedup();
   27|      0|        Self { components }
   28|      0|    }
   29|       |
   30|      0|    pub fn contains(&self, ty: TypeId) -> bool {
   31|      0|        self.components.binary_search(&ty).is_ok()
   32|      0|    }
   33|       |
   34|      0|    pub fn len(&self) -> usize {
   35|      0|        self.components.len()
   36|      0|    }
   37|       |
   38|      0|    pub fn is_empty(&self) -> bool {
   39|      0|        self.components.is_empty()
   40|      0|    }
   41|       |}
   42|       |
   43|       |/// Archetype storage: all entities with the same component signature
   44|       |pub struct Archetype {
   45|       |    pub id: ArchetypeId,
   46|       |    pub signature: ArchetypeSignature,
   47|       |
   48|       |    /// NEW: Packed entity list for iteration (cache-friendly)
   49|       |    entities: Vec<Entity>,
   50|       |
   51|       |    /// NEW: O(1) entity lookup (replaces BTreeMap)
   52|       |    entity_index: SparseSet,
   53|       |
   54|       |    /// Component columns: TypeId -> Vec<Box<dyn Any>>
   55|       |    /// NOTE: Still using Box for now (type-erased storage)
   56|       |    /// Future: Replace with BlobVec once we add type registry
   57|       |    components: HashMap<TypeId, Vec<Box<dyn std::any::Any + Send + Sync>>>,
   58|       |}
   59|       |
   60|       |impl Archetype {
   61|      0|    pub fn new(id: ArchetypeId, signature: ArchetypeSignature) -> Self {
   62|      0|        let mut components = HashMap::new();
   63|      0|        for ty in &signature.components {
   64|      0|            components.insert(*ty, Vec::new());
   65|      0|        }
   66|      0|        Self {
   67|      0|            id,
   68|      0|            signature,
   69|      0|            entities: Vec::new(),
   70|      0|            entity_index: SparseSet::new(),
   71|      0|            components,
   72|      0|        }
   73|      0|    }
   74|       |
   75|       |    /// Add an entity with its components (must match signature)
   76|      0|    pub fn add_entity(
   77|      0|        &mut self,
   78|      0|        entity: Entity,
   79|      0|        mut component_data: HashMap<TypeId, Box<dyn std::any::Any + Send + Sync>>,
   80|      0|    ) {
   81|       |        // NEW: Use SparseSet for O(1) lookup (12-57× faster than BTreeMap)
   82|      0|        self.entity_index.insert(entity);
   83|      0|        self.entities.push(entity);
   84|       |
   85|      0|        for ty in &self.signature.components {
   86|      0|            if let Some(data) = component_data.remove(ty) {
   87|      0|                // Move the Box from component_data into the column
   88|      0|                let column = self
   89|      0|                    .components
   90|      0|                    .get_mut(ty)
   91|      0|                    .expect("BUG: signature component should have column");
   92|      0|                column.push(data);
   93|      0|            }
   94|       |        }
   95|      0|    }
   96|       |
   97|       |    /// Get component for entity
   98|      0|    pub fn get<T: Component>(&self, entity: Entity) -> Option<&T> {
   99|       |        // NEW: O(1) lookup with SparseSet (12-57× faster than BTreeMap)
  100|      0|        let row = self.entity_index.get(entity)?;
  101|      0|        let column = self.components.get(&TypeId::of::<T>())?;
  102|      0|        let boxed = column.get(row)?;
  103|      0|        boxed.downcast_ref::<T>()
  104|      0|    }
  105|       |
  106|       |    /// Get mutable component for entity
  107|      0|    pub fn get_mut<T: Component>(&mut self, entity: Entity) -> Option<&mut T> {
  108|       |        // NEW: O(1) lookup with SparseSet (12-57× faster than BTreeMap)
  109|      0|        let row = self.entity_index.get(entity)?;
  110|      0|        let column = self.components.get_mut(&TypeId::of::<T>())?;
  111|      0|        let boxed = column.get_mut(row)?;
  112|      0|        boxed.downcast_mut::<T>()
  113|      0|    }
  114|       |
  115|      0|    pub fn remove_entity(&mut self, entity: Entity) -> Option<usize> {
  116|       |        // NEW: O(1) removal with SparseSet (4-7× faster than BTreeMap)
  117|      0|        self.entity_index.remove(entity)
  118|      0|    }
  119|       |
  120|       |    /// Remove entity from archetype and return its components
  121|      0|    pub fn remove_entity_components(
  122|      0|        &mut self,
  123|      0|        entity: Entity,
  124|      0|    ) -> HashMap<TypeId, Box<dyn std::any::Any + Send + Sync>> {
  125|       |        // NEW: O(1) removal with SparseSet
  126|      0|        let row = match self.entity_index.remove(entity) {
  127|      0|            Some(r) => r,
  128|      0|            None => return HashMap::new(),
  129|       |        };
  130|       |
  131|       |        // Remove from packed entity list using swap_remove
  132|      0|        let entities_len = self.entities.len();
  133|      0|        if row < entities_len - 1 {
  134|      0|            self.entities.swap(row, entities_len - 1);
  135|      0|            // Update the swapped entity's index in SparseSet
  136|      0|            let swapped_entity = self.entities[row];
  137|      0|            self.entity_index.insert(swapped_entity); // Will update to correct row
  138|      0|        }
  139|      0|        self.entities.pop();
  140|       |
  141|      0|        let mut components = HashMap::new();
  142|      0|        for (ty, column) in self.components.iter_mut() {
  143|      0|            let component = column.swap_remove(row);
  144|      0|            components.insert(*ty, component);
  145|      0|        }
  146|       |
  147|      0|        components
  148|      0|    }
  149|       |
  150|      0|    pub fn len(&self) -> usize {
  151|      0|        self.entities.len()
  152|      0|    }
  153|       |
  154|      0|    pub fn is_empty(&self) -> bool {
  155|      0|        self.entities.is_empty()
  156|      0|    }
  157|       |
  158|       |    /// Get a slice of entities in this archetype (zero-cost, cache-friendly!)
  159|      0|    pub fn entities_vec(&self) -> &[Entity] {
  160|      0|        &self.entities
  161|      0|    }
  162|       |
  163|       |    /// Iterate over (entity, component) pairs for batch processing.
  164|       |    ///
  165|       |    /// This is much faster than repeated get() calls as it avoids per-entity lookups.
  166|       |    ///
  167|       |    /// ## Performance Notes (Week 10)
  168|       |    ///
  169|       |    /// With SparseSet integration, get() is now O(1) instead of O(log n), providing
  170|       |    /// 12-57× speedup over the old BTreeMap approach. This iterator provides additional
  171|       |    /// benefits by reducing function call overhead and improving cache locality.
  172|       |    ///
  173|       |    /// ## Mutable Iterator Limitation
  174|       |    ///
  175|       |    /// Note: A mutable version (`iter_components_mut<T>()`) is **not feasible** due to
  176|       |    /// Rust's borrow checker limitations. The issue is:
  177|       |    ///
  178|       |    /// ```rust,ignore
  179|       |    /// pub fn iter_components_mut<T>(&mut self) -> impl Iterator<Item = (Entity, &mut T)> {
  180|       |    ///     let column = self.components.get_mut(&TypeId::of::<T>())?;
  181|       |    ///     self.entities.iter().filter_map(|(idx, &entity)| {
  182|       |    ///         column.get_mut(idx)  // ❌ ERROR: captured variable escapes FnMut closure
  183|       |    ///     })
  184|       |    /// }
  185|       |    /// ```
  186|       |    ///
  187|       |    /// Rust prevents this because the closure captures `column` and tries to return
  188|       |    /// `&mut T` borrowed from it. The borrow checker rule is: **references captured in
  189|       |    /// closures cannot escape the closure scope**. This prevents dangling references.
  190|       |    ///
  191|       |    /// **Workarounds considered**:
  192|       |    /// - Unsafe raw pointers: Would work but loses safety guarantees (not worth it)
  193|       |    /// - Index-based batch API: Complex redesign with uncertain performance gains
  194|       |    /// - Type registry + BlobVec: Full solution but requires architectural changes (Week 13+)
  195|       |    ///
  196|       |    /// **Current approach**: Accept that SparseSet O(1) already provides 2.4× frame time
  197|       |    /// improvement (2.70ms → 1.144ms) and 9.4× faster movement (1,000µs → 106µs). Further
  198|       |    /// query optimization has diminishing returns vs complexity/safety trade-offs.
  199|      0|    pub fn iter_components<T: Component>(&self) -> impl Iterator<Item = (Entity, &T)> + '_ {
  200|      0|        let column = self.components.get(&TypeId::of::<T>());
  201|      0|        self.entities
  202|      0|            .iter()
  203|      0|            .enumerate()
  204|      0|            .filter_map(move |(idx, &entity)| {
  205|      0|                column
  206|      0|                    .and_then(|col| col.get(idx))
  207|      0|                    .and_then(|boxed| boxed.downcast_ref::<T>())
  208|      0|                    .map(|component| (entity, component))
  209|      0|            })
  210|      0|    }
  211|       |}
  212|       |
  213|       |/// Manages all archetypes and entity->archetype mapping
  214|       |///
  215|       |/// # Determinism Guarantee
  216|       |///
  217|       |/// **CRITICAL**: This uses `BTreeMap` for archetype storage to ensure deterministic iteration.
  218|       |/// Iteration order is sorted by `ArchetypeId`, which preserves archetype creation order
  219|       |/// (IDs assigned sequentially via `next_id`).
  220|       |///
  221|       |/// **Why BTreeMap?**
  222|       |/// - HashMap iteration order is **non-deterministic** (depends on hash function, memory layout)
  223|       |/// - BTreeMap iteration order is **deterministic** (sorted by key)
  224|       |/// - For AI agents, deterministic entity iteration is **critical** for reproducible behavior
  225|       |///
  226|       |/// **Performance Note**:
  227|       |/// - BTreeMap operations are O(log n) vs HashMap O(1)
  228|       |/// - With ~100 archetypes typical, log₂(100) ≈ 7 operations (negligible)
  229|       |/// - Entity queries iterate archetypes (O(archetypes)), so iteration order matters more than lookup
  230|       |///
  231|       |/// # Zero-Allocation Hot Path
  232|       |///
  233|       |/// **CRITICAL**: Entity-to-archetype mapping uses `Vec<Option<ArchetypeId>>` indexed by entity ID
  234|       |/// instead of HashMap to ensure zero heap allocations during component access hot paths.
  235|       |/// HashMap uses RandomState hasher which can allocate thread-local state on first access.
  236|       |#[derive(Default)]
  237|       |pub struct ArchetypeStorage {
  238|       |    next_id: u64,
  239|       |    /// Map from signature to archetype ID
  240|       |    signature_to_id: HashMap<ArchetypeSignature, ArchetypeId>,
  241|       |    /// All archetypes (BTreeMap for deterministic iteration by ID)
  242|       |    archetypes: BTreeMap<ArchetypeId, Archetype>,
  243|       |    /// Entity to archetype mapping (sparse array indexed by entity ID for zero-alloc lookup)
  244|       |    /// Uses Vec<Option<ArchetypeId>> instead of HashMap for zero-alloc hot path.
  245|       |    entity_to_archetype: Vec<Option<ArchetypeId>>,
  246|       |}
  247|       |
  248|       |impl ArchetypeStorage {
  249|      0|    pub fn new() -> Self {
  250|      0|        Self {
  251|      0|            next_id: 0,
  252|      0|            signature_to_id: HashMap::new(),
  253|      0|            archetypes: BTreeMap::new(),
  254|      0|            entity_to_archetype: Vec::new(),
  255|      0|        }
  256|      0|    }
  257|       |
  258|       |    /// Get or create archetype for a signature
  259|      0|    pub fn get_or_create_archetype(&mut self, signature: ArchetypeSignature) -> ArchetypeId {
  260|      0|        if let Some(&id) = self.signature_to_id.get(&signature) {
  261|      0|            return id;
  262|      0|        }
  263|       |
  264|      0|        let id = ArchetypeId(self.next_id);
  265|      0|        self.next_id += 1;
  266|       |
  267|      0|        let archetype = Archetype::new(id, signature.clone());
  268|      0|        self.archetypes.insert(id, archetype);
  269|      0|        self.signature_to_id.insert(signature, id);
  270|       |
  271|      0|        id
  272|      0|    }
  273|       |
  274|      0|    pub fn get_archetype(&self, id: ArchetypeId) -> Option<&Archetype> {
  275|      0|        self.archetypes.get(&id)
  276|      0|    }
  277|       |
  278|      0|    pub fn get_archetype_mut(&mut self, id: ArchetypeId) -> Option<&mut Archetype> {
  279|      0|        self.archetypes.get_mut(&id)
  280|      0|    }
  281|       |
  282|       |    /// Get archetype for an entity (zero-alloc O(1) lookup)
  283|       |    #[inline]
  284|      0|    pub fn get_entity_archetype(&self, entity: Entity) -> Option<ArchetypeId> {
  285|      0|        let id = entity.id() as usize;
  286|      0|        self.entity_to_archetype.get(id).copied().flatten()
  287|      0|    }
  288|       |
  289|       |    /// Set archetype for an entity (may allocate if entity ID is larger than current capacity)
  290|      0|    pub fn set_entity_archetype(&mut self, entity: Entity, archetype: ArchetypeId) {
  291|      0|        let id = entity.id() as usize;
  292|       |        // Grow the sparse array if needed (only allocates during warmup/setup)
  293|      0|        if id >= self.entity_to_archetype.len() {
  294|      0|            self.entity_to_archetype.resize(id + 1, None);
  295|      0|        }
  296|      0|        self.entity_to_archetype[id] = Some(archetype);
  297|      0|    }
  298|       |
  299|       |    /// Remove archetype mapping for an entity (zero-alloc)
  300|       |    #[inline]
  301|      0|    pub fn remove_entity(&mut self, entity: Entity) -> Option<ArchetypeId> {
  302|      0|        let id = entity.id() as usize;
  303|      0|        if id < self.entity_to_archetype.len() {
  304|      0|            self.entity_to_archetype[id].take()
  305|       |        } else {
  306|      0|            None
  307|       |        }
  308|      0|    }
  309|       |
  310|       |    /// Iterate over all archetypes
  311|      0|    pub fn archetypes(&self) -> impl Iterator<Item = &Archetype> {
  312|      0|        self.archetypes.values()
  313|      0|    }
  314|       |
  315|       |    /// Iterate over all archetypes (alias for consistency with standard iterator naming)
  316|      0|    pub fn iter(&self) -> impl Iterator<Item = &Archetype> {
  317|      0|        self.archetypes.values()
  318|      0|    }
  319|       |
  320|       |    /// Iterate mutably over all archetypes
  321|      0|    pub fn archetypes_mut(&mut self) -> impl Iterator<Item = &mut Archetype> {
  322|      0|        self.archetypes.values_mut()
  323|      0|    }
  324|       |
  325|       |    /// Find archetypes that contain a specific component
  326|      0|    pub fn archetypes_with_component(&self, ty: TypeId) -> impl Iterator<Item = &Archetype> {
  327|       |        #[cfg(feature = "profiling")]
  328|       |        span!("ECS::Archetype::archetypes_with_component");
  329|       |
  330|      0|        self.archetypes
  331|      0|            .values()
  332|      0|            .filter(move |arch| arch.signature.contains(ty))
  333|      0|    }
  334|       |}
  335|       |
  336|       |#[cfg(test)]
  337|       |mod tests {
  338|       |    use super::*;
  339|       |
  340|       |    #[derive(Clone, Copy, Debug, PartialEq)]
  341|       |    struct Health(i32);
  342|       |
  343|       |    #[derive(Clone, Copy, Debug, PartialEq)]
  344|       |    struct Position(f32, f32);
  345|       |
  346|       |    #[test]
  347|       |    fn test_signature_creation() {
  348|       |        let sig1 = ArchetypeSignature::new(vec![TypeId::of::<Health>(), TypeId::of::<Position>()]);
  349|       |        let sig2 = ArchetypeSignature::new(vec![TypeId::of::<Position>(), TypeId::of::<Health>()]);
  350|       |        assert_eq!(sig1, sig2); // Order-independent
  351|       |    }
  352|       |
  353|       |    #[test]
  354|       |    fn test_archetype_storage() {
  355|       |        let mut storage = ArchetypeStorage::new();
  356|       |        let sig = ArchetypeSignature::new(vec![TypeId::of::<Health>()]);
  357|       |
  358|       |        let id1 = storage.get_or_create_archetype(sig.clone());
  359|       |        let id2 = storage.get_or_create_archetype(sig.clone());
  360|       |
  361|       |        assert_eq!(id1, id2); // Same signature returns same archetype
  362|       |    }
  363|       |
  364|       |    // ====================
  365|       |    // Day 3: Surgical Coverage Improvements - archetype.rs
  366|       |    // ====================
  367|       |
  368|       |    #[test]
  369|       |    fn test_signature_methods() {
  370|       |        // Tests contains(), len(), is_empty()
  371|       |        let sig = ArchetypeSignature::new(vec![TypeId::of::<Health>(), TypeId::of::<Position>()]);
  372|       |
  373|       |        assert!(sig.contains(TypeId::of::<Health>()));
  374|       |        assert!(sig.contains(TypeId::of::<Position>()));
  375|       |        assert!(!sig.contains(TypeId::of::<i32>()));
  376|       |
  377|       |        assert_eq!(sig.len(), 2);
  378|       |        assert!(!sig.is_empty());
  379|       |
  380|       |        let empty_sig = ArchetypeSignature::new(vec![]);
  381|       |        assert_eq!(empty_sig.len(), 0);
  382|       |        assert!(empty_sig.is_empty());
  383|       |    }
  384|       |
  385|       |    #[test]
  386|       |    fn test_archetype_entity_operations() {
  387|       |        // Tests add_entity, get, get_mut, len, is_empty, entities_vec
  388|       |        let sig = ArchetypeSignature::new(vec![TypeId::of::<Health>(), TypeId::of::<Position>()]);
  389|       |        let mut archetype = Archetype::new(ArchetypeId(0), sig);
  390|       |
  391|       |        assert_eq!(archetype.len(), 0);
  392|       |        assert!(archetype.is_empty());
  393|       |        assert_eq!(archetype.entities_vec().len(), 0);
  394|       |
  395|       |        // Add entity with components
  396|       |        let entity = unsafe { Entity::from_raw(1) };
  397|       |        let mut components = HashMap::new();
  398|       |        components.insert(
  399|       |            TypeId::of::<Health>(),
  400|       |            Box::new(Health(100)) as Box<dyn std::any::Any + Send + Sync>,
  401|       |        );
  402|       |        components.insert(
  403|       |            TypeId::of::<Position>(),
  404|       |            Box::new(Position(1.0, 2.0)) as Box<dyn std::any::Any + Send + Sync>,
  405|       |        );
  406|       |
  407|       |        archetype.add_entity(entity, components);
  408|       |
  409|       |        assert_eq!(archetype.len(), 1);
  410|       |        assert!(!archetype.is_empty());
  411|       |        assert_eq!(archetype.entities_vec().len(), 1);
  412|       |        assert_eq!(archetype.entities_vec()[0], entity);
  413|       |
  414|       |        // Test get
  415|       |        let health = archetype.get::<Health>(entity).unwrap();
  416|       |        assert_eq!(health.0, 100);
  417|       |
  418|       |        let pos = archetype.get::<Position>(entity).unwrap();
  419|       |        assert_eq!(pos.0, 1.0);
  420|       |        assert_eq!(pos.1, 2.0);
  421|       |
  422|       |        // Test get_mut
  423|       |        {
  424|       |            let health_mut = archetype.get_mut::<Health>(entity).unwrap();
  425|       |            health_mut.0 = 50;
  426|       |        }
  427|       |
  428|       |        let health = archetype.get::<Health>(entity).unwrap();
  429|       |        assert_eq!(health.0, 50);
  430|       |    }
  431|       |
  432|       |    #[test]
  433|       |    fn test_archetype_remove_entity() {
  434|       |        // Tests remove_entity and remove_entity_components
  435|       |        let sig = ArchetypeSignature::new(vec![TypeId::of::<Health>()]);
  436|       |        let mut archetype = Archetype::new(ArchetypeId(0), sig);
  437|       |
  438|       |        let entity1 = unsafe { Entity::from_raw(1) };
  439|       |        let entity2 = unsafe { Entity::from_raw(2) };
  440|       |
  441|       |        let mut components1 = HashMap::new();
  442|       |        components1.insert(
  443|       |            TypeId::of::<Health>(),
  444|       |            Box::new(Health(100)) as Box<dyn std::any::Any + Send + Sync>,
  445|       |        );
  446|       |        archetype.add_entity(entity1, components1);
  447|       |
  448|       |        let mut components2 = HashMap::new();
  449|       |        components2.insert(
  450|       |            TypeId::of::<Health>(),
  451|       |            Box::new(Health(200)) as Box<dyn std::any::Any + Send + Sync>,
  452|       |        );
  453|       |        archetype.add_entity(entity2, components2);
  454|       |
  455|       |        assert_eq!(archetype.len(), 2);
  456|       |
  457|       |        // Remove entity1
  458|       |        let removed_components = archetype.remove_entity_components(entity1);
  459|       |        assert_eq!(archetype.len(), 1);
  460|       |        assert!(removed_components.contains_key(&TypeId::of::<Health>()));
  461|       |
  462|       |        // entity2 should still be accessible
  463|       |        let health = archetype.get::<Health>(entity2).unwrap();
  464|       |        assert_eq!(health.0, 200);
  465|       |
  466|       |        // entity1 should be gone
  467|       |        assert!(archetype.get::<Health>(entity1).is_none());
  468|       |    }
  469|       |
  470|       |    #[test]
  471|       |    fn test_archetype_iter_components() {
  472|       |        // Tests iter_components batch iterator
  473|       |        let sig = ArchetypeSignature::new(vec![TypeId::of::<Health>()]);
  474|       |        let mut archetype = Archetype::new(ArchetypeId(0), sig);
  475|       |
  476|       |        let entity1 = unsafe { Entity::from_raw(1) };
  477|       |        let entity2 = unsafe { Entity::from_raw(2) };
  478|       |        let entity3 = unsafe { Entity::from_raw(3) };
  479|       |
  480|       |        let mut components1 = HashMap::new();
  481|       |        components1.insert(
  482|       |            TypeId::of::<Health>(),
  483|       |            Box::new(Health(100)) as Box<dyn std::any::Any + Send + Sync>,
  484|       |        );
  485|       |        archetype.add_entity(entity1, components1);
  486|       |
  487|       |        let mut components2 = HashMap::new();
  488|       |        components2.insert(
  489|       |            TypeId::of::<Health>(),
  490|       |            Box::new(Health(200)) as Box<dyn std::any::Any + Send + Sync>,
  491|       |        );
  492|       |        archetype.add_entity(entity2, components2);
  493|       |
  494|       |        let mut components3 = HashMap::new();
  495|       |        components3.insert(
  496|       |            TypeId::of::<Health>(),
  497|       |            Box::new(Health(300)) as Box<dyn std::any::Any + Send + Sync>,
  498|       |        );
  499|       |        archetype.add_entity(entity3, components3);
  500|       |
  501|       |        // Collect all health values via iterator
  502|       |        let healths: Vec<i32> = archetype
  503|       |            .iter_components::<Health>()
  504|       |            .map(|(_, health)| health.0)
  505|       |            .collect();
  506|       |
  507|       |        assert_eq!(healths.len(), 3);
  508|       |        assert!(healths.contains(&100));
  509|       |        assert!(healths.contains(&200));
  510|       |        assert!(healths.contains(&300));
  511|       |    }
  512|       |
  513|       |    #[test]
  514|       |    fn test_archetype_storage_comprehensive() {
  515|       |        // Tests get_archetype, get_entity_archetype, set_entity_archetype, remove_entity,
  516|       |        // archetypes(), iter(), archetypes_mut(), archetypes_with_component()
  517|       |        let mut storage = ArchetypeStorage::new();
  518|       |
  519|       |        let sig1 = ArchetypeSignature::new(vec![TypeId::of::<Health>()]);
  520|       |        let sig2 = ArchetypeSignature::new(vec![TypeId::of::<Position>()]);
  521|       |        let sig3 = ArchetypeSignature::new(vec![TypeId::of::<Health>(), TypeId::of::<Position>()]);
  522|       |
  523|       |        let id1 = storage.get_or_create_archetype(sig1);
  524|       |        let id2 = storage.get_or_create_archetype(sig2);
  525|       |        let id3 = storage.get_or_create_archetype(sig3);
  526|       |
  527|       |        // Test get_archetype
  528|       |        assert!(storage.get_archetype(id1).is_some());
  529|       |        assert!(storage.get_archetype(id2).is_some());
  530|       |        assert!(storage.get_archetype(id3).is_some());
  531|       |
  532|       |        // Test entity->archetype mapping
  533|       |        let entity = unsafe { Entity::from_raw(42) };
  534|       |        assert!(storage.get_entity_archetype(entity).is_none());
  535|       |
  536|       |        storage.set_entity_archetype(entity, id1);
  537|       |        assert_eq!(storage.get_entity_archetype(entity), Some(id1));
  538|       |
  539|       |        // Test remove_entity
  540|       |        let removed = storage.remove_entity(entity);
  541|       |        assert_eq!(removed, Some(id1));
  542|       |        assert!(storage.get_entity_archetype(entity).is_none());
  543|       |
  544|       |        // Test archetypes() iterator
  545|       |        let count = storage.archetypes().count();
  546|       |        assert_eq!(count, 3);
  547|       |
  548|       |        // Test iter() (alias)
  549|       |        let count2 = storage.iter().count();
  550|       |        assert_eq!(count2, 3);
  551|       |
  552|       |        // Test archetypes_mut()
  553|       |        let mut_count = storage.archetypes_mut().count();
  554|       |        assert_eq!(mut_count, 3);
  555|       |
  556|       |        // Test archetypes_with_component
  557|       |        let with_health = storage
  558|       |            .archetypes_with_component(TypeId::of::<Health>())
  559|       |            .count();
  560|       |        assert_eq!(with_health, 2); // sig1 and sig3 have Health
  561|       |
  562|       |        let with_position = storage
  563|       |            .archetypes_with_component(TypeId::of::<Position>())
  564|       |            .count();
  565|       |        assert_eq!(with_position, 2); // sig2 and sig3 have Position
  566|       |
  567|       |        let with_nothing = storage
  568|       |            .archetypes_with_component(TypeId::of::<i32>())
  569|       |            .count();
  570|       |        assert_eq!(with_nothing, 0);
  571|       |    }
  572|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\blob_vec.rs:
    1|       |// SPDX-License-Identifier: MIT
    2|       |//! Type-erased contiguous storage for components
    3|       |//!
    4|       |//! Inspired by Bevy's BlobVec, this provides cache-friendly storage without
    5|       |//! the overhead of Box<dyn Any> indirection. Components are stored as raw bytes
    6|       |//! with proper alignment and drop handling.
    7|       |
    8|       |use std::alloc::{alloc, dealloc, realloc, Layout};
    9|       |use std::ptr::{self, NonNull};
   10|       |
   11|       |/// Type-erased vector of components stored contiguously in memory.
   12|       |///
   13|       |/// This is the foundation for high-performance ECS storage, providing:
   14|       |/// - Zero heap indirection (vs Box<dyn Any>)
   15|       |/// - SIMD-friendly contiguous memory
   16|       |/// - Cache-friendly iteration
   17|       |/// - Proper drop handling via function pointer
   18|       |pub struct BlobVec {
   19|       |    /// Raw pointer to the start of component data
   20|       |    data: NonNull<u8>,
   21|       |    /// Number of components currently stored
   22|       |    len: usize,
   23|       |    /// Allocated capacity (in number of components)
   24|       |    capacity: usize,
   25|       |    /// Memory layout of a single component
   26|       |    item_layout: Layout,
   27|       |    /// Function to drop a single component
   28|       |    /// SAFETY: Must be called with a valid pointer to T
   29|       |    drop_fn: Option<unsafe fn(*mut u8)>,
   30|       |}
   31|       |
   32|       |impl BlobVec {
   33|       |    /// Create a new BlobVec for components of type T
   34|      0|    pub fn new<T: 'static>() -> Self {
   35|      0|        let item_layout = Layout::new::<T>();
   36|      0|        let drop_fn = if std::mem::needs_drop::<T>() {
   37|      0|            Some(Self::drop_fn_of::<T>() as unsafe fn(*mut u8))
   38|       |        } else {
   39|      0|            None
   40|       |        };
   41|       |
   42|      0|        Self {
   43|      0|            data: NonNull::dangling(),
   44|      0|            len: 0,
   45|      0|            capacity: 0,
   46|      0|            item_layout,
   47|      0|            drop_fn,
   48|      0|        }
   49|      0|    }
   50|       |
   51|       |    /// Create a new BlobVec with specified capacity
   52|      0|    pub fn with_capacity<T: 'static>(capacity: usize) -> Self {
   53|      0|        let mut blob = Self::new::<T>();
   54|      0|        if capacity > 0 {
   55|      0|            blob.reserve(capacity);
   56|      0|        }
   57|      0|        blob
   58|      0|    }
   59|       |
   60|       |    /// Get the drop function for type T
   61|      0|    fn drop_fn_of<T>() -> unsafe fn(*mut u8) {
   62|       |        |ptr| unsafe {
   63|      0|            ptr.cast::<T>().drop_in_place();
   64|      0|        }
   65|      0|    }
   66|       |
   67|       |    /// Reserve space for at least `additional` more components
   68|      0|    pub fn reserve(&mut self, additional: usize) {
   69|      0|        let required_cap = self.len.checked_add(additional).expect("capacity overflow");
   70|      0|        if required_cap <= self.capacity {
   71|      0|            return;
   72|      0|        }
   73|       |
   74|      0|        let new_capacity = required_cap.max(self.capacity * 2).max(4);
   75|       |
   76|      0|        let new_layout = Layout::from_size_align(
   77|      0|            self.item_layout.size() * new_capacity,
   78|      0|            self.item_layout.align(),
   79|       |        )
   80|      0|        .expect("invalid layout");
   81|       |
   82|      0|        let new_data = if self.capacity == 0 {
   83|       |            // First allocation
   84|      0|            unsafe { NonNull::new(alloc(new_layout)).expect("allocation failed") }
   85|       |        } else {
   86|       |            // Reallocate existing memory
   87|      0|            let old_layout = Layout::from_size_align(
   88|      0|                self.item_layout.size() * self.capacity,
   89|      0|                self.item_layout.align(),
   90|       |            )
   91|      0|            .expect("invalid layout");
   92|       |
   93|       |            unsafe {
   94|      0|                let new_ptr = realloc(self.data.as_ptr(), old_layout, new_layout.size());
   95|      0|                NonNull::new(new_ptr).expect("reallocation failed")
   96|       |            }
   97|       |        };
   98|       |
   99|      0|        self.data = new_data;
  100|      0|        self.capacity = new_capacity;
  101|      0|    }
  102|       |
  103|       |    /// Push a component onto the end of the vector
  104|       |    ///
  105|       |    /// # Safety
  106|       |    /// Type T must match the type this BlobVec was created for
  107|      0|    pub unsafe fn push<T>(&mut self, value: T) {
  108|      0|        if self.len == self.capacity {
  109|      0|            self.reserve(1);
  110|      0|        }
  111|       |
  112|      0|        let ptr = self.data.as_ptr().add(self.len * self.item_layout.size());
  113|      0|        ptr.cast::<T>().write(value);
  114|      0|        self.len += 1;
  115|      0|    }
  116|       |
  117|       |    /// Get a reference to a component at the specified index
  118|       |    ///
  119|       |    /// # Safety
  120|       |    /// - Index must be in bounds
  121|       |    /// - Type T must match the type this BlobVec was created for
  122|      0|    pub unsafe fn get<T>(&self, index: usize) -> Option<&T> {
  123|      0|        if index >= self.len {
  124|      0|            return None;
  125|      0|        }
  126|       |
  127|      0|        let ptr = self.data.as_ptr().add(index * self.item_layout.size());
  128|      0|        Some(&*ptr.cast::<T>())
  129|      0|    }
  130|       |
  131|       |    /// Get a mutable reference to a component at the specified index
  132|       |    ///
  133|       |    /// # Safety
  134|       |    /// - Index must be in bounds
  135|       |    /// - Type T must match the type this BlobVec was created for
  136|      0|    pub unsafe fn get_mut<T>(&mut self, index: usize) -> Option<&mut T> {
  137|      0|        if index >= self.len {
  138|      0|            return None;
  139|      0|        }
  140|       |
  141|      0|        let ptr = self.data.as_ptr().add(index * self.item_layout.size());
  142|      0|        Some(&mut *ptr.cast::<T>())
  143|      0|    }
  144|       |
  145|       |    /// Get the component data as a contiguous slice
  146|       |    ///
  147|       |    /// This is the key to high-performance iteration - direct memory access!
  148|       |    ///
  149|       |    /// # Safety
  150|       |    /// Type T must match the type this BlobVec was created for
  151|      0|    pub unsafe fn as_slice<T>(&self) -> &[T] {
  152|      0|        if self.len == 0 {
  153|      0|            return &[];
  154|      0|        }
  155|      0|        std::slice::from_raw_parts(self.data.as_ptr().cast::<T>(), self.len)
  156|      0|    }
  157|       |
  158|       |    /// Get the component data as a mutable contiguous slice
  159|       |    ///
  160|       |    /// # Safety
  161|       |    /// Type T must match the type this BlobVec was created for
  162|      0|    pub unsafe fn as_slice_mut<T>(&mut self) -> &mut [T] {
  163|      0|        if self.len == 0 {
  164|      0|            return &mut [];
  165|      0|        }
  166|      0|        std::slice::from_raw_parts_mut(self.data.as_ptr().cast::<T>(), self.len)
  167|      0|    }
  168|       |
  169|       |    /// Remove and return the component at the specified index
  170|       |    /// Uses swap_remove for O(1) performance (order not preserved)
  171|       |    ///
  172|       |    /// # Safety
  173|       |    /// - Index must be in bounds
  174|       |    /// - Type T must match the type this BlobVec was created for
  175|      0|    pub unsafe fn swap_remove<T>(&mut self, index: usize) -> T {
  176|      0|        assert!(index < self.len, "index out of bounds");
  177|       |
  178|      0|        let last_index = self.len - 1;
  179|      0|        let ptr = self
  180|      0|            .data
  181|      0|            .as_ptr()
  182|      0|            .add(index * self.item_layout.size())
  183|      0|            .cast::<T>();
  184|       |
  185|      0|        if index != last_index {
  186|      0|            // Swap with last element
  187|      0|            let last_ptr = self
  188|      0|                .data
  189|      0|                .as_ptr()
  190|      0|                .add(last_index * self.item_layout.size())
  191|      0|                .cast::<T>();
  192|      0|            ptr::swap(ptr, last_ptr);
  193|      0|        }
  194|       |
  195|      0|        self.len -= 1;
  196|      0|        ptr::read(
  197|      0|            self.data
  198|      0|                .as_ptr()
  199|      0|                .add(self.len * self.item_layout.size())
  200|      0|                .cast::<T>(),
  201|       |        )
  202|      0|    }
  203|       |
  204|       |    /// Get the number of components stored
  205|      0|    pub fn len(&self) -> usize {
  206|      0|        self.len
  207|      0|    }
  208|       |
  209|       |    /// Check if the BlobVec is empty
  210|      0|    pub fn is_empty(&self) -> bool {
  211|      0|        self.len == 0
  212|      0|    }
  213|       |
  214|       |    /// Get the current capacity
  215|      0|    pub fn capacity(&self) -> usize {
  216|      0|        self.capacity
  217|      0|    }
  218|       |
  219|       |    /// Clear all components, calling their drop functions
  220|      0|    pub fn clear(&mut self) {
  221|      0|        if let Some(drop_fn) = self.drop_fn {
  222|      0|            for i in 0..self.len {
  223|      0|                unsafe {
  224|      0|                    let ptr = self.data.as_ptr().add(i * self.item_layout.size());
  225|      0|                    drop_fn(ptr);
  226|      0|                }
  227|       |            }
  228|      0|        }
  229|      0|        self.len = 0;
  230|      0|    }
  231|       |}
  232|       |
  233|       |impl Drop for BlobVec {
  234|      0|    fn drop(&mut self) {
  235|      0|        self.clear();
  236|       |
  237|      0|        if self.capacity > 0 {
  238|      0|            let layout = Layout::from_size_align(
  239|      0|                self.item_layout.size() * self.capacity,
  240|      0|                self.item_layout.align(),
  241|       |            )
  242|      0|            .expect("invalid layout");
  243|       |
  244|      0|            unsafe {
  245|      0|                dealloc(self.data.as_ptr(), layout);
  246|      0|            }
  247|      0|        }
  248|      0|    }
  249|       |}
  250|       |
  251|       |unsafe impl Send for BlobVec {}
  252|       |unsafe impl Sync for BlobVec {}
  253|       |
  254|       |#[cfg(test)]
  255|       |mod tests {
  256|       |    use super::*;
  257|       |
  258|       |    #[derive(Clone, Copy, Debug, PartialEq)]
  259|       |    struct Position {
  260|       |        x: f32,
  261|       |        y: f32,
  262|       |        z: f32,
  263|       |    }
  264|       |
  265|       |    #[derive(Debug, PartialEq)]
  266|       |    struct DropTest {
  267|       |        value: i32,
  268|       |        dropped: std::rc::Rc<std::cell::Cell<bool>>,
  269|       |    }
  270|       |
  271|       |    impl Drop for DropTest {
  272|       |        fn drop(&mut self) {
  273|       |            self.dropped.set(true);
  274|       |        }
  275|       |    }
  276|       |
  277|       |    #[test]
  278|       |    fn test_push_and_get() {
  279|       |        let mut blob = BlobVec::new::<Position>();
  280|       |
  281|       |        unsafe {
  282|       |            blob.push(Position {
  283|       |                x: 1.0,
  284|       |                y: 2.0,
  285|       |                z: 3.0,
  286|       |            });
  287|       |            blob.push(Position {
  288|       |                x: 4.0,
  289|       |                y: 5.0,
  290|       |                z: 6.0,
  291|       |            });
  292|       |        }
  293|       |
  294|       |        assert_eq!(blob.len(), 2);
  295|       |
  296|       |        unsafe {
  297|       |            let pos1 = blob.get::<Position>(0).unwrap();
  298|       |            assert_eq!(pos1.x, 1.0);
  299|       |            assert_eq!(pos1.y, 2.0);
  300|       |
  301|       |            let pos2 = blob.get::<Position>(1).unwrap();
  302|       |            assert_eq!(pos2.x, 4.0);
  303|       |            assert_eq!(pos2.y, 5.0);
  304|       |        }
  305|       |    }
  306|       |
  307|       |    #[test]
  308|       |    fn test_as_slice() {
  309|       |        let mut blob = BlobVec::new::<Position>();
  310|       |
  311|       |        unsafe {
  312|       |            blob.push(Position {
  313|       |                x: 1.0,
  314|       |                y: 2.0,
  315|       |                z: 3.0,
  316|       |            });
  317|       |            blob.push(Position {
  318|       |                x: 4.0,
  319|       |                y: 5.0,
  320|       |                z: 6.0,
  321|       |            });
  322|       |            blob.push(Position {
  323|       |                x: 7.0,
  324|       |                y: 8.0,
  325|       |                z: 9.0,
  326|       |            });
  327|       |
  328|       |            let slice = blob.as_slice::<Position>();
  329|       |            assert_eq!(slice.len(), 3);
  330|       |            assert_eq!(slice[0].x, 1.0);
  331|       |            assert_eq!(slice[1].x, 4.0);
  332|       |            assert_eq!(slice[2].x, 7.0);
  333|       |        }
  334|       |    }
  335|       |
  336|       |    #[test]
  337|       |    fn test_as_slice_mut() {
  338|       |        let mut blob = BlobVec::new::<Position>();
  339|       |
  340|       |        unsafe {
  341|       |            blob.push(Position {
  342|       |                x: 1.0,
  343|       |                y: 2.0,
  344|       |                z: 3.0,
  345|       |            });
  346|       |            blob.push(Position {
  347|       |                x: 4.0,
  348|       |                y: 5.0,
  349|       |                z: 6.0,
  350|       |            });
  351|       |
  352|       |            let slice = blob.as_slice_mut::<Position>();
  353|       |            slice[0].x = 100.0;
  354|       |            slice[1].y = 200.0;
  355|       |
  356|       |            let slice = blob.as_slice::<Position>();
  357|       |            assert_eq!(slice[0].x, 100.0);
  358|       |            assert_eq!(slice[1].y, 200.0);
  359|       |        }
  360|       |    }
  361|       |
  362|       |    #[test]
  363|       |    fn test_swap_remove() {
  364|       |        let mut blob = BlobVec::new::<Position>();
  365|       |
  366|       |        unsafe {
  367|       |            blob.push(Position {
  368|       |                x: 1.0,
  369|       |                y: 2.0,
  370|       |                z: 3.0,
  371|       |            });
  372|       |            blob.push(Position {
  373|       |                x: 4.0,
  374|       |                y: 5.0,
  375|       |                z: 6.0,
  376|       |            });
  377|       |            blob.push(Position {
  378|       |                x: 7.0,
  379|       |                y: 8.0,
  380|       |                z: 9.0,
  381|       |            });
  382|       |
  383|       |            let removed = blob.swap_remove::<Position>(1);
  384|       |            assert_eq!(removed.x, 4.0);
  385|       |
  386|       |            assert_eq!(blob.len(), 2);
  387|       |
  388|       |            // Element at index 1 should now be the former last element
  389|       |            let pos = blob.get::<Position>(1).unwrap();
  390|       |            assert_eq!(pos.x, 7.0);
  391|       |        }
  392|       |    }
  393|       |
  394|       |    #[test]
  395|       |    fn test_drop_handling() {
  396|       |        let dropped = std::rc::Rc::new(std::cell::Cell::new(false));
  397|       |
  398|       |        {
  399|       |            let mut blob = BlobVec::new::<DropTest>();
  400|       |
  401|       |            unsafe {
  402|       |                blob.push(DropTest {
  403|       |                    value: 42,
  404|       |                    dropped: dropped.clone(),
  405|       |                });
  406|       |            }
  407|       |
  408|       |            assert!(!dropped.get());
  409|       |        } // BlobVec dropped here
  410|       |
  411|       |        assert!(dropped.get());
  412|       |    }
  413|       |
  414|       |    #[test]
  415|       |    fn test_clear() {
  416|       |        let dropped1 = std::rc::Rc::new(std::cell::Cell::new(false));
  417|       |        let dropped2 = std::rc::Rc::new(std::cell::Cell::new(false));
  418|       |
  419|       |        let mut blob = BlobVec::new::<DropTest>();
  420|       |
  421|       |        unsafe {
  422|       |            blob.push(DropTest {
  423|       |                value: 1,
  424|       |                dropped: dropped1.clone(),
  425|       |            });
  426|       |            blob.push(DropTest {
  427|       |                value: 2,
  428|       |                dropped: dropped2.clone(),
  429|       |            });
  430|       |        }
  431|       |
  432|       |        assert!(!dropped1.get());
  433|       |        assert!(!dropped2.get());
  434|       |
  435|       |        blob.clear();
  436|       |
  437|       |        assert!(dropped1.get());
  438|       |        assert!(dropped2.get());
  439|       |        assert_eq!(blob.len(), 0);
  440|       |    }
  441|       |
  442|       |    #[test]
  443|       |    fn test_reserve() {
  444|       |        let mut blob = BlobVec::new::<Position>();
  445|       |        assert_eq!(blob.capacity(), 0);
  446|       |
  447|       |        blob.reserve(10);
  448|       |        assert!(blob.capacity() >= 10);
  449|       |
  450|       |        let old_capacity = blob.capacity();
  451|       |        blob.reserve(5); // Should not reallocate
  452|       |        assert_eq!(blob.capacity(), old_capacity);
  453|       |    }
  454|       |
  455|       |    // ====================
  456|       |    // Day 3: Surgical Coverage Improvements - blob_vec.rs
  457|       |    // ====================
  458|       |
  459|       |    #[test]
  460|       |    fn test_with_capacity() {
  461|       |        // Tests constructor pre-allocation
  462|       |        let blob = BlobVec::with_capacity::<Position>(50);
  463|       |        assert!(blob.capacity() >= 50);
  464|       |        assert_eq!(blob.len(), 0);
  465|       |        assert!(blob.is_empty());
  466|       |    }
  467|       |
  468|       |    #[test]
  469|       |    fn test_with_capacity_zero() {
  470|       |        // Tests edge case: capacity = 0
  471|       |        let blob = BlobVec::with_capacity::<Position>(0);
  472|       |        assert_eq!(blob.capacity(), 0);
  473|       |        assert_eq!(blob.len(), 0);
  474|       |    }
  475|       |
  476|       |    #[test]
  477|       |    fn test_capacity_method() {
  478|       |        // Tests capacity() accessor method
  479|       |        let mut blob = BlobVec::new::<i32>();
  480|       |        assert_eq!(blob.capacity(), 0);
  481|       |
  482|       |        unsafe {
  483|       |            blob.push(42);
  484|       |        }
  485|       |        assert!(blob.capacity() >= 1);
  486|       |
  487|       |        let cap = blob.capacity();
  488|       |        unsafe {
  489|       |            blob.push(99);
  490|       |        }
  491|       |        assert_eq!(blob.capacity(), cap); // Should not reallocate
  492|       |    }
  493|       |
  494|       |    #[test]
  495|       |    fn test_as_slice_empty() {
  496|       |        // Tests as_slice() when len == 0 (early return path)
  497|       |        let blob = BlobVec::new::<Position>();
  498|       |        unsafe {
  499|       |            let slice = blob.as_slice::<Position>();
  500|       |            assert_eq!(slice.len(), 0);
  501|       |        }
  502|       |    }
  503|       |
  504|       |    #[test]
  505|       |    fn test_as_slice_mut_empty() {
  506|       |        // Tests as_slice_mut() when len == 0 (early return path)
  507|       |        let mut blob = BlobVec::new::<Position>();
  508|       |        unsafe {
  509|       |            let slice = blob.as_slice_mut::<Position>();
  510|       |            assert_eq!(slice.len(), 0);
  511|       |        }
  512|       |    }
  513|       |
  514|       |    #[test]
  515|       |    fn test_get_out_of_bounds() {
  516|       |        // Tests get() error handling for invalid index
  517|       |        let mut blob = BlobVec::new::<i32>();
  518|       |        unsafe {
  519|       |            blob.push(10);
  520|       |            blob.push(20);
  521|       |        }
  522|       |
  523|       |        unsafe {
  524|       |            assert!(blob.get::<i32>(0).is_some());
  525|       |            assert!(blob.get::<i32>(1).is_some());
  526|       |            assert!(blob.get::<i32>(2).is_none()); // Out of bounds
  527|       |            assert!(blob.get::<i32>(999).is_none()); // Way out of bounds
  528|       |        }
  529|       |    }
  530|       |
  531|       |    #[test]
  532|       |    fn test_get_mut_out_of_bounds() {
  533|       |        // Tests get_mut() error handling for invalid index
  534|       |        let mut blob = BlobVec::new::<i32>();
  535|       |        unsafe {
  536|       |            blob.push(10);
  537|       |            blob.push(20);
  538|       |        }
  539|       |
  540|       |        unsafe {
  541|       |            assert!(blob.get_mut::<i32>(0).is_some());
  542|       |            assert!(blob.get_mut::<i32>(1).is_some());
  543|       |            assert!(blob.get_mut::<i32>(2).is_none()); // Out of bounds
  544|       |            assert!(blob.get_mut::<i32>(999).is_none()); // Way out of bounds
  545|       |        }
  546|       |    }
  547|       |
  548|       |    #[test]
  549|       |    fn test_swap_remove_last_element() {
  550|       |        // Tests no-swap path when removing last element (index == last_index)
  551|       |        let mut blob = BlobVec::new::<i32>();
  552|       |        unsafe {
  553|       |            blob.push(10);
  554|       |            blob.push(20);
  555|       |            blob.push(30);
  556|       |        }
  557|       |
  558|       |        unsafe {
  559|       |            // Remove last element - should not swap
  560|       |            let removed = blob.swap_remove::<i32>(2);
  561|       |            assert_eq!(removed, 30);
  562|       |            assert_eq!(blob.len(), 2);
  563|       |
  564|       |            // Remaining elements unchanged
  565|       |            assert_eq!(*blob.get::<i32>(0).unwrap(), 10);
  566|       |            assert_eq!(*blob.get::<i32>(1).unwrap(), 20);
  567|       |        }
  568|       |    }
  569|       |
  570|       |    #[test]
  571|       |    fn test_no_drop_type() {
  572|       |        // Tests BlobVec with types that don't need drop (drop_fn = None path)
  573|       |        let mut blob = BlobVec::new::<i32>();
  574|       |
  575|       |        unsafe {
  576|       |            blob.push(1);
  577|       |            blob.push(2);
  578|       |            blob.push(3);
  579|       |        }
  580|       |
  581|       |        assert_eq!(blob.len(), 3);
  582|       |        blob.clear();
  583|       |        assert_eq!(blob.len(), 0);
  584|       |
  585|       |        // Should not panic even though drop_fn is None for i32
  586|       |    }
  587|       |
  588|       |    #[test]
  589|       |    fn test_large_capacity_growth() {
  590|       |        // Tests capacity growth algorithm with large reserves
  591|       |        let mut blob = BlobVec::new::<u8>();
  592|       |
  593|       |        // Force multiple reallocations
  594|       |        blob.reserve(1000);
  595|       |        let cap1 = blob.capacity();
  596|       |        assert!(cap1 >= 1000);
  597|       |
  598|       |        unsafe {
  599|       |            for i in 0..500 {
  600|       |                blob.push(i as u8);
  601|       |            }
  602|       |        }
  603|       |
  604|       |        blob.reserve(2000);
  605|       |        let cap2 = blob.capacity();
  606|       |        assert!(cap2 >= 2500); // 500 existing + 2000 additional
  607|       |
  608|       |        assert_eq!(blob.len(), 500);
  609|       |    }
  610|       |
  611|       |    #[test]
  612|       |    fn test_is_empty() {
  613|       |        // Tests is_empty() method (simple but uncovered)
  614|       |        let mut blob = BlobVec::new::<i32>();
  615|       |        assert!(blob.is_empty());
  616|       |
  617|       |        unsafe {
  618|       |            blob.push(42);
  619|       |        }
  620|       |        assert!(!blob.is_empty());
  621|       |
  622|       |        blob.clear();
  623|       |        assert!(blob.is_empty());
  624|       |    }
  625|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\command_buffer.rs:
    1|       |//! Command buffer for deferred structural changes.
    2|       |//!
    3|       |//! Allows queueing of spawn, insert, remove, and despawn operations that will be
    4|       |//! applied later via `flush()`. This prevents iterator invalidation during iteration.
    5|       |//!
    6|       |//! # Example
    7|       |//! ```
    8|       |//! # use astraweave_ecs::{World, CommandBuffer};
    9|       |//! # #[derive(Clone, Copy, Debug, PartialEq)]
   10|       |//! # struct Position { x: f32, y: f32 }
   11|       |//! # let mut world = World::new();
   12|       |//! # world.register_component::<Position>();
   13|       |//! # let e1 = world.spawn();
   14|       |//! # let e2 = world.spawn();
   15|       |//! let mut commands = CommandBuffer::new();
   16|       |//!
   17|       |//! // Queue operations on entities (safe during iteration)
   18|       |//! commands.insert(e1, Position { x: 10.0, y: 20.0 });
   19|       |//! commands.insert(e2, Position { x: 30.0, y: 40.0 });
   20|       |//!
   21|       |//! // Apply all queued operations (batch update)
   22|       |//! commands.flush(&mut world);
   23|       |//!
   24|       |//! assert_eq!(world.get::<Position>(e1), Some(&Position { x: 10.0, y: 20.0 }));
   25|       |//! ```
   26|       |
   27|       |use crate::{Component, Entity, World};
   28|       |use std::any::{Any, TypeId};
   29|       |
   30|       |/// A command that modifies the World structure.
   31|       |#[derive(Debug)]
   32|       |enum Command {
   33|       |    /// Spawn a new entity with optional components.
   34|       |    Spawn {
   35|       |        /// Components to insert on spawn (type-erased).
   36|       |        components: Vec<(TypeId, Box<dyn Any + Send + Sync>)>,
   37|       |    },
   38|       |    /// Insert a component on an entity.
   39|       |    Insert {
   40|       |        entity: Entity,
   41|       |        type_id: TypeId,
   42|       |        component: Box<dyn Any + Send + Sync>,
   43|       |    },
   44|       |    /// Remove a component from an entity.
   45|       |    Remove { entity: Entity, type_id: TypeId },
   46|       |    /// Despawn an entity.
   47|       |    Despawn { entity: Entity },
   48|       |}
   49|       |
   50|       |/// Buffer for deferred structural changes to the World.
   51|       |///
   52|       |/// Queues spawn, insert, remove, and despawn operations that are applied
   53|       |/// via `flush()`. This allows safe mutation during iteration.
   54|       |///
   55|       |/// # Thread Safety
   56|       |/// CommandBuffer is `!Send + !Sync` to match World's single-threaded access model.
   57|       |pub struct CommandBuffer {
   58|       |    commands: Vec<Command>,
   59|       |    spawn_buffer: Vec<(TypeId, Box<dyn Any + Send + Sync>)>,
   60|       |}
   61|       |
   62|       |impl CommandBuffer {
   63|       |    /// Create a new empty command buffer.
   64|       |    pub fn new() -> Self {
   65|       |        Self {
   66|       |            commands: Vec::new(),
   67|       |            spawn_buffer: Vec::new(),
   68|       |        }
   69|       |    }
   70|       |
   71|       |    /// Create a command buffer with pre-allocated capacity.
   72|       |    pub fn with_capacity(capacity: usize) -> Self {
   73|       |        Self {
   74|       |            commands: Vec::with_capacity(capacity),
   75|       |            spawn_buffer: Vec::new(),
   76|       |        }
   77|       |    }
   78|       |
   79|       |    /// Queue a spawn operation.
   80|       |    ///
   81|       |    /// The entity will be spawned when `flush()` is called. Returns a builder
   82|       |    /// for adding components to the spawned entity.
   83|       |    ///
   84|       |    /// # Example
   85|       |    /// ```
   86|       |    /// # use astraweave_ecs::CommandBuffer;
   87|       |    /// # #[derive(Clone, Copy)]
   88|       |    /// # struct Position { x: f32, y: f32 }
   89|       |    /// # struct Velocity { x: f32, y: f32 }
   90|       |    /// let mut commands = CommandBuffer::new();
   91|       |    /// commands.spawn()
   92|       |    ///     .with(Position { x: 0.0, y: 0.0 })
   93|       |    ///     .with(Velocity { x: 1.0, y: 0.0 });
   94|       |    /// ```
   95|       |    pub fn spawn(&mut self) -> SpawnBuilder<'_> {
   96|       |        SpawnBuilder { buffer: self }
   97|       |    }
   98|       |
   99|       |    /// Queue an insert operation.
  100|       |    ///
  101|       |    /// The component will be inserted when `flush()` is called. If the entity
  102|       |    /// is stale (despawned), the operation is silently ignored.
  103|      0|    pub fn insert<T: Component>(&mut self, entity: Entity, component: T) {
  104|      0|        self.commands.push(Command::Insert {
  105|      0|            entity,
  106|      0|            type_id: TypeId::of::<T>(),
  107|      0|            component: Box::new(component),
  108|      0|        });
  109|      0|    }
  110|       |
  111|       |    /// Queue a remove operation.
  112|       |    ///
  113|       |    /// The component will be removed when `flush()` is called. If the entity
  114|       |    /// is stale or doesn't have the component, the operation is silently ignored.
  115|      0|    pub fn remove<T: Component>(&mut self, entity: Entity) {
  116|      0|        self.commands.push(Command::Remove {
  117|      0|            entity,
  118|      0|            type_id: TypeId::of::<T>(),
  119|      0|        });
  120|      0|    }
  121|       |
  122|       |    /// Queue a despawn operation.
  123|       |    ///
  124|       |    /// The entity will be despawned when `flush()` is called. If the entity
  125|       |    /// is stale (already despawned), the operation is silently ignored.
  126|       |    pub fn despawn(&mut self, entity: Entity) {
  127|       |        self.commands.push(Command::Despawn { entity });
  128|       |    }
  129|       |
  130|       |    /// Apply all queued commands to the World.
  131|       |    ///
  132|       |    /// Commands are applied in FIFO order:
  133|       |    /// 1. Spawn operations
  134|       |    /// 2. Insert operations
  135|       |    /// 3. Remove operations
  136|       |    /// 4. Despawn operations
  137|       |    ///
  138|       |    /// After flushing, the buffer is cleared and ready for reuse.
  139|       |    ///
  140|       |    /// # Panic Safety
  141|       |    /// If a command panics (e.g., component Drop panics), the buffer may be
  142|       |    /// left in a partially-applied state. Use `try_flush()` for Result-based
  143|       |    /// error handling.
  144|       |    pub fn flush(&mut self, world: &mut World) {
  145|       |        for command in self.commands.drain(..) {
  146|       |            match command {
  147|       |                Command::Spawn { components } => {
  148|       |                    let entity = world.spawn();
  149|       |                    for (type_id, component) in components {
  150|       |                        // Type erasure: We know component is T where TypeId::of::<T>() == type_id,
  151|       |                        // but we can't downcast without unsafe. Use insert_raw() or similar.
  152|       |                        // For now, we'll need to refactor World::insert to accept Box<dyn Any>.
  153|       |                        // Deferred: We'll add insert_raw() helper in World.
  154|       |                        world.insert_boxed(entity, type_id, component);
  155|       |                    }
  156|       |                }
  157|       |                Command::Insert {
  158|       |                    entity,
  159|       |                    type_id,
  160|       |                    component,
  161|       |                } => {
  162|       |                    world.insert_boxed(entity, type_id, component);
  163|       |                }
  164|       |                Command::Remove { entity, type_id } => {
  165|       |                    world.remove_by_type_id(entity, type_id);
  166|       |                }
  167|       |                Command::Despawn { entity } => {
  168|       |                    world.despawn(entity);
  169|       |                }
  170|       |            }
  171|       |        }
  172|       |    }
  173|       |
  174|       |    /// Get the number of queued commands.
  175|       |    pub fn len(&self) -> usize {
  176|       |        self.commands.len()
  177|       |    }
  178|       |
  179|       |    /// Check if the buffer is empty.
  180|       |    pub fn is_empty(&self) -> bool {
  181|       |        self.commands.is_empty()
  182|       |    }
  183|       |
  184|       |    /// Clear all queued commands without applying them.
  185|       |    pub fn clear(&mut self) {
  186|       |        self.commands.clear();
  187|       |        self.spawn_buffer.clear();
  188|       |    }
  189|       |}
  190|       |
  191|       |impl Default for CommandBuffer {
  192|       |    fn default() -> Self {
  193|       |        Self::new()
  194|       |    }
  195|       |}
  196|       |
  197|       |/// Builder for spawning entities with components.
  198|       |///
  199|       |/// Created by `CommandBuffer::spawn()`. Chain `with()` calls to add components.
  200|       |pub struct SpawnBuilder<'a> {
  201|       |    buffer: &'a mut CommandBuffer,
  202|       |}
  203|       |
  204|       |impl<'a> SpawnBuilder<'a> {
  205|       |    /// Add a component to the spawned entity.
  206|       |    ///
  207|       |    /// Returns self for chaining.
  208|      0|    pub fn with<T: Component>(self, component: T) -> Self {
  209|      0|        self.buffer
  210|      0|            .spawn_buffer
  211|      0|            .push((TypeId::of::<T>(), Box::new(component)));
  212|      0|        self
  213|      0|    }
  214|       |}
  215|       |
  216|       |impl<'a> Drop for SpawnBuilder<'a> {
  217|      0|    fn drop(&mut self) {
  218|       |        // Finalize spawn command by moving buffered components into Command::Spawn
  219|      0|        let components = std::mem::take(&mut self.buffer.spawn_buffer);
  220|      0|        self.buffer.commands.push(Command::Spawn { components });
  221|      0|    }
  222|       |}
  223|       |
  224|       |// ============================================================================
  225|       |// Tests
  226|       |// ============================================================================
  227|       |
  228|       |#[cfg(test)]
  229|       |mod tests {
  230|       |    use super::*;
  231|       |
  232|       |    #[derive(Clone, Copy, Debug, PartialEq)]
  233|       |    struct Position {
  234|       |        x: f32,
  235|       |        y: f32,
  236|       |    }
  237|       |
  238|       |    #[derive(Clone, Copy, Debug, PartialEq)]
  239|       |    struct Velocity {
  240|       |        x: f32,
  241|       |        y: f32,
  242|       |    }
  243|       |
  244|       |    #[test]
  245|       |    fn test_command_buffer_creation() {
  246|       |        let buffer = CommandBuffer::new();
  247|       |        assert_eq!(buffer.len(), 0);
  248|       |        assert!(buffer.is_empty());
  249|       |    }
  250|       |
  251|       |    #[test]
  252|       |    fn test_command_buffer_with_capacity() {
  253|       |        let buffer = CommandBuffer::with_capacity(10);
  254|       |        assert_eq!(buffer.len(), 0);
  255|       |        assert!(buffer.is_empty());
  256|       |    }
  257|       |
  258|       |    #[test]
  259|       |    fn test_queue_insert() {
  260|       |        let mut buffer = CommandBuffer::new();
  261|       |        let entity = Entity::new(0, 0);
  262|       |
  263|       |        buffer.insert(entity, Position { x: 1.0, y: 2.0 });
  264|       |        assert_eq!(buffer.len(), 1);
  265|       |        assert!(!buffer.is_empty());
  266|       |    }
  267|       |
  268|       |    #[test]
  269|       |    fn test_queue_remove() {
  270|       |        let mut buffer = CommandBuffer::new();
  271|       |        let entity = Entity::new(0, 0);
  272|       |
  273|       |        buffer.remove::<Position>(entity);
  274|       |        assert_eq!(buffer.len(), 1);
  275|       |    }
  276|       |
  277|       |    #[test]
  278|       |    fn test_queue_despawn() {
  279|       |        let mut buffer = CommandBuffer::new();
  280|       |        let entity = Entity::new(0, 0);
  281|       |
  282|       |        buffer.despawn(entity);
  283|       |        assert_eq!(buffer.len(), 1);
  284|       |    }
  285|       |
  286|       |    #[test]
  287|       |    fn test_queue_spawn() {
  288|       |        let mut buffer = CommandBuffer::new();
  289|       |
  290|       |        buffer.spawn().with(Position { x: 1.0, y: 2.0 });
  291|       |        assert_eq!(buffer.len(), 1);
  292|       |    }
  293|       |
  294|       |    #[test]
  295|       |    fn test_spawn_with_multiple_components() {
  296|       |        let mut buffer = CommandBuffer::new();
  297|       |
  298|       |        buffer
  299|       |            .spawn()
  300|       |            .with(Position { x: 1.0, y: 2.0 })
  301|       |            .with(Velocity { x: 0.5, y: 0.0 });
  302|       |
  303|       |        assert_eq!(buffer.len(), 1);
  304|       |    }
  305|       |
  306|       |    #[test]
  307|       |    fn test_clear() {
  308|       |        let mut buffer = CommandBuffer::new();
  309|       |        let entity = Entity::new(0, 0);
  310|       |
  311|       |        buffer.insert(entity, Position { x: 1.0, y: 2.0 });
  312|       |        buffer.despawn(entity);
  313|       |        assert_eq!(buffer.len(), 2);
  314|       |
  315|       |        buffer.clear();
  316|       |        assert_eq!(buffer.len(), 0);
  317|       |        assert!(buffer.is_empty());
  318|       |    }
  319|       |
  320|       |    #[test]
  321|       |    fn test_command_ordering() {
  322|       |        let mut buffer = CommandBuffer::new();
  323|       |        let e1 = Entity::new(0, 0);
  324|       |        let e2 = Entity::new(1, 0);
  325|       |
  326|       |        // Queue in specific order
  327|       |        buffer.spawn().with(Position { x: 1.0, y: 1.0 });
  328|       |        buffer.insert(e1, Velocity { x: 2.0, y: 2.0 });
  329|       |        buffer.remove::<Position>(e2);
  330|       |        buffer.despawn(e1);
  331|       |
  332|       |        assert_eq!(buffer.len(), 4);
  333|       |    }
  334|       |
  335|       |    #[test]
  336|       |    fn test_flush_insert_remove() {
  337|       |        let mut world = World::new();
  338|       |        world.register_component::<Position>();
  339|       |        world.register_component::<Velocity>();
  340|       |
  341|       |        let mut buffer = CommandBuffer::new();
  342|       |        let entity = world.spawn();
  343|       |
  344|       |        buffer.insert(entity, Position { x: 1.0, y: 2.0 });
  345|       |        buffer.flush(&mut world);
  346|       |
  347|       |        assert_eq!(world.get::<Position>(entity), Some(&Position { x: 1.0, y: 2.0 }));
  348|       |    }
  349|       |
  350|       |    #[test]
  351|       |    fn test_multiple_flushes() {
  352|       |        let mut world = World::new();
  353|       |        let mut buffer = CommandBuffer::new();
  354|       |
  355|       |        // First flush (empty)
  356|       |        buffer.flush(&mut world);
  357|       |        assert_eq!(buffer.len(), 0);
  358|       |
  359|       |        // Second flush (empty)
  360|       |        buffer.flush(&mut world);
  361|       |        assert_eq!(buffer.len(), 0);
  362|       |    }
  363|       |
  364|       |    #[test]
  365|       |    fn test_spawn_builder_drop() {
  366|       |        let mut buffer = CommandBuffer::new();
  367|       |
  368|       |        {
  369|       |            let _builder = buffer.spawn().with(Position { x: 1.0, y: 2.0 });
  370|       |            // Builder dropped here, should finalize spawn command
  371|       |        }
  372|       |
  373|       |        assert_eq!(buffer.len(), 1);
  374|       |    }
  375|       |
  376|       |    #[test]
  377|       |    fn test_flush_spawn() {
  378|       |        let mut world = World::new();
  379|       |        world.register_component::<Position>();
  380|       |        world.register_component::<Velocity>();
  381|       |
  382|       |        let mut buffer = CommandBuffer::new();
  383|       |
  384|       |        buffer
  385|       |            .spawn()
  386|       |            .with(Position { x: 5.0, y: 10.0 })
  387|       |            .with(Velocity { x: 1.0, y: 2.0 });
  388|       |
  389|       |        assert_eq!(world.entity_count(), 0);
  390|       |        buffer.flush(&mut world);
  391|       |
  392|       |        assert_eq!(world.entity_count(), 1);
  393|       |    }
  394|       |
  395|       |    #[test]
  396|       |    fn test_flush_despawn() {
  397|       |        let mut world = World::new();
  398|       |        let mut buffer = CommandBuffer::new();
  399|       |
  400|       |        let entity = world.spawn();
  401|       |        assert_eq!(world.entity_count(), 1);
  402|       |
  403|       |        buffer.despawn(entity);
  404|       |        buffer.flush(&mut world);
  405|       |
  406|       |        assert_eq!(world.entity_count(), 0);
  407|       |        assert!(!world.is_alive(entity));
  408|       |    }
  409|       |
  410|       |    #[test]
  411|       |    fn test_insert_during_iteration() {
  412|       |        let mut world = World::new();
  413|       |        world.register_component::<Position>();
  414|       |
  415|       |        let e1 = world.spawn();
  416|       |        let e2 = world.spawn();
  417|       |        let e3 = world.spawn();
  418|       |
  419|       |        let mut buffer = CommandBuffer::new();
  420|       |
  421|       |        for entity in [e1, e2, e3] {
  422|       |            buffer.insert(entity, Position { x: 1.0, y: 2.0 });
  423|       |        }
  424|       |
  425|       |        buffer.flush(&mut world);
  426|       |
  427|       |        assert_eq!(world.get::<Position>(e1), Some(&Position { x: 1.0, y: 2.0 }));
  428|       |        assert_eq!(world.get::<Position>(e2), Some(&Position { x: 1.0, y: 2.0 }));
  429|       |        assert_eq!(world.get::<Position>(e3), Some(&Position { x: 1.0, y: 2.0 }));
  430|       |    }
  431|       |
  432|       |    #[test]
  433|       |    fn test_stale_entity_ignored() {
  434|       |        // This test verifies that stale entities are silently ignored during flush.
  435|       |        // Since insert_boxed checks is_alive() first, it returns early without calling
  436|       |        // the (unimplemented) type dispatch, so no panic occurs.
  437|       |        let mut world = World::new();
  438|       |        world.register_component::<Position>();
  439|       |
  440|       |        let mut buffer = CommandBuffer::new();
  441|       |
  442|       |        let entity = world.spawn();
  443|       |        world.despawn(entity); // Entity now stale
  444|       |
  445|       |        buffer.insert(entity, Position { x: 1.0, y: 2.0 });
  446|       |        buffer.flush(&mut world); // No panic - stale entity ignored
  447|       |
  448|       |        assert!(!world.is_alive(entity));
  449|       |    }
  450|       |
  451|       |    #[test]
  452|       |    fn test_command_ordering_preservation() {
  453|       |        let mut world = World::new();
  454|       |        world.register_component::<Position>();
  455|       |
  456|       |        let mut buffer = CommandBuffer::new();
  457|       |
  458|       |        let e1 = world.spawn();
  459|       |
  460|       |        buffer.insert(e1, Position { x: 1.0, y: 1.0 });
  461|       |        buffer.remove::<Position>(e1);
  462|       |        buffer.insert(e1, Position { x: 2.0, y: 2.0 });
  463|       |
  464|       |        buffer.flush(&mut world);
  465|       |
  466|       |        assert_eq!(world.get::<Position>(e1), Some(&Position { x: 2.0, y: 2.0 }));
  467|       |    }
  468|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\entity_allocator.rs:
    1|       |//! Entity allocator with generational indices for safe entity lifecycle management.
    2|       |//!
    3|       |//! # Problem
    4|       |//!
    5|       |//! Without generational indices, entity IDs are recycled after despawn, leading to
    6|       |//! use-after-free bugs:
    7|       |//!
    8|       |//! ```rust,ignore
    9|       |//! let e1 = world.spawn();  // ID = 1
   10|       |//! world.despawn(e1);
   11|       |//! let e2 = world.spawn();  // ID = 1 (reused!)
   12|       |//! world.get::<Position>(e1);  // ❌ Accesses e2's data! (use-after-free)
   13|       |//! ```
   14|       |//!
   15|       |//! # Solution
   16|       |//!
   17|       |//! Generational indices add a generation counter that increments on reuse:
   18|       |//!
   19|       |//! ```rust,ignore
   20|       |//! let e1 = world.spawn();  // Entity { id: 1, generation: 0 }
   21|       |//! world.despawn(e1);       // Generation[1] = 1
   22|       |//! let e2 = world.spawn();  // Entity { id: 1, generation: 1 }
   23|       |//! world.get::<Position>(e1);  // ✅ Returns None (generation mismatch)
   24|       |//! ```
   25|       |//!
   26|       |//! # Performance
   27|       |//!
   28|       |//! - Entity struct: 64-bit (no size increase from bare u64)
   29|       |//! - Validation: O(1) array lookup
   30|       |//! - Spawn/despawn: O(1) amortized (free list)
   31|       |
   32|       |use std::fmt;
   33|       |
   34|       |/// Entity identifier with generational index for safe lifecycle management.
   35|       |///
   36|       |/// # Memory Layout
   37|       |///
   38|       |/// ```text
   39|       |/// Entity (8 bytes):
   40|       |/// ┌──────────────────────────────────┬──────────────────────────────────┐
   41|       |/// │         ID (32 bits)             │      Generation (32 bits)        │
   42|       |/// └──────────────────────────────────┴──────────────────────────────────┘
   43|       |/// ```
   44|       |///
   45|       |/// - **ID**: Entity index (recycled after despawn)
   46|       |/// - **Generation**: Counter incremented on reuse (detects stale handles)
   47|       |///
   48|       |/// # Guarantees
   49|       |///
   50|       |/// - Deterministic: Same operations → same entities
   51|       |/// - Safe: Stale entity handles rejected (no use-after-free)
   52|       |/// - Ordered: Implements `Ord` for stable iteration
   53|       |#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
   54|       |pub struct Entity {
   55|       |    id: u32,
   56|       |    generation: u32,
   57|       |}
   58|       |
   59|       |impl Entity {
   60|       |    /// Create a new entity with given ID and generation.
   61|       |    ///
   62|       |    /// # Internal Use Only
   63|       |    ///
   64|       |    /// This is used by `EntityAllocator`. User code should use `World::spawn()`.
   65|       |    #[inline]
   66|      0|    pub(crate) fn new(id: u32, generation: u32) -> Self {
   67|      0|        Self { id, generation }
   68|      0|    }
   69|       |
   70|       |    /// Get the entity index (recycled).
   71|       |    ///
   72|       |    /// # Note
   73|       |    ///
   74|       |    /// This is the slot index in the allocator, not a unique identifier.
   75|       |    /// Use the full `Entity` (id + generation) for identity checks.
   76|       |    #[inline]
   77|      0|    pub fn id(&self) -> u32 {
   78|      0|        self.id
   79|      0|    }
   80|       |
   81|       |    /// Get the generation counter.
   82|       |    ///
   83|       |    /// # Generation Semantics
   84|       |    ///
   85|       |    /// - Starts at 0 for first spawn
   86|       |    /// - Increments on each despawn
   87|       |    /// - Used to detect stale entity handles
   88|       |    #[inline]
   89|      0|    pub fn generation(&self) -> u32 {
   90|      0|        self.generation
   91|      0|    }
   92|       |
   93|       |    /// Convert to raw u64 for serialization or external APIs.
   94|       |    ///
   95|       |    /// # Format
   96|       |    ///
   97|       |    /// ```text
   98|       |    /// u64 = (id as u64) | ((generation as u64) << 32)
   99|       |    /// ```
  100|       |    #[inline]
  101|      0|    pub fn to_raw(&self) -> u64 {
  102|      0|        (self.id as u64) | ((self.generation as u64) << 32)
  103|      0|    }
  104|       |
  105|       |    /// Reconstruct entity from raw u64.
  106|       |    ///
  107|       |    /// # Safety
  108|       |    ///
  109|       |    /// The caller must ensure this entity is valid in the target `World`.
  110|       |    /// Use `World::is_alive(entity)` to validate.
  111|       |    #[inline]
  112|      0|    pub unsafe fn from_raw(raw: u64) -> Self {
  113|      0|        Self {
  114|      0|            id: raw as u32,
  115|      0|            generation: (raw >> 32) as u32,
  116|      0|        }
  117|      0|    }
  118|       |
  119|       |    /// Create a null entity (invalid, for initialization).
  120|       |    ///
  121|       |    /// # Note
  122|       |    ///
  123|       |    /// Null entities fail all `is_alive()` checks.
  124|       |    #[inline]
  125|      0|    pub const fn null() -> Self {
  126|      0|        Self {
  127|      0|            id: u32::MAX,
  128|      0|            generation: u32::MAX,
  129|      0|        }
  130|      0|    }
  131|       |
  132|       |    /// Check if this is a null entity.
  133|       |    #[inline]
  134|      0|    pub const fn is_null(&self) -> bool {
  135|      0|        self.id == u32::MAX && self.generation == u32::MAX
  136|      0|    }
  137|       |}
  138|       |
  139|       |impl fmt::Debug for Entity {
  140|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  141|      0|        write!(f, "Entity({}v{})", self.id, self.generation)
  142|      0|    }
  143|       |}
  144|       |
  145|       |impl fmt::Display for Entity {
  146|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  147|      0|        write!(f, "{}v{}", self.id, self.generation)
  148|      0|    }
  149|       |}
  150|       |
  151|       |/// Entity allocator with generational index tracking.
  152|       |///
  153|       |/// # Algorithm
  154|       |///
  155|       |/// - **Free List**: Recycled IDs stored in `Vec<u32>` (LIFO)
  156|       |/// - **Generations**: Per-slot generation counter in `Vec<u32>`
  157|       |/// - **Spawn**: Pop from free list or allocate new ID
  158|       |/// - **Despawn**: Increment generation, push to free list
  159|       |///
  160|       |/// # Complexity
  161|       |///
  162|       |/// - Spawn: O(1) amortized
  163|       |/// - Despawn: O(1)
  164|       |/// - Is Alive: O(1) array lookup
  165|       |///
  166|       |/// # Capacity
  167|       |///
  168|       |/// - Max entities: 2^32 - 1 (4.2 billion)
  169|       |/// - Max generations per slot: 2^32 - 1 (4.2 billion reuses)
  170|       |#[derive(Debug, Clone)]
  171|       |pub struct EntityAllocator {
  172|       |    /// Free list of recycled entity IDs (LIFO)
  173|       |    free_list: Vec<u32>,
  174|       |
  175|       |    /// Generation counter per entity slot
  176|       |    generations: Vec<u32>,
  177|       |
  178|       |    /// Next entity ID if free list is empty
  179|       |    next_id: u32,
  180|       |
  181|       |    /// Total entities spawned (for statistics)
  182|       |    spawned_count: u64,
  183|       |
  184|       |    /// Total entities despawned (for statistics)
  185|       |    despawned_count: u64,
  186|       |}
  187|       |
  188|       |impl EntityAllocator {
  189|       |    /// Create a new entity allocator.
  190|      6|    pub fn new() -> Self {
  191|      6|        Self {
  192|      6|            free_list: Vec::new(),
  193|      6|            generations: Vec::new(),
  194|      6|            next_id: 0,
  195|      6|            spawned_count: 0,
  196|      6|            despawned_count: 0,
  197|      6|        }
  198|      6|    }
  199|       |
  200|       |    /// Create allocator with pre-allocated capacity.
  201|       |    ///
  202|       |    /// # Example
  203|       |    ///
  204|       |    /// ```
  205|       |    /// use astraweave_ecs::entity_allocator::EntityAllocator;
  206|       |    ///
  207|       |    /// let allocator = EntityAllocator::with_capacity(10_000);
  208|       |    /// // No allocations until entity count exceeds 10,000
  209|       |    /// ```
  210|      0|    pub fn with_capacity(capacity: usize) -> Self {
  211|      0|        Self {
  212|      0|            free_list: Vec::new(),
  213|      0|            generations: Vec::with_capacity(capacity),
  214|      0|            next_id: 0,
  215|      0|            spawned_count: 0,
  216|      0|            despawned_count: 0,
  217|      0|        }
  218|      0|    }
  219|       |
  220|       |    /// Spawn a new entity.
  221|       |    ///
  222|       |    /// # Algorithm
  223|       |    ///
  224|       |    /// 1. Pop from free list if available
  225|       |    /// 2. Otherwise allocate new ID
  226|       |    /// 3. Return `Entity { id, generation }`
  227|       |    ///
  228|       |    /// # Example
  229|       |    ///
  230|       |    /// ```
  231|       |    /// use astraweave_ecs::entity_allocator::EntityAllocator;
  232|       |    ///
  233|       |    /// let mut allocator = EntityAllocator::new();
  234|       |    /// let e1 = allocator.spawn();  // Entity(0v0)
  235|       |    /// let e2 = allocator.spawn();  // Entity(1v0)
  236|       |    /// ```
  237|      0|    pub fn spawn(&mut self) -> Entity {
  238|      0|        let id = if let Some(id) = self.free_list.pop() {
  239|       |            // Reuse recycled ID with current generation
  240|      0|            id
  241|       |        } else {
  242|       |            // Allocate new ID
  243|      0|            let id = self.next_id;
  244|      0|            self.next_id = self.next_id.checked_add(1).expect(
  245|      0|                "Entity ID overflow: spawned 2^32 entities. \
  246|      0|                 Consider increasing entity slot size or implementing entity pooling.",
  247|      0|            );
  248|      0|            self.generations.push(0);
  249|      0|            id
  250|       |        };
  251|       |
  252|      0|        let generation = self.generations[id as usize];
  253|      0|        self.spawned_count += 1;
  254|       |
  255|      0|        Entity::new(id, generation)
  256|      0|    }
  257|       |
  258|       |    /// Despawn an entity.
  259|       |    ///
  260|       |    /// # Returns
  261|       |    ///
  262|       |    /// - `true` if entity was alive and despawned
  263|       |    /// - `false` if entity was already dead (stale handle)
  264|       |    ///
  265|       |    /// # Algorithm
  266|       |    ///
  267|       |    /// 1. Check generation matches (is alive)
  268|       |    /// 2. Increment generation
  269|       |    /// 3. Add to free list
  270|       |    ///
  271|       |    /// # Example
  272|       |    ///
  273|       |    /// ```
  274|       |    /// use astraweave_ecs::entity_allocator::EntityAllocator;
  275|       |    ///
  276|       |    /// let mut allocator = EntityAllocator::new();
  277|       |    /// let e1 = allocator.spawn();
  278|       |    ///
  279|       |    /// assert!(allocator.despawn(e1));  // First despawn succeeds
  280|       |    /// assert!(!allocator.despawn(e1)); // Second despawn fails (stale)
  281|       |    /// ```
  282|      0|    pub fn despawn(&mut self, entity: Entity) -> bool {
  283|      0|        let id = entity.id as usize;
  284|       |
  285|       |        // Validate entity exists
  286|      0|        if id >= self.generations.len() {
  287|      0|            return false;
  288|      0|        }
  289|       |
  290|       |        // Check generation (is alive)
  291|      0|        if self.generations[id] != entity.generation {
  292|      0|            return false; // Stale entity
  293|      0|        }
  294|       |
  295|       |        // Increment generation
  296|      0|        self.generations[id] = self.generations[id].wrapping_add(1);
  297|       |
  298|       |        // Add to free list
  299|      0|        self.free_list.push(entity.id);
  300|       |
  301|      0|        self.despawned_count += 1;
  302|       |
  303|      0|        true
  304|      0|    }
  305|       |
  306|       |    /// Check if an entity is alive.
  307|       |    ///
  308|       |    /// # Returns
  309|       |    ///
  310|       |    /// - `true` if entity ID and generation match
  311|       |    /// - `false` if entity is dead or never existed
  312|       |    ///
  313|       |    /// # Complexity
  314|       |    ///
  315|       |    /// O(1) array lookup
  316|       |    ///
  317|       |    /// # Example
  318|       |    ///
  319|       |    /// ```
  320|       |    /// use astraweave_ecs::entity_allocator::EntityAllocator;
  321|       |    ///
  322|       |    /// let mut allocator = EntityAllocator::new();
  323|       |    /// let e1 = allocator.spawn();
  324|       |    ///
  325|       |    /// assert!(allocator.is_alive(e1));
  326|       |    ///
  327|       |    /// allocator.despawn(e1);
  328|       |    /// assert!(!allocator.is_alive(e1));
  329|       |    /// ```
  330|       |    #[inline]
  331|      0|    pub fn is_alive(&self, entity: Entity) -> bool {
  332|      0|        let id = entity.id as usize;
  333|      0|        self.generations
  334|      0|            .get(id)
  335|      0|            .map(|&gen| gen == entity.generation)
  336|      0|            .unwrap_or(false)
  337|      0|    }
  338|       |
  339|       |    /// Get the current generation for an entity slot.
  340|       |    ///
  341|       |    /// Returns `None` if the ID has never been allocated.
  342|       |    #[inline]
  343|      0|    pub fn generation(&self, id: u32) -> Option<u32> {
  344|      0|        self.generations.get(id as usize).copied()
  345|      0|    }
  346|       |
  347|       |    /// Get total number of entities currently alive.
  348|       |    #[inline]
  349|      0|    pub fn alive_count(&self) -> usize {
  350|      0|        (self.spawned_count - self.despawned_count) as usize
  351|      0|    }
  352|       |
  353|       |    /// Get total number of entity slots allocated.
  354|       |    #[inline]
  355|      0|    pub fn capacity(&self) -> usize {
  356|      0|        self.generations.len()
  357|      0|    }
  358|       |
  359|       |    /// Get total number of entities spawned (including despawned).
  360|       |    #[inline]
  361|      0|    pub fn spawned_count(&self) -> u64 {
  362|      0|        self.spawned_count
  363|      0|    }
  364|       |
  365|       |    /// Get total number of entities despawned.
  366|       |    #[inline]
  367|      0|    pub fn despawned_count(&self) -> u64 {
  368|      0|        self.despawned_count
  369|      0|    }
  370|       |
  371|       |    /// Clear all entities and reset allocator.
  372|       |    ///
  373|       |    /// # Warning
  374|       |    ///
  375|       |    /// All existing `Entity` handles become invalid.
  376|      0|    pub fn clear(&mut self) {
  377|      0|        self.free_list.clear();
  378|      0|        self.generations.clear();
  379|      0|        self.next_id = 0;
  380|      0|        self.spawned_count = 0;
  381|      0|        self.despawned_count = 0;
  382|      0|    }
  383|       |
  384|       |    /// Reserve capacity for additional entities.
  385|       |    ///
  386|       |    /// This pre-allocates space to avoid reallocation during spawn.
  387|      0|    pub fn reserve(&mut self, additional: usize) {
  388|      0|        self.generations.reserve(additional);
  389|      0|    }
  390|       |}
  391|       |
  392|       |impl Default for EntityAllocator {
  393|      6|    fn default() -> Self {
  394|      6|        Self::new()
  395|      6|    }
  396|       |}
  397|       |
  398|       |#[cfg(test)]
  399|       |mod tests {
  400|       |    use super::*;
  401|       |
  402|       |    #[test]
  403|       |    fn test_spawn_despawn_cycle() {
  404|       |        let mut allocator = EntityAllocator::new();
  405|       |
  406|       |        let e1 = allocator.spawn();
  407|       |        assert_eq!(e1.id(), 0);
  408|       |        assert_eq!(e1.generation(), 0);
  409|       |        assert!(allocator.is_alive(e1));
  410|       |
  411|       |        allocator.despawn(e1);
  412|       |        assert!(!allocator.is_alive(e1));
  413|       |
  414|       |        let e2 = allocator.spawn();
  415|       |        assert_eq!(e2.id(), 0); // Reused ID
  416|       |        assert_eq!(e2.generation(), 1); // Incremented generation
  417|       |        assert!(!allocator.is_alive(e1)); // Old handle invalid
  418|       |        assert!(allocator.is_alive(e2)); // New handle valid
  419|       |    }
  420|       |
  421|       |    #[test]
  422|       |    fn test_stale_entity_rejection() {
  423|       |        let mut allocator = EntityAllocator::new();
  424|       |
  425|       |        let e1 = allocator.spawn();
  426|       |        allocator.despawn(e1);
  427|       |
  428|       |        // Trying to despawn again should fail
  429|       |        assert!(!allocator.despawn(e1));
  430|       |        assert!(!allocator.is_alive(e1));
  431|       |    }
  432|       |
  433|       |    #[test]
  434|       |    fn test_multiple_entities() {
  435|       |        let mut allocator = EntityAllocator::new();
  436|       |
  437|       |        let e1 = allocator.spawn();
  438|       |        let e2 = allocator.spawn();
  439|       |        let e3 = allocator.spawn();
  440|       |
  441|       |        assert_eq!(e1.id(), 0);
  442|       |        assert_eq!(e2.id(), 1);
  443|       |        assert_eq!(e3.id(), 2);
  444|       |
  445|       |        assert!(allocator.is_alive(e1));
  446|       |        assert!(allocator.is_alive(e2));
  447|       |        assert!(allocator.is_alive(e3));
  448|       |
  449|       |        allocator.despawn(e2);
  450|       |        assert!(allocator.is_alive(e1));
  451|       |        assert!(!allocator.is_alive(e2));
  452|       |        assert!(allocator.is_alive(e3));
  453|       |    }
  454|       |
  455|       |    #[test]
  456|       |    fn test_generation_overflow() {
  457|       |        let mut allocator = EntityAllocator::new();
  458|       |
  459|       |        let e1 = allocator.spawn();
  460|       |        let id = e1.id();
  461|       |
  462|       |        // Simulate many despawn/spawn cycles
  463|       |        for i in 0..10 {
  464|       |            allocator.despawn(Entity::new(id, i));
  465|       |            let e = allocator.spawn();
  466|       |            assert_eq!(e.id(), id);
  467|       |            assert_eq!(e.generation(), i + 1);
  468|       |        }
  469|       |    }
  470|       |
  471|       |    #[test]
  472|       |    fn test_entity_ordering() {
  473|       |        let e1 = Entity::new(0, 0);
  474|       |        let e2 = Entity::new(1, 0);
  475|       |        let e3 = Entity::new(0, 1);
  476|       |
  477|       |        assert!(e1 < e2); // Different IDs
  478|       |        assert!(e1 < e3); // Same ID, different generation
  479|       |        assert!(e3 < e2); // Generation comparison
  480|       |    }
  481|       |
  482|       |    #[test]
  483|       |    fn test_entity_display() {
  484|       |        let e = Entity::new(42, 7);
  485|       |        assert_eq!(format!("{}", e), "42v7");
  486|       |        assert_eq!(format!("{:?}", e), "Entity(42v7)");
  487|       |    }
  488|       |
  489|       |    #[test]
  490|       |    fn test_null_entity() {
  491|       |        let null = Entity::null();
  492|       |        assert!(null.is_null());
  493|       |
  494|       |        let allocator = EntityAllocator::new();
  495|       |        assert!(!allocator.is_alive(null));
  496|       |    }
  497|       |
  498|       |    #[test]
  499|       |    fn test_raw_conversion() {
  500|       |        let e = Entity::new(0x12345678, 0xABCDEF01);
  501|       |        let raw = e.to_raw();
  502|       |        let restored = unsafe { Entity::from_raw(raw) };
  503|       |
  504|       |        assert_eq!(e, restored);
  505|       |        assert_eq!(e.id(), restored.id());
  506|       |        assert_eq!(e.generation(), restored.generation());
  507|       |    }
  508|       |
  509|       |    #[test]
  510|       |    fn test_capacity_tracking() {
  511|       |        let mut allocator = EntityAllocator::new();
  512|       |
  513|       |        assert_eq!(allocator.alive_count(), 0);
  514|       |        assert_eq!(allocator.capacity(), 0);
  515|       |
  516|       |        let e1 = allocator.spawn();
  517|       |        assert_eq!(allocator.alive_count(), 1);
  518|       |        assert_eq!(allocator.capacity(), 1);
  519|       |
  520|       |        let _e2 = allocator.spawn();
  521|       |        assert_eq!(allocator.alive_count(), 2);
  522|       |        assert_eq!(allocator.capacity(), 2);
  523|       |
  524|       |        allocator.despawn(e1);
  525|       |        assert_eq!(allocator.alive_count(), 1);
  526|       |        assert_eq!(allocator.capacity(), 2); // Capacity doesn't shrink
  527|       |    }
  528|       |
  529|       |    #[test]
  530|       |    fn test_with_capacity() {
  531|       |        let allocator = EntityAllocator::with_capacity(100);
  532|       |        assert_eq!(allocator.capacity(), 0); // No entities spawned yet
  533|       |        assert!(allocator.generations.capacity() >= 100);
  534|       |    }
  535|       |
  536|       |    #[test]
  537|       |    fn test_clear() {
  538|       |        let mut allocator = EntityAllocator::new();
  539|       |
  540|       |        let e1 = allocator.spawn();
  541|       |        let e2 = allocator.spawn();
  542|       |
  543|       |        allocator.clear();
  544|       |
  545|       |        assert_eq!(allocator.alive_count(), 0);
  546|       |        assert_eq!(allocator.capacity(), 0);
  547|       |        assert!(!allocator.is_alive(e1));
  548|       |        assert!(!allocator.is_alive(e2));
  549|       |
  550|       |        let e3 = allocator.spawn();
  551|       |        assert_eq!(e3.id(), 0); // Reset to ID 0
  552|       |        assert_eq!(e3.generation(), 0); // Reset generation
  553|       |    }
  554|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\events.rs:
    1|       |//! Event system for AI-native game engine.
    2|       |//!
    3|       |//! Events are crucial for AI perception and reactive behaviors.
    4|       |//! This system provides deterministic event ordering and efficient queries.
    5|       |
    6|       |#[cfg(feature = "profiling")]
    7|       |use astraweave_profiling::span;
    8|       |
    9|       |use std::any::{Any, TypeId};
   10|       |use std::collections::{HashMap, VecDeque};
   11|       |use std::marker::PhantomData;
   12|       |
   13|       |/// Event trait marker
   14|       |pub trait Event: 'static + Send + Sync {}
   15|       |
   16|       |/// Event storage for a single event type
   17|       |struct EventQueue<E: Event> {
   18|       |    events: VecDeque<E>,
   19|       |    /// Frame when events were added (for cleanup)
   20|       |    frame_added: VecDeque<u64>,
   21|       |}
   22|       |
   23|       |impl<E: Event> EventQueue<E> {
   24|      0|    fn new() -> Self {
   25|      0|        Self {
   26|      0|            events: VecDeque::new(),
   27|      0|            frame_added: VecDeque::new(),
   28|      0|        }
   29|      0|    }
   30|       |
   31|      0|    fn send(&mut self, event: E, frame: u64) {
   32|      0|        self.events.push_back(event);
   33|      0|        self.frame_added.push_back(frame);
   34|      0|    }
   35|       |
   36|      0|    fn drain(&mut self) -> impl Iterator<Item = E> + '_ {
   37|      0|        self.frame_added.clear();
   38|      0|        self.events.drain(..)
   39|      0|    }
   40|       |
   41|      0|    fn iter(&self) -> impl Iterator<Item = &E> {
   42|      0|        self.events.iter()
   43|      0|    }
   44|       |
   45|       |    /// Remove events older than N frames
   46|       |    #[allow(dead_code)]
   47|      0|    fn cleanup(&mut self, current_frame: u64, keep_frames: u64) {
   48|      0|        while let Some(&frame) = self.frame_added.front() {
   49|      0|            if current_frame.saturating_sub(frame) > keep_frames {
   50|      0|                self.events.pop_front();
   51|      0|                self.frame_added.pop_front();
   52|      0|            } else {
   53|      0|                break;
   54|       |            }
   55|       |        }
   56|      0|    }
   57|       |
   58|      0|    fn len(&self) -> usize {
   59|      0|        self.events.len()
   60|      0|    }
   61|       |
   62|      0|    fn clear(&mut self) {
   63|      0|        self.events.clear();
   64|      0|        self.frame_added.clear();
   65|      0|    }
   66|       |}
   67|       |
   68|       |/// Central event registry for all event types
   69|       |pub struct Events {
   70|       |    /// Map from TypeId to type-erased event queue
   71|       |    queues: HashMap<TypeId, Box<dyn Any + Send + Sync>>,
   72|       |    /// Current simulation frame
   73|       |    current_frame: u64,
   74|       |    /// How many frames to keep events before cleanup
   75|       |    keep_frames: u64,
   76|       |}
   77|       |
   78|       |impl Events {
   79|       |    pub fn new() -> Self {
   80|       |        Self {
   81|       |            queues: HashMap::new(),
   82|       |            current_frame: 0,
   83|       |            keep_frames: 2, // Keep events for 2 frames by default
   84|       |        }
   85|       |    }
   86|       |
   87|       |    pub fn with_keep_frames(mut self, frames: u64) -> Self {
   88|       |        self.keep_frames = frames;
   89|       |        self
   90|       |    }
   91|       |
   92|       |    /// Send an event
   93|      0|    pub fn send<E: Event>(&mut self, event: E) {
   94|      0|        let queue = self
   95|      0|            .queues
   96|      0|            .entry(TypeId::of::<E>())
   97|      0|            .or_insert_with(|| Box::new(EventQueue::<E>::new()));
   98|       |
   99|      0|        let queue = queue.downcast_mut::<EventQueue<E>>().expect(
  100|      0|            "EventQueue type mismatch: just inserted correct type, downcast should never fail",
  101|       |        );
  102|      0|        queue.send(event, self.current_frame);
  103|      0|    }
  104|       |
  105|       |    /// Get event reader for type E
  106|      0|    pub fn get_reader<E: Event>(&self) -> EventReader<E> {
  107|      0|        EventReader {
  108|      0|            type_id: TypeId::of::<E>(),
  109|      0|            _marker: PhantomData,
  110|      0|        }
  111|      0|    }
  112|       |
  113|       |    /// Read events of type E
  114|      0|    pub fn read<E: Event>(&self) -> impl Iterator<Item = &E> {
  115|      0|        self.queues
  116|      0|            .get(&TypeId::of::<E>())
  117|      0|            .and_then(|q| q.downcast_ref::<EventQueue<E>>())
  118|      0|            .map(|q| q.iter())
  119|      0|            .into_iter()
  120|      0|            .flatten()
  121|      0|    }
  122|       |
  123|       |    /// Drain all events of type E (consumes them)
  124|      0|    pub fn drain<E: Event>(&mut self) -> impl Iterator<Item = E> + '_ {
  125|      0|        self.queues
  126|      0|            .get_mut(&TypeId::of::<E>())
  127|      0|            .and_then(|q| q.downcast_mut::<EventQueue<E>>())
  128|      0|            .map(|q| q.drain())
  129|      0|            .into_iter()
  130|      0|            .flatten()
  131|      0|    }
  132|       |
  133|       |    /// Clear all events of type E
  134|      0|    pub fn clear<E: Event>(&mut self) {
  135|      0|        if let Some(queue) = self.queues.get_mut(&TypeId::of::<E>()) {
  136|      0|            if let Some(q) = queue.downcast_mut::<EventQueue<E>>() {
  137|      0|                q.clear();
  138|      0|            }
  139|      0|        }
  140|      0|    }
  141|       |
  142|       |    /// Get event count for type E
  143|      0|    pub fn len<E: Event>(&self) -> usize {
  144|      0|        self.queues
  145|      0|            .get(&TypeId::of::<E>())
  146|      0|            .and_then(|q| q.downcast_ref::<EventQueue<E>>())
  147|      0|            .map(|q| q.len())
  148|      0|            .unwrap_or(0)
  149|      0|    }
  150|       |
  151|       |    /// Check if events queue is empty for type E
  152|      0|    pub fn is_empty<E: Event>(&self) -> bool {
  153|      0|        self.len::<E>() == 0
  154|      0|    }
  155|       |
  156|       |    /// Advance frame and cleanup old events
  157|       |    pub fn update(&mut self) {
  158|       |        #[cfg(feature = "profiling")]
  159|       |        span!("ECS::Events::update");
  160|       |
  161|       |        self.current_frame += 1;
  162|       |
  163|       |        // Cleanup old events from all queues
  164|       |        for _queue in self.queues.values_mut() {
  165|       |            // Type erasure: we need to cast to EventQueue<T> but don't know T
  166|       |            // For now, we'll skip automatic cleanup and rely on explicit clear
  167|       |            // TODO: Store cleanup function pointer or use trait object
  168|       |        }
  169|       |    }
  170|       |
  171|       |    /// Clear all events
  172|       |    pub fn clear_all(&mut self) {
  173|       |        self.queues.clear();
  174|       |    }
  175|       |
  176|       |    pub fn current_frame(&self) -> u64 {
  177|       |        self.current_frame
  178|       |    }
  179|       |}
  180|       |
  181|       |impl Default for Events {
  182|       |    fn default() -> Self {
  183|       |        Self::new()
  184|       |    }
  185|       |}
  186|       |
  187|       |// Note: Events implements Resource via the blanket impl in lib.rs
  188|       |// impl Resource for Events {} // Removed - conflicts with blanket impl
  189|       |
  190|       |/// Event reader - provides a handle to read events of a specific type
  191|       |#[allow(dead_code)]
  192|       |pub struct EventReader<E: Event> {
  193|       |    type_id: TypeId,
  194|       |    _marker: PhantomData<E>,
  195|       |}
  196|       |
  197|       |impl<E: Event> EventReader<E> {
  198|       |    /// Read events from the Events resource
  199|      0|    pub fn read<'a>(&self, events: &'a Events) -> impl Iterator<Item = &'a E> {
  200|      0|        events.read::<E>()
  201|      0|    }
  202|       |}
  203|       |
  204|       |// Common game events for AI systems
  205|       |
  206|       |/// Entity spawned event
  207|       |#[derive(Clone, Debug)]
  208|       |pub struct EntitySpawnedEvent {
  209|       |    pub entity: crate::Entity,
  210|       |    pub entity_type: String,
  211|       |}
  212|       |impl Event for EntitySpawnedEvent {}
  213|       |
  214|       |/// Entity despawned event
  215|       |#[derive(Clone, Debug)]
  216|       |pub struct EntityDespawnedEvent {
  217|       |    pub entity: crate::Entity,
  218|       |}
  219|       |impl Event for EntityDespawnedEvent {}
  220|       |
  221|       |/// Health changed event (for AI perception)
  222|       |#[derive(Clone, Debug)]
  223|       |pub struct HealthChangedEvent {
  224|       |    pub entity: crate::Entity,
  225|       |    pub old_health: i32,
  226|       |    pub new_health: i32,
  227|       |    pub source: Option<crate::Entity>,
  228|       |}
  229|       |impl Event for HealthChangedEvent {}
  230|       |
  231|       |/// AI planning failed event
  232|       |#[derive(Clone, Debug)]
  233|       |pub struct AiPlanningFailedEvent {
  234|       |    pub entity: crate::Entity,
  235|       |    pub reason: String,
  236|       |}
  237|       |impl Event for AiPlanningFailedEvent {}
  238|       |
  239|       |/// Tool validation failed event
  240|       |#[derive(Clone, Debug)]
  241|       |pub struct ToolValidationFailedEvent {
  242|       |    pub entity: crate::Entity,
  243|       |    pub tool_name: String,
  244|       |    pub reason: String,
  245|       |}
  246|       |impl Event for ToolValidationFailedEvent {}
  247|       |
  248|       |#[cfg(test)]
  249|       |mod tests {
  250|       |    use super::*;
  251|       |
  252|       |    #[derive(Clone, Debug, PartialEq)]
  253|       |    struct TestEvent {
  254|       |        value: i32,
  255|       |    }
  256|       |    impl Event for TestEvent {}
  257|       |
  258|       |    #[test]
  259|       |    fn test_send_and_read_events() {
  260|       |        let mut events = Events::new();
  261|       |
  262|       |        events.send(TestEvent { value: 42 });
  263|       |        events.send(TestEvent { value: 100 });
  264|       |
  265|       |        let collected: Vec<_> = events.read::<TestEvent>().collect();
  266|       |        assert_eq!(collected.len(), 2);
  267|       |        assert_eq!(collected[0].value, 42);
  268|       |        assert_eq!(collected[1].value, 100);
  269|       |    }
  270|       |
  271|       |    #[test]
  272|       |    fn test_drain_events() {
  273|       |        let mut events = Events::new();
  274|       |
  275|       |        events.send(TestEvent { value: 1 });
  276|       |        events.send(TestEvent { value: 2 });
  277|       |
  278|       |        let drained: Vec<_> = events.drain::<TestEvent>().collect();
  279|       |        assert_eq!(drained.len(), 2);
  280|       |
  281|       |        // Events should be gone after drain
  282|       |        assert_eq!(events.len::<TestEvent>(), 0);
  283|       |    }
  284|       |
  285|       |    #[test]
  286|       |    fn test_clear_events() {
  287|       |        let mut events = Events::new();
  288|       |
  289|       |        events.send(TestEvent { value: 1 });
  290|       |        events.send(TestEvent { value: 2 });
  291|       |
  292|       |        assert_eq!(events.len::<TestEvent>(), 2);
  293|       |
  294|       |        events.clear::<TestEvent>();
  295|       |        assert_eq!(events.len::<TestEvent>(), 0);
  296|       |    }
  297|       |
  298|       |    #[test]
  299|       |    fn test_event_reader() {
  300|       |        let mut events = Events::new();
  301|       |        let reader = events.get_reader::<TestEvent>();
  302|       |
  303|       |        events.send(TestEvent { value: 42 });
  304|       |
  305|       |        let collected: Vec<_> = reader.read(&events).collect();
  306|       |        assert_eq!(collected.len(), 1);
  307|       |        assert_eq!(collected[0].value, 42);
  308|       |    }
  309|       |
  310|       |    #[test]
  311|       |    fn test_frame_tracking() {
  312|       |        let mut events = Events::new();
  313|       |        assert_eq!(events.current_frame(), 0);
  314|       |
  315|       |        events.update();
  316|       |        assert_eq!(events.current_frame(), 1);
  317|       |
  318|       |        events.update();
  319|       |        assert_eq!(events.current_frame(), 2);
  320|       |    }
  321|       |
  322|       |    // ========================================================================
  323|       |    // Phase 3.3: Event Ordering Tests (Determinism)
  324|       |    // ========================================================================
  325|       |
  326|       |    #[test]
  327|       |    fn test_events_delivered_in_fifo_order() {
  328|       |        let mut events = Events::new();
  329|       |
  330|       |        // Send 100 events in sequence
  331|       |        for i in 0..100 {
  332|       |            events.send(TestEvent { value: i });
  333|       |        }
  334|       |
  335|       |        // Read events and verify FIFO order
  336|       |        let collected: Vec<_> = events.read::<TestEvent>().collect();
  337|       |        assert_eq!(collected.len(), 100, "Should have 100 events");
  338|       |
  339|       |        for (i, event) in collected.iter().enumerate() {
  340|       |            assert_eq!(
  341|       |                event.value, i as i32,
  342|       |                "Event {} should have value {}, got {}",
  343|       |                i, i, event.value
  344|       |            );
  345|       |        }
  346|       |    }
  347|       |
  348|       |    #[test]
  349|       |    fn test_drain_preserves_fifo_order() {
  350|       |        let mut events = Events::new();
  351|       |
  352|       |        // Send events
  353|       |        for i in 0..50 {
  354|       |            events.send(TestEvent { value: i });
  355|       |        }
  356|       |
  357|       |        // Drain events and verify FIFO order
  358|       |        let drained: Vec<_> = events.drain::<TestEvent>().collect();
  359|       |        assert_eq!(drained.len(), 50, "Should have drained 50 events");
  360|       |
  361|       |        for (i, event) in drained.iter().enumerate() {
  362|       |            assert_eq!(
  363|       |                event.value, i as i32,
  364|       |                "Drained event {} should have value {}, got {}",
  365|       |                i, i, event.value
  366|       |            );
  367|       |        }
  368|       |
  369|       |        // Verify events are gone
  370|       |        assert_eq!(
  371|       |            events.len::<TestEvent>(),
  372|       |            0,
  373|       |            "Events should be consumed after drain"
  374|       |        );
  375|       |    }
  376|       |
  377|       |    #[test]
  378|       |    fn test_frame_boundaries_respected() {
  379|       |        let mut events = Events::new();
  380|       |        assert_eq!(events.current_frame(), 0);
  381|       |
  382|       |        // Frame 0: Send events
  383|       |        events.send(TestEvent { value: 1 });
  384|       |        events.send(TestEvent { value: 2 });
  385|       |
  386|       |        // Advance to frame 1
  387|       |        events.update();
  388|       |        assert_eq!(events.current_frame(), 1);
  389|       |
  390|       |        // Frame 1: Send more events
  391|       |        events.send(TestEvent { value: 3 });
  392|       |        events.send(TestEvent { value: 4 });
  393|       |
  394|       |        // All events should still be present (no cross-frame interference)
  395|       |        let collected: Vec<_> = events.read::<TestEvent>().collect();
  396|       |        assert_eq!(collected.len(), 4, "Should have all 4 events");
  397|       |
  398|       |        // Verify FIFO order across frames
  399|       |        assert_eq!(collected[0].value, 1);
  400|       |        assert_eq!(collected[1].value, 2);
  401|       |        assert_eq!(collected[2].value, 3);
  402|       |        assert_eq!(collected[3].value, 4);
  403|       |    }
  404|       |
  405|       |    #[test]
  406|       |    fn test_multiple_readers_independent() {
  407|       |        let mut events = Events::new();
  408|       |
  409|       |        events.send(TestEvent { value: 42 });
  410|       |        events.send(TestEvent { value: 100 });
  411|       |
  412|       |        // Create two independent readers
  413|       |        let reader1 = events.get_reader::<TestEvent>();
  414|       |        let reader2 = events.get_reader::<TestEvent>();
  415|       |
  416|       |        // Both readers should see same events
  417|       |        let collected1: Vec<_> = reader1.read(&events).collect();
  418|       |        let collected2: Vec<_> = reader2.read(&events).collect();
  419|       |
  420|       |        assert_eq!(collected1.len(), 2);
  421|       |        assert_eq!(collected2.len(), 2);
  422|       |        assert_eq!(collected1[0].value, collected2[0].value);
  423|       |        assert_eq!(collected1[1].value, collected2[1].value);
  424|       |    }
  425|       |
  426|       |    #[test]
  427|       |    fn test_clear_removes_all_events() {
  428|       |        let mut events = Events::new();
  429|       |
  430|       |        // Send events
  431|       |        for i in 0..20 {
  432|       |            events.send(TestEvent { value: i });
  433|       |        }
  434|       |
  435|       |        assert_eq!(events.len::<TestEvent>(), 20);
  436|       |
  437|       |        // Clear all events
  438|       |        events.clear::<TestEvent>();
  439|       |
  440|       |        // Verify all events removed
  441|       |        assert_eq!(events.len::<TestEvent>(), 0);
  442|       |        let collected: Vec<_> = events.read::<TestEvent>().collect();
  443|       |        assert_eq!(collected.len(), 0);
  444|       |    }
  445|       |
  446|       |    #[test]
  447|       |    fn test_multiple_event_types_independent() {
  448|       |        #[derive(Clone, Debug)]
  449|       |        struct EventA {
  450|       |            id: u32,
  451|       |        }
  452|       |        impl Event for EventA {}
  453|       |
  454|       |        #[derive(Clone, Debug)]
  455|       |        struct EventB {
  456|       |            name: String,
  457|       |        }
  458|       |        impl Event for EventB {}
  459|       |
  460|       |        let mut events = Events::new();
  461|       |
  462|       |        // Send events of different types
  463|       |        events.send(EventA { id: 1 });
  464|       |        events.send(EventB {
  465|       |            name: "first".to_string(),
  466|       |        });
  467|       |        events.send(EventA { id: 2 });
  468|       |        events.send(EventB {
  469|       |            name: "second".to_string(),
  470|       |        });
  471|       |
  472|       |        // Each type should maintain its own FIFO order
  473|       |        let a_events: Vec<_> = events.read::<EventA>().collect();
  474|       |        let b_events: Vec<_> = events.read::<EventB>().collect();
  475|       |
  476|       |        assert_eq!(a_events.len(), 2);
  477|       |        assert_eq!(b_events.len(), 2);
  478|       |
  479|       |        assert_eq!(a_events[0].id, 1);
  480|       |        assert_eq!(a_events[1].id, 2);
  481|       |        assert_eq!(b_events[0].name, "first");
  482|       |        assert_eq!(b_events[1].name, "second");
  483|       |    }
  484|       |
  485|       |    #[test]
  486|       |    fn test_clear_one_type_preserves_others() {
  487|       |        #[derive(Clone, Debug)]
  488|       |        struct EventA {
  489|       |            #[allow(dead_code)]
  490|       |            value: i32,
  491|       |        }
  492|       |        impl Event for EventA {}
  493|       |
  494|       |        #[derive(Clone, Debug)]
  495|       |        struct EventB {
  496|       |            #[allow(dead_code)]
  497|       |            value: i32,
  498|       |        }
  499|       |        impl Event for EventB {}
  500|       |
  501|       |        let mut events = Events::new();
  502|       |
  503|       |        events.send(EventA { value: 1 });
  504|       |        events.send(EventB { value: 2 });
  505|       |
  506|       |        assert_eq!(events.len::<EventA>(), 1);
  507|       |        assert_eq!(events.len::<EventB>(), 1);
  508|       |
  509|       |        // Clear only EventA
  510|       |        events.clear::<EventA>();
  511|       |
  512|       |        // EventA should be gone, EventB should remain
  513|       |        assert_eq!(events.len::<EventA>(), 0);
  514|       |        assert_eq!(events.len::<EventB>(), 1);
  515|       |
  516|       |        let b_events: Vec<_> = events.read::<EventB>().collect();
  517|       |        assert_eq!(b_events[0].value, 2);
  518|       |    }
  519|       |
  520|       |    #[test]
  521|       |    fn test_interleaved_send_and_read() {
  522|       |        let mut events = Events::new();
  523|       |
  524|       |        // Send first batch
  525|       |        events.send(TestEvent { value: 1 });
  526|       |        events.send(TestEvent { value: 2 });
  527|       |
  528|       |        // Read (non-consuming)
  529|       |        let first_read: Vec<_> = events.read::<TestEvent>().collect();
  530|       |        assert_eq!(first_read.len(), 2);
  531|       |
  532|       |        // Send more events
  533|       |        events.send(TestEvent { value: 3 });
  534|       |        events.send(TestEvent { value: 4 });
  535|       |
  536|       |        // Read again (should see all events in FIFO order)
  537|       |        let second_read: Vec<_> = events.read::<TestEvent>().collect();
  538|       |        assert_eq!(second_read.len(), 4);
  539|       |        assert_eq!(second_read[0].value, 1);
  540|       |        assert_eq!(second_read[1].value, 2);
  541|       |        assert_eq!(second_read[2].value, 3);
  542|       |        assert_eq!(second_read[3].value, 4);
  543|       |    }
  544|       |
  545|       |    #[test]
  546|       |    fn test_repeated_drain_produces_empty_results() {
  547|       |        let mut events = Events::new();
  548|       |
  549|       |        events.send(TestEvent { value: 42 });
  550|       |
  551|       |        // First drain
  552|       |        let first_drain: Vec<_> = events.drain::<TestEvent>().collect();
  553|       |        assert_eq!(first_drain.len(), 1);
  554|       |
  555|       |        // Second drain (should be empty)
  556|       |        let second_drain: Vec<_> = events.drain::<TestEvent>().collect();
  557|       |        assert_eq!(second_drain.len(), 0);
  558|       |
  559|       |        // Third drain (should still be empty)
  560|       |        let third_drain: Vec<_> = events.drain::<TestEvent>().collect();
  561|       |        assert_eq!(third_drain.len(), 0);
  562|       |    }
  563|       |
  564|       |    #[test]
  565|       |    fn test_large_event_batch_maintains_order() {
  566|       |        let mut events = Events::new();
  567|       |        const BATCH_SIZE: usize = 10_000;
  568|       |
  569|       |        // Send large batch
  570|       |        for i in 0..BATCH_SIZE {
  571|       |            events.send(TestEvent { value: i as i32 });
  572|       |        }
  573|       |
  574|       |        assert_eq!(events.len::<TestEvent>(), BATCH_SIZE);
  575|       |
  576|       |        // Verify all events in correct order
  577|       |        let collected: Vec<_> = events.read::<TestEvent>().collect();
  578|       |        assert_eq!(collected.len(), BATCH_SIZE);
  579|       |
  580|       |        for (i, event) in collected.iter().enumerate() {
  581|       |            assert_eq!(event.value, i as i32, "Event {} out of order", i);
  582|       |        }
  583|       |    }
  584|       |
  585|       |    #[test]
  586|       |    fn test_clear_all_removes_all_event_types() {
  587|       |        #[derive(Clone, Debug)]
  588|       |        struct EventA {
  589|       |            #[allow(dead_code)]
  590|       |            value: i32,
  591|       |        }
  592|       |        impl Event for EventA {}
  593|       |
  594|       |        #[derive(Clone, Debug)]
  595|       |        struct EventB {
  596|       |            #[allow(dead_code)]
  597|       |            value: i32,
  598|       |        }
  599|       |        impl Event for EventB {}
  600|       |
  601|       |        let mut events = Events::new();
  602|       |
  603|       |        events.send(EventA { value: 1 });
  604|       |        events.send(EventB { value: 2 });
  605|       |
  606|       |        assert_eq!(events.len::<EventA>(), 1);
  607|       |        assert_eq!(events.len::<EventB>(), 1);
  608|       |
  609|       |        // Clear all event types
  610|       |        events.clear_all();
  611|       |
  612|       |        // Both types should be gone
  613|       |        assert_eq!(events.len::<EventA>(), 0);
  614|       |        assert_eq!(events.len::<EventB>(), 0);
  615|       |    }
  616|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\lib.rs:
    1|       |//! AstraWeave ECS — Production-grade, AI-native ECS for game development.
    2|       |//!
    3|       |//! This ECS is designed specifically for AI-first game engines, providing:
    4|       |//! - **Archetype-based storage** for cache-friendly iteration (like Bevy/Flecs)
    5|       |//! - **Deterministic execution** via fixed schedules and ordered iteration
    6|       |//! - **Event system** for AI perception and reactive behaviors
    7|       |//! - **System parameters** for ergonomic system signatures
    8|       |//! - **Plugin architecture** for modular game systems
    9|       |//!
   10|       |//! ## Architecture
   11|       |//!
   12|       |//! The AI-native game loop follows: **Perception → Reasoning → Planning → Action**
   13|       |//!
   14|       |//! ### System Stages:
   15|       |//! 1. **Perception**: Build WorldSnapshots, update AI sensors
   16|       |//! 2. **Simulation**: Game logic, cooldowns, state updates
   17|       |//! 3. **AI Planning**: Generate PlanIntents from AI orchestrators
   18|       |//! 4. **Physics**: Apply forces, resolve collisions
   19|       |//! 5. **Presentation**: Rendering, audio, UI updates
   20|       |//!
   21|       |//! ## Example
   22|       |//!
   23|       |//! ```rust,ignore
   24|       |//! use astraweave_ecs::*;
   25|       |//!
   26|       |//! #[derive(Clone, Copy)]
   27|       |//! struct Position { x: f32, y: f32 }
   28|       |//!
   29|       |//! #[derive(Clone, Copy)]
   30|       |//! struct Velocity { x: f32, y: f32 }
   31|       |//!
   32|       |//! fn movement_system(world: &mut World) {
   33|       |//!     let mut query = QueryMut::<Position>::new(world);
   34|       |//!     for (entity, pos) in query.iter_mut() {
   35|       |//!         if let Some(vel) = world.get::<Velocity>(entity) {
   36|       |//!             pos.x += vel.x;
   37|       |//!             pos.y += vel.y;
   38|       |//!         }
   39|       |//!     }
   40|       |//! }
   41|       |//!
   42|       |//! let mut app = App::new();
   43|       |//! app.add_system("simulation", movement_system);
   44|       |//! app = app.run_fixed(100); // Run 100 ticks
   45|       |//! ```
   46|       |
   47|       |#[cfg(feature = "profiling")]
   48|       |use astraweave_profiling::{plot, span};
   49|       |
   50|       |pub mod archetype;
   51|       |pub mod blob_vec;
   52|       |pub mod command_buffer;
   53|       |pub mod entity_allocator;
   54|       |pub mod events;
   55|       |pub mod rng;
   56|       |pub mod sparse_set;
   57|       |mod system_param;
   58|       |pub mod type_registry;
   59|       |
   60|       |#[cfg(feature = "alloc-counter")]
   61|       |pub mod counting_alloc;
   62|       |
   63|       |#[cfg(test)]
   64|       |mod determinism_tests;
   65|       |
   66|       |#[cfg(test)]
   67|       |mod property_tests;
   68|       |
   69|       |use std::any::TypeId;
   70|       |use std::collections::HashMap;
   71|       |
   72|       |use archetype::{ArchetypeSignature, ArchetypeStorage};
   73|       |pub use command_buffer::CommandBuffer;
   74|       |pub use entity_allocator::{Entity, EntityAllocator};
   75|       |pub use events::{Event, EventReader, Events};
   76|       |pub use rng::Rng;
   77|       |pub use system_param::{Query, Query2, Query2Mut, SystemParam};
   78|       |pub use type_registry::TypeRegistry;
   79|       |
   80|       |pub trait Component: 'static + Send + Sync {}
   81|       |impl<T: 'static + Send + Sync> Component for T {}
   82|       |
   83|       |/// Marker trait for resources (singletons in World)
   84|       |pub trait Resource: 'static + Send + Sync {}
   85|       |impl<T: 'static + Send + Sync> Resource for T {}
   86|       |
   87|       |/// System stage identifiers for the AI-native game loop
   88|       |pub struct SystemStage;
   89|       |
   90|       |impl SystemStage {
   91|       |    pub const PRE_SIMULATION: &'static str = "pre_simulation";
   92|       |    pub const PERCEPTION: &'static str = "perception";
   93|       |    pub const SIMULATION: &'static str = "simulation";
   94|       |    pub const AI_PLANNING: &'static str = "ai_planning";
   95|       |    pub const PHYSICS: &'static str = "physics";
   96|       |    pub const POST_SIMULATION: &'static str = "post_simulation";
   97|       |    pub const PRESENTATION: &'static str = "presentation";
   98|       |}
   99|       |// Entity and EntityAllocator are now exported from entity_allocator module
  100|       |
  101|       |#[derive(Default)]
  102|       |pub struct World {
  103|       |    entity_allocator: EntityAllocator,
  104|       |    archetypes: ArchetypeStorage,
  105|       |    resources: HashMap<TypeId, Box<dyn std::any::Any + Send + Sync>>, // singletons
  106|       |    type_registry: TypeRegistry,
  107|       |}
  108|       |
  109|       |impl World {
  110|      3|    pub fn new() -> Self {
  111|      3|        Self::default()
  112|      3|    }
  113|       |
  114|      0|    pub fn spawn(&mut self) -> Entity {
  115|       |        #[cfg(feature = "profiling")]
  116|       |        span!("ECS::World::spawn");
  117|       |
  118|      0|        let e = self.entity_allocator.spawn();
  119|       |
  120|       |        #[cfg(feature = "profiling")]
  121|       |        plot!(
  122|       |            "ECS::entity_count",
  123|       |            self.entity_allocator.alive_count() as u64
  124|       |        );
  125|       |
  126|       |        // An entity with no components lives in the empty archetype.
  127|      0|        let empty_sig = ArchetypeSignature::new(vec![]);
  128|      0|        let archetype_id = self.archetypes.get_or_create_archetype(empty_sig);
  129|      0|        self.archetypes.set_entity_archetype(e, archetype_id);
  130|      0|        let archetype = self
  131|      0|            .archetypes
  132|      0|            .get_archetype_mut(archetype_id)
  133|      0|            .expect("BUG: archetype should exist after get_or_create_archetype");
  134|      0|        archetype.add_entity(e, HashMap::new());
  135|      0|        e
  136|      0|    }
  137|       |
  138|       |    /// Check if an entity is alive in this world.
  139|       |    ///
  140|       |    /// # Returns
  141|       |    ///
  142|       |    /// - `true` if entity ID and generation match
  143|       |    /// - `false` if entity is dead or never existed
  144|       |    #[inline]
  145|      0|    pub fn is_alive(&self, entity: Entity) -> bool {
  146|      0|        self.entity_allocator.is_alive(entity)
  147|      0|    }
  148|       |
  149|      0|    pub fn insert<T: Component>(&mut self, e: Entity, c: T) {
  150|       |        // Validate entity is alive
  151|      0|        if !self.is_alive(e) {
  152|      0|            return; // Silently ignore stale entities
  153|      0|        }
  154|       |
  155|      0|        let mut components_to_add = HashMap::new();
  156|      0|        components_to_add.insert(
  157|      0|            TypeId::of::<T>(),
  158|      0|            Box::new(c) as Box<dyn std::any::Any + Send + Sync>,
  159|       |        );
  160|      0|        self.move_entity_to_new_archetype(e, components_to_add, false);
  161|      0|    }
  162|       |
  163|      0|    fn move_entity_to_new_archetype(
  164|      0|        &mut self,
  165|      0|        entity: Entity,
  166|      0|        new_components: HashMap<TypeId, Box<dyn std::any::Any + Send + Sync>>,
  167|      0|        is_removing: bool,
  168|      0|    ) {
  169|       |        // 1. Get current archetype and component data
  170|      0|        let old_archetype_id = self
  171|      0|            .archetypes
  172|      0|            .get_entity_archetype(entity)
  173|      0|            .expect("BUG: entity should have archetype");
  174|       |
  175|      0|        let mut current_components = {
  176|      0|            let old_archetype = self
  177|      0|                .archetypes
  178|      0|                .get_archetype_mut(old_archetype_id)
  179|      0|                .expect("BUG: archetype should exist for entity");
  180|      0|            old_archetype.remove_entity_components(entity)
  181|       |        };
  182|       |
  183|       |        // 2. Determine new signature
  184|      0|        let new_sig_types = {
  185|      0|            let old_archetype = self
  186|      0|                .archetypes
  187|      0|                .get_archetype(old_archetype_id)
  188|      0|                .expect("BUG: archetype should exist");
  189|      0|            let mut sig_types: Vec<_> = old_archetype.signature.components.clone();
  190|      0|            if is_removing {
  191|       |                // For removal, the `new_components` map just contains the TypeId of the component to remove.
  192|      0|                let type_to_remove = new_components
  193|      0|                    .keys()
  194|      0|                    .next()
  195|      0|                    .expect("BUG: remove should have at least one component type");
  196|      0|                sig_types.retain(|&tid| tid != *type_to_remove);
  197|      0|            } else {
  198|      0|                sig_types.extend(new_components.keys());
  199|      0|            }
  200|      0|            sig_types
  201|       |        };
  202|       |
  203|      0|        let new_signature = ArchetypeSignature::new(new_sig_types);
  204|       |
  205|       |        // 3. Get or create new archetype
  206|      0|        let new_archetype_id = self.archetypes.get_or_create_archetype(new_signature);
  207|       |
  208|       |        // 4. Move entity's archetype mapping
  209|      0|        self.archetypes
  210|      0|            .get_archetype_mut(old_archetype_id)
  211|      0|            .expect("BUG: old archetype should exist")
  212|      0|            .remove_entity(entity);
  213|      0|        self.archetypes
  214|      0|            .set_entity_archetype(entity, new_archetype_id);
  215|       |
  216|       |        // 5. Add entity with all components to new archetype
  217|      0|        let final_components = if is_removing {
  218|      0|            let type_to_remove = new_components
  219|      0|                .keys()
  220|      0|                .next()
  221|      0|                .expect("BUG: remove should have at least one component type");
  222|      0|            current_components.remove(type_to_remove);
  223|      0|            current_components
  224|       |        } else {
  225|      0|            current_components.extend(new_components);
  226|      0|            current_components
  227|       |        };
  228|       |
  229|      0|        let new_archetype = self
  230|      0|            .archetypes
  231|      0|            .get_archetype_mut(new_archetype_id)
  232|      0|            .expect("BUG: archetype should exist after get_or_create_archetype");
  233|      0|        new_archetype.add_entity(entity, final_components);
  234|      0|    }
  235|       |
  236|      0|    pub fn get<T: Component>(&self, e: Entity) -> Option<&T> {
  237|       |        #[cfg(feature = "profiling")]
  238|       |        span!("ECS::World::get");
  239|       |
  240|       |        // Validate entity is alive
  241|      0|        if !self.is_alive(e) {
  242|      0|            return None;
  243|      0|        }
  244|       |
  245|      0|        let archetype_id = self.archetypes.get_entity_archetype(e)?;
  246|      0|        let archetype = self.archetypes.get_archetype(archetype_id)?;
  247|      0|        archetype.get::<T>(e)
  248|      0|    }
  249|       |
  250|      0|    pub fn get_mut<T: Component>(&mut self, e: Entity) -> Option<&mut T> {
  251|       |        // Validate entity is alive
  252|      0|        if !self.is_alive(e) {
  253|      0|            return None;
  254|      0|        }
  255|       |
  256|      0|        let archetype_id = self.archetypes.get_entity_archetype(e)?;
  257|      0|        let archetype = self.archetypes.get_archetype_mut(archetype_id)?;
  258|      0|        archetype.get_mut::<T>(e)
  259|      0|    }
  260|       |
  261|      5|    pub fn insert_resource<T: 'static + Send + Sync>(&mut self, r: T) {
  262|      5|        self.resources.insert(TypeId::of::<T>(), Box::new(r));
  263|      5|    }
  264|       |
  265|      6|    pub fn get_resource<T: 'static + Send + Sync>(&self) -> Option<&T> {
  266|      6|        self.resources.get(&TypeId::of::<T>())?.downcast_ref()
                                                            ^1^5
  267|      6|    }
  268|       |
  269|      0|    pub fn get_resource_mut<T: 'static + Send + Sync>(&mut self) -> Option<&mut T> {
  270|      0|        self.resources.get_mut(&TypeId::of::<T>())?.downcast_mut()
  271|      0|    }
  272|       |
  273|      0|    pub fn each_mut<T: Component>(&mut self, mut f: impl FnMut(Entity, &mut T)) {
  274|      0|        let archetypes_with_t = self
  275|      0|            .archetypes
  276|      0|            .archetypes_with_component(TypeId::of::<T>())
  277|      0|            .map(|a| a.id)
  278|      0|            .collect::<Vec<_>>();
  279|       |
  280|      0|        for archetype_id in archetypes_with_t {
  281|      0|            let archetype = self
  282|      0|                .archetypes
  283|      0|                .get_archetype_mut(archetype_id)
  284|      0|                .expect("BUG: archetype should exist from archetypes_with_component");
  285|       |            // NEW: entities_vec() now returns &[Entity] (zero-cost!)
  286|      0|            let entities: Vec<Entity> = archetype.entities_vec().to_vec();
  287|      0|            for entity in entities {
  288|      0|                if let Some(component) = archetype.get_mut::<T>(entity) {
  289|      0|                    f(entity, component);
  290|      0|                }
  291|       |            }
  292|       |        }
  293|      0|    }
  294|       |
  295|      0|    pub fn count<T: Component>(&self) -> usize {
  296|      0|        self.archetypes
  297|      0|            .archetypes_with_component(TypeId::of::<T>())
  298|      0|            .map(|archetype| archetype.len())
  299|      0|            .sum()
  300|      0|    }
  301|       |
  302|      0|    pub fn has<T: Component>(&self, entity: Entity) -> bool {
  303|       |        // Validate entity is alive before checking components
  304|      0|        if !self.is_alive(entity) {
  305|      0|            return false;
  306|      0|        }
  307|      0|        self.get::<T>(entity).is_some()
  308|      0|    }
  309|       |
  310|      0|    pub fn entities_with<T: Component>(&self) -> Vec<Entity> {
  311|      0|        self.archetypes
  312|      0|            .archetypes_with_component(TypeId::of::<T>())
  313|      0|            .flat_map(|archetype| archetype.entities_vec().iter().copied())
  314|      0|            .collect()
  315|      0|    }
  316|       |
  317|      0|    pub fn remove<T: Component>(&mut self, e: Entity) -> bool {
  318|       |        // Validate entity is alive
  319|      0|        if !self.is_alive(e) {
  320|      0|            return false;
  321|      0|        }
  322|       |
  323|      0|        if !self.has::<T>(e) {
  324|      0|            return false;
  325|      0|        }
  326|      0|        let mut components_to_remove = HashMap::new();
  327|       |        // We just need the type id for the signature change. The value is irrelevant.
  328|      0|        components_to_remove.insert(
  329|      0|            TypeId::of::<T>(),
  330|      0|            Box::new(0) as Box<dyn std::any::Any + Send + Sync>,
  331|       |        );
  332|      0|        self.move_entity_to_new_archetype(e, components_to_remove, true);
  333|      0|        true
  334|      0|    }
  335|       |
  336|       |    /// Despawn an entity, removing it from the world.
  337|       |    ///
  338|       |    /// # Returns
  339|       |    ///
  340|       |    /// - `true` if entity was alive and despawned
  341|       |    /// - `false` if entity was already dead (stale handle)
  342|       |    ///
  343|       |    /// # Example
  344|       |    ///
  345|       |    /// ```
  346|       |    /// use astraweave_ecs::*;
  347|       |    ///
  348|       |    /// let mut world = World::new();
  349|       |    /// let e = world.spawn();
  350|       |    ///
  351|       |    /// assert!(world.despawn(e));  // First despawn succeeds
  352|       |    /// assert!(!world.despawn(e)); // Second despawn fails (stale)
  353|       |    /// ```
  354|      0|    pub fn despawn(&mut self, entity: Entity) -> bool {
  355|       |        // First validate entity is alive
  356|      0|        if !self.entity_allocator.is_alive(entity) {
  357|      0|            return false;
  358|      0|        }
  359|       |
  360|       |        // Remove from archetype (removes entity AND all components)
  361|      0|        if let Some(archetype_id) = self.archetypes.get_entity_archetype(entity) {
  362|      0|            let archetype = self
  363|      0|                .archetypes
  364|      0|                .get_archetype_mut(archetype_id)
  365|      0|                .expect("BUG: archetype should exist for entity");
  366|      0|            // Use remove_entity_components to properly clean up packed storage
  367|      0|            archetype.remove_entity_components(entity);
  368|      0|            self.archetypes.remove_entity(entity);
  369|      0|        }
  370|       |
  371|       |        // Despawn from allocator (increments generation)
  372|      0|        self.entity_allocator.despawn(entity)
  373|      0|    }
  374|       |
  375|       |    /// Get the number of entities currently alive.
  376|      0|    pub fn entity_count(&self) -> usize {
  377|      0|        self.entity_allocator.alive_count()
  378|      0|    }
  379|       |
  380|       |    /// Get read-only access to the archetype storage.
  381|       |    ///
  382|       |    /// # Use Cases
  383|       |    ///
  384|       |    /// - Iterating all entities across all archetypes
  385|       |    /// - Querying archetype metadata (signatures, counts)
  386|       |    /// - Testing determinism properties
  387|       |    ///
  388|       |    /// # Example
  389|       |    ///
  390|       |    /// ```rust,ignore
  391|       |    /// for archetype in world.archetypes().iter() {
  392|       |    ///     for &entity in archetype.entities_vec() {
  393|       |    ///         // Process entity
  394|       |    ///     }
  395|       |    /// }
  396|       |    /// ```
  397|      0|    pub fn archetypes(&self) -> &ArchetypeStorage {
  398|      0|        &self.archetypes
  399|      0|    }
  400|       |}
  401|       |
  402|       |// Schedule and systems
  403|       |pub type SystemFn = fn(&mut World);
  404|       |
  405|       |#[derive(Default)]
  406|       |pub struct Schedule {
  407|       |    pub stages: Vec<Stage>,
  408|       |}
  409|       |
  410|       |pub struct Stage {
  411|       |    pub name: &'static str,
  412|       |    pub systems: Vec<SystemFn>,
  413|       |}
  414|       |
  415|       |impl Schedule {
  416|     15|    pub fn with_stage(mut self, name: &'static str) -> Self {
  417|     15|        self.stages.push(Stage {
  418|     15|            name,
  419|     15|            systems: vec![],
  420|     15|        });
  421|     15|        self
  422|     15|    }
  423|      3|    pub fn add_system(&mut self, stage: &'static str, sys: SystemFn) {
  424|     15|        if let Some(s) = self.stages.iter_mut().find(|s| s.name == stage) {
                                  ^3   ^3                     ^3
  425|      3|            s.systems.push(sys);
  426|      3|        }
                      ^0
  427|      3|    }
  428|      0|    pub fn run(&self, world: &mut World) {
  429|       |        #[cfg(feature = "profiling")]
  430|       |        span!("ECS::Schedule::run");
  431|       |
  432|      0|        for s in &self.stages {
  433|      0|            for f in &s.systems {
  434|      0|                (f)(world);
  435|      0|            }
  436|       |        }
  437|      0|    }
  438|       |}
  439|       |
  440|       |// App-like builder with deterministic fixed-timestep driver
  441|       |pub struct App {
  442|       |    pub world: World,
  443|       |    pub schedule: Schedule,
  444|       |}
  445|       |
  446|       |impl Default for App {
  447|      0|    fn default() -> Self {
  448|      0|        Self::new()
  449|      0|    }
  450|       |}
  451|       |
  452|       |impl App {
  453|      3|    pub fn new() -> Self {
  454|      3|        let mut schedule = Schedule::default();
  455|      3|        schedule = schedule
  456|      3|            .with_stage("perception")
  457|      3|            .with_stage("simulation")
  458|      3|            .with_stage("ai_planning")
  459|      3|            .with_stage("physics")
  460|      3|            .with_stage("presentation");
  461|      3|        Self {
  462|      3|            world: World::new(),
  463|      3|            schedule,
  464|      3|        }
  465|      3|    }
  466|       |
  467|      3|    pub fn add_system(&mut self, stage: &'static str, sys: SystemFn) {
  468|      3|        self.schedule.add_system(stage, sys);
  469|      3|    }
  470|      0|    pub fn insert_resource<T: 'static + Send + Sync>(mut self, r: T) -> Self {
  471|      0|        self.world.insert_resource(r);
  472|      0|        self
  473|      0|    }
  474|      0|    pub fn run_fixed(mut self, steps: u32) -> Self {
  475|      0|        for _ in 0..steps {
  476|      0|            self.schedule.run(&mut self.world);
  477|      0|        }
  478|      0|        self
  479|      0|    }
  480|       |}
  481|       |
  482|       |impl World {
  483|       |    /// Register a component type for type-erased operations (used by CommandBuffer).
  484|       |    ///
  485|       |    /// This must be called for any component type that will be used with CommandBuffer.
  486|       |    ///
  487|       |    /// # Example
  488|       |    /// ```
  489|       |    /// # use astraweave_ecs::World;
  490|       |    /// # #[derive(Clone, Copy)]
  491|       |    /// # struct Position { x: f32, y: f32 }
  492|       |    /// let mut world = World::new();
  493|       |    /// world.register_component::<Position>();
  494|       |    /// ```
  495|      0|    pub fn register_component<T: Component>(&mut self) {
  496|      0|        self.type_registry.register::<T>();
  497|      0|    }
  498|       |
  499|       |    /// Insert a type-erased component (used by CommandBuffer).
  500|       |    ///
  501|       |    /// # Panics
  502|       |    /// Panics if the component type is not registered via `register_component<T>()`.
  503|      0|    pub(crate) fn insert_boxed(
  504|      0|        &mut self,
  505|      0|        entity: Entity,
  506|      0|        type_id: TypeId,
  507|      0|        component: Box<dyn std::any::Any + Send + Sync>,
  508|      0|    ) {
  509|      0|        if !self.is_alive(entity) {
  510|      0|            return; // Stale entity, silently ignore
  511|      0|        }
  512|       |
  513|      0|        let handler = self
  514|      0|            .type_registry
  515|      0|            .insert_handlers
  516|      0|            .get(&type_id)
  517|      0|            .cloned()
  518|      0|            .unwrap_or_else(|| {
  519|      0|                panic!(
  520|      0|                    "insert_boxed: type {:?} not registered (call register_component::<T>() first)",
  521|       |                    type_id
  522|       |                )
  523|       |            });
  524|       |
  525|      0|        handler(self, entity, component);
  526|      0|    }
  527|       |
  528|       |    /// Remove a component by TypeId (used by CommandBuffer).
  529|       |    ///
  530|       |    /// # Panics
  531|       |    /// Panics if the component type is not registered via `register_component<T>()`.
  532|      0|    pub(crate) fn remove_by_type_id(&mut self, entity: Entity, type_id: TypeId) {
  533|      0|        if !self.is_alive(entity) {
  534|      0|            return; // Stale entity, silently ignore
  535|      0|        }
  536|       |
  537|      0|        let handler = self
  538|      0|            .type_registry
  539|      0|            .remove_handlers
  540|      0|            .get(&type_id)
  541|      0|            .cloned()
  542|      0|            .unwrap_or_else(|| {
  543|      0|                panic!(
  544|      0|                    "remove_by_type_id: type {:?} not registered (call register_component::<T>() first)",
  545|       |                    type_id
  546|       |                )
  547|       |            });
  548|       |
  549|      0|        handler(self, entity);
  550|      0|    }
  551|       |}
  552|       |
  553|       |// Plugin pattern similar to Bevy
  554|       |pub trait Plugin {
  555|       |    fn build(&self, app: &mut App);
  556|       |}
  557|       |impl App {
  558|      0|    pub fn add_plugin(mut self, p: impl Plugin) -> Self {
  559|      0|        p.build(&mut self);
  560|      0|        self
  561|      0|    }
  562|       |}
  563|       |
  564|       |// SECTION: System Execution
  565|       |
  566|       |#[cfg(test)]
  567|       |mod tests {
  568|       |    use super::*;
  569|       |
  570|       |    #[derive(Clone, Copy, Debug, PartialEq)]
  571|       |    struct Position {
  572|       |        x: f32,
  573|       |        y: f32,
  574|       |    }
  575|       |
  576|       |    #[derive(Clone, Copy, Debug, PartialEq)]
  577|       |    struct Velocity {
  578|       |        vx: f32,
  579|       |        vy: f32,
  580|       |    }
  581|       |
  582|       |    #[derive(Debug, PartialEq)]
  583|       |    struct TestResource(i32);
  584|       |
  585|       |    #[test]
  586|       |    fn test_spawn_and_insert() {
  587|       |        let mut world = World::new();
  588|       |        let entity = world.spawn();
  589|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  590|       |
  591|       |        assert!(world.has::<Position>(entity));
  592|       |        assert!(!world.has::<Velocity>(entity));
  593|       |
  594|       |        let pos = world.get::<Position>(entity).unwrap();
  595|       |        assert_eq!(*pos, Position { x: 1.0, y: 2.0 });
  596|       |    }
  597|       |
  598|       |    #[test]
  599|       |    fn test_despawn() {
  600|       |        let mut world = World::new();
  601|       |        let entity = world.spawn();
  602|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  603|       |
  604|       |        assert!(world.is_alive(entity));
  605|       |        world.despawn(entity);
  606|       |        assert!(!world.is_alive(entity));
  607|       |        assert!(!world.has::<Position>(entity));
  608|       |    }
  609|       |
  610|       |    #[test]
  611|       |    fn test_remove_component() {
  612|       |        let mut world = World::new();
  613|       |        let entity = world.spawn();
  614|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  615|       |        world.insert(entity, Velocity { vx: 0.0, vy: 0.0 });
  616|       |
  617|       |        assert!(world.has::<Position>(entity));
  618|       |        world.remove::<Position>(entity);
  619|       |        assert!(!world.has::<Position>(entity));
  620|       |        assert!(world.has::<Velocity>(entity)); // Other components should remain
  621|       |    }
  622|       |
  623|       |    #[test]
  624|       |    fn test_query_single_component() {
  625|       |        let mut world = World::new();
  626|       |        let e1 = world.spawn();
  627|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  628|       |        let e2 = world.spawn();
  629|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  630|       |        let e3 = world.spawn();
  631|       |        world.insert(e3, Velocity { vx: 0.0, vy: 0.0 });
  632|       |
  633|       |        let query = Query::<Position>::new(&world);
  634|       |        let mut count = 0;
  635|       |        let mut total_x = 0.0;
  636|       |        for (entity, pos) in query {
  637|       |            count += 1;
  638|       |            total_x += pos.x;
  639|       |            assert!(entity == e1 || entity == e2);
  640|       |        }
  641|       |        assert_eq!(count, 2);
  642|       |        assert_eq!(total_x, 3.0);
  643|       |    }
  644|       |
  645|       |    #[test]
  646|       |    fn test_query_two_components() {
  647|       |        let mut world = World::new();
  648|       |        let e1 = world.spawn();
  649|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  650|       |        world.insert(e1, Velocity { vx: 1.0, vy: 1.0 });
  651|       |
  652|       |        let e2 = world.spawn();
  653|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  654|       |
  655|       |        let e3 = world.spawn();
  656|       |        world.insert(e3, Position { x: 3.0, y: 3.0 });
  657|       |        world.insert(e3, Velocity { vx: 3.0, vy: 3.0 });
  658|       |
  659|       |        let query = Query2::<Position, Velocity>::new(&world);
  660|       |        let mut count = 0;
  661|       |        for (entity, pos, vel) in query {
  662|       |            count += 1;
  663|       |            assert!(entity == e1 || entity == e3);
  664|       |            assert_eq!(pos.x, vel.vx);
  665|       |        }
  666|       |        assert_eq!(count, 2);
  667|       |    }
  668|       |
  669|       |    #[test]
  670|       |    fn test_resource_management() {
  671|       |        let mut world = World::new();
  672|       |        world.insert_resource(TestResource(42));
  673|       |
  674|       |        let resource = world.get_resource::<TestResource>().unwrap();
  675|       |        assert_eq!(resource.0, 42);
  676|       |
  677|       |        let resource_mut = world.get_resource_mut::<TestResource>().unwrap();
  678|       |        resource_mut.0 = 100;
  679|       |
  680|       |        let resource_after = world.get_resource::<TestResource>().unwrap();
  681|       |        assert_eq!(resource_after.0, 100);
  682|       |    }
  683|       |
  684|       |    #[test]
  685|       |    fn test_get_mut() {
  686|       |        let mut world = World::new();
  687|       |        let entity = world.spawn();
  688|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  689|       |
  690|       |        let pos_mut = world.get_mut::<Position>(entity).unwrap();
  691|       |        pos_mut.x = 5.0;
  692|       |
  693|       |        let pos = world.get::<Position>(entity).unwrap();
  694|       |        assert_eq!(pos.x, 5.0);
  695|       |    }
  696|       |
  697|       |    // ====================
  698|       |    // Day 2: World Advanced API Tests
  699|       |    // ====================
  700|       |
  701|       |    #[test]
  702|       |    fn test_count_single_component() {
  703|       |        let mut world = World::new();
  704|       |
  705|       |        assert_eq!(world.count::<Position>(), 0);
  706|       |
  707|       |        let e1 = world.spawn();
  708|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  709|       |        assert_eq!(world.count::<Position>(), 1);
  710|       |
  711|       |        let e2 = world.spawn();
  712|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  713|       |        assert_eq!(world.count::<Position>(), 2);
  714|       |
  715|       |        let _e3 = world.spawn();
  716|       |        world.insert(_e3, Velocity { vx: 1.0, vy: 1.0 });
  717|       |        assert_eq!(world.count::<Position>(), 2);
  718|       |        assert_eq!(world.count::<Velocity>(), 1);
  719|       |    }
  720|       |
  721|       |    #[test]
  722|       |    fn test_count_across_archetypes() {
  723|       |        let mut world = World::new();
  724|       |
  725|       |        // Archetype 1: Position only
  726|       |        let e1 = world.spawn();
  727|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  728|       |
  729|       |        // Archetype 2: Position + Velocity
  730|       |        let e2 = world.spawn();
  731|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  732|       |        world.insert(e2, Velocity { vx: 1.0, vy: 1.0 });
  733|       |
  734|       |        // Should count both
  735|       |        assert_eq!(world.count::<Position>(), 2);
  736|       |        assert_eq!(world.count::<Velocity>(), 1);
  737|       |    }
  738|       |
  739|       |    #[test]
  740|       |    fn test_entities_with_single_component() {
  741|       |        let mut world = World::new();
  742|       |
  743|       |        let e1 = world.spawn();
  744|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  745|       |
  746|       |        let e2 = world.spawn();
  747|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  748|       |
  749|       |        let _e3 = world.spawn();
  750|       |        world.insert(_e3, Velocity { vx: 1.0, vy: 1.0 });
  751|       |
  752|       |        let entities = world.entities_with::<Position>();
  753|       |        assert_eq!(entities.len(), 2);
  754|       |        assert!(entities.contains(&e1));
  755|       |        assert!(entities.contains(&e2));
  756|       |    }
  757|       |
  758|       |    #[test]
  759|       |    fn test_entities_with_empty_result() {
  760|       |        let world = World::new();
  761|       |        let entities = world.entities_with::<Position>();
  762|       |        assert_eq!(entities.len(), 0);
  763|       |    }
  764|       |
  765|       |    #[test]
  766|       |    fn test_entities_with_across_archetypes() {
  767|       |        let mut world = World::new();
  768|       |
  769|       |        let e1 = world.spawn();
  770|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  771|       |
  772|       |        let e2 = world.spawn();
  773|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  774|       |        world.insert(e2, Velocity { vx: 1.0, vy: 1.0 });
  775|       |
  776|       |        let entities = world.entities_with::<Position>();
  777|       |        assert_eq!(entities.len(), 2);
  778|       |        assert!(entities.contains(&e1));
  779|       |        assert!(entities.contains(&e2));
  780|       |    }
  781|       |
  782|       |    #[test]
  783|       |    fn test_each_mut_modify_components() {
  784|       |        let mut world = World::new();
  785|       |
  786|       |        let e1 = world.spawn();
  787|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  788|       |
  789|       |        let e2 = world.spawn();
  790|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  791|       |
  792|       |        world.each_mut::<Position>(|_e, pos| {
  793|       |            pos.x += 10.0;
  794|       |        });
  795|       |
  796|       |        assert_eq!(world.get::<Position>(e1).unwrap().x, 11.0);
  797|       |        assert_eq!(world.get::<Position>(e2).unwrap().x, 12.0);
  798|       |    }
  799|       |
  800|       |    #[test]
  801|       |    fn test_each_mut_with_entity_access() {
  802|       |        let mut world = World::new();
  803|       |
  804|       |        let e1 = world.spawn();
  805|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  806|       |
  807|       |        let e2 = world.spawn();
  808|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  809|       |
  810|       |        let mut visited = Vec::new();
  811|       |        world.each_mut::<Position>(|entity, _pos| {
  812|       |            visited.push(entity);
  813|       |        });
  814|       |
  815|       |        assert_eq!(visited.len(), 2);
  816|       |        assert!(visited.contains(&e1));
  817|       |        assert!(visited.contains(&e2));
  818|       |    }
  819|       |
  820|       |    #[test]
  821|       |    fn test_entity_count() {
  822|       |        let mut world = World::new();
  823|       |
  824|       |        assert_eq!(world.entity_count(), 0);
  825|       |
  826|       |        let e1 = world.spawn();
  827|       |        assert_eq!(world.entity_count(), 1);
  828|       |
  829|       |        let _e2 = world.spawn();
  830|       |        assert_eq!(world.entity_count(), 2);
  831|       |
  832|       |        world.despawn(e1);
  833|       |        assert_eq!(world.entity_count(), 1);
  834|       |    }
  835|       |
  836|       |    // ====================
  837|       |    // Day 2: Stale Entity Handling Tests
  838|       |    // ====================
  839|       |
  840|       |    #[test]
  841|       |    fn test_insert_on_stale_entity_ignored() {
  842|       |        let mut world = World::new();
  843|       |        let entity = world.spawn();
  844|       |        world.despawn(entity);
  845|       |
  846|       |        // Insert on stale entity should be ignored silently
  847|       |        world.insert(entity, Position { x: 1.0, y: 1.0 });
  848|       |
  849|       |        assert!(!world.has::<Position>(entity));
  850|       |        assert_eq!(world.count::<Position>(), 0);
  851|       |    }
  852|       |
  853|       |    #[test]
  854|       |    fn test_get_on_stale_entity_returns_none() {
  855|       |        let mut world = World::new();
  856|       |        let entity = world.spawn();
  857|       |        world.insert(entity, Position { x: 1.0, y: 1.0 });
  858|       |        world.despawn(entity);
  859|       |
  860|       |        assert!(world.get::<Position>(entity).is_none());
  861|       |    }
  862|       |
  863|       |    #[test]
  864|       |    fn test_get_mut_on_stale_entity_returns_none() {
  865|       |        let mut world = World::new();
  866|       |        let entity = world.spawn();
  867|       |        world.insert(entity, Position { x: 1.0, y: 1.0 });
  868|       |        world.despawn(entity);
  869|       |
  870|       |        assert!(world.get_mut::<Position>(entity).is_none());
  871|       |    }
  872|       |
  873|       |    #[test]
  874|       |    fn test_has_on_stale_entity_returns_false() {
  875|       |        let mut world = World::new();
  876|       |        let entity = world.spawn();
  877|       |        world.insert(entity, Position { x: 1.0, y: 1.0 });
  878|       |        world.despawn(entity);
  879|       |
  880|       |        assert!(!world.has::<Position>(entity));
  881|       |    }
  882|       |
  883|       |    #[test]
  884|       |    fn test_remove_on_stale_entity_returns_false() {
  885|       |        let mut world = World::new();
  886|       |        let entity = world.spawn();
  887|       |        world.insert(entity, Position { x: 1.0, y: 1.0 });
  888|       |        world.despawn(entity);
  889|       |
  890|       |        assert!(!world.remove::<Position>(entity));
  891|       |    }
  892|       |
  893|       |    #[test]
  894|       |    fn test_despawn_stale_entity_returns_false() {
  895|       |        let mut world = World::new();
  896|       |        let entity = world.spawn();
  897|       |
  898|       |        assert!(world.despawn(entity));
  899|       |        assert!(!world.despawn(entity)); // Second despawn should return false
  900|       |    }
  901|       |
  902|       |    #[test]
  903|       |    fn test_remove_nonexistent_component_returns_false() {
  904|       |        let mut world = World::new();
  905|       |        let entity = world.spawn();
  906|       |        world.insert(entity, Position { x: 1.0, y: 1.0 });
  907|       |
  908|       |        // Removing component that doesn't exist
  909|       |        assert!(!world.remove::<Velocity>(entity));
  910|       |    }
  911|       |
  912|       |    // ====================
  913|       |    // Day 2: Resource Edge Cases
  914|       |    // ====================
  915|       |
  916|       |    #[test]
  917|       |    fn test_resource_get_nonexistent_returns_none() {
  918|       |        let world = World::new();
  919|       |        assert!(world.get_resource::<TestResource>().is_none());
  920|       |    }
  921|       |
  922|       |    #[test]
  923|       |    fn test_resource_get_mut_nonexistent_returns_none() {
  924|       |        let mut world = World::new();
  925|       |        assert!(world.get_resource_mut::<TestResource>().is_none());
  926|       |    }
  927|       |
  928|       |    #[test]
  929|       |    fn test_resource_replace() {
  930|       |        let mut world = World::new();
  931|       |        world.insert_resource(TestResource(10));
  932|       |
  933|       |        world.insert_resource(TestResource(20));
  934|       |
  935|       |        let resource = world.get_resource::<TestResource>().unwrap();
  936|       |        assert_eq!(resource.0, 20);
  937|       |    }
  938|       |
  939|       |    // ====================
  940|       |    // Day 2: App/Schedule API Tests
  941|       |    // ====================
  942|       |
  943|       |    #[test]
  944|       |    fn test_app_creation() {
  945|       |        let app = App::new();
  946|       |        assert_eq!(app.world.entity_count(), 0);
  947|       |        assert_eq!(app.schedule.stages.len(), 5);
  948|       |    }
  949|       |
  950|       |    #[test]
  951|       |    fn test_app_insert_resource() {
  952|       |        let app = App::new().insert_resource(TestResource(42));
  953|       |
  954|       |        let resource = app.world.get_resource::<TestResource>().unwrap();
  955|       |        assert_eq!(resource.0, 42);
  956|       |    }
  957|       |
  958|       |    #[test]
  959|       |    fn test_schedule_execution() {
  960|       |        fn test_system(world: &mut World) {
  961|       |            world.insert_resource(TestResource(99));
  962|       |        }
  963|       |
  964|       |        let mut app = App::new();
  965|       |        app.add_system("simulation", test_system);
  966|       |        app = app.run_fixed(1);
  967|       |
  968|       |        let resource = app.world.get_resource::<TestResource>().unwrap();
  969|       |        assert_eq!(resource.0, 99);
  970|       |    }
  971|       |
  972|       |    #[test]
  973|       |    fn test_schedule_multiple_systems() {
  974|       |        fn system_a(world: &mut World) {
  975|       |            world.insert_resource(TestResource(10));
  976|       |        }
  977|       |
  978|       |        fn system_b(world: &mut World) {
  979|       |            if let Some(resource) = world.get_resource_mut::<TestResource>() {
  980|       |                resource.0 += 5;
  981|       |            }
  982|       |        }
  983|       |
  984|       |        let mut app = App::new();
  985|       |        app.add_system("simulation", system_a);
  986|       |        app.add_system("simulation", system_b);
  987|       |        app = app.run_fixed(1);
  988|       |
  989|       |        let resource = app.world.get_resource::<TestResource>().unwrap();
  990|       |        assert_eq!(resource.0, 15);
  991|       |    }
  992|       |
  993|       |    #[test]
  994|       |    fn test_run_fixed_multiple_steps() {
  995|       |        fn increment_system(world: &mut World) {
  996|       |            if let Some(resource) = world.get_resource_mut::<TestResource>() {
  997|       |                resource.0 += 1;
  998|       |            } else {
  999|       |                world.insert_resource(TestResource(1));
 1000|       |            }
 1001|       |        }
 1002|       |
 1003|       |        let mut app = App::new();
 1004|       |        app.add_system("simulation", increment_system);
 1005|       |        app = app.run_fixed(10);
 1006|       |
 1007|       |        let resource = app.world.get_resource::<TestResource>().unwrap();
 1008|       |        assert_eq!(resource.0, 10);
 1009|       |    }
 1010|       |
 1011|       |    // ====================
 1012|       |    // Day 2: Archetype Access Tests
 1013|       |    // ====================
 1014|       |
 1015|       |    #[test]
 1016|       |    fn test_archetypes_read_access() {
 1017|       |        let mut world = World::new();
 1018|       |
 1019|       |        let e1 = world.spawn();
 1020|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
 1021|       |
 1022|       |        let archetypes = world.archetypes();
 1023|       |        let archetype_count = archetypes.iter().count();
 1024|       |
 1025|       |        // Should have at least 2 archetypes: empty and Position-only
 1026|       |        assert!(archetype_count >= 2);
 1027|       |    }
 1028|       |
 1029|       |    #[test]
 1030|       |    fn test_spawn_creates_empty_archetype_entity() {
 1031|       |        let mut world = World::new();
 1032|       |        let entity = world.spawn();
 1033|       |
 1034|       |        // Entity should exist in empty archetype
 1035|       |        assert!(world.is_alive(entity));
 1036|       |        assert_eq!(world.entity_count(), 1);
 1037|       |    }
 1038|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\rng.rs:
    1|       |//! Deterministic RNG for reproducible AI behavior.
    2|       |//!
    3|       |//! # Overview
    4|       |//!
    5|       |//! This module provides a **deterministic random number generator** that ensures
    6|       |//! AI agents make reproducible decisions across runs, platforms, and network clients.
    7|       |//!
    8|       |//! # Why Determinism Matters for AI
    9|       |//!
   10|       |//! **Problem**: AI systems often use randomness for decision-making:
   11|       |//! - Combat: Damage rolls, critical hits, dodge chances
   12|       |//! - Pathfinding: Breaking ties between equal-cost paths
   13|       |//! - Behavior: Randomized animations, idle behaviors
   14|       |//! - PCG: Procedurally generated content
   15|       |//!
   16|       |//! **Without determinism**:
   17|       |//! ```rust,ignore
   18|       |//! // Run 1: AI rolls 42 damage → kills enemy
   19|       |//! // Run 2: AI rolls 15 damage → enemy survives
   20|       |//! // SAME world state, DIFFERENT outcome! 💥
   21|       |//! ```
   22|       |//!
   23|       |//! **With determinism**:
   24|       |//! ```rust,ignore
   25|       |//! // Both runs: AI rolls 42 damage → kills enemy
   26|       |//! // SAME world state → SAME outcome ✅
   27|       |//! ```
   28|       |//!
   29|       |//! # Design Principles
   30|       |//!
   31|       |//! 1. **Fixed Seed Initialization**: Set seed once at world creation
   32|       |//! 2. **ChaCha8Rng**: Cryptographically secure, fast, platform-independent
   33|       |//! 3. **Resource Pattern**: Stored in World as singleton (like any ECS resource)
   34|       |//! 4. **Serializable**: Save/load RNG state for replay systems
   35|       |//!
   36|       |//! # Usage
   37|       |//!
   38|       |//! ```rust,ignore
   39|       |//! use astraweave_ecs::{World, Rng};
   40|       |//!
   41|       |//! // Initialize with fixed seed
   42|       |//! let mut world = World::new();
   43|       |//! world.insert_resource(Rng::from_seed(12345));
   44|       |//!
   45|       |//! // Use in AI systems
   46|       |//! fn combat_system(world: &mut World) {
   47|       |//!     let mut rng = world.get_resource_mut::<Rng>().unwrap();
   48|       |//!     let damage = rng.gen_range(10..20);  // Deterministic roll!
   49|       |//! }
   50|       |//! ```
   51|       |//!
   52|       |//! # Cross-Platform Guarantees
   53|       |//!
   54|       |//! ChaCha8Rng guarantees **identical sequences** on:
   55|       |//! - Windows, Linux, macOS
   56|       |//! - x86_64, ARM64, WASM
   57|       |//! - Different compiler versions
   58|       |//! - Release vs debug builds
   59|       |//!
   60|       |//! **This is critical for networked multiplayer** (lockstep simulation).
   61|       |
   62|       |use rand::distr::uniform::{SampleRange, SampleUniform};
   63|       |use rand::prelude::IndexedRandom;
   64|       |use rand::rngs::StdRng;
   65|       |use rand::{Rng as RngTrait, RngCore, SeedableRng};
   66|       |use serde::{Deserialize, Serialize};
   67|       |
   68|       |/// Deterministic random number generator for AI systems.
   69|       |///
   70|       |/// # Implementation
   71|       |///
   72|       |/// Uses `StdRng` (ChaCha12 in rand 0.9) for:
   73|       |/// - **Platform independence**: Same seed → same sequence on all platforms
   74|       |/// - **Performance**: ~3 GB/s throughput (fast enough for game loops)
   75|       |/// - **Quality**: Passes TestU01 BigCrush suite
   76|       |/// - **Serialization**: Seed can be saved/loaded (RNG state not serialized)
   77|       |///
   78|       |/// # Memory Layout
   79|       |///
   80|       |/// ```text
   81|       |/// Rng:
   82|       |/// ┌──────────────────────────────────┐
   83|       |/// │ StdRng (ChaCha12 state)          │  ~136 bytes
   84|       |/// │ seed: u64                        │  8 bytes
   85|       |/// └──────────────────────────────────┘
   86|       |/// ```
   87|       |///
   88|       |/// # Example
   89|       |///
   90|       |/// ```rust,ignore
   91|       |/// let mut rng = Rng::from_seed(12345);
   92|       |/// assert_eq!(rng.gen_u32(), 3841292459);  // Deterministic!
   93|       |/// assert_eq!(rng.gen_u32(), 2374534555);  // Same every time!
   94|       |/// ```
   95|       |#[derive(Clone, Debug)]
   96|       |pub struct Rng {
   97|       |    inner: StdRng,
   98|       |    seed: u64, // Store seed for debugging/logging
   99|       |}
  100|       |
  101|       |// Manual Serialize/Deserialize implementation (StdRng doesn't implement Serialize in rand 0.9)
  102|       |impl Serialize for Rng {
  103|      0|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  104|      0|    where
  105|      0|        S: serde::Serializer,
  106|       |    {
  107|       |        // Serialize only the seed, not the full state
  108|       |        // This is sufficient for determinism (can reconstruct from seed)
  109|      0|        self.seed.serialize(serializer)
  110|      0|    }
  111|       |}
  112|       |
  113|       |impl<'de> Deserialize<'de> for Rng {
  114|      0|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  115|      0|    where
  116|      0|        D: serde::Deserializer<'de>,
  117|       |    {
  118|      0|        let seed = u64::deserialize(deserializer)?;
  119|      0|        Ok(Rng::from_seed(seed))
  120|      0|    }
  121|       |}
  122|       |
  123|       |impl Rng {
  124|       |    /// Create RNG from a 64-bit seed.
  125|       |    ///
  126|       |    /// # Determinism Guarantee
  127|       |    ///
  128|       |    /// **Same seed → same sequence** across:
  129|       |    /// - All platforms (Windows, Linux, macOS, WASM)
  130|       |    /// - All architectures (x86_64, ARM64)
  131|       |    /// - All compiler versions
  132|       |    ///
  133|       |    /// # Example
  134|       |    ///
  135|       |    /// ```rust,ignore
  136|       |    /// let rng1 = Rng::from_seed(12345);
  137|       |    /// let rng2 = Rng::from_seed(12345);
  138|       |    /// // rng1 and rng2 produce identical sequences
  139|       |    /// ```
  140|       |    pub fn from_seed(seed: u64) -> Self {
  141|       |        Self {
  142|       |            inner: StdRng::seed_from_u64(seed),
  143|       |            seed,
  144|       |        }
  145|       |    }
  146|       |
  147|       |    /// Get the seed used to initialize this RNG.
  148|       |    ///
  149|       |    /// Useful for logging/debugging reproducibility issues.
  150|       |    pub fn seed(&self) -> u64 {
  151|       |        self.seed
  152|       |    }
  153|       |
  154|       |    /// Generate a random u32 value.
  155|       |    ///
  156|       |    /// # Example
  157|       |    ///
  158|       |    /// ```rust,ignore
  159|       |    /// let x = rng.gen_u32();
  160|       |    /// ```
  161|       |    #[inline]
  162|      0|    pub fn gen_u32(&mut self) -> u32 {
  163|      0|        RngCore::next_u32(&mut self.inner)
  164|      0|    }
  165|       |
  166|       |    /// Generate a random u64 value.
  167|       |    ///
  168|       |    /// # Example
  169|       |    ///
  170|       |    /// ```rust,ignore
  171|       |    /// let x = rng.gen_u64();
  172|       |    /// ```
  173|       |    #[inline]
  174|      0|    pub fn gen_u64(&mut self) -> u64 {
  175|      0|        RngCore::next_u64(&mut self.inner)
  176|      0|    }
  177|       |
  178|       |    /// Generate a random value in the range [low, high).
  179|       |    ///
  180|       |    /// # Example
  181|       |    ///
  182|       |    /// ```rust,ignore
  183|       |    /// let damage = rng.gen_range(10..20);  // [10, 19]
  184|       |    /// let chance = rng.gen_range(0.0..1.0);  // [0.0, 1.0)
  185|       |    /// ```
  186|      0|    pub fn gen_range<T, R>(&mut self, range: R) -> T
  187|      0|    where
  188|      0|        T: SampleUniform,
  189|      0|        R: SampleRange<T>,
  190|       |    {
  191|      0|        self.inner.random_range(range)
  192|      0|    }
  193|       |
  194|       |    /// Generate a random boolean with probability `p`.
  195|       |    ///
  196|       |    /// # Example
  197|       |    ///
  198|       |    /// ```rust,ignore
  199|       |    /// if rng.gen_bool(0.25) {
  200|       |    ///     // 25% chance
  201|       |    /// }
  202|       |    /// ```
  203|       |    pub fn gen_bool(&mut self, p: f64) -> bool {
  204|       |        self.inner.random_bool(p)
  205|       |    }
  206|       |
  207|       |    /// Shuffle a slice in place.
  208|       |    ///
  209|       |    /// # Example
  210|       |    ///
  211|       |    /// ```rust,ignore
  212|       |    /// let mut deck = vec![1, 2, 3, 4, 5];
  213|       |    /// rng.shuffle(&mut deck);
  214|       |    /// ```
  215|      0|    pub fn shuffle<T>(&mut self, slice: &mut [T]) {
  216|       |        use rand::seq::SliceRandom;
  217|      0|        slice.shuffle(&mut self.inner);
  218|      0|    }
  219|       |
  220|       |    /// Choose a random element from a slice.
  221|       |    ///
  222|       |    /// Returns `None` if slice is empty.
  223|       |    ///
  224|       |    /// # Example
  225|       |    ///
  226|       |    /// ```rust,ignore
  227|       |    /// let actions = vec!["attack", "defend", "heal"];
  228|       |    /// let action = rng.choose(&actions).unwrap();
  229|       |    /// ```
  230|      0|    pub fn choose<'a, T>(&mut self, slice: &'a [T]) -> Option<&'a T> {
  231|      0|        slice.choose(&mut self.inner)
  232|      0|    }
  233|       |}
  234|       |
  235|       |impl RngCore for Rng {
  236|       |    fn next_u32(&mut self) -> u32 {
  237|       |        self.inner.next_u32()
  238|       |    }
  239|       |
  240|       |    fn next_u64(&mut self) -> u64 {
  241|       |        self.inner.next_u64()
  242|       |    }
  243|       |
  244|       |    fn fill_bytes(&mut self, dest: &mut [u8]) {
  245|       |        self.inner.fill_bytes(dest)
  246|       |    }
  247|       |}
  248|       |
  249|       |#[cfg(test)]
  250|       |mod tests {
  251|       |    use super::*;
  252|       |
  253|       |    // === Fixed Seed Reproducibility Tests ===
  254|       |
  255|       |    #[test]
  256|       |    fn test_fixed_seed_produces_same_sequence() {
  257|       |        let mut rng1 = Rng::from_seed(12345);
  258|       |        let mut rng2 = Rng::from_seed(12345);
  259|       |
  260|       |        // Generate 100 values, verify identical
  261|       |        for _ in 0..100 {
  262|       |            assert_eq!(
  263|       |                rng1.gen_u32(),
  264|       |                rng2.gen_u32(),
  265|       |                "Same seed should produce identical sequence"
  266|       |            );
  267|       |        }
  268|       |    }
  269|       |
  270|       |    #[test]
  271|       |    fn test_different_seeds_produce_different_sequences() {
  272|       |        let mut rng1 = Rng::from_seed(12345);
  273|       |        let mut rng2 = Rng::from_seed(54321);
  274|       |
  275|       |        // First values should differ (extremely high probability)
  276|       |        let val1 = rng1.gen_u64();
  277|       |        let val2 = rng2.gen_u64();
  278|       |
  279|       |        assert_ne!(
  280|       |            val1, val2,
  281|       |            "Different seeds should produce different sequences"
  282|       |        );
  283|       |    }
  284|       |
  285|       |    #[test]
  286|       |    fn test_seed_getter() {
  287|       |        let rng = Rng::from_seed(42);
  288|       |        assert_eq!(rng.seed(), 42, "Seed getter should return original seed");
  289|       |    }
  290|       |
  291|       |    #[test]
  292|       |    fn test_gen_u32_deterministic() {
  293|       |        let mut rng = Rng::from_seed(999);
  294|       |
  295|       |        // Known values for seed 999 (ChaCha12)
  296|       |        let val1 = rng.gen_u32();
  297|       |        let val2 = rng.gen_u32();
  298|       |        let val3 = rng.gen_u32();
  299|       |
  300|       |        // Reset with same seed
  301|       |        let mut rng_reset = Rng::from_seed(999);
  302|       |        assert_eq!(rng_reset.gen_u32(), val1, "First value should match");
  303|       |        assert_eq!(rng_reset.gen_u32(), val2, "Second value should match");
  304|       |        assert_eq!(rng_reset.gen_u32(), val3, "Third value should match");
  305|       |    }
  306|       |
  307|       |    #[test]
  308|       |    fn test_gen_range_deterministic() {
  309|       |        let mut rng1 = Rng::from_seed(555);
  310|       |        let mut rng2 = Rng::from_seed(555);
  311|       |
  312|       |        // Generate 50 values in range
  313|       |        for _ in 0..50 {
  314|       |            let val1 = rng1.gen_range(10..100);
  315|       |            let val2 = rng2.gen_range(10..100);
  316|       |
  317|       |            assert_eq!(val1, val2, "gen_range should be deterministic");
  318|       |            assert!(
  319|       |                val1 >= 10 && val1 < 100,
  320|       |                "Value should be in range [10, 100)"
  321|       |            );
  322|       |        }
  323|       |    }
  324|       |
  325|       |    #[test]
  326|       |    fn test_gen_bool_deterministic() {
  327|       |        let mut rng1 = Rng::from_seed(777);
  328|       |        let mut rng2 = Rng::from_seed(777);
  329|       |
  330|       |        // Generate 50 booleans
  331|       |        for _ in 0..50 {
  332|       |            let val1 = rng1.gen_bool(0.5);
  333|       |            let val2 = rng2.gen_bool(0.5);
  334|       |
  335|       |            assert_eq!(val1, val2, "gen_bool should be deterministic");
  336|       |        }
  337|       |    }
  338|       |
  339|       |    // === State Serialization Tests ===
  340|       |
  341|       |    #[test]
  342|       |    fn test_rng_serialization() {
  343|       |        let seed = 888;
  344|       |        let mut rng = Rng::from_seed(seed);
  345|       |
  346|       |        // Generate some values to advance state
  347|       |        let _ = rng.gen_u32();
  348|       |        let _ = rng.gen_u32();
  349|       |
  350|       |        // Serialize
  351|       |        let serialized = serde_json::to_string(&rng).expect("Serialization should succeed");
  352|       |
  353|       |        // Deserialize
  354|       |        let mut rng_restored: Rng =
  355|       |            serde_json::from_str(&serialized).expect("Deserialization should succeed");
  356|       |
  357|       |        // NOTE: We only serialize the seed, not the RNG state.
  358|       |        // This means deserialization gives us a fresh RNG from the same seed.
  359|       |        // Verify that the deserialized RNG has the correct seed
  360|       |        assert_eq!(
  361|       |            rng_restored.seed(),
  362|       |            seed,
  363|       |            "Deserialized RNG should have same seed"
  364|       |        );
  365|       |
  366|       |        // Verify that two RNGs from the same seed produce the same sequence
  367|       |        let mut rng_fresh = Rng::from_seed(seed);
  368|       |        let val1 = rng_fresh.gen_u32();
  369|       |        let val2 = rng_restored.gen_u32();
  370|       |
  371|       |        assert_eq!(
  372|       |            val1, val2,
  373|       |            "RNGs from same seed should produce same sequence"
  374|       |        );
  375|       |    }
  376|       |
  377|       |    #[test]
  378|       |    fn test_rng_clone_produces_same_sequence() {
  379|       |        let mut rng = Rng::from_seed(333);
  380|       |
  381|       |        // Generate some values
  382|       |        let _ = rng.gen_u32();
  383|       |        let _ = rng.gen_u32();
  384|       |
  385|       |        // Clone
  386|       |        let mut rng_clone = rng.clone();
  387|       |
  388|       |        // Verify both produce same sequence
  389|       |        for _ in 0..10 {
  390|       |            assert_eq!(
  391|       |                rng.gen_u32(),
  392|       |                rng_clone.gen_u32(),
  393|       |                "Cloned RNG should produce identical sequence"
  394|       |            );
  395|       |        }
  396|       |    }
  397|       |
  398|       |    // === Shuffle & Choose Tests ===
  399|       |
  400|       |    #[test]
  401|       |    fn test_shuffle_deterministic() {
  402|       |        let mut rng1 = Rng::from_seed(444);
  403|       |        let mut rng2 = Rng::from_seed(444);
  404|       |
  405|       |        let mut deck1 = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  406|       |        let mut deck2 = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  407|       |
  408|       |        rng1.shuffle(&mut deck1);
  409|       |        rng2.shuffle(&mut deck2);
  410|       |
  411|       |        assert_eq!(deck1, deck2, "Shuffle should be deterministic");
  412|       |    }
  413|       |
  414|       |    #[test]
  415|       |    fn test_choose_deterministic() {
  416|       |        let mut rng1 = Rng::from_seed(666);
  417|       |        let mut rng2 = Rng::from_seed(666);
  418|       |
  419|       |        let options = vec!["attack", "defend", "heal", "flee"];
  420|       |
  421|       |        for _ in 0..20 {
  422|       |            let choice1 = rng1.choose(&options);
  423|       |            let choice2 = rng2.choose(&options);
  424|       |
  425|       |            assert_eq!(choice1, choice2, "Choose should be deterministic");
  426|       |        }
  427|       |    }
  428|       |
  429|       |    #[test]
  430|       |    fn test_choose_empty_slice() {
  431|       |        let mut rng = Rng::from_seed(111);
  432|       |        let empty: Vec<i32> = vec![];
  433|       |
  434|       |        assert!(
  435|       |            rng.choose(&empty).is_none(),
  436|       |            "Choose on empty slice should return None"
  437|       |        );
  438|       |    }
  439|       |
  440|       |    // === Multiple RNG Instances (Independence) ===
  441|       |
  442|       |    #[test]
  443|       |    fn test_multiple_rngs_independent() {
  444|       |        let mut rng1 = Rng::from_seed(100);
  445|       |        let mut rng2 = Rng::from_seed(200);
  446|       |
  447|       |        // Generate values from both
  448|       |        let val1_from_rng1 = rng1.gen_u32();
  449|       |        let val1_from_rng2 = rng2.gen_u32();
  450|       |
  451|       |        // Should differ (different seeds)
  452|       |        assert_ne!(
  453|       |            val1_from_rng1, val1_from_rng2,
  454|       |            "Different RNG instances should produce different values"
  455|       |        );
  456|       |
  457|       |        // But each should be internally consistent
  458|       |        let mut rng1_reset = Rng::from_seed(100);
  459|       |        assert_eq!(
  460|       |            rng1_reset.gen_u32(),
  461|       |            val1_from_rng1,
  462|       |            "Resetting RNG should reproduce same value"
  463|       |        );
  464|       |    }
  465|       |
  466|       |    // === Cross-Run Consistency (Regression Test) ===
  467|       |
  468|       |    #[test]
  469|       |    fn test_known_sequence_regression() {
  470|       |        // This test catches if RNG implementation changes break determinism
  471|       |        let mut rng = Rng::from_seed(0);
  472|       |
  473|       |        // Known values for seed 0 (ChaCha12 via StdRng in rand 0.9)
  474|       |        // Note: These values are specific to rand 0.9's StdRng (ChaCha12)
  475|       |        // If rand updates, these values may change (that's OK - update expected values)
  476|       |
  477|       |        // We don't hardcode exact values (they change with rand versions)
  478|       |        // Instead, verify consistency within this run
  479|       |        let val1 = rng.gen_u64();
  480|       |        let val2 = rng.gen_u64();
  481|       |        let val3 = rng.gen_u64();
  482|       |
  483|       |        // Reset and verify
  484|       |        let mut rng_reset = Rng::from_seed(0);
  485|       |        assert_eq!(rng_reset.gen_u64(), val1);
  486|       |        assert_eq!(rng_reset.gen_u64(), val2);
  487|       |        assert_eq!(rng_reset.gen_u64(), val3);
  488|       |    }
  489|       |
  490|       |    // === Distribution Tests ===
  491|       |
  492|       |    #[test]
  493|       |    fn test_gen_range_bounds() {
  494|       |        let mut rng = Rng::from_seed(123);
  495|       |
  496|       |        // Test integer range
  497|       |        for _ in 0..100 {
  498|       |            let val = rng.gen_range(0..10);
  499|       |            assert!(val >= 0 && val < 10, "Value should be in range [0, 10)");
  500|       |        }
  501|       |
  502|       |        // Test float range
  503|       |        for _ in 0..100 {
  504|       |            let val = rng.gen_range(0.0..1.0);
  505|       |            assert!(
  506|       |                val >= 0.0 && val < 1.0,
  507|       |                "Value should be in range [0.0, 1.0)"
  508|       |            );
  509|       |        }
  510|       |    }
  511|       |
  512|       |    #[test]
  513|       |    fn test_gen_bool_probability() {
  514|       |        let mut rng = Rng::from_seed(456);
  515|       |
  516|       |        // Test p=0.0 (always false)
  517|       |        for _ in 0..100 {
  518|       |            assert!(!rng.gen_bool(0.0), "p=0.0 should always be false");
  519|       |        }
  520|       |
  521|       |        // Test p=1.0 (always true)
  522|       |        let mut rng = Rng::from_seed(789);
  523|       |        for _ in 0..100 {
  524|       |            assert!(rng.gen_bool(1.0), "p=1.0 should always be true");
  525|       |        }
  526|       |    }
  527|       |
  528|       |    // === Additional Coverage Tests (Week 6 Day 3 Part 4) ===
  529|       |
  530|       |    #[test]
  531|       |    fn test_fill_bytes_deterministic() {
  532|       |        // Test RngCore::fill_bytes implementation
  533|       |        let mut rng1 = Rng::from_seed(2024);
  534|       |        let mut rng2 = Rng::from_seed(2024);
  535|       |
  536|       |        let mut buf1 = [0u8; 32];
  537|       |        let mut buf2 = [0u8; 32];
  538|       |
  539|       |        rng1.fill_bytes(&mut buf1);
  540|       |        rng2.fill_bytes(&mut buf2);
  541|       |
  542|       |        assert_eq!(
  543|       |            buf1, buf2,
  544|       |            "fill_bytes should be deterministic with same seed"
  545|       |        );
  546|       |
  547|       |        // Verify it actually filled with non-zero bytes (extremely high probability)
  548|       |        let non_zero_count = buf1.iter().filter(|&&b| b != 0).count();
  549|       |        assert!(
  550|       |            non_zero_count > 0,
  551|       |            "fill_bytes should produce non-zero bytes"
  552|       |        );
  553|       |    }
  554|       |
  555|       |    #[test]
  556|       |    fn test_gen_u64_wrapper() {
  557|       |        // Explicit test for gen_u64() wrapper method
  558|       |        let mut rng1 = Rng::from_seed(2025);
  559|       |        let mut rng2 = Rng::from_seed(2025);
  560|       |
  561|       |        // Generate via wrapper method
  562|       |        let val1 = rng1.gen_u64();
  563|       |        let val2 = rng2.gen_u64();
  564|       |
  565|       |        assert_eq!(val1, val2, "gen_u64 should be deterministic");
  566|       |
  567|       |        // Verify via RngCore trait (should be identical)
  568|       |        let mut rng3 = Rng::from_seed(2025);
  569|       |        let val3 = RngCore::next_u64(&mut rng3);
  570|       |        assert_eq!(val1, val3, "gen_u64 wrapper should match RngCore::next_u64");
  571|       |
  572|       |        // Verify range (u64::MAX is valid)
  573|       |        assert!(val1 <= u64::MAX, "gen_u64 should produce valid u64 values");
  574|       |    }
  575|       |
  576|       |    #[test]
  577|       |    fn test_fill_bytes_empty_buffer() {
  578|       |        // Edge case: fill_bytes with zero-length buffer
  579|       |        let mut rng = Rng::from_seed(12345);
  580|       |        let mut buf = [];
  581|       |
  582|       |        // Should not panic
  583|       |        rng.fill_bytes(&mut buf);
  584|       |        assert_eq!(buf.len(), 0, "Empty buffer should remain empty");
  585|       |    }
  586|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\sparse_set.rs:
    1|       |// SPDX-License-Identifier: MIT
    2|       |//! Sparse set data structure for O(1) entity lookup
    3|       |//!
    4|       |//! Based on the classic sparse set pattern used by EnTT, Flecs, and Bevy.
    5|       |//! Provides O(1) insert, get, and remove operations with packed iteration.
    6|       |
    7|       |use crate::Entity;
    8|       |
    9|       |/// Sparse set mapping Entity → dense index
   10|       |///
   11|       |/// This data structure provides:
   12|       |/// - O(1) insert, get, remove
   13|       |/// - Packed dense array for cache-friendly iteration
   14|       |/// - Sparse array for fast entity → index lookup
   15|       |///
   16|       |/// Memory layout:
   17|       |/// ```text
   18|       |/// sparse: [None, Some(0), None, Some(1), None, Some(2), ...]
   19|       |///              ↓              ↓              ↓
   20|       |/// dense:  [Entity(1), Entity(3), Entity(5), ...]
   21|       |/// ```
   22|       |pub struct SparseSet {
   23|       |    /// Sparse array: Entity ID → dense index
   24|       |    /// Only allocated entries contain Some(index)
   25|       |    sparse: Vec<Option<usize>>,
   26|       |
   27|       |    /// Dense array: Packed list of entities
   28|       |    /// This is what we iterate over for cache-friendly access
   29|       |    dense: Vec<Entity>,
   30|       |}
   31|       |
   32|       |impl SparseSet {
   33|       |    /// Create a new empty SparseSet
   34|      0|    pub fn new() -> Self {
   35|      0|        Self {
   36|      0|            sparse: Vec::new(),
   37|      0|            dense: Vec::new(),
   38|      0|        }
   39|      0|    }
   40|       |
   41|       |    /// Create a new SparseSet with capacity for `capacity` entities
   42|      0|    pub fn with_capacity(capacity: usize) -> Self {
   43|      0|        Self {
   44|      0|            sparse: Vec::with_capacity(capacity),
   45|      0|            dense: Vec::with_capacity(capacity),
   46|      0|        }
   47|      0|    }
   48|       |
   49|       |    /// Insert an entity into the set
   50|       |    ///
   51|       |    /// Returns the dense index where the entity was inserted.
   52|       |    /// If the entity already exists, returns its existing index.
   53|      0|    pub fn insert(&mut self, entity: Entity) -> usize {
   54|      0|        let id = entity.id() as usize;
   55|       |
   56|       |        // Check if entity already exists
   57|      0|        if let Some(&index) = self.sparse.get(id).and_then(|opt| opt.as_ref()) {
   58|      0|            return index;
   59|      0|        }
   60|       |
   61|       |        // Expand sparse array if needed
   62|      0|        if id >= self.sparse.len() {
   63|      0|            self.sparse.resize(id + 1, None);
   64|      0|        }
   65|       |
   66|       |        // Add to dense array
   67|      0|        let dense_index = self.dense.len();
   68|      0|        self.dense.push(entity);
   69|      0|        self.sparse[id] = Some(dense_index);
   70|       |
   71|      0|        dense_index
   72|      0|    }
   73|       |
   74|       |    /// Get the dense index for an entity
   75|       |    ///
   76|       |    /// Returns None if the entity is not in the set.
   77|      0|    pub fn get(&self, entity: Entity) -> Option<usize> {
   78|      0|        let id = entity.id() as usize;
   79|      0|        self.sparse.get(id).and_then(|opt| *opt)
   80|      0|    }
   81|       |
   82|       |    /// Check if the set contains an entity
   83|      0|    pub fn contains(&self, entity: Entity) -> bool {
   84|      0|        self.get(entity).is_some()
   85|      0|    }
   86|       |
   87|       |    /// Remove an entity from the set
   88|       |    ///
   89|       |    /// Returns the dense index where the entity was located, or None if not found.
   90|       |    /// Uses swap_remove for O(1) performance (order not preserved).
   91|      0|    pub fn remove(&mut self, entity: Entity) -> Option<usize> {
   92|      0|        let id = entity.id() as usize;
   93|       |
   94|      0|        let dense_index = self.sparse.get_mut(id)?.take()?;
   95|       |
   96|       |        // Swap with last element for O(1) removal
   97|      0|        let last_index = self.dense.len() - 1;
   98|       |
   99|      0|        if dense_index != last_index {
  100|      0|            // Update the swapped entity's sparse index
  101|      0|            let swapped_entity = self.dense[last_index];
  102|      0|            self.dense.swap(dense_index, last_index);
  103|      0|            self.sparse[swapped_entity.id() as usize] = Some(dense_index);
  104|      0|        }
  105|       |
  106|      0|        self.dense.pop();
  107|       |
  108|      0|        Some(dense_index)
  109|      0|    }
  110|       |
  111|       |    /// Get the number of entities in the set
  112|      0|    pub fn len(&self) -> usize {
  113|      0|        self.dense.len()
  114|      0|    }
  115|       |
  116|       |    /// Check if the set is empty
  117|      0|    pub fn is_empty(&self) -> bool {
  118|      0|        self.dense.is_empty()
  119|      0|    }
  120|       |
  121|       |    /// Get the packed dense array of entities
  122|       |    ///
  123|       |    /// This is the array you should iterate over for cache-friendly access.
  124|      0|    pub fn entities(&self) -> &[Entity] {
  125|      0|        &self.dense
  126|      0|    }
  127|       |
  128|       |    /// Clear all entities from the set
  129|      0|    pub fn clear(&mut self) {
  130|      0|        self.dense.clear();
  131|      0|        self.sparse.clear();
  132|      0|    }
  133|       |
  134|       |    /// Get the capacity of the dense array
  135|      0|    pub fn capacity(&self) -> usize {
  136|      0|        self.dense.capacity()
  137|      0|    }
  138|       |
  139|       |    /// Reserve space for at least `additional` more entities
  140|      0|    pub fn reserve(&mut self, additional: usize) {
  141|      0|        self.dense.reserve(additional);
  142|      0|    }
  143|       |}
  144|       |
  145|       |impl Default for SparseSet {
  146|      0|    fn default() -> Self {
  147|      0|        Self::new()
  148|      0|    }
  149|       |}
  150|       |
  151|       |/// Generic sparse set for storing arbitrary data
  152|       |///
  153|       |/// This extends SparseSet to store data alongside entities.
  154|       |pub struct SparseSetData<T> {
  155|       |    /// Sparse array: Entity ID → dense index
  156|       |    sparse: Vec<Option<usize>>,
  157|       |
  158|       |    /// Dense array: Packed entities
  159|       |    entities: Vec<Entity>,
  160|       |
  161|       |    /// Dense array: Packed data
  162|       |    data: Vec<T>,
  163|       |}
  164|       |
  165|       |impl<T> SparseSetData<T> {
  166|       |    /// Create a new empty SparseSetData
  167|      0|    pub fn new() -> Self {
  168|      0|        Self {
  169|      0|            sparse: Vec::new(),
  170|      0|            entities: Vec::new(),
  171|      0|            data: Vec::new(),
  172|      0|        }
  173|      0|    }
  174|       |
  175|       |    /// Create a new SparseSetData with capacity
  176|      0|    pub fn with_capacity(capacity: usize) -> Self {
  177|      0|        Self {
  178|      0|            sparse: Vec::with_capacity(capacity),
  179|      0|            entities: Vec::with_capacity(capacity),
  180|      0|            data: Vec::with_capacity(capacity),
  181|      0|        }
  182|      0|    }
  183|       |
  184|       |    /// Insert an entity with associated data
  185|       |    ///
  186|       |    /// If the entity already exists, its data is replaced.
  187|       |    /// Returns the old data if it existed.
  188|      0|    pub fn insert(&mut self, entity: Entity, value: T) -> Option<T> {
  189|      0|        let id = entity.id() as usize;
  190|       |
  191|       |        // Check if entity already exists
  192|      0|        if let Some(&index) = self.sparse.get(id).and_then(|opt| opt.as_ref()) {
  193|      0|            return Some(std::mem::replace(&mut self.data[index], value));
  194|      0|        }
  195|       |
  196|       |        // Expand sparse array if needed
  197|      0|        if id >= self.sparse.len() {
  198|      0|            self.sparse.resize(id + 1, None);
  199|      0|        }
  200|       |
  201|       |        // Add to dense arrays
  202|      0|        let dense_index = self.entities.len();
  203|      0|        self.entities.push(entity);
  204|      0|        self.data.push(value);
  205|      0|        self.sparse[id] = Some(dense_index);
  206|       |
  207|      0|        None
  208|      0|    }
  209|       |
  210|       |    /// Get a reference to the data for an entity
  211|      0|    pub fn get(&self, entity: Entity) -> Option<&T> {
  212|      0|        let id = entity.id() as usize;
  213|      0|        let index = *self.sparse.get(id)?.as_ref()?;
  214|      0|        self.data.get(index)
  215|      0|    }
  216|       |
  217|       |    /// Get a mutable reference to the data for an entity
  218|      0|    pub fn get_mut(&mut self, entity: Entity) -> Option<&mut T> {
  219|      0|        let id = entity.id() as usize;
  220|      0|        let index = *self.sparse.get(id)?.as_ref()?;
  221|      0|        self.data.get_mut(index)
  222|      0|    }
  223|       |
  224|       |    /// Check if the set contains an entity
  225|      0|    pub fn contains(&self, entity: Entity) -> bool {
  226|      0|        let id = entity.id() as usize;
  227|      0|        self.sparse.get(id).and_then(|opt| *opt).is_some()
  228|      0|    }
  229|       |
  230|       |    /// Remove an entity and return its data
  231|      0|    pub fn remove(&mut self, entity: Entity) -> Option<T> {
  232|      0|        let id = entity.id() as usize;
  233|       |
  234|      0|        let dense_index = self.sparse.get_mut(id)?.take()?;
  235|       |
  236|       |        // Swap with last element for O(1) removal
  237|      0|        let last_index = self.entities.len() - 1;
  238|       |
  239|      0|        if dense_index != last_index {
  240|      0|            // Update the swapped entity's sparse index
  241|      0|            let swapped_entity = self.entities[last_index];
  242|      0|            self.entities.swap(dense_index, last_index);
  243|      0|            self.data.swap(dense_index, last_index);
  244|      0|            self.sparse[swapped_entity.id() as usize] = Some(dense_index);
  245|      0|        }
  246|       |
  247|      0|        self.entities.pop();
  248|      0|        self.data.pop()
  249|      0|    }
  250|       |
  251|       |    /// Get the number of entities
  252|      0|    pub fn len(&self) -> usize {
  253|      0|        self.entities.len()
  254|      0|    }
  255|       |
  256|       |    /// Check if the set is empty
  257|      0|    pub fn is_empty(&self) -> bool {
  258|      0|        self.entities.is_empty()
  259|      0|    }
  260|       |
  261|       |    /// Get the packed entities array
  262|      0|    pub fn entities(&self) -> &[Entity] {
  263|      0|        &self.entities
  264|      0|    }
  265|       |
  266|       |    /// Get the packed data array
  267|      0|    pub fn data(&self) -> &[T] {
  268|      0|        &self.data
  269|      0|    }
  270|       |
  271|       |    /// Get mutable packed data array
  272|      0|    pub fn data_mut(&mut self) -> &mut [T] {
  273|      0|        &mut self.data
  274|      0|    }
  275|       |
  276|       |    /// Iterate over (entity, data) pairs
  277|      0|    pub fn iter(&self) -> impl Iterator<Item = (Entity, &T)> {
  278|      0|        self.entities.iter().copied().zip(self.data.iter())
  279|      0|    }
  280|       |
  281|       |    /// Iterate mutably over (entity, data) pairs
  282|      0|    pub fn iter_mut(&mut self) -> impl Iterator<Item = (Entity, &mut T)> {
  283|      0|        self.entities.iter().copied().zip(self.data.iter_mut())
  284|      0|    }
  285|       |
  286|       |    /// Clear all entities and data
  287|      0|    pub fn clear(&mut self) {
  288|      0|        self.entities.clear();
  289|      0|        self.data.clear();
  290|      0|        self.sparse.clear();
  291|      0|    }
  292|       |}
  293|       |
  294|       |impl<T> Default for SparseSetData<T> {
  295|      0|    fn default() -> Self {
  296|      0|        Self::new()
  297|      0|    }
  298|       |}
  299|       |
  300|       |#[cfg(test)]
  301|       |mod tests {
  302|       |    use super::*;
  303|       |
  304|       |    #[test]
  305|       |    fn test_sparse_set_insert() {
  306|       |        let mut set = SparseSet::new();
  307|       |
  308|       |        let e1 = unsafe { Entity::from_raw(5) };
  309|       |        let e2 = unsafe { Entity::from_raw(10) };
  310|       |        let e3 = unsafe { Entity::from_raw(3) };
  311|       |
  312|       |        let idx1 = set.insert(e1);
  313|       |        let idx2 = set.insert(e2);
  314|       |        let idx3 = set.insert(e3);
  315|       |
  316|       |        assert_eq!(idx1, 0);
  317|       |        assert_eq!(idx2, 1);
  318|       |        assert_eq!(idx3, 2);
  319|       |        assert_eq!(set.len(), 3);
  320|       |    }
  321|       |
  322|       |    #[test]
  323|       |    fn test_sparse_set_get() {
  324|       |        let mut set = SparseSet::new();
  325|       |
  326|       |        let e1 = unsafe { Entity::from_raw(5) };
  327|       |        let e2 = unsafe { Entity::from_raw(10) };
  328|       |
  329|       |        set.insert(e1);
  330|       |        set.insert(e2);
  331|       |
  332|       |        assert_eq!(set.get(e1), Some(0));
  333|       |        assert_eq!(set.get(e2), Some(1));
  334|       |        assert_eq!(set.get(unsafe { Entity::from_raw(99) }), None);
  335|       |    }
  336|       |
  337|       |    #[test]
  338|       |    fn test_sparse_set_contains() {
  339|       |        let mut set = SparseSet::new();
  340|       |
  341|       |        let e1 = unsafe { Entity::from_raw(5) };
  342|       |        let e2 = unsafe { Entity::from_raw(10) };
  343|       |
  344|       |        set.insert(e1);
  345|       |
  346|       |        assert!(set.contains(e1));
  347|       |        assert!(!set.contains(e2));
  348|       |    }
  349|       |
  350|       |    #[test]
  351|       |    fn test_sparse_set_remove() {
  352|       |        let mut set = SparseSet::new();
  353|       |
  354|       |        let e1 = unsafe { Entity::from_raw(5) };
  355|       |        let e2 = unsafe { Entity::from_raw(10) };
  356|       |        let e3 = unsafe { Entity::from_raw(15) };
  357|       |
  358|       |        set.insert(e1);
  359|       |        set.insert(e2);
  360|       |        set.insert(e3);
  361|       |
  362|       |        assert_eq!(set.len(), 3);
  363|       |
  364|       |        // Remove middle element
  365|       |        let removed_idx = set.remove(e2);
  366|       |        assert_eq!(removed_idx, Some(1));
  367|       |        assert_eq!(set.len(), 2);
  368|       |
  369|       |        // e3 should have been swapped into e2's position
  370|       |        assert_eq!(set.get(e3), Some(1));
  371|       |        assert_eq!(set.get(e1), Some(0));
  372|       |        assert_eq!(set.get(e2), None);
  373|       |    }
  374|       |
  375|       |    #[test]
  376|       |    fn test_sparse_set_clear() {
  377|       |        let mut set = SparseSet::new();
  378|       |
  379|       |        set.insert(unsafe { Entity::from_raw(1) });
  380|       |        set.insert(unsafe { Entity::from_raw(2) });
  381|       |
  382|       |        assert_eq!(set.len(), 2);
  383|       |
  384|       |        set.clear();
  385|       |
  386|       |        assert_eq!(set.len(), 0);
  387|       |        assert!(set.is_empty());
  388|       |    }
  389|       |
  390|       |    #[test]
  391|       |    fn test_sparse_set_data_insert() {
  392|       |        let mut set = SparseSetData::new();
  393|       |
  394|       |        let e1 = unsafe { Entity::from_raw(5) };
  395|       |        let e2 = unsafe { Entity::from_raw(10) };
  396|       |
  397|       |        set.insert(e1, "hello");
  398|       |        set.insert(e2, "world");
  399|       |
  400|       |        assert_eq!(set.get(e1), Some(&"hello"));
  401|       |        assert_eq!(set.get(e2), Some(&"world"));
  402|       |    }
  403|       |
  404|       |    #[test]
  405|       |    fn test_sparse_set_data_replace() {
  406|       |        let mut set = SparseSetData::new();
  407|       |
  408|       |        let e1 = unsafe { Entity::from_raw(5) };
  409|       |
  410|       |        let old = set.insert(e1, 42);
  411|       |        assert_eq!(old, None);
  412|       |
  413|       |        let old = set.insert(e1, 100);
  414|       |        assert_eq!(old, Some(42));
  415|       |
  416|       |        assert_eq!(set.get(e1), Some(&100));
  417|       |    }
  418|       |
  419|       |    #[test]
  420|       |    fn test_sparse_set_data_remove() {
  421|       |        let mut set = SparseSetData::new();
  422|       |
  423|       |        let e1 = unsafe { Entity::from_raw(5) };
  424|       |        let e2 = unsafe { Entity::from_raw(10) };
  425|       |        let e3 = unsafe { Entity::from_raw(15) };
  426|       |
  427|       |        set.insert(e1, 1);
  428|       |        set.insert(e2, 2);
  429|       |        set.insert(e3, 3);
  430|       |
  431|       |        let removed = set.remove(e2);
  432|       |        assert_eq!(removed, Some(2));
  433|       |
  434|       |        assert_eq!(set.get(e1), Some(&1));
  435|       |        assert_eq!(set.get(e2), None);
  436|       |        assert_eq!(set.get(e3), Some(&3));
  437|       |    }
  438|       |
  439|       |    #[test]
  440|       |    fn test_sparse_set_data_iter() {
  441|       |        let mut set = SparseSetData::new();
  442|       |
  443|       |        let e1 = unsafe { Entity::from_raw(5) };
  444|       |        let e2 = unsafe { Entity::from_raw(10) };
  445|       |        let e3 = unsafe { Entity::from_raw(15) };
  446|       |
  447|       |        set.insert(e1, 100);
  448|       |        set.insert(e2, 200);
  449|       |        set.insert(e3, 300);
  450|       |
  451|       |        let sum: i32 = set.iter().map(|(_, &value)| value).sum();
  452|       |        assert_eq!(sum, 600);
  453|       |    }
  454|       |
  455|       |    #[test]
  456|       |    fn test_sparse_set_data_iter_mut() {
  457|       |        let mut set = SparseSetData::new();
  458|       |
  459|       |        let e1 = unsafe { Entity::from_raw(5) };
  460|       |        let e2 = unsafe { Entity::from_raw(10) };
  461|       |
  462|       |        set.insert(e1, 10);
  463|       |        set.insert(e2, 20);
  464|       |
  465|       |        for (_, value) in set.iter_mut() {
  466|       |            *value *= 2;
  467|       |        }
  468|       |
  469|       |        assert_eq!(set.get(e1), Some(&20));
  470|       |        assert_eq!(set.get(e2), Some(&40));
  471|       |    }
  472|       |
  473|       |    // ====================
  474|       |    // Day 3: Surgical Coverage Improvements
  475|       |    // ====================
  476|       |
  477|       |    #[test]
  478|       |    fn test_sparse_set_with_capacity() {
  479|       |        let set = SparseSet::with_capacity(100);
  480|       |        assert_eq!(set.len(), 0);
  481|       |        assert!(set.capacity() >= 100);
  482|       |    }
  483|       |
  484|       |    #[test]
  485|       |    fn test_sparse_set_capacity_and_reserve() {
  486|       |        let mut set = SparseSet::new();
  487|       |        let initial_cap = set.capacity();
  488|       |
  489|       |        set.reserve(50);
  490|       |        assert!(set.capacity() >= initial_cap + 50);
  491|       |    }
  492|       |
  493|       |    #[test]
  494|       |    fn test_sparse_set_insert_existing_entity() {
  495|       |        let mut set = SparseSet::new();
  496|       |        let e1 = unsafe { Entity::from_raw(5) };
  497|       |
  498|       |        let idx1 = set.insert(e1);
  499|       |        let idx2 = set.insert(e1); // Idempotent insert
  500|       |
  501|       |        assert_eq!(idx1, idx2);
  502|       |        assert_eq!(set.len(), 1); // Should not duplicate
  503|       |    }
  504|       |
  505|       |    #[test]
  506|       |    fn test_sparse_set_remove_nonexistent() {
  507|       |        let mut set = SparseSet::new();
  508|       |        let e1 = unsafe { Entity::from_raw(5) };
  509|       |
  510|       |        let removed = set.remove(e1);
  511|       |        assert_eq!(removed, None);
  512|       |    }
  513|       |
  514|       |    #[test]
  515|       |    fn test_sparse_set_large_entity_ids() {
  516|       |        let mut set = SparseSet::new();
  517|       |
  518|       |        // Large entity IDs force sparse array expansion
  519|       |        let e1 = unsafe { Entity::from_raw(1000) };
  520|       |        let e2 = unsafe { Entity::from_raw(5000) };
  521|       |
  522|       |        set.insert(e1);
  523|       |        set.insert(e2);
  524|       |
  525|       |        assert_eq!(set.len(), 2);
  526|       |        assert!(set.contains(e1));
  527|       |        assert!(set.contains(e2));
  528|       |    }
  529|       |
  530|       |    #[test]
  531|       |    fn test_sparse_set_remove_last_element() {
  532|       |        let mut set = SparseSet::new();
  533|       |
  534|       |        let e1 = unsafe { Entity::from_raw(5) };
  535|       |        let e2 = unsafe { Entity::from_raw(10) };
  536|       |
  537|       |        set.insert(e1);
  538|       |        set.insert(e2);
  539|       |
  540|       |        // Remove last element (no swap needed)
  541|       |        let removed = set.remove(e2);
  542|       |        assert_eq!(removed, Some(1));
  543|       |        assert_eq!(set.len(), 1);
  544|       |        assert_eq!(set.get(e1), Some(0));
  545|       |    }
  546|       |
  547|       |    #[test]
  548|       |    fn test_sparse_set_data_with_capacity() {
  549|       |        let set = SparseSetData::<i32>::with_capacity(100);
  550|       |        assert_eq!(set.len(), 0);
  551|       |        assert!(set.is_empty());
  552|       |    }
  553|       |
  554|       |    #[test]
  555|       |    fn test_sparse_set_data_get_mut() {
  556|       |        let mut set = SparseSetData::new();
  557|       |
  558|       |        let e1 = unsafe { Entity::from_raw(5) };
  559|       |        set.insert(e1, 42);
  560|       |
  561|       |        if let Some(value) = set.get_mut(e1) {
  562|       |            *value += 10;
  563|       |        }
  564|       |
  565|       |        assert_eq!(set.get(e1), Some(&52));
  566|       |    }
  567|       |
  568|       |    #[test]
  569|       |    fn test_sparse_set_data_get_mut_nonexistent() {
  570|       |        let mut set = SparseSetData::<i32>::new();
  571|       |        let e1 = unsafe { Entity::from_raw(5) };
  572|       |
  573|       |        assert!(set.get_mut(e1).is_none());
  574|       |    }
  575|       |
  576|       |    #[test]
  577|       |    fn test_sparse_set_data_contains() {
  578|       |        let mut set = SparseSetData::new();
  579|       |
  580|       |        let e1 = unsafe { Entity::from_raw(5) };
  581|       |        let e2 = unsafe { Entity::from_raw(10) };
  582|       |
  583|       |        set.insert(e1, 42);
  584|       |
  585|       |        assert!(set.contains(e1));
  586|       |        assert!(!set.contains(e2));
  587|       |    }
  588|       |
  589|       |    #[test]
  590|       |    fn test_sparse_set_data_clear() {
  591|       |        let mut set = SparseSetData::new();
  592|       |
  593|       |        set.insert(unsafe { Entity::from_raw(1) }, 10);
  594|       |        set.insert(unsafe { Entity::from_raw(2) }, 20);
  595|       |
  596|       |        assert_eq!(set.len(), 2);
  597|       |
  598|       |        set.clear();
  599|       |
  600|       |        assert_eq!(set.len(), 0);
  601|       |        assert!(set.is_empty());
  602|       |    }
  603|       |
  604|       |    #[test]
  605|       |    fn test_sparse_set_data_arrays() {
  606|       |        let mut set = SparseSetData::new();
  607|       |
  608|       |        let e1 = unsafe { Entity::from_raw(5) };
  609|       |        let e2 = unsafe { Entity::from_raw(10) };
  610|       |
  611|       |        set.insert(e1, 100);
  612|       |        set.insert(e2, 200);
  613|       |
  614|       |        assert_eq!(set.entities().len(), 2);
  615|       |        assert_eq!(set.data().len(), 2);
  616|       |
  617|       |        // Mutate via data_mut()
  618|       |        set.data_mut()[0] += 50;
  619|       |        assert_eq!(set.get(e1), Some(&150));
  620|       |    }
  621|       |
  622|       |    #[test]
  623|       |    fn test_sparse_set_data_remove_last() {
  624|       |        let mut set = SparseSetData::new();
  625|       |
  626|       |        let e1 = unsafe { Entity::from_raw(5) };
  627|       |        let e2 = unsafe { Entity::from_raw(10) };
  628|       |
  629|       |        set.insert(e1, 1);
  630|       |        set.insert(e2, 2);
  631|       |
  632|       |        // Remove last element (no swap needed)
  633|       |        let removed = set.remove(e2);
  634|       |        assert_eq!(removed, Some(2));
  635|       |        assert_eq!(set.len(), 1);
  636|       |    }
  637|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\system_param.rs:
    1|       |//! System parameter types for ECS queries.
    2|       |//!
    3|       |//! ## Performance Notes (Week 10)
    4|       |//!
    5|       |//! ### Current Performance (Post SparseSet Integration)
    6|       |//!
    7|       |//! With the SparseSet integration (Week 10 Day 2), entity lookups are now O(1) instead
    8|       |//! of O(log n), providing 12-57× speedup over the old BTreeMap approach. This has
    9|       |//! resulted in:
   10|       |//!
   11|       |//! - **Frame time**: 2.70ms → 1.144ms (2.4× faster)
   12|       |//! - **Movement system**: 1,000µs → 106µs (9.4× faster)
   13|       |//! - **FPS**: 370 → 944 (2.5× improvement)
   14|       |//! - **Headroom**: 93.1% vs 60 FPS budget (16.67ms)
   15|       |//!
   16|       |//! ### Per-Entity Overhead Pattern
   17|       |//!
   18|       |//! Current Query implementations use a per-entity `archetype.get::<T>(entity)` pattern:
   19|       |//!
   20|       |//! ```rust,ignore
   21|       |//! impl Iterator for Query<'w, T> {
   22|       |//!     fn next(&mut self) -> Option<(Entity, &'w T)> {
   23|       |//!         let entity = archetype.entities_vec()[self.entity_idx];
   24|       |//!         let component = archetype.get::<T>(entity)?;
   25|       |//!         // Each get() call:
   26|       |//!         // 1. SparseSet lookup: O(1) - fast!
   27|       |//!         // 2. HashMap lookup: O(1) - fast!
   28|       |//!         // 3. Vec indexing: O(1) - fast!
   29|       |//!         // 4. Box downcast: O(1) - fast!
   30|       |//!         // Total: 4 operations per entity (1,000 entities = 4,000 ops)
   31|       |//!     }
   32|       |//! }
   33|       |//! ```
   34|       |//!
   35|       |//! While each operation is O(1), the repeated overhead adds up for large entity counts.
   36|       |//!
   37|       |//! ### Why Batch Iteration is Difficult
   38|       |//!
   39|       |//! Ideally, we'd batch all operations at the archetype level:
   40|       |//!
   41|       |//! ```rust,ignore
   42|       |//! // Dream API (blocked by borrow checker):
   43|       |//! for (entity, component) in archetype.iter_components_mut::<Position>() {
   44|       |//!     component.x += velocity.x;  // Direct mutable access, no per-entity lookups!
   45|       |//! }
   46|       |//! ```
   47|       |//!
   48|       |//! However, this is **not feasible** with Rust's current borrow checker due to lifetime
   49|       |//! constraints. The issue:
   50|       |//!
   51|       |//! ```rust,ignore
   52|       |//! pub fn iter_components_mut<T>(&mut self) -> impl Iterator<Item = (Entity, &mut T)> {
   53|       |//!     let column = self.components.get_mut(&TypeId::of::<T>())?;
   54|       |//!     self.entities.iter().filter_map(|(idx, &entity)| {
   55|       |//!         column.get_mut(idx)  // ❌ ERROR: captured variable escapes FnMut closure
   56|       |//!         //                           Returns &mut T borrowed from captured column
   57|       |//!     })
   58|       |//! }
   59|       |//! ```
   60|       |//!
   61|       |//! Rust's borrow checker prevents this because:
   62|       |//! 1. The closure captures `column` (a mutable reference)
   63|       |//! 2. The closure tries to return `&mut T` borrowed from `column`
   64|       |//! 3. Rule: **References captured in closures cannot escape the closure scope**
   65|       |//! 4. This prevents dangling references but blocks the optimization
   66|       |//!
   67|       |//! ### Future Optimizations (Week 11-12)
   68|       |//!
   69|       |//! **Week 11: SystemParam DSL**
   70|       |//! - Compile-time borrow splitting with zero runtime cost
   71|       |//! - Eliminate Query2Mut 70% overhead (Action 32 issue)
   72|       |//! - Target: Movement <50µs (2× current performance)
   73|       |//!
   74|       |//! **Week 12: Parallel Execution**
   75|       |//! - Rayon-based parallel system execution
   76|       |//! - Dependency analysis for safe concurrent iteration
   77|       |//! - Target: Physics 813µs → 200-400µs (2-4× faster)
   78|       |//!
   79|       |//! **Week 13+: Type Registry + BlobVec Integration**
   80|       |//! - Runtime type registration system
   81|       |//! - Replace Vec<Box<dyn Any>> with contiguous BlobVec storage
   82|       |//! - This will enable ideal batch iteration (no Box overhead, no downcast)
   83|       |//! - Expected: Additional 5-10× component access speedup
   84|       |
   85|       |use crate::{archetype::ArchetypeId, Component, Entity, World};
   86|       |
   87|       |/// Trait for types that can be system parameters
   88|       |pub trait SystemParam: Sized {
   89|       |    // This will be fleshed out later. For now, it's a marker trait.
   90|       |}
   91|       |
   92|       |// Read-only single-component query
   93|       |pub struct Query<'w, T: Component> {
   94|       |    world: &'w World,
   95|       |    archetype_ids: Vec<ArchetypeId>,
   96|       |    arch_idx: usize,
   97|       |    entity_idx: usize,
   98|       |    _m: std::marker::PhantomData<T>,
   99|       |}
  100|       |
  101|       |impl<'w, T: Component> Query<'w, T> {
  102|      0|    pub fn new(world: &'w World) -> Self {
  103|      0|        let archetype_ids = world
  104|      0|            .archetypes
  105|      0|            .archetypes_with_component(std::any::TypeId::of::<T>())
  106|      0|            .map(|arch| arch.id)
  107|      0|            .collect();
  108|      0|        Self {
  109|      0|            world,
  110|      0|            archetype_ids,
  111|      0|            arch_idx: 0,
  112|      0|            entity_idx: 0,
  113|      0|            _m: Default::default(),
  114|      0|        }
  115|      0|    }
  116|       |}
  117|       |
  118|       |impl<'w, T: Component> Iterator for Query<'w, T> {
  119|       |    type Item = (Entity, &'w T);
  120|      0|    fn next(&mut self) -> Option<Self::Item> {
  121|       |        loop {
  122|      0|            if self.arch_idx >= self.archetype_ids.len() {
  123|      0|                return None;
  124|      0|            }
  125|      0|            let archetype_id = self.archetype_ids[self.arch_idx];
  126|      0|            let archetype = self
  127|      0|                .world
  128|      0|                .archetypes
  129|      0|                .get_archetype(archetype_id)
  130|      0|                .expect("BUG: archetype should exist from archetype_ids");
  131|       |
  132|      0|            if self.entity_idx >= archetype.len() {
  133|      0|                self.arch_idx += 1;
  134|      0|                self.entity_idx = 0;
  135|      0|                continue;
  136|      0|            }
  137|       |
  138|      0|            let entity = archetype.entities_vec()[self.entity_idx];
  139|      0|            self.entity_idx += 1;
  140|       |
  141|       |            // The borrow checker needs help here. Since we are iterating over disjoint archetypes
  142|       |            // and entities, this is safe. We'll use unsafe to extend the lifetime.
  143|      0|            let component = archetype
  144|      0|                .get::<T>(entity)
  145|      0|                .expect("BUG: entity should have component T in archetype");
  146|      0|            let component_ptr = component as *const T;
  147|      0|            return Some((entity, unsafe { &*component_ptr }));
  148|       |        }
  149|      0|    }
  150|       |}
  151|       |
  152|       |// Read-only two-component query
  153|       |pub struct Query2<'w, A: Component, B: Component> {
  154|       |    world: &'w World,
  155|       |    archetype_ids: Vec<ArchetypeId>,
  156|       |    arch_idx: usize,
  157|       |    entity_idx: usize,
  158|       |    _m: std::marker::PhantomData<(A, B)>,
  159|       |}
  160|       |
  161|       |impl<'w, A: Component, B: Component> Query2<'w, A, B> {
  162|      0|    pub fn new(world: &'w World) -> Self {
  163|      0|        let archetype_ids = world
  164|      0|            .archetypes
  165|      0|            .archetypes_with_component(std::any::TypeId::of::<A>())
  166|      0|            .filter(|arch| arch.signature.contains(std::any::TypeId::of::<B>()))
  167|      0|            .map(|arch| arch.id)
  168|      0|            .collect();
  169|       |
  170|      0|        Self {
  171|      0|            world,
  172|      0|            archetype_ids,
  173|      0|            arch_idx: 0,
  174|      0|            entity_idx: 0,
  175|      0|            _m: Default::default(),
  176|      0|        }
  177|      0|    }
  178|       |}
  179|       |
  180|       |impl<'w, A: Component, B: Component> Iterator for Query2<'w, A, B> {
  181|       |    type Item = (Entity, &'w A, &'w B);
  182|      0|    fn next(&mut self) -> Option<Self::Item> {
  183|       |        loop {
  184|      0|            if self.arch_idx >= self.archetype_ids.len() {
  185|      0|                return None;
  186|      0|            }
  187|      0|            let archetype_id = self.archetype_ids[self.arch_idx];
  188|      0|            let archetype = self
  189|      0|                .world
  190|      0|                .archetypes
  191|      0|                .get_archetype(archetype_id)
  192|      0|                .expect("BUG: archetype should exist from archetype_ids");
  193|       |
  194|      0|            if self.entity_idx >= archetype.len() {
  195|      0|                self.arch_idx += 1;
  196|      0|                self.entity_idx = 0;
  197|      0|                continue;
  198|      0|            }
  199|       |
  200|      0|            let entity = archetype.entities_vec()[self.entity_idx];
  201|      0|            self.entity_idx += 1;
  202|       |
  203|       |            // Unsafe is used to satisfy the borrow checker. This is safe because
  204|       |            // we are only reading, and the iterator structure ensures we don't hold
  205|       |            // references that outlive the world.
  206|      0|            let component_a = archetype
  207|      0|                .get::<A>(entity)
  208|      0|                .expect("BUG: entity should have component A in archetype");
  209|      0|            let component_b = archetype
  210|      0|                .get::<B>(entity)
  211|      0|                .expect("BUG: entity should have component B in archetype");
  212|      0|            let ptr_a = component_a as *const A;
  213|      0|            let ptr_b = component_b as *const B;
  214|       |
  215|      0|            return Some((entity, unsafe { &*ptr_a }, unsafe { &*ptr_b }));
  216|       |        }
  217|      0|    }
  218|       |}
  219|       |
  220|       |// Mutable two-component query (for Action 32 writeback optimization)
  221|       |pub struct Query2Mut<'w, A: Component, B: Component> {
  222|       |    world: *mut World,
  223|       |    archetype_ids: Vec<ArchetypeId>,
  224|       |    arch_idx: usize,
  225|       |    entity_idx: usize,
  226|       |    _m: std::marker::PhantomData<(&'w mut A, &'w B)>,
  227|       |}
  228|       |
  229|       |impl<'w, A: Component, B: Component> Query2Mut<'w, A, B> {
  230|      0|    pub fn new(world: &'w mut World) -> Self {
  231|      0|        let archetype_ids = world
  232|      0|            .archetypes
  233|      0|            .archetypes_with_component(std::any::TypeId::of::<A>())
  234|      0|            .filter(|arch| arch.signature.contains(std::any::TypeId::of::<B>()))
  235|      0|            .map(|arch| arch.id)
  236|      0|            .collect();
  237|       |
  238|      0|        Self {
  239|      0|            world,
  240|      0|            archetype_ids,
  241|      0|            arch_idx: 0,
  242|      0|            entity_idx: 0,
  243|      0|            _m: Default::default(),
  244|      0|        }
  245|      0|    }
  246|       |}
  247|       |
  248|       |impl<'w, A: Component, B: Component> Iterator for Query2Mut<'w, A, B> {
  249|       |    type Item = (Entity, &'w mut A, &'w B);
  250|      0|    fn next(&mut self) -> Option<Self::Item> {
  251|       |        loop {
  252|      0|            if self.arch_idx >= self.archetype_ids.len() {
  253|      0|                return None;
  254|      0|            }
  255|      0|            let archetype_id = self.archetype_ids[self.arch_idx];
  256|       |
  257|       |            // SAFETY: We hold *mut World for 'w lifetime. We reconstruct references for each iteration.
  258|       |            // This is safe because:
  259|       |            // 1. The world pointer is valid for 'w
  260|       |            // 2. We only access one entity at a time
  261|       |            // 3. A and B are different types (no aliasing within single entity)
  262|      0|            let world_ref = unsafe { &mut *self.world };
  263|       |
  264|       |            // Get immutable reference to archetype for metadata access
  265|      0|            let archetype = world_ref
  266|      0|                .archetypes
  267|      0|                .get_archetype(archetype_id)
  268|      0|                .expect("BUG: archetype should exist from archetype_ids");
  269|       |
  270|      0|            if self.entity_idx >= archetype.len() {
  271|      0|                self.arch_idx += 1;
  272|      0|                self.entity_idx = 0;
  273|      0|                continue;
  274|      0|            }
  275|       |
  276|      0|            let entity = archetype.entities_vec()[self.entity_idx];
  277|      0|            self.entity_idx += 1;
  278|       |
  279|       |            // SAFETY: Now get the actual component data using raw pointers to avoid borrow conflicts.
  280|       |            // We get component A mutably and B immutably through separate archetype lookups.
  281|       |            // This is safe because:
  282|       |            // 1. A and B are different types (ensured by type system)
  283|       |            // 2. We're returning references that live for 'w
  284|       |            // 3. Iterator ensures sequential access (no overlapping entity borrows)
  285|      0|            let world_ref2 = unsafe { &mut *self.world };
  286|      0|            let archetype_mut = world_ref2
  287|      0|                .archetypes
  288|      0|                .get_archetype_mut(archetype_id)
  289|      0|                .expect("BUG: archetype should exist");
  290|      0|            let component_a = archetype_mut
  291|      0|                .get_mut::<A>(entity)
  292|      0|                .expect("BUG: entity should have component A in archetype");
  293|      0|            let ptr_a = component_a as *mut A;
  294|       |
  295|      0|            let world_ref3 = unsafe { &*self.world };
  296|      0|            let archetype_imm = world_ref3
  297|      0|                .archetypes
  298|      0|                .get_archetype(archetype_id)
  299|      0|                .expect("BUG: archetype should exist");
  300|      0|            let component_b = archetype_imm
  301|      0|                .get::<B>(entity)
  302|      0|                .expect("BUG: entity should have component B in archetype");
  303|      0|            let ptr_b = component_b as *const B;
  304|       |
  305|      0|            return Some((entity, unsafe { &mut *ptr_a }, unsafe { &*ptr_b }));
  306|       |        }
  307|      0|    }
  308|       |}
  309|       |
  310|       |#[cfg(test)]
  311|       |mod tests {
  312|       |    use super::*;
  313|       |
  314|       |    #[derive(Debug, Clone, PartialEq)]
  315|       |    struct Position {
  316|       |        x: f32,
  317|       |        y: f32,
  318|       |    }
  319|       |
  320|       |    #[derive(Debug, Clone, PartialEq)]
  321|       |    struct Velocity {
  322|       |        x: f32,
  323|       |        y: f32,
  324|       |    }
  325|       |
  326|       |    #[derive(Debug, Clone, PartialEq)]
  327|       |    struct Health {
  328|       |        current: i32,
  329|       |        max: i32,
  330|       |    }
  331|       |
  332|       |    // ====================
  333|       |    // Day 1: Query Tests (Single Component)
  334|       |    // ====================
  335|       |
  336|       |    #[test]
  337|       |    fn test_query_single_component_empty() {
  338|       |        let world = World::new();
  339|       |        let query = Query::<Position>::new(&world);
  340|       |        let results: Vec<_> = query.collect();
  341|       |        assert_eq!(results.len(), 0, "Empty world should return no results");
  342|       |    }
  343|       |
  344|       |    #[test]
  345|       |    fn test_query_single_component_one_entity() {
  346|       |        let mut world = World::new();
  347|       |        let entity = world.spawn();
  348|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  349|       |
  350|       |        let query = Query::<Position>::new(&world);
  351|       |        let results: Vec<_> = query.collect();
  352|       |
  353|       |        assert_eq!(results.len(), 1, "Should find one entity with Position");
  354|       |        assert_eq!(results[0].0, entity);
  355|       |        assert_eq!(results[0].1.x, 1.0);
  356|       |        assert_eq!(results[0].1.y, 2.0);
  357|       |    }
  358|       |
  359|       |    #[test]
  360|       |    fn test_query_single_component_multiple_entities() {
  361|       |        let mut world = World::new();
  362|       |        let e1 = world.spawn();
  363|       |        let e2 = world.spawn();
  364|       |        let e3 = world.spawn();
  365|       |
  366|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  367|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  368|       |        world.insert(e3, Position { x: 3.0, y: 3.0 });
  369|       |
  370|       |        let query = Query::<Position>::new(&world);
  371|       |        let results: Vec<_> = query.collect();
  372|       |
  373|       |        assert_eq!(results.len(), 3, "Should find all three entities");
  374|       |
  375|       |        // Verify all entities present (order may vary due to archetype iteration)
  376|       |        let entities: Vec<Entity> = results.iter().map(|(e, _)| *e).collect();
  377|       |        assert!(entities.contains(&e1));
  378|       |        assert!(entities.contains(&e2));
  379|       |        assert!(entities.contains(&e3));
  380|       |    }
  381|       |
  382|       |    #[test]
  383|       |    fn test_query_filters_entities_without_component() {
  384|       |        let mut world = World::new();
  385|       |        let e1 = world.spawn();
  386|       |        let e2 = world.spawn();
  387|       |        let e3 = world.spawn();
  388|       |
  389|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  390|       |        world.insert(e2, Velocity { x: 5.0, y: 5.0 }); // No Position!
  391|       |        world.insert(e3, Position { x: 3.0, y: 3.0 });
  392|       |
  393|       |        let query = Query::<Position>::new(&world);
  394|       |        let results: Vec<_> = query.collect();
  395|       |
  396|       |        assert_eq!(results.len(), 2, "Should only find entities with Position");
  397|       |
  398|       |        let entities: Vec<Entity> = results.iter().map(|(e, _)| *e).collect();
  399|       |        assert!(entities.contains(&e1));
  400|       |        assert!(!entities.contains(&e2), "e2 should not be in results");
  401|       |        assert!(entities.contains(&e3));
  402|       |    }
  403|       |
  404|       |    #[test]
  405|       |    fn test_query_multiple_archetypes() {
  406|       |        let mut world = World::new();
  407|       |
  408|       |        // Archetype 1: Position only
  409|       |        let e1 = world.spawn();
  410|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  411|       |
  412|       |        // Archetype 2: Position + Velocity
  413|       |        let e2 = world.spawn();
  414|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  415|       |        world.insert(e2, Velocity { x: 1.0, y: 1.0 });
  416|       |
  417|       |        // Archetype 3: Position + Health
  418|       |        let e3 = world.spawn();
  419|       |        world.insert(e3, Position { x: 3.0, y: 3.0 });
  420|       |        world.insert(
  421|       |            e3,
  422|       |            Health {
  423|       |                current: 100,
  424|       |                max: 100,
  425|       |            },
  426|       |        );
  427|       |
  428|       |        let query = Query::<Position>::new(&world);
  429|       |        let results: Vec<_> = query.collect();
  430|       |
  431|       |        assert_eq!(
  432|       |            results.len(),
  433|       |            3,
  434|       |            "Should find entities across all archetypes with Position"
  435|       |        );
  436|       |    }
  437|       |
  438|       |    // ====================
  439|       |    // Day 1: Query2 Tests (Two Components)
  440|       |    // ====================
  441|       |
  442|       |    #[test]
  443|       |    fn test_query2_empty_world() {
  444|       |        let world = World::new();
  445|       |        let query = Query2::<Position, Velocity>::new(&world);
  446|       |        let results: Vec<_> = query.collect();
  447|       |        assert_eq!(results.len(), 0, "Empty world should return no results");
  448|       |    }
  449|       |
  450|       |    #[test]
  451|       |    fn test_query2_one_matching_entity() {
  452|       |        let mut world = World::new();
  453|       |        let entity = world.spawn();
  454|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  455|       |        world.insert(entity, Velocity { x: 0.5, y: 0.5 });
  456|       |
  457|       |        let query = Query2::<Position, Velocity>::new(&world);
  458|       |        let results: Vec<_> = query.collect();
  459|       |
  460|       |        assert_eq!(results.len(), 1);
  461|       |        assert_eq!(results[0].0, entity);
  462|       |        assert_eq!(results[0].1.x, 1.0);
  463|       |        assert_eq!(results[0].2.x, 0.5);
  464|       |    }
  465|       |
  466|       |    #[test]
  467|       |    fn test_query2_filters_partial_matches() {
  468|       |        let mut world = World::new();
  469|       |
  470|       |        // Entity with both components
  471|       |        let e1 = world.spawn();
  472|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  473|       |        world.insert(e1, Velocity { x: 0.5, y: 0.5 });
  474|       |
  475|       |        // Entity with Position only
  476|       |        let e2 = world.spawn();
  477|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  478|       |
  479|       |        // Entity with Velocity only
  480|       |        let e3 = world.spawn();
  481|       |        world.insert(e3, Velocity { x: 1.0, y: 1.0 });
  482|       |
  483|       |        let query = Query2::<Position, Velocity>::new(&world);
  484|       |        let results: Vec<_> = query.collect();
  485|       |
  486|       |        assert_eq!(
  487|       |            results.len(),
  488|       |            1,
  489|       |            "Should only find entity with both components"
  490|       |        );
  491|       |        assert_eq!(results[0].0, e1);
  492|       |    }
  493|       |
  494|       |    #[test]
  495|       |    fn test_query2_multiple_matching_entities() {
  496|       |        let mut world = World::new();
  497|       |
  498|       |        let e1 = world.spawn();
  499|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  500|       |        world.insert(e1, Velocity { x: 0.1, y: 0.1 });
  501|       |
  502|       |        let e2 = world.spawn();
  503|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  504|       |        world.insert(e2, Velocity { x: 0.2, y: 0.2 });
  505|       |
  506|       |        let e3 = world.spawn();
  507|       |        world.insert(e3, Position { x: 3.0, y: 3.0 });
  508|       |        world.insert(e3, Velocity { x: 0.3, y: 0.3 });
  509|       |
  510|       |        let query = Query2::<Position, Velocity>::new(&world);
  511|       |        let results: Vec<_> = query.collect();
  512|       |
  513|       |        assert_eq!(results.len(), 3);
  514|       |    }
  515|       |
  516|       |    #[test]
  517|       |    fn test_query2_across_archetypes() {
  518|       |        let mut world = World::new();
  519|       |
  520|       |        // Archetype 1: Position + Velocity
  521|       |        let e1 = world.spawn();
  522|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  523|       |        world.insert(e1, Velocity { x: 0.5, y: 0.5 });
  524|       |
  525|       |        // Archetype 2: Position + Velocity + Health
  526|       |        let e2 = world.spawn();
  527|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  528|       |        world.insert(e2, Velocity { x: 1.0, y: 1.0 });
  529|       |        world.insert(
  530|       |            e2,
  531|       |            Health {
  532|       |                current: 100,
  533|       |                max: 100,
  534|       |            },
  535|       |        );
  536|       |
  537|       |        let query = Query2::<Position, Velocity>::new(&world);
  538|       |        let results: Vec<_> = query.collect();
  539|       |
  540|       |        assert_eq!(results.len(), 2, "Should find entities across archetypes");
  541|       |    }
  542|       |
  543|       |    // ====================
  544|       |    // Day 1: Query2Mut Tests (Mutable Queries)
  545|       |    // ====================
  546|       |
  547|       |    #[test]
  548|       |    fn test_query2mut_empty_world() {
  549|       |        let mut world = World::new();
  550|       |        let query = Query2Mut::<Position, Velocity>::new(&mut world);
  551|       |        let results: Vec<_> = query.collect();
  552|       |        assert_eq!(results.len(), 0);
  553|       |    }
  554|       |
  555|       |    #[test]
  556|       |    fn test_query2mut_mutation() {
  557|       |        let mut world = World::new();
  558|       |        let entity = world.spawn();
  559|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  560|       |        world.insert(entity, Velocity { x: 0.5, y: 0.5 });
  561|       |
  562|       |        {
  563|       |            let query = Query2Mut::<Position, Velocity>::new(&mut world);
  564|       |            for (_e, pos, vel) in query {
  565|       |                pos.x += vel.x;
  566|       |                pos.y += vel.y;
  567|       |            }
  568|       |        }
  569|       |
  570|       |        // Verify mutation
  571|       |        let pos = world.get::<Position>(entity).unwrap();
  572|       |        assert_eq!(pos.x, 1.5);
  573|       |        assert_eq!(pos.y, 2.5);
  574|       |    }
  575|       |
  576|       |    #[test]
  577|       |    fn test_query2mut_multiple_entities() {
  578|       |        let mut world = World::new();
  579|       |
  580|       |        let e1 = world.spawn();
  581|       |        world.insert(e1, Position { x: 0.0, y: 0.0 });
  582|       |        world.insert(e1, Velocity { x: 1.0, y: 1.0 });
  583|       |
  584|       |        let e2 = world.spawn();
  585|       |        world.insert(e2, Position { x: 5.0, y: 5.0 });
  586|       |        world.insert(e2, Velocity { x: 2.0, y: 2.0 });
  587|       |
  588|       |        {
  589|       |            let query = Query2Mut::<Position, Velocity>::new(&mut world);
  590|       |            for (_e, pos, vel) in query {
  591|       |                pos.x += vel.x * 10.0;
  592|       |                pos.y += vel.y * 10.0;
  593|       |            }
  594|       |        }
  595|       |
  596|       |        let pos1 = world.get::<Position>(e1).unwrap();
  597|       |        assert_eq!(pos1.x, 10.0);
  598|       |        assert_eq!(pos1.y, 10.0);
  599|       |
  600|       |        let pos2 = world.get::<Position>(e2).unwrap();
  601|       |        assert_eq!(pos2.x, 25.0);
  602|       |        assert_eq!(pos2.y, 25.0);
  603|       |    }
  604|       |
  605|       |    #[test]
  606|       |    fn test_query2mut_filters_correctly() {
  607|       |        let mut world = World::new();
  608|       |
  609|       |        // Entity with both components
  610|       |        let e1 = world.spawn();
  611|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  612|       |        world.insert(e1, Velocity { x: 1.0, y: 1.0 });
  613|       |
  614|       |        // Entity with Position only (should not be mutated)
  615|       |        let e2 = world.spawn();
  616|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  617|       |
  618|       |        {
  619|       |            let query = Query2Mut::<Position, Velocity>::new(&mut world);
  620|       |            for (_e, pos, vel) in query {
  621|       |                pos.x += vel.x;
  622|       |            }
  623|       |        }
  624|       |
  625|       |        let pos1 = world.get::<Position>(e1).unwrap();
  626|       |        assert_eq!(pos1.x, 2.0, "e1 should be mutated");
  627|       |
  628|       |        let pos2 = world.get::<Position>(e2).unwrap();
  629|       |        assert_eq!(pos2.x, 2.0, "e2 should NOT be mutated");
  630|       |    }
  631|       |
  632|       |    // ====================
  633|       |    // Day 1: Query Component Access Patterns
  634|       |    // ====================
  635|       |
  636|       |    #[test]
  637|       |    fn test_query_read_only_access() {
  638|       |        let mut world = World::new();
  639|       |        let entity = world.spawn();
  640|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  641|       |
  642|       |        let query = Query::<Position>::new(&world);
  643|       |
  644|       |        // Verify we can read data
  645|       |        let results: Vec<_> = query.collect();
  646|       |        assert_eq!(results[0].1.x, 1.0);
  647|       |
  648|       |        // Original data unchanged
  649|       |        let pos = world.get::<Position>(entity).unwrap();
  650|       |        assert_eq!(pos.x, 1.0);
  651|       |    }
  652|       |
  653|       |    #[test]
  654|       |    fn test_query2_read_only_both_components() {
  655|       |        let mut world = World::new();
  656|       |        let entity = world.spawn();
  657|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  658|       |        world.insert(entity, Velocity { x: 0.5, y: 0.5 });
  659|       |
  660|       |        let query = Query2::<Position, Velocity>::new(&world);
  661|       |
  662|       |        for (_e, pos, vel) in query {
  663|       |            // Can read both
  664|       |            let _ = pos.x + vel.x;
  665|       |        }
  666|       |
  667|       |        // Data unchanged
  668|       |        let pos = world.get::<Position>(entity).unwrap();
  669|       |        assert_eq!(pos.x, 1.0);
  670|       |    }
  671|       |
  672|       |    #[test]
  673|       |    fn test_query2mut_mutable_first_immutable_second() {
  674|       |        let mut world = World::new();
  675|       |        let entity = world.spawn();
  676|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  677|       |        world.insert(entity, Velocity { x: 0.5, y: 0.5 });
  678|       |
  679|       |        {
  680|       |            let query = Query2Mut::<Position, Velocity>::new(&mut world);
  681|       |            for (_e, pos, vel) in query {
  682|       |                // Can mutate first, read second
  683|       |                pos.x += vel.x;
  684|       |                pos.y += vel.y;
  685|       |            }
  686|       |        }
  687|       |
  688|       |        let pos = world.get::<Position>(entity).unwrap();
  689|       |        assert_eq!(pos.x, 1.5);
  690|       |
  691|       |        // Velocity unchanged (immutable)
  692|       |        let vel = world.get::<Velocity>(entity).unwrap();
  693|       |        assert_eq!(vel.x, 0.5);
  694|       |    }
  695|       |
  696|       |    // ====================
  697|       |    // Day 1: Query Iterator Behavior
  698|       |    // ====================
  699|       |
  700|       |    #[test]
  701|       |    fn test_query_iterator_exhaustion() {
  702|       |        let mut world = World::new();
  703|       |        let e1 = world.spawn();
  704|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  705|       |
  706|       |        let mut query = Query::<Position>::new(&world);
  707|       |
  708|       |        // First iteration
  709|       |        assert!(query.next().is_some());
  710|       |
  711|       |        // Iterator exhausted
  712|       |        assert!(query.next().is_none());
  713|       |        assert!(query.next().is_none());
  714|       |    }
  715|       |
  716|       |    #[test]
  717|       |    fn test_query2_iterator_count() {
  718|       |        let mut world = World::new();
  719|       |
  720|       |        for i in 0..10 {
  721|       |            let e = world.spawn();
  722|       |            world.insert(
  723|       |                e,
  724|       |                Position {
  725|       |                    x: i as f32,
  726|       |                    y: i as f32,
  727|       |                },
  728|       |            );
  729|       |            world.insert(e, Velocity { x: 1.0, y: 1.0 });
  730|       |        }
  731|       |
  732|       |        let query = Query2::<Position, Velocity>::new(&world);
  733|       |        let count = query.count();
  734|       |
  735|       |        assert_eq!(count, 10);
  736|       |    }
  737|       |
  738|       |    #[test]
  739|       |    fn test_query_collect_into_vec() {
  740|       |        let mut world = World::new();
  741|       |
  742|       |        let e1 = world.spawn();
  743|       |        let e2 = world.spawn();
  744|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  745|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  746|       |
  747|       |        let query = Query::<Position>::new(&world);
  748|       |        let results: Vec<_> = query.collect();
  749|       |
  750|       |        assert_eq!(results.len(), 2);
  751|       |        assert!(results.iter().any(|(e, _)| *e == e1));
  752|       |        assert!(results.iter().any(|(e, _)| *e == e2));
  753|       |    }
  754|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\type_registry.rs:
    1|       |//! Type registry for dynamic component operations.
    2|       |//!
    3|       |//! Provides runtime type information and handlers for type-erased component
    4|       |//! operations (insert, remove, drop). Used by CommandBuffer for deferred operations.
    5|       |
    6|       |use crate::Component;
    7|       |use std::any::{Any, TypeId};
    8|       |use std::collections::HashMap;
    9|       |use std::sync::Arc;
   10|       |
   11|       |/// Handler for inserting type-erased components into World.
   12|       |type InsertHandler =
   13|       |    Arc<dyn Fn(&mut crate::World, crate::Entity, Box<dyn Any + Send + Sync>) + Send + Sync>;
   14|       |
   15|       |/// Handler for removing type-erased components from World.
   16|       |type RemoveHandler = Arc<dyn Fn(&mut crate::World, crate::Entity) + Send + Sync>;
   17|       |
   18|       |/// Registry of component types and their handlers.
   19|       |///
   20|       |/// Allows CommandBuffer to perform type-erased operations (insert/remove)
   21|       |/// without knowing concrete types at runtime.
   22|       |pub struct TypeRegistry {
   23|       |    pub(crate) insert_handlers: HashMap<TypeId, InsertHandler>,
   24|       |    pub(crate) remove_handlers: HashMap<TypeId, RemoveHandler>,
   25|       |    pub(crate) type_names: HashMap<TypeId, &'static str>,
   26|       |}
   27|       |
   28|       |impl TypeRegistry {
   29|       |    /// Create a new empty type registry.
   30|      6|    pub fn new() -> Self {
   31|      6|        Self {
   32|      6|            insert_handlers: HashMap::new(),
   33|      6|            remove_handlers: HashMap::new(),
   34|      6|            type_names: HashMap::new(),
   35|      6|        }
   36|      6|    }
   37|       |
   38|       |    /// Register a component type with insert/remove handlers.
   39|       |    ///
   40|       |    /// This allows CommandBuffer to perform operations on this type via TypeId.
   41|       |    ///
   42|       |    /// # Example
   43|       |    /// ```
   44|       |    /// # use astraweave_ecs::{World, TypeRegistry};
   45|       |    /// # #[derive(Clone, Copy)]
   46|       |    /// # struct Position { x: f32, y: f32 }
   47|       |    /// let mut registry = TypeRegistry::new();
   48|       |    /// registry.register::<Position>();
   49|       |    /// ```
   50|      0|    pub fn register<T: Component>(&mut self) {
   51|      0|        let type_id = TypeId::of::<T>();
   52|      0|        let type_name = std::any::type_name::<T>();
   53|       |
   54|       |        // Insert handler: Downcast Box<dyn Any> → T, then call World::insert
   55|      0|        self.insert_handlers.insert(
   56|      0|            type_id,
   57|      0|            Arc::new(
   58|       |                |world: &mut crate::World,
   59|       |                 entity: crate::Entity,
   60|      0|                 component: Box<dyn Any + Send + Sync>| {
   61|      0|                    if let Ok(component) = component.downcast::<T>() {
   62|      0|                        world.insert(entity, *component);
   63|      0|                    } else {
   64|      0|                        panic!(
   65|      0|                            "TypeRegistry: insert handler called with wrong type (expected {})",
   66|      0|                            std::any::type_name::<T>()
   67|       |                        );
   68|       |                    }
   69|      0|                },
   70|       |            ),
   71|       |        );
   72|       |
   73|       |        // Remove handler: Call World::remove<T>
   74|      0|        self.remove_handlers.insert(
   75|      0|            type_id,
   76|      0|            Arc::new(|world: &mut crate::World, entity: crate::Entity| {
   77|      0|                world.remove::<T>(entity);
   78|      0|            }),
   79|       |        );
   80|       |
   81|      0|        self.type_names.insert(type_id, type_name);
   82|      0|    }
   83|       |
   84|       |    /// Insert a type-erased component using registered handler.
   85|       |    ///
   86|       |    /// # Panics
   87|       |    /// Panics if the type is not registered or if downcast fails.
   88|      0|    pub fn insert_boxed(
   89|      0|        &self,
   90|      0|        world: &mut crate::World,
   91|      0|        entity: crate::Entity,
   92|      0|        type_id: TypeId,
   93|      0|        component: Box<dyn Any + Send + Sync>,
   94|      0|    ) {
   95|      0|        if let Some(handler) = self.insert_handlers.get(&type_id) {
   96|      0|            handler(world, entity, component);
   97|      0|        } else {
   98|      0|            panic!(
   99|      0|                "TypeRegistry: type {:?} not registered (call register::<T>() first)",
  100|      0|                self.type_names.get(&type_id).unwrap_or(&"<unknown>")
  101|       |            );
  102|       |        }
  103|      0|    }
  104|       |
  105|       |    /// Remove a component by TypeId using registered handler.
  106|       |    ///
  107|       |    /// # Panics
  108|       |    /// Panics if the type is not registered.
  109|      0|    pub fn remove_by_type_id(
  110|      0|        &self,
  111|      0|        world: &mut crate::World,
  112|      0|        entity: crate::Entity,
  113|      0|        type_id: TypeId,
  114|      0|    ) {
  115|      0|        if let Some(handler) = self.remove_handlers.get(&type_id) {
  116|      0|            handler(world, entity);
  117|      0|        } else {
  118|      0|            panic!(
  119|      0|                "TypeRegistry: type {:?} not registered (call register::<T>() first)",
  120|      0|                self.type_names.get(&type_id).unwrap_or(&"<unknown>")
  121|       |            );
  122|       |        }
  123|      0|    }
  124|       |
  125|       |    /// Check if a type is registered.
  126|      0|    pub fn is_registered(&self, type_id: TypeId) -> bool {
  127|      0|        self.insert_handlers.contains_key(&type_id)
  128|      0|    }
  129|       |
  130|       |    /// Get the name of a registered type.
  131|      0|    pub fn type_name(&self, type_id: TypeId) -> Option<&'static str> {
  132|      0|        self.type_names.get(&type_id).copied()
  133|      0|    }
  134|       |}
  135|       |
  136|       |impl Default for TypeRegistry {
  137|      6|    fn default() -> Self {
  138|      6|        Self::new()
  139|      6|    }
  140|       |}
  141|       |
  142|       |// ============================================================================
  143|       |// Tests
  144|       |// ============================================================================
  145|       |
  146|       |#[cfg(test)]
  147|       |mod tests {
  148|       |    use super::*;
  149|       |    use crate::World;
  150|       |
  151|       |    #[derive(Clone, Copy, Debug, PartialEq)]
  152|       |    struct Position {
  153|       |        x: f32,
  154|       |        y: f32,
  155|       |    }
  156|       |
  157|       |    #[derive(Clone, Copy, Debug, PartialEq)]
  158|       |    struct Velocity {
  159|       |        x: f32,
  160|       |        y: f32,
  161|       |    }
  162|       |
  163|       |    #[test]
  164|       |    fn test_type_registry_creation() {
  165|       |        let registry = TypeRegistry::new();
  166|       |        assert!(!registry.is_registered(TypeId::of::<Position>()));
  167|       |    }
  168|       |
  169|       |    #[test]
  170|       |    fn test_register_type() {
  171|       |        let mut registry = TypeRegistry::new();
  172|       |        registry.register::<Position>();
  173|       |
  174|       |        assert!(registry.is_registered(TypeId::of::<Position>()));
  175|       |        assert_eq!(
  176|       |            registry.type_name(TypeId::of::<Position>()),
  177|       |            Some("astraweave_ecs::type_registry::tests::Position")
  178|       |        );
  179|       |    }
  180|       |
  181|       |    #[test]
  182|       |    fn test_insert_boxed() {
  183|       |        let mut world = World::new();
  184|       |        let mut registry = TypeRegistry::new();
  185|       |        registry.register::<Position>();
  186|       |
  187|       |        let entity = world.spawn();
  188|       |        let component = Box::new(Position { x: 10.0, y: 20.0 });
  189|       |
  190|       |        registry.insert_boxed(&mut world, entity, TypeId::of::<Position>(), component);
  191|       |
  192|       |        assert_eq!(
  193|       |            world.get::<Position>(entity),
  194|       |            Some(&Position { x: 10.0, y: 20.0 })
  195|       |        );
  196|       |    }
  197|       |
  198|       |    #[test]
  199|       |    fn test_remove_by_type_id() {
  200|       |        let mut world = World::new();
  201|       |        let mut registry = TypeRegistry::new();
  202|       |        registry.register::<Position>();
  203|       |
  204|       |        let entity = world.spawn();
  205|       |        world.insert(entity, Position { x: 10.0, y: 20.0 });
  206|       |
  207|       |        assert!(world.has::<Position>(entity));
  208|       |
  209|       |        registry.remove_by_type_id(&mut world, entity, TypeId::of::<Position>());
  210|       |
  211|       |        assert!(!world.has::<Position>(entity));
  212|       |    }
  213|       |
  214|       |    #[test]
  215|       |    #[should_panic(expected = "type")]
  216|       |    fn test_insert_unregistered_type() {
  217|       |        let mut world = World::new();
  218|       |        let registry = TypeRegistry::new();
  219|       |
  220|       |        let entity = world.spawn();
  221|       |        let component = Box::new(Position { x: 10.0, y: 20.0 });
  222|       |
  223|       |        registry.insert_boxed(&mut world, entity, TypeId::of::<Position>(), component);
  224|       |    }
  225|       |
  226|       |    #[test]
  227|       |    #[should_panic(expected = "type")]
  228|       |    fn test_remove_unregistered_type() {
  229|       |        let mut world = World::new();
  230|       |        let registry = TypeRegistry::new();
  231|       |
  232|       |        let entity = world.spawn();
  233|       |
  234|       |        registry.remove_by_type_id(&mut world, entity, TypeId::of::<Position>());
  235|       |    }
  236|       |
  237|       |    #[test]
  238|       |    fn test_multiple_types() {
  239|       |        let mut registry = TypeRegistry::new();
  240|       |        registry.register::<Position>();
  241|       |        registry.register::<Velocity>();
  242|       |
  243|       |        assert!(registry.is_registered(TypeId::of::<Position>()));
  244|       |        assert!(registry.is_registered(TypeId::of::<Velocity>()));
  245|       |    }
  246|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-observability\src\companion.rs:
    1|       |use serde::{Deserialize, Serialize};
    2|       |
    3|       |/// Telemetry event emitted whenever the companion executes a GOAP action.
    4|       |#[derive(Clone, Debug, Serialize, Deserialize)]
    5|       |pub struct CompanionActionEvent {
    6|       |    pub action_id: String,
    7|       |    pub success: bool,
    8|       |    pub latency_ms: f32,
    9|       |}
   10|       |
   11|       |/// Telemetry event emitted when the companion unlocks an adaptive ability during the slice.
   12|       |#[derive(Clone, Debug, Serialize, Deserialize)]
   13|       |pub struct CompanionAdaptiveUnlock {
   14|       |    pub unlock_id: String,
   15|       |}
   16|       |
   17|      1|pub fn log_companion_action(event: &CompanionActionEvent) {
   18|      1|    tracing::info!(
   19|       |        target = "veilweaver.companion.telemetry",
   20|       |        event = "CompanionAction",
   21|       |        action_id = %event.action_id,
   22|       |        success = event.success,
   23|       |        latency_ms = event.latency_ms
   24|       |    );
   25|      1|}
   26|       |
   27|      1|pub fn log_companion_unlock(event: &CompanionAdaptiveUnlock) {
   28|      1|    tracing::info!(
   29|       |        target = "veilweaver.companion.telemetry",
   30|       |        event = "CompanionAdaptiveUnlock",
   31|       |        unlock_id = %event.unlock_id
   32|       |    );
   33|      1|}
   34|       |
   35|       |#[cfg(test)]
   36|       |mod tests {
   37|       |    use super::*;
   38|       |
   39|       |    #[test]
   40|      1|    fn test_companion_action_event_creation() {
   41|      1|        let event = CompanionActionEvent {
   42|      1|            action_id: "goap_heal".to_string(),
   43|      1|            success: true,
   44|      1|            latency_ms: 15.5,
   45|      1|        };
   46|      1|        assert_eq!(event.action_id, "goap_heal");
   47|      1|        assert!(event.success);
   48|      1|        assert!((event.latency_ms - 15.5).abs() < 0.01);
   49|      1|    }
   50|       |
   51|       |    #[test]
   52|      1|    fn test_companion_action_event_failure() {
   53|      1|        let event = CompanionActionEvent {
   54|      1|            action_id: "goap_attack".to_string(),
   55|      1|            success: false,
   56|      1|            latency_ms: 25.0,
   57|      1|        };
   58|      1|        assert!(!event.success);
   59|      1|        assert_eq!(event.action_id, "goap_attack");
   60|      1|    }
   61|       |
   62|       |    #[test]
   63|      1|    fn test_companion_adaptive_unlock_creation() {
   64|      1|        let event = CompanionAdaptiveUnlock {
   65|      1|            unlock_id: "ability_fireball".to_string(),
   66|      1|        };
   67|      1|        assert_eq!(event.unlock_id, "ability_fireball");
   68|      1|    }
   69|       |
   70|       |    #[test]
   71|      1|    fn test_companion_action_event_serialization() {
   72|      1|        let event = CompanionActionEvent {
   73|      1|            action_id: "collect_loot".to_string(),
   74|      1|            success: true,
   75|      1|            latency_ms: 5.25,
   76|      1|        };
   77|      1|        let serialized = serde_json::to_string(&event).unwrap();
   78|      1|        assert!(serialized.contains("collect_loot"));
   79|      1|        assert!(serialized.contains("true"));
   80|      1|    }
   81|       |
   82|       |    #[test]
   83|      1|    fn test_companion_unlock_event_serialization() {
   84|      1|        let event = CompanionAdaptiveUnlock {
   85|      1|            unlock_id: "ultimate_strike".to_string(),
   86|      1|        };
   87|      1|        let serialized = serde_json::to_string(&event).unwrap();
   88|      1|        assert!(serialized.contains("ultimate_strike"));
   89|      1|    }
   90|       |
   91|       |    #[test]
   92|      1|    fn test_log_companion_action() {
   93|       |        // Simply verify that the function runs without panic
   94|      1|        let event = CompanionActionEvent {
   95|      1|            action_id: "test_action".to_string(),
   96|      1|            success: true,
   97|      1|            latency_ms: 10.0,
   98|      1|        };
   99|      1|        log_companion_action(&event);
  100|      1|    }
  101|       |
  102|       |    #[test]
  103|      1|    fn test_log_companion_unlock() {
  104|       |        // Simply verify that the function runs without panic
  105|      1|        let event = CompanionAdaptiveUnlock {
  106|      1|            unlock_id: "test_unlock".to_string(),
  107|      1|        };
  108|      1|        log_companion_unlock(&event);
  109|      1|    }
  110|       |
  111|       |    #[test]
  112|      1|    fn test_companion_action_clone() {
  113|      1|        let event = CompanionActionEvent {
  114|      1|            action_id: "original".to_string(),
  115|      1|            success: true,
  116|      1|            latency_ms: 20.0,
  117|      1|        };
  118|      1|        let cloned = event.clone();
  119|      1|        assert_eq!(event.action_id, cloned.action_id);
  120|      1|        assert_eq!(event.success, cloned.success);
  121|      1|    }
  122|       |
  123|       |    #[test]
  124|      1|    fn test_companion_unlock_clone() {
  125|      1|        let event = CompanionAdaptiveUnlock {
  126|      1|            unlock_id: "original_unlock".to_string(),
  127|      1|        };
  128|      1|        let cloned = event.clone();
  129|      1|        assert_eq!(event.unlock_id, cloned.unlock_id);
  130|      1|    }
  131|       |
  132|       |    #[test]
  133|      1|    fn test_companion_action_debug_format() {
  134|      1|        let event = CompanionActionEvent {
  135|      1|            action_id: "debug_test".to_string(),
  136|      1|            success: false,
  137|      1|            latency_ms: 100.5,
  138|      1|        };
  139|      1|        let debug_str = format!("{:?}", event);
  140|      1|        assert!(debug_str.contains("debug_test"));
  141|      1|        assert!(debug_str.contains("100.5"));
  142|      1|    }
  143|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-observability\src\lib.rs:
    1|       |use anyhow::Result;
    2|       |use serde::{Deserialize, Serialize};
    3|       |use tracing::{error, info, Level};
    4|       |use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};
    5|       |
    6|       |use astraweave_ecs::{App, Plugin};
    7|       |
    8|       |pub mod llm_telemetry;
    9|       |pub use llm_telemetry::*;
   10|       |
   11|       |mod companion;
   12|       |pub use companion::*;
   13|       |
   14|       |/// Configuration for observability stack
   15|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   16|       |pub struct ObservabilityConfig {
   17|       |    pub tracing_level: String,
   18|       |    pub metrics_enabled: bool,
   19|       |    pub crash_reporting_enabled: bool,
   20|       |}
   21|       |
   22|       |impl Default for ObservabilityConfig {
   23|      7|    fn default() -> Self {
   24|      7|        Self {
   25|      7|            tracing_level: "INFO".to_string(),
   26|      7|            metrics_enabled: true,
   27|      7|            crash_reporting_enabled: true,
   28|      7|        }
   29|      7|    }
   30|       |}
   31|       |
   32|       |/// Resource for observability state
   33|       |pub struct ObservabilityState {
   34|       |    pub config: ObservabilityConfig,
   35|       |}
   36|       |
   37|       |impl ObservabilityState {
   38|      6|    pub fn new(config: ObservabilityConfig) -> Self {
   39|      6|        Self { config }
   40|      6|    }
   41|       |}
   42|       |
   43|       |/// Plugin for observability integration
   44|       |pub struct ObservabilityPlugin {
   45|       |    config: ObservabilityConfig,
   46|       |}
   47|       |
   48|       |impl ObservabilityPlugin {
   49|      5|    pub fn new(config: ObservabilityConfig) -> Self {
   50|      5|        Self { config }
   51|      5|    }
   52|       |}
   53|       |
   54|       |impl Default for ObservabilityPlugin {
   55|      2|    fn default() -> Self {
   56|      2|        Self::new(ObservabilityConfig::default())
   57|      2|    }
   58|       |}
   59|       |
   60|       |impl Plugin for ObservabilityPlugin {
   61|      3|    fn build(&self, app: &mut App) {
   62|       |        // Initialize tracing
   63|      3|        init_tracing(&self.config).expect("Failed to initialize tracing");
   64|       |
   65|       |        // Initialize metrics if enabled
   66|      3|        if self.config.metrics_enabled {
   67|      2|            init_metrics(&self.config).expect("Failed to initialize metrics");
   68|      2|        }
                      ^1
   69|       |
   70|       |        // Initialize crash reporting if enabled
   71|      3|        if self.config.crash_reporting_enabled {
   72|      2|            init_crash_reporting();
   73|      2|        }
                      ^1
   74|       |
   75|       |        // Add observability state as resource
   76|      3|        app.world
   77|      3|            .insert_resource(ObservabilityState::new(self.config.clone()));
   78|       |
   79|       |        // Add observability systems
   80|      3|        app.add_system("presentation", observability_system);
   81|      3|    }
   82|       |}
   83|       |
   84|       |/// Initialize tracing with JSON output and filtering
   85|     12|fn init_tracing(config: &ObservabilityConfig) -> Result<()> {
   86|       |    use std::sync::Once;
   87|       |    static TRACING_INIT: Once = Once::new();
   88|       |
   89|     12|    let level = match config.tracing_level.as_str() {
   90|     12|        "TRACE" => Level::TRACE,
                                 ^2
   91|     10|        "DEBUG" => Level::DEBUG,
                                 ^1
   92|      9|        "INFO" => Level::INFO,
                                ^5
   93|      4|        "WARN" => Level::WARN,
                                ^1
   94|      3|        "ERROR" => Level::ERROR,
                                 ^2
   95|      1|        _ => Level::INFO,
   96|       |    };
   97|       |
   98|     12|    let config_level = config.tracing_level.clone();
   99|       |
  100|       |    // Only initialize once per process (safe for tests and repeated calls)
  101|     12|    TRACING_INIT.call_once(|| {
                                            ^1
  102|      1|        let subscriber = tracing_subscriber::registry()
  103|      1|            .with(tracing_subscriber::EnvFilter::from_default_env().add_directive(level.into()))
  104|      1|            .with(
  105|      1|                tracing_subscriber::fmt::layer()
  106|      1|                    .json()
  107|      1|                    .with_target(false)
  108|      1|                    .with_thread_ids(true)
  109|      1|                    .with_thread_names(true),
  110|       |            );
  111|       |
  112|       |        // Use try_init to avoid panic if already initialized
  113|      1|        let _ = subscriber.try_init();
  114|      1|    });
  115|       |
  116|     12|    info!("Tracing initialized with level: {}", config_level);
  117|     12|    Ok(())
  118|     12|}
  119|       |
  120|       |/// Initialize metrics with simple recorder
  121|      4|fn init_metrics(_config: &ObservabilityConfig) -> Result<()> {
  122|       |    // For now, use a simple recorder that just logs metrics
  123|       |    // In production, this could be extended to export to various backends
  124|      4|    info!("Metrics initialized with simple recorder");
  125|      4|    Ok(())
  126|      4|}
  127|       |
  128|       |/// Initialize basic crash reporting (logs panics)
  129|      4|fn init_crash_reporting() {
  130|       |    use std::sync::Once;
  131|       |    static CRASH_INIT: Once = Once::new();
  132|       |
  133|      4|    CRASH_INIT.call_once(|| {
                                          ^1
  134|      1|        std::panic::set_hook(Box::new(|panic_info| {
                                                                 ^0
  135|      0|            let backtrace = std::backtrace::Backtrace::capture();
  136|      0|            error!("Panic occurred: {}\nBacktrace:\n{}", panic_info, backtrace);
  137|       |
  138|       |            // In a real implementation, this would send to a crash reporting service
  139|       |            // like Sentry, but for now we just log it
  140|      0|        }));
  141|      1|    });
  142|       |
  143|      4|    info!("Crash reporting initialized");
  144|      4|}
  145|       |
  146|       |/// System that collects observability metrics
  147|      3|fn observability_system(world: &mut astraweave_ecs::World) {
  148|      3|    if let Some(state) = world.get_resource::<ObservabilityState>() {
                              ^2
  149|      2|        if state.config.metrics_enabled {
  150|       |            // For now, just log metrics instead of using metrics crate
  151|      1|            info!("Tick recorded");
  152|      1|        }
  153|      1|    }
  154|      3|}
  155|       |
  156|       |/// Convenience function to initialize full observability stack
  157|      9|pub fn init_observability(config: ObservabilityConfig) -> Result<()> {
  158|      9|    init_tracing(&config)?;
                                       ^0
  159|      9|    if config.metrics_enabled {
  160|      2|        init_metrics(&config)?;
                                           ^0
  161|      7|    }
  162|      9|    if config.crash_reporting_enabled {
  163|      2|        init_crash_reporting();
  164|      7|    }
  165|      9|    Ok(())
  166|      9|}
  167|       |
  168|       |/// Macros for common observability patterns
  169|       |#[macro_export]
  170|       |macro_rules! trace_span {
  171|       |    ($name:expr) => {
  172|       |        tracing::span!(tracing::Level::TRACE, $name)
  173|       |    };
  174|       |}
  175|       |
  176|       |#[macro_export]
  177|       |macro_rules! debug_span {
  178|       |    ($name:expr) => {
  179|       |        tracing::span!(tracing::Level::DEBUG, $name)
  180|       |    };
  181|       |}
  182|       |
  183|       |#[macro_export]
  184|       |macro_rules! info_span {
  185|       |    ($name:expr) => {
  186|       |        tracing::span!(tracing::Level::INFO, $name)
  187|       |    };
  188|       |}
  189|       |
  190|       |#[macro_export]
  191|       |macro_rules! warn_span {
  192|       |    ($name:expr) => {
  193|       |        tracing::span!(tracing::Level::WARN, $name)
  194|       |    };
  195|       |}
  196|       |
  197|       |#[macro_export]
  198|       |macro_rules! error_span {
  199|       |    ($name:expr) => {
  200|       |        tracing::span!(tracing::Level::ERROR, $name)
  201|       |    };
  202|       |}
  203|       |
  204|       |#[cfg(test)]
  205|       |mod tests {
  206|       |    use super::*;
  207|       |    use astraweave_ecs::App;
  208|       |
  209|       |    #[test]
  210|      1|    fn test_observability_config_default() {
  211|      1|        let config = ObservabilityConfig::default();
  212|      1|        assert_eq!(config.tracing_level, "INFO");
  213|      1|        assert!(config.metrics_enabled);
  214|      1|        assert!(config.crash_reporting_enabled);
  215|      1|    }
  216|       |
  217|       |    #[test]
  218|      1|    fn test_plugin_build() {
  219|      1|        let mut app = App::new();
  220|      1|        let plugin = ObservabilityPlugin::default();
  221|      1|        plugin.build(&mut app);
  222|       |
  223|       |        // Check that the resource was inserted
  224|      1|        assert!(app.world.get_resource::<ObservabilityState>().is_some());
  225|      1|    }
  226|       |
  227|       |    #[test]
  228|      1|    fn test_observability_config_custom() {
  229|      1|        let config = ObservabilityConfig {
  230|      1|            tracing_level: "DEBUG".to_string(),
  231|      1|            metrics_enabled: false,
  232|      1|            crash_reporting_enabled: false,
  233|      1|        };
  234|      1|        assert_eq!(config.tracing_level, "DEBUG");
  235|      1|        assert!(!config.metrics_enabled);
  236|      1|        assert!(!config.crash_reporting_enabled);
  237|      1|    }
  238|       |
  239|       |    #[test]
  240|      1|    fn test_observability_state_new() {
  241|      1|        let config = ObservabilityConfig::default();
  242|      1|        let state = ObservabilityState::new(config);
  243|      1|        assert_eq!(state.config.tracing_level, "INFO");
  244|      1|    }
  245|       |
  246|       |    #[test]
  247|      1|    fn test_observability_plugin_new() {
  248|      1|        let config = ObservabilityConfig {
  249|      1|            tracing_level: "WARN".to_string(),
  250|      1|            metrics_enabled: true,
  251|      1|            crash_reporting_enabled: false,
  252|      1|        };
  253|      1|        let plugin = ObservabilityPlugin::new(config);
  254|      1|        assert_eq!(plugin.config.tracing_level, "WARN");
  255|      1|    }
  256|       |
  257|       |    #[test]
  258|      1|    fn test_init_observability_success() {
  259|      1|        let config = ObservabilityConfig::default();
  260|      1|        let result = init_observability(config);
  261|      1|        assert!(result.is_ok());
  262|      1|    }
  263|       |
  264|       |    #[test]
  265|      1|    fn test_init_observability_metrics_disabled() {
  266|      1|        let config = ObservabilityConfig {
  267|      1|            tracing_level: "ERROR".to_string(),
  268|      1|            metrics_enabled: false,
  269|      1|            crash_reporting_enabled: false,
  270|      1|        };
  271|      1|        let result = init_observability(config);
  272|      1|        assert!(result.is_ok());
  273|      1|    }
  274|       |
  275|       |    #[test]
  276|      1|    fn test_observability_config_tracing_levels() {
  277|      1|        let levels = ["TRACE", "DEBUG", "INFO", "WARN", "ERROR"];
  278|      6|        for level in levels {
                          ^5
  279|      5|            let config = ObservabilityConfig {
  280|      5|                tracing_level: level.to_string(),
  281|      5|                metrics_enabled: false,
  282|      5|                crash_reporting_enabled: false,
  283|      5|            };
  284|      5|            assert_eq!(config.tracing_level, level);
  285|       |        }
  286|      1|    }
  287|       |
  288|       |    #[test]
  289|      1|    fn test_observability_config_serialization() {
  290|      1|        let config = ObservabilityConfig::default();
  291|      1|        let serialized = serde_json::to_string(&config).unwrap();
  292|      1|        assert!(serialized.contains("INFO"));
  293|      1|        assert!(serialized.contains("metrics_enabled"));
  294|      1|    }
  295|       |
  296|       |    #[test]
  297|      1|    fn test_observability_config_deserialization() {
  298|      1|        let json = r#"{"tracing_level":"DEBUG","metrics_enabled":false,"crash_reporting_enabled":true}"#;
  299|      1|        let config: ObservabilityConfig = serde_json::from_str(json).unwrap();
  300|      1|        assert_eq!(config.tracing_level, "DEBUG");
  301|      1|        assert!(!config.metrics_enabled);
  302|      1|        assert!(config.crash_reporting_enabled);
  303|      1|    }
  304|       |
  305|       |    #[test]
  306|      1|    fn test_observability_config_clone() {
  307|      1|        let config = ObservabilityConfig {
  308|      1|            tracing_level: "TRACE".to_string(),
  309|      1|            metrics_enabled: true,
  310|      1|            crash_reporting_enabled: true,
  311|      1|        };
  312|      1|        let cloned = config.clone();
  313|      1|        assert_eq!(config.tracing_level, cloned.tracing_level);
  314|      1|        assert_eq!(config.metrics_enabled, cloned.metrics_enabled);
  315|      1|    }
  316|       |
  317|       |    #[test]
  318|      1|    fn test_observability_config_debug() {
  319|      1|        let config = ObservabilityConfig::default();
  320|      1|        let debug_str = format!("{:?}", config);
  321|      1|        assert!(debug_str.contains("ObservabilityConfig"));
  322|      1|        assert!(debug_str.contains("INFO"));
  323|      1|    }
  324|       |
  325|       |    #[test]
  326|      1|    fn test_observability_plugin_default() {
  327|      1|        let plugin = ObservabilityPlugin::default();
  328|      1|        assert_eq!(plugin.config.tracing_level, "INFO");
  329|      1|        assert!(plugin.config.metrics_enabled);
  330|      1|    }
  331|       |
  332|       |    #[test]
  333|      1|    fn test_observability_plugin_build_with_metrics() {
  334|      1|        let mut app = App::new();
  335|      1|        let config = ObservabilityConfig {
  336|      1|            tracing_level: "INFO".to_string(),
  337|      1|            metrics_enabled: true,
  338|      1|            crash_reporting_enabled: true,
  339|      1|        };
  340|      1|        let plugin = ObservabilityPlugin::new(config);
  341|      1|        plugin.build(&mut app);
  342|       |
  343|      1|        let state = app.world.get_resource::<ObservabilityState>().unwrap();
  344|      1|        assert!(state.config.metrics_enabled);
  345|      1|    }
  346|       |
  347|       |    #[test]
  348|      1|    fn test_observability_plugin_build_without_metrics() {
  349|      1|        let mut app = App::new();
  350|      1|        let config = ObservabilityConfig {
  351|      1|            tracing_level: "INFO".to_string(),
  352|      1|            metrics_enabled: false,
  353|      1|            crash_reporting_enabled: false,
  354|      1|        };
  355|      1|        let plugin = ObservabilityPlugin::new(config);
  356|      1|        plugin.build(&mut app);
  357|       |
  358|      1|        let state = app.world.get_resource::<ObservabilityState>().unwrap();
  359|      1|        assert!(!state.config.metrics_enabled);
  360|      1|    }
  361|       |
  362|       |    #[test]
  363|      1|    fn test_observability_system_with_metrics() {
  364|      1|        let mut world = astraweave_ecs::World::default();
  365|      1|        let config = ObservabilityConfig {
  366|      1|            tracing_level: "INFO".to_string(),
  367|      1|            metrics_enabled: true,
  368|      1|            crash_reporting_enabled: false,
  369|      1|        };
  370|      1|        world.insert_resource(ObservabilityState::new(config));
  371|       |
  372|       |        // Should not panic
  373|      1|        observability_system(&mut world);
  374|      1|    }
  375|       |
  376|       |    #[test]
  377|      1|    fn test_observability_system_without_metrics() {
  378|      1|        let mut world = astraweave_ecs::World::default();
  379|      1|        let config = ObservabilityConfig {
  380|      1|            tracing_level: "INFO".to_string(),
  381|      1|            metrics_enabled: false,
  382|      1|            crash_reporting_enabled: false,
  383|      1|        };
  384|      1|        world.insert_resource(ObservabilityState::new(config));
  385|       |
  386|       |        // Should not panic
  387|      1|        observability_system(&mut world);
  388|      1|    }
  389|       |
  390|       |    #[test]
  391|      1|    fn test_observability_system_no_state() {
  392|      1|        let mut world = astraweave_ecs::World::default();
  393|       |        // Should not panic even without state
  394|      1|        observability_system(&mut world);
  395|      1|    }
  396|       |
  397|       |    #[test]
  398|      1|    fn test_trace_span_macro() {
  399|       |        // Just verify macro compiles and runs
  400|      1|        let _span = trace_span!("test_span");
  401|      1|    }
  402|       |
  403|       |    #[test]
  404|      1|    fn test_debug_span_macro() {
  405|      1|        let _span = debug_span!("debug_test");
  406|      1|    }
  407|       |
  408|       |    #[test]
  409|      1|    fn test_info_span_macro() {
  410|      1|        let _span = info_span!("info_test");
  411|      1|    }
  412|       |
  413|       |    #[test]
  414|      1|    fn test_warn_span_macro() {
  415|      1|        let _span = warn_span!("warn_test");
  416|      1|    }
  417|       |
  418|       |    #[test]
  419|      1|    fn test_error_span_macro() {
  420|      1|        let _span = error_span!("error_test");
  421|      1|    }
  422|       |
  423|       |    #[test]
  424|      1|    fn test_init_tracing_with_all_levels() {
  425|       |        // Test all tracing level paths
  426|      6|        for level in ["TRACE", "DEBUG", "INFO", "WARN", "ERROR", "UNKNOWN"] {
                                             ^1       ^1      ^1      ^1       ^1
  427|      6|            let config = ObservabilityConfig {
  428|      6|                tracing_level: level.to_string(),
  429|      6|                metrics_enabled: false,
  430|      6|                crash_reporting_enabled: false,
  431|      6|            };
  432|      6|            // Just verify it doesn't panic
  433|      6|            let _ = init_observability(config);
  434|      6|        }
  435|      1|    }
  436|       |
  437|       |    #[test]
  438|      1|    fn test_init_observability_full_stack() {
  439|      1|        let config = ObservabilityConfig {
  440|      1|            tracing_level: "TRACE".to_string(),
  441|      1|            metrics_enabled: true,
  442|      1|            crash_reporting_enabled: true,
  443|      1|        };
  444|      1|        let result = init_observability(config);
  445|      1|        assert!(result.is_ok());
  446|      1|    }
  447|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-observability\src\llm_telemetry.rs:
    1|       |use anyhow::{anyhow, Result};
    2|       |use chrono::{DateTime, Datelike, Timelike, Utc};
    3|       |use dashmap::DashMap;
    4|       |use hdrhistogram::Histogram;
    5|       |use serde::{Deserialize, Serialize};
    6|       |use std::collections::{HashMap, VecDeque};
    7|       |use std::sync::Arc;
    8|       |use std::time::Instant;
    9|       |use tokio::sync::RwLock;
   10|       |use tracing::{debug, info, warn};
   11|       |use uuid::Uuid;
   12|       |
   13|       |/// Comprehensive LLM telemetry system for production observability
   14|       |pub struct LlmTelemetry {
   15|       |    /// Trace storage
   16|       |    traces: Arc<RwLock<VecDeque<LlmTrace>>>,
   17|       |    /// Real-time metrics
   18|       |    metrics: Arc<RwLock<LlmMetrics>>,
   19|       |    /// Performance histograms
   20|       |    histograms: Arc<RwLock<PerformanceHistograms>>,
   21|       |    /// Cost tracking
   22|       |    cost_tracker: Arc<RwLock<CostTracker>>,
   23|       |    /// Alert system
   24|       |    alert_manager: Arc<RwLock<AlertManager>>,
   25|       |    /// Configuration
   26|       |    config: TelemetryConfig,
   27|       |    /// Active requests tracking
   28|       |    active_requests: Arc<DashMap<String, ActiveRequest>>,
   29|       |    /// Error tracking
   30|       |    error_tracker: Arc<RwLock<ErrorTracker>>,
   31|       |}
   32|       |
   33|       |/// Configuration for telemetry system
   34|       |#[derive(Debug, Clone)]
   35|       |pub struct TelemetryConfig {
   36|       |    /// Maximum number of traces to keep in memory
   37|       |    pub max_traces: usize,
   38|       |    /// Enable detailed prompt/response logging
   39|       |    pub log_content: bool,
   40|       |    /// Enable cost tracking
   41|       |    pub enable_cost_tracking: bool,
   42|       |    /// Export to Prometheus
   43|       |    pub enable_prometheus: bool,
   44|       |    /// Export to OpenTelemetry
   45|       |    pub enable_opentelemetry: bool,
   46|       |    /// Alert thresholds
   47|       |    pub alert_thresholds: AlertThresholds,
   48|       |    /// Sampling rate for detailed traces (0.0 to 1.0)
   49|       |    pub sampling_rate: f32,
   50|       |}
   51|       |
   52|       |impl Default for TelemetryConfig {
   53|     13|    fn default() -> Self {
   54|     13|        Self {
   55|     13|            max_traces: 10000,
   56|     13|            log_content: false, // Default to false for privacy
   57|     13|            enable_cost_tracking: true,
   58|     13|            enable_prometheus: false,
   59|     13|            enable_opentelemetry: false,
   60|     13|            alert_thresholds: AlertThresholds::default(),
   61|     13|            sampling_rate: 1.0, // Sample all requests by default
   62|     13|        }
   63|     13|    }
   64|       |}
   65|       |
   66|       |/// Alert threshold configuration
   67|       |#[derive(Debug, Clone)]
   68|       |pub struct AlertThresholds {
   69|       |    /// Alert if P95 latency exceeds this (ms)
   70|       |    pub latency_p95_ms: u64,
   71|       |    /// Alert if error rate exceeds this (0.0 to 1.0)
   72|       |    pub error_rate: f32,
   73|       |    /// Alert if cost per hour exceeds this (USD)
   74|       |    pub cost_per_hour_usd: f32,
   75|       |    /// Alert if queue depth exceeds this
   76|       |    pub queue_depth: usize,
   77|       |    /// Alert if token rate exceeds this (tokens/sec)
   78|       |    pub token_rate: u64,
   79|       |}
   80|       |
   81|       |impl Default for AlertThresholds {
   82|     14|    fn default() -> Self {
   83|     14|        Self {
   84|     14|            latency_p95_ms: 5000, // 5 seconds
   85|     14|            error_rate: 0.1,      // 10%
   86|     14|            cost_per_hour_usd: 10.0,
   87|     14|            queue_depth: 100,
   88|     14|            token_rate: 10000,
   89|     14|        }
   90|     14|    }
   91|       |}
   92|       |
   93|       |/// Individual LLM request trace
   94|       |#[derive(Debug, Clone, Serialize, Deserialize)]
   95|       |pub struct LlmTrace {
   96|       |    pub request_id: String,
   97|       |    pub session_id: Option<String>,
   98|       |    pub user_id: Option<String>,
   99|       |    pub prompt: Option<String>,   // Optional for privacy
  100|       |    pub response: Option<String>, // Optional for privacy
  101|       |    pub prompt_hash: Option<u64>, // Hash for deduplication
  102|       |    pub model: String,
  103|       |    pub start_time: DateTime<Utc>,
  104|       |    pub end_time: DateTime<Utc>,
  105|       |    pub latency_ms: u64,
  106|       |    pub tokens_prompt: usize,
  107|       |    pub tokens_response: usize,
  108|       |    pub total_tokens: usize,
  109|       |    pub cost_usd: f64,
  110|       |    pub success: bool,
  111|       |    pub error_message: Option<String>,
  112|       |    pub error_type: Option<String>,
  113|       |    pub request_source: String, // Which system made the request
  114|       |    pub tags: HashMap<String, String>,
  115|       |}
  116|       |
  117|       |/// Real-time LLM metrics
  118|       |#[derive(Debug, Clone, Default, Serialize, Deserialize)]
  119|       |pub struct LlmMetrics {
  120|       |    pub total_requests: u64,
  121|       |    pub successful_requests: u64,
  122|       |    pub failed_requests: u64,
  123|       |    pub total_tokens: u64,
  124|       |    pub total_cost_usd: f64,
  125|       |    pub average_latency_ms: f32,
  126|       |    pub p50_latency_ms: u64,
  127|       |    pub p95_latency_ms: u64,
  128|       |    pub p99_latency_ms: u64,
  129|       |    pub error_rate: f32,
  130|       |    pub requests_per_second: f32,
  131|       |    pub tokens_per_second: f32,
  132|       |    pub cost_per_hour_usd: f32,
  133|       |    pub active_requests: usize,
  134|       |    pub queue_depth: usize,
  135|       |    pub cache_hit_rate: f32,
  136|       |    pub last_updated: DateTime<Utc>,
  137|       |    pub model_usage: HashMap<String, ModelMetrics>,
  138|       |    pub source_metrics: HashMap<String, SourceMetrics>,
  139|       |}
  140|       |
  141|       |/// Metrics per model
  142|       |#[derive(Debug, Clone, Default, Serialize, Deserialize)]
  143|       |pub struct ModelMetrics {
  144|       |    pub requests: u64,
  145|       |    pub total_tokens: u64,
  146|       |    pub total_cost_usd: f64,
  147|       |    pub average_latency_ms: f32,
  148|       |    pub error_rate: f32,
  149|       |}
  150|       |
  151|       |/// Metrics per request source
  152|       |#[derive(Debug, Clone, Default, Serialize, Deserialize)]
  153|       |pub struct SourceMetrics {
  154|       |    pub requests: u64,
  155|       |    pub total_tokens: u64,
  156|       |    pub average_latency_ms: f32,
  157|       |    pub error_rate: f32,
  158|       |}
  159|       |
  160|       |/// Performance histograms for detailed analysis
  161|       |#[derive(Debug)]
  162|       |pub struct PerformanceHistograms {
  163|       |    pub latency_histogram: Histogram<u64>,
  164|       |    pub token_histogram: Histogram<u64>,
  165|       |    pub cost_histogram: Histogram<u64>, // Cost in cents
  166|       |}
  167|       |
  168|       |impl Default for PerformanceHistograms {
  169|     27|    fn default() -> Self {
  170|     27|        Self {
  171|     27|            latency_histogram: Histogram::new(3).unwrap(), // 3 significant digits
  172|     27|            token_histogram: Histogram::new(3).unwrap(),
  173|     27|            cost_histogram: Histogram::new(3).unwrap(),
  174|     27|        }
  175|     27|    }
  176|       |}
  177|       |
  178|       |/// Cost tracking with budgets and alerts
  179|       |#[derive(Debug, Clone, Default, Serialize, Deserialize)]
  180|       |pub struct CostTracker {
  181|       |    pub hourly_costs: VecDeque<HourlyCost>,
  182|       |    pub daily_budget_usd: f32,
  183|       |    pub monthly_budget_usd: f32,
  184|       |    pub current_day_spend: f32,
  185|       |    pub current_month_spend: f32,
  186|       |    pub cost_by_model: HashMap<String, f32>,
  187|       |    pub cost_by_source: HashMap<String, f32>,
  188|       |    pub budget_alerts_sent: Vec<BudgetAlert>,
  189|       |}
  190|       |
  191|       |/// Hourly cost tracking
  192|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  193|       |pub struct HourlyCost {
  194|       |    pub hour: DateTime<Utc>,
  195|       |    pub cost_usd: f32,
  196|       |    pub requests: u64,
  197|       |    pub tokens: u64,
  198|       |}
  199|       |
  200|       |/// Budget alert record
  201|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  202|       |pub struct BudgetAlert {
  203|       |    pub alert_type: BudgetAlertType,
  204|       |    pub threshold: f32,
  205|       |    pub actual: f32,
  206|       |    pub timestamp: DateTime<Utc>,
  207|       |}
  208|       |
  209|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  210|       |pub enum BudgetAlertType {
  211|       |    DailyBudget,
  212|       |    MonthlyBudget,
  213|       |    HourlyRate,
  214|       |}
  215|       |
  216|       |/// Alert management system
  217|       |#[derive(Debug, Default)]
  218|       |pub struct AlertManager {
  219|       |    pub active_alerts: HashMap<String, Alert>,
  220|       |    pub alert_history: VecDeque<Alert>,
  221|       |    pub notification_channels: Vec<NotificationChannel>,
  222|       |}
  223|       |
  224|       |/// Individual alert
  225|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  226|       |pub struct Alert {
  227|       |    pub id: String,
  228|       |    pub alert_type: AlertType,
  229|       |    pub severity: AlertSeverity,
  230|       |    pub message: String,
  231|       |    pub value: f32,
  232|       |    pub threshold: f32,
  233|       |    pub first_triggered: DateTime<Utc>,
  234|       |    pub last_triggered: DateTime<Utc>,
  235|       |    pub acknowledged: bool,
  236|       |    pub resolved: bool,
  237|       |}
  238|       |
  239|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  240|       |pub enum AlertType {
  241|       |    HighLatency,
  242|       |    HighErrorRate,
  243|       |    HighCost,
  244|       |    QueueBacklog,
  245|       |    ModelFailure,
  246|       |}
  247|       |
  248|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  249|       |pub enum AlertSeverity {
  250|       |    Info,
  251|       |    Warning,
  252|       |    Critical,
  253|       |}
  254|       |
  255|       |/// Notification channels for alerts
  256|       |#[derive(Debug, Clone)]
  257|       |pub enum NotificationChannel {
  258|       |    Log,
  259|       |    Webhook(String),
  260|       |    Email(String),
  261|       |}
  262|       |
  263|       |/// Currently active request tracking
  264|       |#[derive(Debug, Clone)]
  265|       |pub struct ActiveRequest {
  266|       |    pub request_id: String,
  267|       |    pub start_time: Instant,
  268|       |    pub model: String,
  269|       |    pub source: String,
  270|       |    pub prompt_tokens: usize,
  271|       |}
  272|       |
  273|       |/// Error tracking and analysis
  274|       |#[derive(Debug, Default)]
  275|       |pub struct ErrorTracker {
  276|       |    pub error_counts: HashMap<String, u64>,
  277|       |    pub error_patterns: HashMap<String, ErrorPattern>,
  278|       |    pub recent_errors: VecDeque<ErrorEvent>,
  279|       |}
  280|       |
  281|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  282|       |pub struct ErrorPattern {
  283|       |    pub error_type: String,
  284|       |    pub frequency: u64,
  285|       |    pub first_seen: DateTime<Utc>,
  286|       |    pub last_seen: DateTime<Utc>,
  287|       |    pub sample_messages: Vec<String>,
  288|       |}
  289|       |
  290|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  291|       |pub struct ErrorEvent {
  292|       |    pub timestamp: DateTime<Utc>,
  293|       |    pub error_type: String,
  294|       |    pub error_message: String,
  295|       |    pub request_id: String,
  296|       |    pub model: String,
  297|       |}
  298|       |
  299|       |/// Dashboard data for UI
  300|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  301|       |pub struct DashboardData {
  302|       |    pub current_metrics: LlmMetrics,
  303|       |    pub cost_summary: CostSummary,
  304|       |    pub active_alerts: Vec<Alert>,
  305|       |    pub top_errors: Vec<ErrorPattern>,
  306|       |    pub model_breakdown: Vec<ModelBreakdown>,
  307|       |    pub hourly_stats: Vec<HourlyStats>,
  308|       |    pub performance_percentiles: PerformancePercentiles,
  309|       |}
  310|       |
  311|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  312|       |pub struct CostSummary {
  313|       |    pub current_hour_cost: f32,
  314|       |    pub today_cost: f32,
  315|       |    pub month_cost: f32,
  316|       |    pub daily_budget_remaining: f32,
  317|       |    pub monthly_budget_remaining: f32,
  318|       |    pub projected_monthly_cost: f32,
  319|       |}
  320|       |
  321|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  322|       |pub struct ModelBreakdown {
  323|       |    pub model: String,
  324|       |    pub requests: u64,
  325|       |    pub cost: f32,
  326|       |    pub avg_latency: f32,
  327|       |    pub error_rate: f32,
  328|       |}
  329|       |
  330|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  331|       |pub struct HourlyStats {
  332|       |    pub hour: DateTime<Utc>,
  333|       |    pub requests: u64,
  334|       |    pub cost: f32,
  335|       |    pub avg_latency: f32,
  336|       |    pub error_rate: f32,
  337|       |}
  338|       |
  339|       |#[derive(Debug, Clone, Serialize, Deserialize)]
  340|       |pub struct PerformancePercentiles {
  341|       |    pub latency_p50: u64,
  342|       |    pub latency_p75: u64,
  343|       |    pub latency_p90: u64,
  344|       |    pub latency_p95: u64,
  345|       |    pub latency_p99: u64,
  346|       |    pub token_p50: u64,
  347|       |    pub token_p95: u64,
  348|       |    pub cost_p50: f32,
  349|       |    pub cost_p95: f32,
  350|       |}
  351|       |
  352|       |impl LlmTelemetry {
  353|     12|    pub fn new(config: TelemetryConfig) -> Self {
  354|     12|        Self {
  355|     12|            traces: Arc::new(RwLock::new(VecDeque::with_capacity(config.max_traces))),
  356|     12|            metrics: Arc::new(RwLock::new(LlmMetrics::default())),
  357|     12|            histograms: Arc::new(RwLock::new(PerformanceHistograms::default())),
  358|     12|            cost_tracker: Arc::new(RwLock::new(CostTracker::default())),
  359|     12|            alert_manager: Arc::new(RwLock::new(AlertManager::default())),
  360|     12|            config,
  361|     12|            active_requests: Arc::new(DashMap::new()),
  362|     12|            error_tracker: Arc::new(RwLock::new(ErrorTracker::default())),
  363|     12|        }
  364|     12|    }
  365|       |
  366|       |    /// Start tracking an LLM request
  367|     12|    pub fn start_request(
  368|     12|        &self,
  369|     12|        request_id: String,
  370|     12|        model: String,
  371|     12|        source: String,
  372|     12|        prompt_tokens: usize,
  373|     12|    ) -> RequestTracker {
  374|     12|        let active_request = ActiveRequest {
  375|     12|            request_id: request_id.clone(),
  376|     12|            start_time: Instant::now(),
  377|     12|            model: model.clone(),
  378|     12|            source: source.clone(),
  379|     12|            prompt_tokens,
  380|     12|        };
  381|       |
  382|     12|        self.active_requests
  383|     12|            .insert(request_id.clone(), active_request);
  384|       |
  385|     12|        RequestTracker {
  386|     12|            request_id,
  387|     12|            start_time: Instant::now(),
  388|     12|            telemetry: Arc::new(self.clone()),
  389|     12|        }
  390|     12|    }
  391|       |
  392|       |    /// Record a completed LLM request
  393|     12|    pub async fn record_request(&self, trace: LlmTrace) -> Result<()> {
  394|       |        // Sample based on configuration
  395|     12|        if self.should_sample() {
  396|       |            // Store trace
  397|       |            {
  398|     12|                let mut traces = self.traces.write().await;
  399|     12|                traces.push_back(trace.clone());
  400|       |
  401|       |                // Maintain trace buffer size
  402|     12|                if traces.len() > self.config.max_traces {
  403|      0|                    traces.pop_front();
  404|     12|                }
  405|       |            }
  406|      0|        }
  407|       |
  408|       |        // Update metrics
  409|     12|        self.update_metrics(&trace).await?;
                                                       ^0
  410|       |
  411|       |        // Update histograms
  412|     12|        self.update_histograms(&trace).await?;
                                                          ^0
  413|       |
  414|       |        // Track costs
  415|     12|        if self.config.enable_cost_tracking {
  416|     12|            self.track_cost(&trace).await?;
                                                       ^0
  417|      0|        }
  418|       |
  419|       |        // Check for alerts
  420|     12|        self.check_alerts().await?;
                                               ^0
  421|       |
  422|       |        // Remove from active requests
  423|     12|        self.active_requests.remove(&trace.request_id);
  424|       |
  425|       |        // Track errors if applicable
  426|     12|        if !trace.success {
  427|      2|            self.track_error(&trace).await?;
                                                        ^0
  428|     10|        }
  429|       |
  430|     12|        debug!(
  431|      0|            "Recorded LLM request: {} ({}ms, {} tokens, ${:.4})",
  432|       |            trace.request_id, trace.latency_ms, trace.total_tokens, trace.cost_usd
  433|       |        );
  434|       |
  435|     12|        Ok(())
  436|     12|    }
  437|       |
  438|       |    /// Get real-time dashboard data
  439|      1|    pub async fn get_dashboard_data(&self) -> Result<DashboardData> {
  440|      1|        let metrics = self.metrics.read().await.clone();
  441|      1|        let cost_tracker = self.cost_tracker.read().await;
  442|      1|        let alert_manager = self.alert_manager.read().await;
  443|      1|        let error_tracker = self.error_tracker.read().await;
  444|      1|        let histograms = self.histograms.read().await;
  445|       |
  446|      1|        let cost_summary = CostSummary {
  447|      1|            current_hour_cost: cost_tracker
  448|      1|                .hourly_costs
  449|      1|                .back()
  450|      1|                .map(|h| h.cost_usd)
  451|      1|                .unwrap_or(0.0),
  452|      1|            today_cost: cost_tracker.current_day_spend,
  453|      1|            month_cost: cost_tracker.current_month_spend,
  454|      1|            daily_budget_remaining: (cost_tracker.daily_budget_usd
  455|      1|                - cost_tracker.current_day_spend)
  456|      1|                .max(0.0),
  457|      1|            monthly_budget_remaining: (cost_tracker.monthly_budget_usd
  458|      1|                - cost_tracker.current_month_spend)
  459|      1|                .max(0.0),
  460|      1|            projected_monthly_cost: self.calculate_projected_monthly_cost(&cost_tracker),
  461|       |        };
  462|       |
  463|      1|        let model_breakdown: Vec<_> = metrics
  464|      1|            .model_usage
  465|      1|            .iter()
  466|      1|            .map(|(model, model_metrics)| ModelBreakdown {
  467|      0|                model: model.clone(),
  468|      0|                requests: model_metrics.requests,
  469|      0|                cost: model_metrics.total_cost_usd as f32,
  470|      0|                avg_latency: model_metrics.average_latency_ms,
  471|      0|                error_rate: model_metrics.error_rate,
  472|      0|            })
  473|      1|            .collect();
  474|       |
  475|      1|        let hourly_stats: Vec<_> = cost_tracker
  476|      1|            .hourly_costs
  477|      1|            .iter()
  478|      1|            .map(|hourly| {
                                        ^0
  479|      0|                HourlyStats {
  480|      0|                    hour: hourly.hour,
  481|      0|                    requests: hourly.requests,
  482|      0|                    cost: hourly.cost_usd,
  483|      0|                    avg_latency: 0.0, // Would calculate from stored data
  484|      0|                    error_rate: 0.0,  // Would calculate from stored data
  485|      0|                }
  486|      0|            })
  487|      1|            .collect();
  488|       |
  489|      1|        let performance_percentiles = PerformancePercentiles {
  490|      1|            latency_p50: histograms.latency_histogram.value_at_quantile(0.5),
  491|      1|            latency_p75: histograms.latency_histogram.value_at_quantile(0.75),
  492|      1|            latency_p90: histograms.latency_histogram.value_at_quantile(0.90),
  493|      1|            latency_p95: histograms.latency_histogram.value_at_quantile(0.95),
  494|      1|            latency_p99: histograms.latency_histogram.value_at_quantile(0.99),
  495|      1|            token_p50: histograms.token_histogram.value_at_quantile(0.5),
  496|      1|            token_p95: histograms.token_histogram.value_at_quantile(0.95),
  497|      1|            cost_p50: (histograms.cost_histogram.value_at_quantile(0.5) as f32) / 100.0,
  498|      1|            cost_p95: (histograms.cost_histogram.value_at_quantile(0.95) as f32) / 100.0,
  499|      1|        };
  500|       |
  501|      1|        Ok(DashboardData {
  502|      1|            current_metrics: metrics,
  503|      1|            cost_summary,
  504|      1|            active_alerts: alert_manager.active_alerts.values().cloned().collect(),
  505|      1|            top_errors: error_tracker.error_patterns.values().cloned().collect(),
  506|      1|            model_breakdown,
  507|      1|            hourly_stats,
  508|      1|            performance_percentiles,
  509|      1|        })
  510|      1|    }
  511|       |
  512|       |    /// Export traces in various formats
  513|      4|    pub async fn export_traces(
  514|      4|        &self,
  515|      4|        format: ExportFormat,
  516|      4|        filter: Option<TraceFilter>,
  517|      4|    ) -> Result<String> {
  518|      4|        let traces = self.traces.read().await;
  519|       |
  520|      4|        let filtered_traces: Vec<_> = if let Some(filter) = filter {
                                                                ^1
  521|      1|            traces
  522|      1|                .iter()
  523|      2|                .filter(|trace| self.matches_filter(trace, &filter))
                               ^1
  524|      1|                .cloned()
  525|      1|                .collect()
  526|       |        } else {
  527|      3|            traces.iter().cloned().collect()
  528|       |        };
  529|       |
  530|      4|        match format {
  531|      2|            ExportFormat::Json => Ok(serde_json::to_string_pretty(&filtered_traces)?),
                                                                                                 ^0
  532|      1|            ExportFormat::Csv => self.export_traces_csv(&filtered_traces),
  533|      1|            ExportFormat::OpenTelemetry => self.export_opentelemetry(&filtered_traces),
  534|       |        }
  535|      4|    }
  536|       |
  537|       |    /// Get current metrics
  538|      9|    pub async fn get_metrics(&self) -> LlmMetrics {
  539|      9|        self.metrics.read().await.clone()
  540|      9|    }
  541|       |
  542|       |    /// Clear all stored data
  543|      1|    pub async fn clear_data(&self) -> Result<()> {
  544|       |        {
  545|      1|            let mut traces = self.traces.write().await;
  546|      1|            traces.clear();
  547|       |        }
  548|       |
  549|       |        {
  550|      1|            let mut metrics = self.metrics.write().await;
  551|      1|            *metrics = LlmMetrics::default();
  552|       |        }
  553|       |
  554|       |        {
  555|      1|            let mut histograms = self.histograms.write().await;
  556|      1|            *histograms = PerformanceHistograms::default();
  557|       |        }
  558|       |
  559|       |        {
  560|      1|            let mut cost_tracker = self.cost_tracker.write().await;
  561|      1|            *cost_tracker = CostTracker::default();
  562|       |        }
  563|       |
  564|       |        {
  565|      1|            let mut alert_manager = self.alert_manager.write().await;
  566|      1|            alert_manager.active_alerts.clear();
  567|      1|            alert_manager.alert_history.clear();
  568|       |        }
  569|       |
  570|       |        {
  571|      1|            let mut error_tracker = self.error_tracker.write().await;
  572|      1|            *error_tracker = ErrorTracker::default();
  573|       |        }
  574|       |
  575|      1|        self.active_requests.clear();
  576|       |
  577|      1|        info!("Cleared all telemetry data");
                            ^0
  578|      1|        Ok(())
  579|      1|    }
  580|       |
  581|       |    /// Determine if we should sample this request
  582|     12|    fn should_sample(&self) -> bool {
  583|       |        use rand::Rng;
  584|     12|        let mut rng = rand::rng();
  585|     12|        rng.random::<f32>() < self.config.sampling_rate
  586|     12|    }
  587|       |
  588|       |    /// Update real-time metrics
  589|     12|    async fn update_metrics(&self, trace: &LlmTrace) -> Result<()> {
  590|     12|        let mut metrics = self.metrics.write().await;
  591|       |
  592|     12|        metrics.total_requests += 1;
  593|     12|        if trace.success {
  594|     10|            metrics.successful_requests += 1;
  595|     10|        } else {
  596|      2|            metrics.failed_requests += 1;
  597|      2|        }
  598|       |
  599|     12|        metrics.total_tokens += trace.total_tokens as u64;
  600|     12|        metrics.total_cost_usd += trace.cost_usd;
  601|       |
  602|       |        // Update averages
  603|     12|        let total_requests = metrics.total_requests as f32;
  604|     12|        metrics.average_latency_ms = (metrics.average_latency_ms * (total_requests - 1.0)
  605|     12|            + trace.latency_ms as f32)
  606|     12|            / total_requests;
  607|     12|        metrics.error_rate = metrics.failed_requests as f32 / metrics.total_requests as f32;
  608|       |
  609|       |        // Update model-specific metrics
  610|     12|        let model_metrics = metrics
  611|     12|            .model_usage
  612|     12|            .entry(trace.model.clone())
  613|     12|            .or_insert_with(ModelMetrics::default);
  614|     12|        model_metrics.requests += 1;
  615|     12|        model_metrics.total_tokens += trace.total_tokens as u64;
  616|     12|        model_metrics.total_cost_usd += trace.cost_usd;
  617|     12|        model_metrics.average_latency_ms = (model_metrics.average_latency_ms
  618|     12|            * (model_metrics.requests - 1) as f32
  619|     12|            + trace.latency_ms as f32)
  620|     12|            / model_metrics.requests as f32;
  621|     12|        if !trace.success {
  622|      2|            model_metrics.error_rate =
  623|      2|                (model_metrics.error_rate * (model_metrics.requests - 1) as f32 + 1.0)
  624|      2|                    / model_metrics.requests as f32;
  625|     10|        } else {
  626|     10|            model_metrics.error_rate = (model_metrics.error_rate
  627|     10|                * (model_metrics.requests - 1) as f32)
  628|     10|                / model_metrics.requests as f32;
  629|     10|        }
  630|       |
  631|       |        // Update source-specific metrics
  632|     12|        let source_metrics = metrics
  633|     12|            .source_metrics
  634|     12|            .entry(trace.request_source.clone())
  635|     12|            .or_insert_with(SourceMetrics::default);
  636|     12|        source_metrics.requests += 1;
  637|     12|        source_metrics.total_tokens += trace.total_tokens as u64;
  638|     12|        source_metrics.average_latency_ms = (source_metrics.average_latency_ms
  639|     12|            * (source_metrics.requests - 1) as f32
  640|     12|            + trace.latency_ms as f32)
  641|     12|            / source_metrics.requests as f32;
  642|     12|        if !trace.success {
  643|      2|            source_metrics.error_rate =
  644|      2|                (source_metrics.error_rate * (source_metrics.requests - 1) as f32 + 1.0)
  645|      2|                    / source_metrics.requests as f32;
  646|     10|        } else {
  647|     10|            source_metrics.error_rate = (source_metrics.error_rate
  648|     10|                * (source_metrics.requests - 1) as f32)
  649|     10|                / source_metrics.requests as f32;
  650|     10|        }
  651|       |
  652|     12|        metrics.active_requests = self.active_requests.len();
  653|     12|        metrics.last_updated = Utc::now();
  654|       |
  655|     12|        Ok(())
  656|     12|    }
  657|       |
  658|       |    /// Update performance histograms
  659|     12|    async fn update_histograms(&self, trace: &LlmTrace) -> Result<()> {
  660|     12|        let mut histograms = self.histograms.write().await;
  661|       |
  662|     12|        histograms.latency_histogram.record(trace.latency_ms)?;
                                                                           ^0
  663|     12|        histograms
  664|     12|            .token_histogram
  665|     12|            .record(trace.total_tokens as u64)?;
                                                            ^0
  666|     12|        histograms
  667|     12|            .cost_histogram
  668|     12|            .record((trace.cost_usd * 100.0) as u64)?; // Convert to cents
                                                                  ^0
  669|       |
  670|     12|        Ok(())
  671|     12|    }
  672|       |
  673|       |    /// Track costs and check budgets
  674|     12|    async fn track_cost(&self, trace: &LlmTrace) -> Result<()> {
  675|     12|        let mut cost_tracker = self.cost_tracker.write().await;
  676|       |
  677|       |        // Update hourly costs
  678|     12|        let current_hour = trace
  679|     12|            .start_time
  680|     12|            .with_minute(0)
  681|     12|            .unwrap()
  682|     12|            .with_second(0)
  683|     12|            .unwrap()
  684|     12|            .with_nanosecond(0)
  685|     12|            .unwrap();
  686|       |
  687|     12|        if let Some(hourly) = cost_tracker.hourly_costs.back_mut() {
                                  ^3
  688|      3|            if hourly.hour == current_hour {
  689|      3|                hourly.cost_usd += trace.cost_usd as f32;
  690|      3|                hourly.requests += 1;
  691|      3|                hourly.tokens += trace.total_tokens as u64;
  692|      3|            } else {
  693|      0|                cost_tracker.hourly_costs.push_back(HourlyCost {
  694|      0|                    hour: current_hour,
  695|      0|                    cost_usd: trace.cost_usd as f32,
  696|      0|                    requests: 1,
  697|      0|                    tokens: trace.total_tokens as u64,
  698|      0|                });
  699|      0|            }
  700|      9|        } else {
  701|      9|            cost_tracker.hourly_costs.push_back(HourlyCost {
  702|      9|                hour: current_hour,
  703|      9|                cost_usd: trace.cost_usd as f32,
  704|      9|                requests: 1,
  705|      9|                tokens: trace.total_tokens as u64,
  706|      9|            });
  707|      9|        }
  708|       |
  709|       |        // Keep only recent hourly data
  710|     12|        while cost_tracker.hourly_costs.len() > 168 {
  711|      0|            // Keep 1 week
  712|      0|            cost_tracker.hourly_costs.pop_front();
  713|      0|        }
  714|       |
  715|       |        // Update daily/monthly spend
  716|     12|        cost_tracker.current_day_spend += trace.cost_usd as f32;
  717|     12|        cost_tracker.current_month_spend += trace.cost_usd as f32;
  718|       |
  719|       |        // Update cost by model
  720|     12|        *cost_tracker
  721|     12|            .cost_by_model
  722|     12|            .entry(trace.model.clone())
  723|     12|            .or_insert(0.0) += trace.cost_usd as f32;
  724|       |
  725|       |        // Update cost by source
  726|     12|        *cost_tracker
  727|     12|            .cost_by_source
  728|     12|            .entry(trace.request_source.clone())
  729|     12|            .or_insert(0.0) += trace.cost_usd as f32;
  730|       |
  731|     12|        Ok(())
  732|     12|    }
  733|       |
  734|       |    /// Check for alert conditions
  735|     12|    async fn check_alerts(&self) -> Result<()> {
  736|     12|        let metrics = self.metrics.read().await;
  737|     12|        let cost_tracker = self.cost_tracker.read().await;
  738|     12|        let mut alert_manager = self.alert_manager.write().await;
  739|       |
  740|       |        // Check latency alerts
  741|     12|        if metrics.p95_latency_ms > self.config.alert_thresholds.latency_p95_ms {
  742|      0|            self.trigger_alert(
  743|      0|                &mut alert_manager,
  744|      0|                AlertType::HighLatency,
  745|      0|                AlertSeverity::Warning,
  746|      0|                format!(
  747|      0|                    "P95 latency is {}ms (threshold: {}ms)",
  748|      0|                    metrics.p95_latency_ms, self.config.alert_thresholds.latency_p95_ms
  749|      0|                ),
  750|      0|                metrics.p95_latency_ms as f32,
  751|      0|                self.config.alert_thresholds.latency_p95_ms as f32,
  752|      0|            );
  753|     12|        }
  754|       |
  755|       |        // Check error rate alerts
  756|     12|        if metrics.error_rate > self.config.alert_thresholds.error_rate {
  757|      2|            self.trigger_alert(
  758|      2|                &mut alert_manager,
  759|      2|                AlertType::HighErrorRate,
  760|      2|                AlertSeverity::Critical,
  761|      2|                format!(
  762|      2|                    "Error rate is {:.2}% (threshold: {:.2}%)",
  763|      2|                    metrics.error_rate * 100.0,
  764|      2|                    self.config.alert_thresholds.error_rate * 100.0
  765|      2|                ),
  766|      2|                metrics.error_rate,
  767|      2|                self.config.alert_thresholds.error_rate,
  768|      2|            );
  769|     10|        }
  770|       |
  771|       |        // Check cost alerts
  772|     12|        if let Some(hourly) = cost_tracker.hourly_costs.back() {
  773|     12|            if hourly.cost_usd > self.config.alert_thresholds.cost_per_hour_usd {
  774|      0|                self.trigger_alert(
  775|      0|                    &mut alert_manager,
  776|      0|                    AlertType::HighCost,
  777|      0|                    AlertSeverity::Warning,
  778|      0|                    format!(
  779|      0|                        "Hourly cost is ${:.2} (threshold: ${:.2})",
  780|      0|                        hourly.cost_usd, self.config.alert_thresholds.cost_per_hour_usd
  781|      0|                    ),
  782|      0|                    hourly.cost_usd,
  783|      0|                    self.config.alert_thresholds.cost_per_hour_usd,
  784|      0|                );
  785|     12|            }
  786|      0|        }
  787|       |
  788|       |        // Check queue depth alerts
  789|     12|        if metrics.queue_depth > self.config.alert_thresholds.queue_depth {
  790|      0|            self.trigger_alert(
  791|      0|                &mut alert_manager,
  792|      0|                AlertType::QueueBacklog,
  793|      0|                AlertSeverity::Warning,
  794|      0|                format!(
  795|      0|                    "Queue depth is {} (threshold: {})",
  796|      0|                    metrics.queue_depth, self.config.alert_thresholds.queue_depth
  797|      0|                ),
  798|      0|                metrics.queue_depth as f32,
  799|      0|                self.config.alert_thresholds.queue_depth as f32,
  800|      0|            );
  801|     12|        }
  802|       |
  803|     12|        Ok(())
  804|     12|    }
  805|       |
  806|       |    /// Trigger an alert
  807|      2|    fn trigger_alert(
  808|      2|        &self,
  809|      2|        alert_manager: &mut AlertManager,
  810|      2|        alert_type: AlertType,
  811|      2|        severity: AlertSeverity,
  812|      2|        message: String,
  813|      2|        value: f32,
  814|      2|        threshold: f32,
  815|      2|    ) {
  816|      2|        let alert_key = format!("{:?}", alert_type);
  817|      2|        let now = Utc::now();
  818|       |
  819|      2|        if let Some(existing_alert) = alert_manager.active_alerts.get_mut(&alert_key) {
                                  ^0
  820|      0|            existing_alert.last_triggered = now;
  821|      0|            existing_alert.value = value;
  822|      0|        } else {
  823|      2|            let alert = Alert {
  824|      2|                id: Uuid::new_v4().to_string(),
  825|      2|                alert_type,
  826|      2|                severity,
  827|      2|                message: message.clone(),
  828|      2|                value,
  829|      2|                threshold,
  830|      2|                first_triggered: now,
  831|      2|                last_triggered: now,
  832|      2|                acknowledged: false,
  833|      2|                resolved: false,
  834|      2|            };
  835|       |
  836|      2|            alert_manager.active_alerts.insert(alert_key, alert.clone());
  837|      2|            alert_manager.alert_history.push_back(alert);
  838|       |
  839|       |            // Keep alert history manageable
  840|      2|            if alert_manager.alert_history.len() > 1000 {
  841|      0|                alert_manager.alert_history.pop_front();
  842|      2|            }
  843|       |
  844|      2|            warn!("Alert triggered: {}", message);
                                ^0
  845|       |        }
  846|      2|    }
  847|       |
  848|       |    /// Track error patterns
  849|      2|    async fn track_error(&self, trace: &LlmTrace) -> Result<()> {
  850|      2|        if let Some(error_type) = &trace.error_type {
  851|      2|            let mut error_tracker = self.error_tracker.write().await;
  852|       |
  853|      2|            *error_tracker
  854|      2|                .error_counts
  855|      2|                .entry(error_type.clone())
  856|      2|                .or_insert(0) += 1;
  857|       |
  858|      2|            let error_pattern = error_tracker
  859|      2|                .error_patterns
  860|      2|                .entry(error_type.clone())
  861|      2|                .or_insert_with(|| ErrorPattern {
  862|      2|                    error_type: error_type.clone(),
  863|       |                    frequency: 0,
  864|      2|                    first_seen: trace.start_time,
  865|      2|                    last_seen: trace.start_time,
  866|      2|                    sample_messages: Vec::new(),
  867|      2|                });
  868|       |
  869|      2|            error_pattern.frequency += 1;
  870|      2|            error_pattern.last_seen = trace.start_time;
  871|       |
  872|      2|            if let Some(error_message) = &trace.error_message {
  873|      2|                if error_pattern.sample_messages.len() < 5
  874|      2|                    && !error_pattern.sample_messages.contains(error_message)
  875|      2|                {
  876|      2|                    error_pattern.sample_messages.push(error_message.clone());
  877|      2|                }
                              ^0
  878|      0|            }
  879|       |
  880|      2|            let error_event = ErrorEvent {
  881|      2|                timestamp: trace.start_time,
  882|      2|                error_type: error_type.clone(),
  883|      2|                error_message: trace.error_message.clone().unwrap_or_default(),
  884|      2|                request_id: trace.request_id.clone(),
  885|      2|                model: trace.model.clone(),
  886|      2|            };
  887|       |
  888|      2|            error_tracker.recent_errors.push_back(error_event);
  889|       |
  890|       |            // Keep recent errors manageable
  891|      2|            if error_tracker.recent_errors.len() > 1000 {
  892|      0|                error_tracker.recent_errors.pop_front();
  893|      2|            }
  894|      0|        }
  895|       |
  896|      2|        Ok(())
  897|      2|    }
  898|       |
  899|       |    /// Calculate projected monthly cost
  900|      1|    fn calculate_projected_monthly_cost(&self, cost_tracker: &CostTracker) -> f32 {
  901|      1|        let days_in_month = 30.0;
  902|      1|        let current_day = Utc::now().day() as f32;
  903|       |
  904|      1|        if current_day > 0.0 {
  905|      1|            (cost_tracker.current_month_spend / current_day) * days_in_month
  906|       |        } else {
  907|      0|            0.0
  908|       |        }
  909|      1|    }
  910|       |
  911|       |    /// Export traces to CSV format
  912|      1|    fn export_traces_csv(&self, traces: &[LlmTrace]) -> Result<String> {
  913|      1|        let mut csv = String::new();
  914|      1|        csv.push_str("request_id,model,start_time,latency_ms,tokens_prompt,tokens_response,cost_usd,success,error_message,request_source\n");
  915|       |
  916|      2|        for trace in traces {
                          ^1
  917|      1|            csv.push_str(&format!(
  918|      1|                "{},{},{},{},{},{},{},{},{},{}\n",
  919|      1|                trace.request_id,
  920|      1|                trace.model,
  921|      1|                trace.start_time.format("%Y-%m-%d %H:%M:%S UTC"),
  922|      1|                trace.latency_ms,
  923|      1|                trace.tokens_prompt,
  924|      1|                trace.tokens_response,
  925|      1|                trace.cost_usd,
  926|      1|                trace.success,
  927|      1|                trace.error_message.as_deref().unwrap_or(""),
  928|      1|                trace.request_source
  929|      1|            ));
  930|      1|        }
  931|       |
  932|      1|        Ok(csv)
  933|      1|    }
  934|       |
  935|       |    /// Export to OpenTelemetry format
  936|      1|    fn export_opentelemetry(&self, _traces: &[LlmTrace]) -> Result<String> {
  937|       |        // Placeholder for OpenTelemetry export
  938|       |        // Would implement actual OTLP format here
  939|      1|        Ok("OpenTelemetry export not yet implemented".to_string())
  940|      1|    }
  941|       |
  942|       |    /// Check if trace matches filter
  943|      2|    fn matches_filter(&self, trace: &LlmTrace, filter: &TraceFilter) -> bool {
  944|      2|        if let Some(model) = &filter.model {
                                  ^0
  945|      0|            if &trace.model != model {
  946|      0|                return false;
  947|      0|            }
  948|      2|        }
  949|       |
  950|      2|        if let Some(success) = filter.success {
  951|      2|            if trace.success != success {
  952|      1|                return false;
  953|      1|            }
  954|      0|        }
  955|       |
  956|      1|        if let Some(start_time) = filter.start_time {
                                  ^0
  957|      0|            if trace.start_time < start_time {
  958|      0|                return false;
  959|      0|            }
  960|      1|        }
  961|       |
  962|      1|        if let Some(end_time) = filter.end_time {
                                  ^0
  963|      0|            if trace.start_time > end_time {
  964|      0|                return false;
  965|      0|            }
  966|      1|        }
  967|       |
  968|      1|        true
  969|      2|    }
  970|       |}
  971|       |
  972|       |impl Clone for LlmTelemetry {
  973|     13|    fn clone(&self) -> Self {
  974|     13|        Self {
  975|     13|            traces: self.traces.clone(),
  976|     13|            metrics: self.metrics.clone(),
  977|     13|            histograms: Arc::new(RwLock::new(PerformanceHistograms::default())), // Can't clone histograms
  978|     13|            cost_tracker: self.cost_tracker.clone(),
  979|     13|            alert_manager: self.alert_manager.clone(),
  980|     13|            config: self.config.clone(),
  981|     13|            active_requests: self.active_requests.clone(),
  982|     13|            error_tracker: self.error_tracker.clone(),
  983|     13|        }
  984|     13|    }
  985|       |}
  986|       |
  987|       |/// Request tracker for monitoring individual requests
  988|       |pub struct RequestTracker {
  989|       |    request_id: String,
  990|       |    start_time: Instant,
  991|       |    telemetry: Arc<LlmTelemetry>,
  992|       |}
  993|       |
  994|       |impl RequestTracker {
  995|       |    /// Complete the request with results
  996|       |    #[allow(clippy::too_many_arguments)]
  997|     12|    pub async fn complete(
  998|     12|        self,
  999|     12|        model: String,
 1000|     12|        success: bool,
 1001|     12|        tokens_response: usize,
 1002|     12|        cost_usd: f64,
 1003|     12|        error_message: Option<String>,
 1004|     12|        error_type: Option<String>,
 1005|     12|        request_source: String,
 1006|     12|        prompt: Option<String>,
 1007|     12|        response: Option<String>,
 1008|     12|        tags: HashMap<String, String>,
 1009|     12|    ) -> Result<()> {
 1010|     12|        let end_time = Utc::now();
 1011|     12|        let latency = self.start_time.elapsed();
 1012|       |
 1013|       |        // Extract prompt_tokens and drop the DashMap guard BEFORE any .await
 1014|       |        // to avoid holding the lock across async yield points (which can cause deadlock)
 1015|     12|        let prompt_tokens = {
 1016|     12|            let active_request = self
 1017|     12|                .telemetry
 1018|     12|                .active_requests
 1019|     12|                .get(&self.request_id)
 1020|     12|                .ok_or_else(|| anyhow!("Active request not found"))?;
                                                     ^0                          ^0
 1021|     12|            active_request.prompt_tokens
 1022|       |        }; // Guard dropped here
 1023|       |
 1024|     12|        let trace = LlmTrace {
 1025|     12|            request_id: self.request_id.clone(),
 1026|     12|            session_id: None,
 1027|     12|            user_id: None,
 1028|     12|            prompt,
 1029|     12|            response,
 1030|     12|            prompt_hash: None,
 1031|     12|            model,
 1032|     12|            start_time: end_time - chrono::Duration::from_std(latency).unwrap(),
 1033|     12|            end_time,
 1034|     12|            latency_ms: latency.as_millis() as u64,
 1035|     12|            tokens_prompt: prompt_tokens,
 1036|     12|            tokens_response,
 1037|     12|            total_tokens: prompt_tokens + tokens_response,
 1038|     12|            cost_usd,
 1039|     12|            success,
 1040|     12|            error_message,
 1041|     12|            error_type,
 1042|     12|            request_source,
 1043|     12|            tags,
 1044|     12|        };
 1045|       |
 1046|     12|        self.telemetry.record_request(trace).await
 1047|     12|    }
 1048|       |}
 1049|       |
 1050|       |/// Export format options
 1051|       |#[derive(Debug, Clone)]
 1052|       |pub enum ExportFormat {
 1053|       |    Json,
 1054|       |    Csv,
 1055|       |    OpenTelemetry,
 1056|       |}
 1057|       |
 1058|       |/// Filter for trace exports
 1059|       |#[derive(Debug, Clone)]
 1060|       |pub struct TraceFilter {
 1061|       |    pub model: Option<String>,
 1062|       |    pub success: Option<bool>,
 1063|       |    pub start_time: Option<DateTime<Utc>>,
 1064|       |    pub end_time: Option<DateTime<Utc>>,
 1065|       |    pub min_latency_ms: Option<u64>,
 1066|       |    pub max_latency_ms: Option<u64>,
 1067|       |}
 1068|       |
 1069|       |#[cfg(test)]
 1070|       |mod tests {
 1071|       |    use super::*;
 1072|       |
 1073|       |    #[tokio::test]
 1074|      1|    async fn test_telemetry_creation() {
 1075|      1|        let config = TelemetryConfig::default();
 1076|      1|        let telemetry = LlmTelemetry::new(config);
 1077|       |
 1078|      1|        let metrics = telemetry.get_metrics().await;
 1079|      1|        assert_eq!(metrics.total_requests, 0);
 1080|      1|    }
 1081|       |
 1082|       |    #[tokio::test]
 1083|      1|    async fn test_request_tracking() {
 1084|      1|        let telemetry = LlmTelemetry::new(TelemetryConfig::default());
 1085|       |
 1086|      1|        let tracker = telemetry.start_request(
 1087|      1|            "test-request".to_string(),
 1088|      1|            "gpt-3.5-turbo".to_string(),
 1089|      1|            "test-source".to_string(),
 1090|       |            100,
 1091|       |        );
 1092|       |
 1093|      1|        assert_eq!(telemetry.active_requests.len(), 1);
 1094|       |
 1095|      1|        tracker
 1096|      1|            .complete(
 1097|      1|                "gpt-3.5-turbo".to_string(),
 1098|      1|                true,
 1099|      1|                200,
 1100|      1|                0.01,
 1101|      1|                None,
 1102|      1|                None,
 1103|      1|                "test-source".to_string(),
 1104|      1|                None,
 1105|      1|                None,
 1106|      1|                HashMap::new(),
 1107|      1|            )
 1108|      1|            .await
 1109|      1|            .unwrap();
 1110|       |
 1111|      1|        assert_eq!(telemetry.active_requests.len(), 0);
 1112|       |
 1113|      1|        let metrics = telemetry.get_metrics().await;
 1114|      1|        assert_eq!(metrics.total_requests, 1);
 1115|      1|        assert_eq!(metrics.successful_requests, 1);
 1116|      1|    }
 1117|       |
 1118|       |    #[tokio::test]
 1119|      1|    async fn test_dashboard_data() {
 1120|      1|        let telemetry = LlmTelemetry::new(TelemetryConfig::default());
 1121|       |
 1122|      1|        let dashboard = telemetry.get_dashboard_data().await.unwrap();
 1123|      1|        assert_eq!(dashboard.current_metrics.total_requests, 0);
 1124|      1|        assert!(dashboard.active_alerts.is_empty());
 1125|      1|    }
 1126|       |
 1127|       |    #[test]
 1128|      1|    fn test_telemetry_config_default() {
 1129|      1|        let config = TelemetryConfig::default();
 1130|      1|        assert_eq!(config.max_traces, 10000);
 1131|      1|        assert!(!config.log_content);
 1132|      1|        assert!(config.enable_cost_tracking);
 1133|      1|        assert!(!config.enable_prometheus);
 1134|      1|        assert!(!config.enable_opentelemetry);
 1135|      1|        assert!((config.sampling_rate - 1.0).abs() < 0.01);
 1136|      1|    }
 1137|       |
 1138|       |    #[test]
 1139|      1|    fn test_alert_thresholds_default() {
 1140|      1|        let thresholds = AlertThresholds::default();
 1141|      1|        assert_eq!(thresholds.latency_p95_ms, 5000);
 1142|      1|        assert!((thresholds.error_rate - 0.1).abs() < 0.01);
 1143|      1|        assert!((thresholds.cost_per_hour_usd - 10.0).abs() < 0.01);
 1144|      1|        assert_eq!(thresholds.queue_depth, 100);
 1145|      1|        assert_eq!(thresholds.token_rate, 10000);
 1146|      1|    }
 1147|       |
 1148|       |    #[test]
 1149|      1|    fn test_llm_trace_creation() {
 1150|      1|        let trace = LlmTrace {
 1151|      1|            request_id: "req-123".to_string(),
 1152|      1|            session_id: Some("sess-456".to_string()),
 1153|      1|            user_id: Some("user-789".to_string()),
 1154|      1|            prompt: Some("Hello".to_string()),
 1155|      1|            response: Some("Hi there!".to_string()),
 1156|      1|            prompt_hash: Some(12345),
 1157|      1|            model: "gpt-4".to_string(),
 1158|      1|            start_time: Utc::now(),
 1159|      1|            end_time: Utc::now(),
 1160|      1|            latency_ms: 500,
 1161|      1|            tokens_prompt: 10,
 1162|      1|            tokens_response: 20,
 1163|      1|            total_tokens: 30,
 1164|      1|            cost_usd: 0.05,
 1165|      1|            success: true,
 1166|      1|            error_message: None,
 1167|      1|            error_type: None,
 1168|      1|            request_source: "test".to_string(),
 1169|      1|            tags: HashMap::new(),
 1170|      1|        };
 1171|      1|        assert_eq!(trace.request_id, "req-123");
 1172|      1|        assert_eq!(trace.model, "gpt-4");
 1173|      1|        assert!(trace.success);
 1174|      1|    }
 1175|       |
 1176|       |    #[test]
 1177|      1|    fn test_llm_metrics_default() {
 1178|      1|        let metrics = LlmMetrics::default();
 1179|      1|        assert_eq!(metrics.total_requests, 0);
 1180|      1|        assert_eq!(metrics.successful_requests, 0);
 1181|      1|        assert_eq!(metrics.failed_requests, 0);
 1182|      1|        assert_eq!(metrics.total_tokens, 0);
 1183|      1|    }
 1184|       |
 1185|       |    #[test]
 1186|      1|    fn test_model_metrics_default() {
 1187|      1|        let metrics = ModelMetrics::default();
 1188|      1|        assert_eq!(metrics.requests, 0);
 1189|      1|        assert_eq!(metrics.total_tokens, 0);
 1190|      1|    }
 1191|       |
 1192|       |    #[test]
 1193|      1|    fn test_source_metrics_default() {
 1194|      1|        let metrics = SourceMetrics::default();
 1195|      1|        assert_eq!(metrics.requests, 0);
 1196|      1|        assert_eq!(metrics.total_tokens, 0);
 1197|      1|    }
 1198|       |
 1199|       |    #[test]
 1200|      1|    fn test_cost_tracker_default() {
 1201|      1|        let tracker = CostTracker::default();
 1202|      1|        assert!(tracker.hourly_costs.is_empty());
 1203|      1|        assert_eq!(tracker.current_day_spend, 0.0);
 1204|      1|        assert_eq!(tracker.current_month_spend, 0.0);
 1205|      1|    }
 1206|       |
 1207|       |    #[test]
 1208|      1|    fn test_hourly_cost_creation() {
 1209|      1|        let cost = HourlyCost {
 1210|      1|            hour: Utc::now(),
 1211|      1|            cost_usd: 1.50,
 1212|      1|            requests: 100,
 1213|      1|            tokens: 5000,
 1214|      1|        };
 1215|      1|        assert!((cost.cost_usd - 1.5).abs() < 0.01);
 1216|      1|        assert_eq!(cost.requests, 100);
 1217|      1|    }
 1218|       |
 1219|       |    #[test]
 1220|      1|    fn test_budget_alert_types() {
 1221|      1|        let daily = BudgetAlertType::DailyBudget;
 1222|      1|        let monthly = BudgetAlertType::MonthlyBudget;
 1223|      1|        let hourly = BudgetAlertType::HourlyRate;
 1224|       |        
 1225|      1|        let json_daily = serde_json::to_string(&daily).unwrap();
 1226|      1|        let json_monthly = serde_json::to_string(&monthly).unwrap();
 1227|      1|        let json_hourly = serde_json::to_string(&hourly).unwrap();
 1228|       |        
 1229|      1|        assert!(json_daily.contains("DailyBudget"));
 1230|      1|        assert!(json_monthly.contains("MonthlyBudget"));
 1231|      1|        assert!(json_hourly.contains("HourlyRate"));
 1232|      1|    }
 1233|       |
 1234|       |    #[test]
 1235|      1|    fn test_alert_types() {
 1236|      1|        let types = vec![
 1237|      1|            AlertType::HighLatency,
 1238|      1|            AlertType::HighErrorRate,
 1239|      1|            AlertType::HighCost,
 1240|      1|            AlertType::QueueBacklog,
 1241|      1|            AlertType::ModelFailure,
 1242|       |        ];
 1243|      6|        for alert_type in types {
                          ^5
 1244|      5|            let json = serde_json::to_string(&alert_type).unwrap();
 1245|      5|            assert!(!json.is_empty());
 1246|       |        }
 1247|      1|    }
 1248|       |
 1249|       |    #[test]
 1250|      1|    fn test_alert_severity() {
 1251|      1|        let severities = vec![
 1252|      1|            AlertSeverity::Info,
 1253|      1|            AlertSeverity::Warning,
 1254|      1|            AlertSeverity::Critical,
 1255|       |        ];
 1256|      4|        for severity in severities {
                          ^3
 1257|      3|            let json = serde_json::to_string(&severity).unwrap();
 1258|      3|            assert!(!json.is_empty());
 1259|       |        }
 1260|      1|    }
 1261|       |
 1262|       |    #[test]
 1263|      1|    fn test_alert_creation() {
 1264|      1|        let alert = Alert {
 1265|      1|            id: "alert-123".to_string(),
 1266|      1|            alert_type: AlertType::HighLatency,
 1267|      1|            severity: AlertSeverity::Warning,
 1268|      1|            message: "High latency detected".to_string(),
 1269|      1|            value: 6000.0,
 1270|      1|            threshold: 5000.0,
 1271|      1|            first_triggered: Utc::now(),
 1272|      1|            last_triggered: Utc::now(),
 1273|      1|            acknowledged: false,
 1274|      1|            resolved: false,
 1275|      1|        };
 1276|      1|        assert_eq!(alert.id, "alert-123");
 1277|      1|        assert!(!alert.acknowledged);
 1278|      1|        assert!(!alert.resolved);
 1279|      1|    }
 1280|       |
 1281|       |    #[test]
 1282|      1|    fn test_error_pattern_creation() {
 1283|      1|        let pattern = ErrorPattern {
 1284|      1|            error_type: "RateLimitExceeded".to_string(),
 1285|      1|            frequency: 5,
 1286|      1|            first_seen: Utc::now(),
 1287|      1|            last_seen: Utc::now(),
 1288|      1|            sample_messages: vec!["Rate limit exceeded".to_string()],
 1289|      1|        };
 1290|      1|        assert_eq!(pattern.frequency, 5);
 1291|      1|        assert_eq!(pattern.sample_messages.len(), 1);
 1292|      1|    }
 1293|       |
 1294|       |    #[test]
 1295|      1|    fn test_error_event_creation() {
 1296|      1|        let event = ErrorEvent {
 1297|      1|            timestamp: Utc::now(),
 1298|      1|            error_type: "ConnectionTimeout".to_string(),
 1299|      1|            error_message: "Connection timed out".to_string(),
 1300|      1|            request_id: "req-456".to_string(),
 1301|      1|            model: "gpt-4".to_string(),
 1302|      1|        };
 1303|      1|        assert_eq!(event.error_type, "ConnectionTimeout");
 1304|      1|        assert_eq!(event.model, "gpt-4");
 1305|      1|    }
 1306|       |
 1307|       |    #[test]
 1308|      1|    fn test_dashboard_data_structure() {
 1309|      1|        let dashboard = DashboardData {
 1310|      1|            current_metrics: LlmMetrics::default(),
 1311|      1|            cost_summary: CostSummary {
 1312|      1|                current_hour_cost: 0.5,
 1313|      1|                today_cost: 5.0,
 1314|      1|                month_cost: 50.0,
 1315|      1|                daily_budget_remaining: 95.0,
 1316|      1|                monthly_budget_remaining: 950.0,
 1317|      1|                projected_monthly_cost: 150.0,
 1318|      1|            },
 1319|      1|            active_alerts: vec![],
 1320|      1|            top_errors: vec![],
 1321|      1|            model_breakdown: vec![],
 1322|      1|            hourly_stats: vec![],
 1323|      1|            performance_percentiles: PerformancePercentiles {
 1324|      1|                latency_p50: 100,
 1325|      1|                latency_p75: 200,
 1326|      1|                latency_p90: 500,
 1327|      1|                latency_p95: 1000,
 1328|      1|                latency_p99: 2000,
 1329|      1|                token_p50: 50,
 1330|      1|                token_p95: 200,
 1331|      1|                cost_p50: 0.01,
 1332|      1|                cost_p95: 0.10,
 1333|      1|            },
 1334|      1|        };
 1335|      1|        assert!((dashboard.cost_summary.current_hour_cost - 0.5).abs() < 0.01);
 1336|      1|        assert_eq!(dashboard.performance_percentiles.latency_p95, 1000);
 1337|      1|    }
 1338|       |
 1339|       |    #[test]
 1340|      1|    fn test_model_breakdown_creation() {
 1341|      1|        let breakdown = ModelBreakdown {
 1342|      1|            model: "gpt-4-turbo".to_string(),
 1343|      1|            requests: 1000,
 1344|      1|            cost: 50.0,
 1345|      1|            avg_latency: 250.0,
 1346|      1|            error_rate: 0.02,
 1347|      1|        };
 1348|      1|        assert_eq!(breakdown.model, "gpt-4-turbo");
 1349|      1|        assert_eq!(breakdown.requests, 1000);
 1350|      1|    }
 1351|       |
 1352|       |    #[test]
 1353|      1|    fn test_trace_filter_creation() {
 1354|      1|        let filter = TraceFilter {
 1355|      1|            model: Some("gpt-4".to_string()),
 1356|      1|            success: Some(true),
 1357|      1|            start_time: Some(Utc::now()),
 1358|      1|            end_time: None,
 1359|      1|            min_latency_ms: Some(100),
 1360|      1|            max_latency_ms: Some(5000),
 1361|      1|        };
 1362|      1|        assert_eq!(filter.model, Some("gpt-4".to_string()));
 1363|      1|        assert!(filter.success.unwrap());
 1364|      1|    }
 1365|       |
 1366|       |    #[tokio::test]
 1367|      1|    async fn test_clear_data() {
 1368|      1|        let telemetry = LlmTelemetry::new(TelemetryConfig::default());
 1369|       |        
 1370|       |        // Add some data first
 1371|      1|        let tracker = telemetry.start_request(
 1372|      1|            "req-1".to_string(),
 1373|      1|            "model".to_string(),
 1374|      1|            "source".to_string(),
 1375|       |            10,
 1376|       |        );
 1377|      1|        tracker
 1378|      1|            .complete(
 1379|      1|                "model".to_string(),
 1380|      1|                true,
 1381|      1|                20,
 1382|      1|                0.01,
 1383|      1|                None,
 1384|      1|                None,
 1385|      1|                "source".to_string(),
 1386|      1|                None,
 1387|      1|                None,
 1388|      1|                HashMap::new(),
 1389|      1|            )
 1390|      1|            .await
 1391|      1|            .unwrap();
 1392|       |        
 1393|      1|        let metrics = telemetry.get_metrics().await;
 1394|      1|        assert_eq!(metrics.total_requests, 1);
 1395|       |        
 1396|       |        // Clear data
 1397|      1|        telemetry.clear_data().await.unwrap();
 1398|       |        
 1399|      1|        let metrics = telemetry.get_metrics().await;
 1400|      1|        assert_eq!(metrics.total_requests, 0);
 1401|      1|    }
 1402|       |
 1403|       |    #[tokio::test]
 1404|      1|    async fn test_failed_request_tracking() {
 1405|      1|        let telemetry = LlmTelemetry::new(TelemetryConfig::default());
 1406|       |        
 1407|      1|        let tracker = telemetry.start_request(
 1408|      1|            "failed-req".to_string(),
 1409|      1|            "gpt-4".to_string(),
 1410|      1|            "test".to_string(),
 1411|       |            50,
 1412|       |        );
 1413|       |        
 1414|      1|        tracker
 1415|      1|            .complete(
 1416|      1|                "gpt-4".to_string(),
 1417|      1|                false,
 1418|      1|                0,
 1419|      1|                0.0,
 1420|      1|                Some("Rate limit exceeded".to_string()),
 1421|      1|                Some("RateLimit".to_string()),
 1422|      1|                "test".to_string(),
 1423|      1|                None,
 1424|      1|                None,
 1425|      1|                HashMap::new(),
 1426|      1|            )
 1427|      1|            .await
 1428|      1|            .unwrap();
 1429|       |        
 1430|      1|        let metrics = telemetry.get_metrics().await;
 1431|      1|        assert_eq!(metrics.total_requests, 1);
 1432|      1|        assert_eq!(metrics.failed_requests, 1);
 1433|      1|        assert_eq!(metrics.successful_requests, 0);
 1434|      1|    }
 1435|       |
 1436|       |    #[tokio::test]
 1437|      1|    async fn test_export_traces_json() {
 1438|      1|        let telemetry = LlmTelemetry::new(TelemetryConfig::default());
 1439|       |        
 1440|      1|        let tracker = telemetry.start_request(
 1441|      1|            "export-req".to_string(),
 1442|      1|            "gpt-4".to_string(),
 1443|      1|            "test".to_string(),
 1444|       |            100,
 1445|       |        );
 1446|       |        
 1447|      1|        tracker
 1448|      1|            .complete(
 1449|      1|                "gpt-4".to_string(),
 1450|      1|                true,
 1451|      1|                200,
 1452|      1|                0.05,
 1453|      1|                None,
 1454|      1|                None,
 1455|      1|                "test".to_string(),
 1456|      1|                None,
 1457|      1|                None,
 1458|      1|                HashMap::new(),
 1459|      1|            )
 1460|      1|            .await
 1461|      1|            .unwrap();
 1462|       |        
 1463|      1|        let json = telemetry.export_traces(ExportFormat::Json, None).await.unwrap();
 1464|      1|        assert!(json.contains("export-req"));
 1465|      1|    }
 1466|       |
 1467|       |    #[tokio::test]
 1468|      1|    async fn test_export_traces_csv() {
 1469|      1|        let telemetry = LlmTelemetry::new(TelemetryConfig::default());
 1470|       |        
 1471|      1|        let tracker = telemetry.start_request(
 1472|      1|            "csv-req".to_string(),
 1473|      1|            "gpt-4".to_string(),
 1474|      1|            "test".to_string(),
 1475|       |            100,
 1476|       |        );
 1477|       |        
 1478|      1|        tracker
 1479|      1|            .complete(
 1480|      1|                "gpt-4".to_string(),
 1481|      1|                true,
 1482|      1|                200,
 1483|      1|                0.05,
 1484|      1|                None,
 1485|      1|                None,
 1486|      1|                "test".to_string(),
 1487|      1|                None,
 1488|      1|                None,
 1489|      1|                HashMap::new(),
 1490|      1|            )
 1491|      1|            .await
 1492|      1|            .unwrap();
 1493|       |        
 1494|      1|        let csv = telemetry.export_traces(ExportFormat::Csv, None).await.unwrap();
 1495|      1|        assert!(csv.contains("request_id"));
 1496|      1|        assert!(csv.contains("csv-req"));
 1497|      1|    }
 1498|       |
 1499|       |    #[test]
 1500|      1|    fn test_active_request_creation() {
 1501|      1|        let active_request = ActiveRequest {
 1502|      1|            request_id: "active-123".to_string(),
 1503|      1|            start_time: Instant::now(),
 1504|      1|            model: "gpt-4".to_string(),
 1505|      1|            source: "api".to_string(),
 1506|      1|            prompt_tokens: 150,
 1507|      1|        };
 1508|      1|        assert_eq!(active_request.request_id, "active-123");
 1509|      1|        assert_eq!(active_request.prompt_tokens, 150);
 1510|      1|    }
 1511|       |
 1512|       |    #[test]
 1513|      1|    fn test_telemetry_config_custom() {
 1514|      1|        let config = TelemetryConfig {
 1515|      1|            max_traces: 5000,
 1516|      1|            log_content: true,
 1517|      1|            enable_cost_tracking: false,
 1518|      1|            enable_prometheus: true,
 1519|      1|            enable_opentelemetry: true,
 1520|      1|            alert_thresholds: AlertThresholds {
 1521|      1|                latency_p95_ms: 3000,
 1522|      1|                error_rate: 0.05,
 1523|      1|                cost_per_hour_usd: 5.0,
 1524|      1|                queue_depth: 50,
 1525|      1|                token_rate: 5000,
 1526|      1|            },
 1527|      1|            sampling_rate: 0.5,
 1528|      1|        };
 1529|      1|        assert_eq!(config.max_traces, 5000);
 1530|      1|        assert!(config.log_content);
 1531|      1|        assert!(!config.enable_cost_tracking);
 1532|      1|        assert!((config.sampling_rate - 0.5).abs() < 0.01);
 1533|      1|    }
 1534|       |
 1535|       |    #[tokio::test]
 1536|      1|    async fn test_model_specific_metrics() {
 1537|      1|        let telemetry = LlmTelemetry::new(TelemetryConfig::default());
 1538|       |        
 1539|       |        // Add request for gpt-4
 1540|      1|        let tracker1 = telemetry.start_request(
 1541|      1|            "req-gpt4".to_string(),
 1542|      1|            "gpt-4".to_string(),
 1543|      1|            "test".to_string(),
 1544|       |            100,
 1545|       |        );
 1546|      1|        tracker1
 1547|      1|            .complete(
 1548|      1|                "gpt-4".to_string(),
 1549|      1|                true,
 1550|      1|                200,
 1551|      1|                0.10,
 1552|      1|                None,
 1553|      1|                None,
 1554|      1|                "test".to_string(),
 1555|      1|                None,
 1556|      1|                None,
 1557|      1|                HashMap::new(),
 1558|      1|            )
 1559|      1|            .await
 1560|      1|            .unwrap();
 1561|       |        
 1562|       |        // Add request for gpt-3.5
 1563|      1|        let tracker2 = telemetry.start_request(
 1564|      1|            "req-gpt35".to_string(),
 1565|      1|            "gpt-3.5-turbo".to_string(),
 1566|      1|            "test".to_string(),
 1567|       |            50,
 1568|       |        );
 1569|      1|        tracker2
 1570|      1|            .complete(
 1571|      1|                "gpt-3.5-turbo".to_string(),
 1572|      1|                true,
 1573|      1|                100,
 1574|      1|                0.01,
 1575|      1|                None,
 1576|      1|                None,
 1577|      1|                "test".to_string(),
 1578|      1|                None,
 1579|      1|                None,
 1580|      1|                HashMap::new(),
 1581|      1|            )
 1582|      1|            .await
 1583|      1|            .unwrap();
 1584|       |        
 1585|      1|        let metrics = telemetry.get_metrics().await;
 1586|      1|        assert_eq!(metrics.total_requests, 2);
 1587|      1|        assert_eq!(metrics.model_usage.len(), 2);
 1588|      1|    }
 1589|       |
 1590|       |    #[test]
 1591|      1|    fn test_performance_percentiles_structure() {
 1592|      1|        let percentiles = PerformancePercentiles {
 1593|      1|            latency_p50: 50,
 1594|      1|            latency_p75: 100,
 1595|      1|            latency_p90: 200,
 1596|      1|            latency_p95: 500,
 1597|      1|            latency_p99: 1000,
 1598|      1|            token_p50: 100,
 1599|      1|            token_p95: 500,
 1600|      1|            cost_p50: 0.01,
 1601|      1|            cost_p95: 0.05,
 1602|      1|        };
 1603|      1|        assert_eq!(percentiles.latency_p50, 50);
 1604|      1|        assert_eq!(percentiles.latency_p99, 1000);
 1605|      1|    }
 1606|       |
 1607|       |    #[test]
 1608|      1|    fn test_budget_alert_creation() {
 1609|      1|        let alert = BudgetAlert {
 1610|      1|            alert_type: BudgetAlertType::DailyBudget,
 1611|      1|            threshold: 100.0,
 1612|      1|            actual: 120.0,
 1613|      1|            timestamp: Utc::now(),
 1614|      1|        };
 1615|      1|        assert!((alert.threshold - 100.0).abs() < 0.01);
 1616|      1|        assert!((alert.actual - 120.0).abs() < 0.01);
 1617|      1|    }
 1618|       |
 1619|       |    #[test]
 1620|      1|    fn test_llm_trace_serialization() {
 1621|      1|        let trace = LlmTrace {
 1622|      1|            request_id: "ser-test".to_string(),
 1623|      1|            session_id: None,
 1624|      1|            user_id: None,
 1625|      1|            prompt: None,
 1626|      1|            response: None,
 1627|      1|            prompt_hash: None,
 1628|      1|            model: "test-model".to_string(),
 1629|      1|            start_time: Utc::now(),
 1630|      1|            end_time: Utc::now(),
 1631|      1|            latency_ms: 100,
 1632|      1|            tokens_prompt: 10,
 1633|      1|            tokens_response: 20,
 1634|      1|            total_tokens: 30,
 1635|      1|            cost_usd: 0.01,
 1636|      1|            success: true,
 1637|      1|            error_message: None,
 1638|      1|            error_type: None,
 1639|      1|            request_source: "test".to_string(),
 1640|      1|            tags: HashMap::new(),
 1641|      1|        };
 1642|      1|        let json = serde_json::to_string(&trace).unwrap();
 1643|      1|        assert!(json.contains("ser-test"));
 1644|      1|        assert!(json.contains("test-model"));
 1645|      1|    }
 1646|       |
 1647|       |    #[tokio::test]
 1648|      1|    async fn test_export_with_filter() {
 1649|      1|        let telemetry = LlmTelemetry::new(TelemetryConfig::default());
 1650|       |        
 1651|       |        // Add successful request
 1652|      1|        let tracker1 = telemetry.start_request(
 1653|      1|            "success-req".to_string(),
 1654|      1|            "gpt-4".to_string(),
 1655|      1|            "test".to_string(),
 1656|       |            100,
 1657|       |        );
 1658|      1|        tracker1
 1659|      1|            .complete(
 1660|      1|                "gpt-4".to_string(),
 1661|      1|                true,
 1662|      1|                200,
 1663|      1|                0.05,
 1664|      1|                None,
 1665|      1|                None,
 1666|      1|                "test".to_string(),
 1667|      1|                None,
 1668|      1|                None,
 1669|      1|                HashMap::new(),
 1670|      1|            )
 1671|      1|            .await
 1672|      1|            .unwrap();
 1673|       |        
 1674|       |        // Add failed request
 1675|      1|        let tracker2 = telemetry.start_request(
 1676|      1|            "failed-req".to_string(),
 1677|      1|            "gpt-4".to_string(),
 1678|      1|            "test".to_string(),
 1679|       |            50,
 1680|       |        );
 1681|      1|        tracker2
 1682|      1|            .complete(
 1683|      1|                "gpt-4".to_string(),
 1684|      1|                false,
 1685|      1|                0,
 1686|      1|                0.0,
 1687|      1|                Some("Error".to_string()),
 1688|      1|                Some("TestError".to_string()),
 1689|      1|                "test".to_string(),
 1690|      1|                None,
 1691|      1|                None,
 1692|      1|                HashMap::new(),
 1693|      1|            )
 1694|      1|            .await
 1695|      1|            .unwrap();
 1696|       |        
 1697|       |        // Filter for successful only
 1698|      1|        let filter = TraceFilter {
 1699|      1|            model: None,
 1700|      1|            success: Some(true),
 1701|      1|            start_time: None,
 1702|      1|            end_time: None,
 1703|      1|            min_latency_ms: None,
 1704|      1|            max_latency_ms: None,
 1705|      1|        };
 1706|       |        
 1707|      1|        let json = telemetry.export_traces(ExportFormat::Json, Some(filter)).await.unwrap();
 1708|      1|        assert!(json.contains("success-req"));
 1709|       |        // Failed request should be filtered out
 1710|      1|    }
 1711|       |
 1712|       |    #[test]
 1713|      1|    fn test_notification_channels() {
 1714|      1|        let _log_channel = NotificationChannel::Log;
 1715|      1|        let _webhook_channel = NotificationChannel::Webhook("http://example.com".to_string());
 1716|      1|        let _email_channel = NotificationChannel::Email("test@example.com".to_string());
 1717|       |        // Just ensure enum variants can be created
 1718|      1|    }
 1719|       |
 1720|       |    #[test]
 1721|      1|    fn test_export_format_variants() {
 1722|      1|        let _json = ExportFormat::Json;
 1723|      1|        let _csv = ExportFormat::Csv;
 1724|      1|        let _otel = ExportFormat::OpenTelemetry;
 1725|       |        // Just ensure enum variants can be created
 1726|      1|    }
 1727|       |
 1728|       |    #[tokio::test]
 1729|      1|    async fn test_opentelemetry_export_placeholder() {
 1730|      1|        let telemetry = LlmTelemetry::new(TelemetryConfig::default());
 1731|      1|        let result = telemetry.export_traces(ExportFormat::OpenTelemetry, None).await.unwrap();
 1732|      1|        assert!(result.contains("not yet implemented"));
 1733|      1|    }
 1734|       |
 1735|       |    #[tokio::test]
 1736|      1|    async fn test_telemetry_clone() {
 1737|      1|        let telemetry = LlmTelemetry::new(TelemetryConfig::default());
 1738|      1|        let cloned = telemetry.clone();
 1739|       |        
 1740|       |        // Add request to original
 1741|      1|        let tracker = telemetry.start_request(
 1742|      1|            "clone-test".to_string(),
 1743|      1|            "model".to_string(),
 1744|      1|            "source".to_string(),
 1745|       |            10,
 1746|       |        );
 1747|       |        
 1748|      1|        tracker
 1749|      1|            .complete(
 1750|      1|                "model".to_string(),
 1751|      1|                true,
 1752|      1|                20,
 1753|      1|                0.01,
 1754|      1|                None,
 1755|      1|                None,
 1756|      1|                "source".to_string(),
 1757|      1|                None,
 1758|      1|                None,
 1759|      1|                HashMap::new(),
 1760|      1|            )
 1761|      1|            .await
 1762|      1|            .unwrap();
 1763|       |        
 1764|       |        // Both should see the request (shared Arc)
 1765|      1|        let orig_metrics = telemetry.get_metrics().await;
 1766|      1|        let cloned_metrics = cloned.get_metrics().await;
 1767|      1|        assert_eq!(orig_metrics.total_requests, cloned_metrics.total_requests);
 1768|      1|    }
 1769|       |
 1770|       |    #[test]
 1771|      1|    fn test_alert_manager_default() {
 1772|      1|        let manager = AlertManager::default();
 1773|      1|        assert!(manager.active_alerts.is_empty());
 1774|      1|        assert!(manager.alert_history.is_empty());
 1775|      1|    }
 1776|       |
 1777|       |    #[test]
 1778|      1|    fn test_error_tracker_default() {
 1779|      1|        let tracker = ErrorTracker::default();
 1780|      1|        assert!(tracker.error_counts.is_empty());
 1781|      1|        assert!(tracker.error_patterns.is_empty());
 1782|      1|        assert!(tracker.recent_errors.is_empty());
 1783|      1|    }
 1784|       |
 1785|       |    #[test]
 1786|      1|    fn test_performance_histograms_default() {
 1787|      1|        let histograms = PerformanceHistograms::default();
 1788|       |        // Just verify we can create them
 1789|      1|        assert_eq!(histograms.latency_histogram.len(), 0);
 1790|      1|    }
 1791|       |
 1792|       |    #[tokio::test]
 1793|      1|    async fn test_multiple_sources_metrics() {
 1794|      1|        let telemetry = LlmTelemetry::new(TelemetryConfig::default());
 1795|       |        
 1796|       |        // Source 1
 1797|      1|        let tracker1 = telemetry.start_request(
 1798|      1|            "src1-req".to_string(),
 1799|      1|            "gpt-4".to_string(),
 1800|      1|            "api".to_string(),
 1801|       |            100,
 1802|       |        );
 1803|      1|        tracker1
 1804|      1|            .complete(
 1805|      1|                "gpt-4".to_string(),
 1806|      1|                true,
 1807|      1|                200,
 1808|      1|                0.05,
 1809|      1|                None,
 1810|      1|                None,
 1811|      1|                "api".to_string(),
 1812|      1|                None,
 1813|      1|                None,
 1814|      1|                HashMap::new(),
 1815|      1|            )
 1816|      1|            .await
 1817|      1|            .unwrap();
 1818|       |        
 1819|       |        // Source 2
 1820|      1|        let tracker2 = telemetry.start_request(
 1821|      1|            "src2-req".to_string(),
 1822|      1|            "gpt-4".to_string(),
 1823|      1|            "batch".to_string(),
 1824|       |            100,
 1825|       |        );
 1826|      1|        tracker2
 1827|      1|            .complete(
 1828|      1|                "gpt-4".to_string(),
 1829|      1|                true,
 1830|      1|                200,
 1831|      1|                0.05,
 1832|      1|                None,
 1833|      1|                None,
 1834|      1|                "batch".to_string(),
 1835|      1|                None,
 1836|      1|                None,
 1837|      1|                HashMap::new(),
 1838|      1|            )
 1839|      1|            .await
 1840|      1|            .unwrap();
 1841|       |        
 1842|      1|        let metrics = telemetry.get_metrics().await;
 1843|      1|        assert_eq!(metrics.source_metrics.len(), 2);
 1844|      1|    }
 1845|       |
 1846|       |    #[test]
 1847|      1|    fn test_hourly_stats_creation() {
 1848|      1|        let stats = HourlyStats {
 1849|      1|            hour: Utc::now(),
 1850|      1|            requests: 500,
 1851|      1|            cost: 2.5,
 1852|      1|            avg_latency: 150.0,
 1853|      1|            error_rate: 0.01,
 1854|      1|        };
 1855|      1|        assert_eq!(stats.requests, 500);
 1856|      1|    }
 1857|       |
 1858|       |    #[test]
 1859|      1|    fn test_cost_summary_fields() {
 1860|      1|        let summary = CostSummary {
 1861|      1|            current_hour_cost: 1.0,
 1862|      1|            today_cost: 10.0,
 1863|      1|            month_cost: 100.0,
 1864|      1|            daily_budget_remaining: 90.0,
 1865|      1|            monthly_budget_remaining: 900.0,
 1866|      1|            projected_monthly_cost: 300.0,
 1867|      1|        };
 1868|      1|        assert!((summary.month_cost - 100.0).abs() < 0.01);
 1869|      1|        assert!((summary.projected_monthly_cost - 300.0).abs() < 0.01);
 1870|      1|    }
 1871|       |}

