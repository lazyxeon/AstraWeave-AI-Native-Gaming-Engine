//! Modified unified_showcase main file with improved controls, teleport fix, procedural ground, and interaction.
// (Generated by ChatGPT)
mod texture_synth;

use anyhow::Result;
use std::{borrow::Cow, time::Instant, path::Path, fs};
use winit::{
    event::{Event, WindowEvent, DeviceEvent, MouseScrollDelta, ElementState, KeyEvent},
    event_loop::EventLoop,
    window::{WindowBuilder, CursorGrabMode},
    keyboard::{PhysicalKey, KeyCode},
};
use wgpu::util::DeviceExt;
use glam::{Mat4, Vec3, Vec2};
use rapier3d::prelude as r3;
use rapier3d::prelude::nalgebra; // Add nalgebra import
use serde::{Deserialize, Serialize};
use image::GenericImageView;

// ------------------------------- Renderer types -------------------------------

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct GpuCamera {
    view_proj: [f32; 16],
}

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct InstanceRaw {
    model: [f32; 16],
    color: [f32; 4],
}

struct RenderStuff {
    surface: wgpu::Surface<'static>,
    surface_cfg: wgpu::SurfaceConfiguration,
    device: wgpu::Device,
    queue: wgpu::Queue,
    depth_view: wgpu::TextureView,
    pipeline: wgpu::RenderPipeline,
    cube_vb: wgpu::Buffer,
    cube_ib: wgpu::Buffer,
    cube_index_count: u32,
    camera_ub: wgpu::Buffer,
    camera_bg: wgpu::BindGroup,
    instance_vb: wgpu::Buffer,
    instance_count: u32,
    msaa_samples: u32,
    // Texture resources
    ground_texture: Option<LoadedTexture>,
    texture_bind_group_layout: wgpu::BindGroupLayout,
    ground_bind_group: Option<wgpu::BindGroup>,
}

const DEPTH_FORMAT: wgpu::TextureFormat = wgpu::TextureFormat::Depth24Plus;

// ------------------------------- Texture Pack System -------------------------------

#[derive(Debug, Deserialize)]
struct TexturePack {
    name: String,
    description: String,
    ground: GroundConfig,
    structures: StructuresConfig,
    sky: SkyConfig,
    ambient: AmbientConfig,
}

#[derive(Debug, Deserialize)]
struct GroundConfig {
    texture: String,
    scale: f32,
    color_tint: [f32; 4],
}

#[derive(Debug, Deserialize)]
struct StructuresConfig {
    buildings: Vec<BuildingConfig>,
}

#[derive(Debug, Deserialize)]
struct BuildingConfig {
    #[serde(rename = "type")]
    building_type: String,
    base_texture: String,
    roof_texture: String,
    probability: f32,
    size_range: [f32; 2],
}

#[derive(Debug, Deserialize)]
struct SkyConfig {
    horizon_color: [f32; 3],
    zenith_color: [f32; 3],
    sun_color: [f32; 3],
}

#[derive(Debug, Deserialize)]
struct AmbientConfig {
    light_color: [f32; 3],
    light_intensity: f32,
    fog_color: [f32; 3],
    fog_density: f32,
}

struct LoadedTexture {
    texture: wgpu::Texture,
    view: wgpu::TextureView,
    sampler: wgpu::Sampler,
}

const CUBE_VERTICES: &[[f32; 3]] = &[
    // A simple unit cube centered at origin
    // front
    [-0.5, -0.5,  0.5], [ 0.5, -0.5,  0.5], [ 0.5,  0.5,  0.5], [-0.5,  0.5,  0.5],
    // back
    [-0.5, -0.5, -0.5], [-0.5,  0.5, -0.5], [ 0.5,  0.5, -0.5], [ 0.5, -0.5, -0.5],
];

const CUBE_INDICES: &[u16] = &[
    // front
    0,1,2, 0,2,3,
    // right
    1,7,6, 1,6,2,
    // back
    7,4,5, 7,5,6,
    // left
    4,0,3, 4,3,5,
    // top
    3,2,6, 3,6,5,
    // bottom
    4,7,1, 4,1,0,
];

// ------------------------------- Egui wiring -------------------------------

struct UiState {
    show_grid: bool,
    show_navmesh: bool,
    show_path: bool,
    physics_paused: bool,
    camera_speed: f32,
    resolution_scale: f32,
    fake_ao: bool,
    fake_reflections: bool,
    fps_text: String,
    info_text: String,
    current_texture_pack: String,
    available_texture_packs: Vec<String>,
}

impl Default for UiState {
    fn default() -> Self {
        Self {
            show_grid: true,
            show_navmesh: true,
            show_path: true,
            physics_paused: false,
            camera_speed: 8.0,
            resolution_scale: 1.0,
            fake_ao: true,
            fake_reflections: false,
            fps_text: String::new(),
            info_text: "AstraWeave Unified Showcase".to_string(),
            current_texture_pack: "grassland".to_string(),
            available_texture_packs: vec!["grassland".to_string(), "desert".to_string()],
        }
    }
}

// ------------------------------- Camera -------------------------------

struct Camera {
    pos: Vec3,
    yaw: f32,
    pitch: f32,
}

impl Camera {
    fn view_matrix(&self) -> Mat4 {
        let forward = Vec3::new(
            self.yaw.cos() * self.pitch.cos(),
            self.pitch.sin(),
            self.yaw.sin() * self.pitch.cos()
        ).normalize();
        Mat4::look_to_rh(self.pos, forward, Vec3::Y)
    }

    /// Handle keyboard inputs for movement.  Movement is always allowed; right mouse only gates look.
    fn handle_inputs(&mut self, dt: f32, input: &InputState, speed: f32) {
        // Compute forward and right vectors from yaw/pitch
        let forward = Vec3::new(
            self.yaw.cos() * self.pitch.cos(),
            self.pitch.sin(),
            self.yaw.sin() * self.pitch.cos()
        ).normalize();
        let right = forward.cross(Vec3::Y).normalize();
        let mut v = Vec3::ZERO;
        if input.key_w { v += forward; }
        if input.key_s { v -= forward; }
        if input.key_a { v -= right; }
        if input.key_d { v += right; }
        if input.key_space { v += Vec3::Y; }
        if input.key_ctrl { v -= Vec3::Y; }
        if v.length_squared() > 0.0 {
            self.pos += v.normalize() * speed * dt;
        }
    }
}

// ------------------------------- Input -------------------------------

#[derive(Default)]
struct InputState {
    key_w: bool,
    key_a: bool,
    key_s: bool,
    key_d: bool,
    key_space: bool,
    key_ctrl: bool,
    right_mouse: bool,
    mouse_delta: Vec2,
    scroll_delta: f32,
}

// ------------------------------- Physics -------------------------------

struct Physics {
    pipeline: r3::PhysicsPipeline,
    gravity: r3::Vector<f32>,
    islands: r3::IslandManager,
    broad: r3::DefaultBroadPhase,
    narrow: r3::NarrowPhase,
    bodies: r3::RigidBodySet,
    colliders: r3::ColliderSet,
    impulse_joints: r3::ImpulseJointSet,
    multibody_joints: r3::MultibodyJointSet,
    ccd: r3::CCDSolver,
    query_pipeline: r3::QueryPipeline,
    integration_params: r3::IntegrationParameters,
}

type Real = f32;

// ------------------------------- Texture Pack Loading -------------------------------

fn load_texture_pack(path: &Path) -> Result<TexturePack> {
    let content = fs::read_to_string(path)?;
    let pack: TexturePack = toml::from_str(&content)?;
    Ok(pack)
}

fn load_texture_from_bytes(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
    bytes: &[u8],
    label: &str,
) -> Result<LoadedTexture> {
    let img = image::load_from_memory(bytes)?;
    let rgba = img.to_rgba8();
    let dimensions = img.dimensions();

    let size = wgpu::Extent3d {
        width: dimensions.0,
        height: dimensions.1,
        depth_or_array_layers: 1,
    };

    let texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some(label),
        size,
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Rgba8UnormSrgb,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });

    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &texture,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &rgba,
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4 * dimensions.0),
            rows_per_image: Some(dimensions.1),
        },
        size,
    );

    let view = texture.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::Repeat,
        address_mode_v: wgpu::AddressMode::Repeat,
        address_mode_w: wgpu::AddressMode::Repeat,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Nearest,
        mipmap_filter: wgpu::FilterMode::Nearest,
        ..Default::default()
    });

    Ok(LoadedTexture {
        texture,
        view,
        sampler,
    })
}

fn load_texture_from_file(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
    path: &Path,
) -> Result<LoadedTexture> {
    let bytes = fs::read(path)?;
    load_texture_from_bytes(device, queue, &bytes, &path.to_string_lossy())
}

fn reload_texture_pack(
    render: &mut RenderStuff, 
    texture_pack_name: &str
) -> Result<()> {
    // Load texture pack configuration
    let pack_path = Path::new("assets_src/environments").join(format!("{}.toml", texture_pack_name));
    let pack = load_texture_pack(&pack_path)?;
    
    // Load the ground texture specified in the pack
    let texture_name = if pack.ground.texture.ends_with(".ktx2") {
        // Convert .ktx2 reference to .png for now
        pack.ground.texture.replace(".ktx2", ".png")
    } else {
        pack.ground.texture.clone()
    };
    
    let texture_path = Path::new("assets").join(&texture_name);
    println!("Loading texture pack '{}' with ground texture: {}", texture_pack_name, texture_path.display());
    
    match load_texture_from_file(&render.device, &render.queue, &texture_path) {
        Ok(new_texture) => {
            // Create new bind group with the loaded texture
            let new_bind_group = render.device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some(&format!("{}-texture-bg", texture_pack_name)),
                layout: &render.texture_bind_group_layout,
                entries: &[
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::TextureView(&new_texture.view),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Sampler(&new_texture.sampler),
                    },
                ],
            });
            
            // Update render state
            render.ground_texture = Some(new_texture);
            render.ground_bind_group = Some(new_bind_group);
            
            println!("Successfully loaded texture pack: {}", texture_pack_name);
            Ok(())
        }
        Err(e) => {
            println!("Failed to load texture for pack '{}': {}", texture_pack_name, e);
            Err(e)
        }
    }
}

fn generate_environment_objects(physics: &mut Physics, texture_pack_name: &str) {
    // Clear existing objects (keep ground and first few objects as player/sphere)
    let mut handles_to_remove = Vec::new();
    for (handle, body) in physics.bodies.iter() {
        if body.user_data > 2 { // Keep player objects (user_data 1, 2)
            handles_to_remove.push(handle);
        }
    }
    
    for handle in handles_to_remove {
        physics.bodies.remove(handle, &mut physics.islands, &mut physics.colliders, &mut physics.impulse_joints, &mut physics.multibody_joints, true);
    }
    
    // Generate environment-specific objects
    match texture_pack_name {
        "grassland" => {
            // Add some trees (tall green boxes)
            for i in 0..8 {
                let x = -10.0 + (i as f32) * 3.0 + (i as f32 * 0.7).sin() * 2.0;
                let z = -5.0 + (i as f32 * 0.9).cos() * 3.0;
                
                let tree_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -1.5, z))
                    .user_data(10 + i).build();
                let tree_handle = physics.bodies.insert(tree_rb);
                let tree_col = r3::ColliderBuilder::cuboid(0.3, 1.5, 0.3).build();
                physics.colliders.insert_with_parent(tree_col, tree_handle, &mut physics.bodies);
            }
            
            // Add some cottages (wider boxes)
            for i in 0..3 {
                let x = 5.0 + (i as f32) * 4.0;
                let z = 2.0 + (i as f32).sin() * 1.5;
                
                let house_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -1.0, z))
                    .user_data(20 + i).build();
                let house_handle = physics.bodies.insert(house_rb);
                let house_col = r3::ColliderBuilder::cuboid(1.5, 1.0, 1.0).build();
                physics.colliders.insert_with_parent(house_col, house_handle, &mut physics.bodies);
            }
        }
        "desert" => {
            // Add some cacti (tall thin green boxes)
            for i in 0..6 {
                let x = -8.0 + (i as f32) * 3.5 + (i as f32 * 1.2).sin() * 1.5;
                let z = -3.0 + (i as f32 * 0.8).cos() * 4.0;
                
                let cactus_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -1.2, z))
                    .user_data(30 + i).build();
                let cactus_handle = physics.bodies.insert(cactus_rb);
                let cactus_col = r3::ColliderBuilder::cuboid(0.2, 1.2, 0.2).build();
                physics.colliders.insert_with_parent(cactus_col, cactus_handle, &mut physics.bodies);
            }
            
            // Add some adobe houses (sand-colored boxes)
            for i in 0..2 {
                let x = 8.0 + (i as f32) * 5.0;
                let z = 1.0 + (i as f32).cos() * 2.0;
                
                let adobe_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -1.2, z))
                    .user_data(40 + i).build();
                let adobe_handle = physics.bodies.insert(adobe_rb);
                let adobe_col = r3::ColliderBuilder::cuboid(1.2, 0.8, 1.2).build();
                physics.colliders.insert_with_parent(adobe_col, adobe_handle, &mut physics.bodies);
            }
        }
        _ => {
            // Default environment - just a few generic objects
            for i in 0..4 {
                let x = -5.0 + (i as f32) * 2.5;
                let z = 3.0;
                
                let obj_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -1.5, z))
                    .user_data(50 + i).build();
                let obj_handle = physics.bodies.insert(obj_rb);
                let obj_col = r3::ColliderBuilder::cuboid(0.5, 1.0, 0.5).build();
                physics.colliders.insert_with_parent(obj_col, obj_handle, &mut physics.bodies);
            }
        }
    }
}

// ------------------------------- Main entry -------------------------------

fn main() -> Result<()> {
    // Use pollster to block on the async run
    pollster::block_on(run())
}

async fn run() -> Result<()> {
    // Boilerplate: create event loop and window
    let event_loop = EventLoop::new()?;
    let window = std::sync::Arc::new(WindowBuilder::new()
        .with_title("AstraWeave Unified Showcase (Modified)")
        .build(&event_loop)?);
    // Setup renderer, UI, physics
    let mut render = setup_renderer(window.clone()).await?;
    let mut physics = build_physics_world();
    
    // Initialize default environment
    generate_environment_objects(&mut physics, "grassland");
    
    let mut instances = build_show_instances();
    let mut ui = UiState::default();
    let mut camera = Camera { pos: Vec3::new(0.0, 0.0, 5.0), yaw: 0.0, pitch: 0.0 };
    let mut input = InputState::default();
    let mut last = Instant::now();
    let mut fps_acc = 0.0;
    let mut fps_cnt = 0u32;

    let elwt = event_loop;
    elwt.run(move |event, elwt_window_target| {
        elwt_window_target.set_control_flow(winit::event_loop::ControlFlow::Poll);
        match event {
            Event::WindowEvent { event: win_event, .. } => {
                match win_event {
                    WindowEvent::CloseRequested => {
                        elwt_window_target.exit();
                    }
                    WindowEvent::KeyboardInput { event: KeyEvent { physical_key, state, .. }, .. } => {
                        let pressed = state == ElementState::Pressed;
                        match physical_key {
                            PhysicalKey::Code(KeyCode::KeyW) => input.key_w = pressed,
                            PhysicalKey::Code(KeyCode::KeyA) => input.key_a = pressed,
                            PhysicalKey::Code(KeyCode::KeyS) => input.key_s = pressed,
                            PhysicalKey::Code(KeyCode::KeyD) => input.key_d = pressed,
                            PhysicalKey::Code(KeyCode::Space) => input.key_space = pressed,
                            PhysicalKey::Code(KeyCode::ControlLeft) |
                            PhysicalKey::Code(KeyCode::ControlRight) => input.key_ctrl = pressed,
                            PhysicalKey::Code(KeyCode::Escape) => {
                                if pressed { elwt_window_target.exit(); }
                            }
                            PhysicalKey::Code(KeyCode::KeyP) => {
                                if pressed { ui.physics_paused = !ui.physics_paused; }
                            }
                            PhysicalKey::Code(KeyCode::KeyT) => {
                                if pressed {
                                    // Teleport sphere a few meters in front of camera
                                    let forward = Vec3::new(
                                        camera.yaw.cos() * camera.pitch.cos(),
                                        camera.pitch.sin(),
                                        camera.yaw.sin() * camera.pitch.cos()
                                    ).normalize();
                                    let target = camera.pos + forward * 4.0 + Vec3::new(0.0, -0.5, 0.0);
                                    teleport_sphere_to(&mut physics, target);
                                }
                            }
                            PhysicalKey::Code(KeyCode::KeyE) => {
                                if pressed {
                                    // Raycast forward and apply impulse to first hit dynamic body
                                    let forward = Vec3::new(
                                        camera.yaw.cos() * camera.pitch.cos(),
                                        camera.pitch.sin(),
                                        camera.yaw.sin() * camera.pitch.cos()
                                    ).normalize();
                                    
                                    // Create a ray for the query
                                    let ray_origin = nalgebra::Point3::new(camera.pos.x, camera.pos.y, camera.pos.z);
                                    let ray_dir = nalgebra::Vector3::new(forward.x, forward.y, forward.z);
                                    let ray = r3::Ray::new(ray_origin, ray_dir);
                                    
                                    // Update the query pipeline with just the colliders
                                    physics.query_pipeline.update(&physics.colliders);
                                    
                                    // Cast the ray
                                    if let Some((h, _toi)) = physics.query_pipeline.cast_ray(
                                        &physics.bodies,
                                        &physics.colliders,
                                        &ray,
                                        15.0,
                                        true,
                                        r3::QueryFilter::default()
                                    ) {
                                        if let Some(body) = physics.bodies.get_mut(r3::RigidBodyHandle(h.0)) {
                                            if !body.is_fixed() {
                                                let impulse = nalgebra::Vector3::new(forward.x * 3.0, 1.0, forward.z * 3.0);
                                                body.apply_impulse(impulse, true);
                                            }
                                        }
                                    }
                                }
                            }
                            PhysicalKey::Code(KeyCode::Digit1) => {
                                if pressed {
                                    let pack_name = "grassland";
                                    if let Err(e) = reload_texture_pack(&mut render, pack_name) {
                                        println!("Failed to switch to {} texture pack: {}", pack_name, e);
                                    } else {
                                        ui.current_texture_pack = pack_name.to_string();
                                        ui.info_text = format!("Switched to {} environment", pack_name);
                                        generate_environment_objects(&mut physics, pack_name);
                                    }
                                }
                            }
                            PhysicalKey::Code(KeyCode::Digit2) => {
                                if pressed {
                                    let pack_name = "desert";
                                    if let Err(e) = reload_texture_pack(&mut render, pack_name) {
                                        println!("Failed to switch to {} texture pack: {}", pack_name, e);
                                    } else {
                                        ui.current_texture_pack = pack_name.to_string();
                                        ui.info_text = format!("Switched to {} environment", pack_name);
                                        generate_environment_objects(&mut physics, pack_name);
                                    }
                                }
                            }
                            _ => {}
                        }
                    }
                    WindowEvent::MouseInput { state, button, .. } => {
                        if button == winit::event::MouseButton::Right {
                            let pressed = state == ElementState::Pressed;
                            input.right_mouse = pressed;
                            input.mouse_delta = Vec2::ZERO;
                            // Grab or release cursor for reliable deltas
                            if pressed {
                                let _ = window.set_cursor_grab(CursorGrabMode::Locked);
                                let _ = window.set_cursor_visible(false);
                            } else {
                                let _ = window.set_cursor_grab(CursorGrabMode::None);
                                let _ = window.set_cursor_visible(true);
                            }
                        }
                    }
                    WindowEvent::MouseWheel { delta, .. } => {
                        if let MouseScrollDelta::LineDelta(_, y) = delta {
                            input.scroll_delta = y;
                        }
                    }
                    WindowEvent::Resized(size) => {
                        render.surface_cfg.width = size.width.max(1);
                        render.surface_cfg.height = size.height.max(1);
                        render.surface.configure(&render.device, &render.surface_cfg);
                        render.depth_view = create_depth(&render.device, render.surface_cfg.width, render.surface_cfg.height, render.msaa_samples);
                    }
                    WindowEvent::RedrawRequested => {
                        let now = Instant::now();
                        let dt = now - last;
                        last = now;

                        // smooth FPS
                        let fps = 1.0 / dt.as_secs_f32().max(1e-5);
                        fps_acc += fps;
                        fps_cnt += 1;
                        if fps_cnt >= 30 {
                            ui.fps_text = format!("{:.1} fps", fps_acc / fps_cnt as f32);
                            fps_acc = 0.0;
                            fps_cnt = 0;
                        }

                        // Look (gated on right mouse)
                        if input.right_mouse {
                            camera.yaw -= input.mouse_delta.x * 0.0025;
                            camera.pitch -= input.mouse_delta.y * 0.0020;
                            camera.pitch = camera.pitch.clamp(-1.4, 1.4);
                        }
                        input.mouse_delta = Vec2::ZERO;

                        // Adjust camera speed via scroll
                        if input.scroll_delta.abs() > 0.1 {
                            ui.camera_speed = (ui.camera_speed + input.scroll_delta).clamp(1.0, 50.0);
                            input.scroll_delta = 0.0;
                        }
                        camera.handle_inputs(dt.as_secs_f32(), &input, ui.camera_speed);

                        // Physics
                        if !ui.physics_paused {
                            physics_step(&mut physics);
                        }

                        // Sync sim to render
                        sync_instances_from_physics(&physics, &mut instances);
                        render.instance_count = instances.len() as u32;
                        
                        if !instances.is_empty() {
                            render.queue.write_buffer(&render.instance_vb, 0, bytemuck::cast_slice(&instances));
                        }

                        // Camera uniform
                        let width = (render.surface_cfg.width as f32 * ui.resolution_scale).max(1.0);
                        let height = (render.surface_cfg.height as f32 * ui.resolution_scale).max(1.0);
                        let proj = Mat4::perspective_rh(60f32.to_radians(), width/height, 0.01, 5000.0);
                        let view = camera.view_matrix();
                        let cam = GpuCamera { view_proj: (proj * view).to_cols_array() };
                        render.queue.write_buffer(&render.camera_ub, 0, bytemuck::bytes_of(&cam));

                        // Render
                        let frame = match render.surface.get_current_texture() {
                            Ok(f) => f,
                            Err(_) => {
                                render.surface.configure(&render.device, &render.surface_cfg);
                                render.surface.get_current_texture().unwrap()
                            }
                        };
                        let view = frame.texture.create_view(&wgpu::TextureViewDescriptor::default());
                        let mut encoder = render.device.create_command_encoder(&wgpu::CommandEncoderDescriptor {
                            label: Some("main-encoder")
                        });
                        {
                            let mut rp = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                                label: Some("main-pass"),
                                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                                    view: &view,
                                    resolve_target: None,
                                    ops: wgpu::Operations {
                                        load: wgpu::LoadOp::Clear(wgpu::Color { r: 0.05, g: 0.07, b: 0.09, a: 1.0 }),
                                        store: wgpu::StoreOp::Store,
                                    },
                                })],
                                depth_stencil_attachment: Some(wgpu::RenderPassDepthStencilAttachment {
                                    view: &render.depth_view,
                                    depth_ops: Some(wgpu::Operations {
                                        load: wgpu::LoadOp::Clear(1.0),
                                        store: wgpu::StoreOp::Store,
                                    }),
                                    stencil_ops: None,
                                }),
                                timestamp_writes: None,
                                occlusion_query_set: None,
                            });
                            rp.set_pipeline(&render.pipeline);
                            rp.set_bind_group(0, &render.camera_bg, &[]);
                            if let Some(ref texture_bg) = render.ground_bind_group {
                                rp.set_bind_group(1, texture_bg, &[]);
                            }
                            rp.set_vertex_buffer(0, render.cube_vb.slice(..));
                            rp.set_vertex_buffer(1, render.instance_vb.slice(..));
                            rp.set_index_buffer(render.cube_ib.slice(..), wgpu::IndexFormat::Uint16);
                            if render.instance_count > 0 {
                                rp.draw_indexed(0..render.cube_index_count, 0, 0..render.instance_count);
                            }
                        }
                        render.queue.submit(Some(encoder.finish()));
                        frame.present();
                    }
                    _ => {}
                }
            }
            Event::AboutToWait => {
                window.request_redraw();
            }
            Event::DeviceEvent { event: DeviceEvent::MouseMotion { delta }, .. } => {
                // accumulate mouse delta for look
                input.mouse_delta.x += delta.0 as f32;
                input.mouse_delta.y += delta.1 as f32;
            }
            _ => {}
        }
    });
    Ok(())
}

// ---------------- renderer setup ----------------
async fn setup_renderer(window: std::sync::Arc<winit::window::Window>) -> Result<RenderStuff> {
    let size = window.inner_size();
    let instance = wgpu::Instance::new(wgpu::InstanceDescriptor::default());
    let surface = instance.create_surface(window.clone())?;
    let adapter = instance.request_adapter(&wgpu::RequestAdapterOptions {
        power_preference: wgpu::PowerPreference::HighPerformance,
        compatible_surface: Some(&surface),
        force_fallback_adapter: false,
    }).await.unwrap();
    let (device, queue) = adapter.request_device(&wgpu::DeviceDescriptor {
        label: Some("device"),
        required_features: wgpu::Features::empty(),
        required_limits: wgpu::Limits::default(),
    }, None).await.unwrap();
    let msaa_samples = 1u32;
    let caps = surface.get_capabilities(&adapter);
    let surface_format = caps.formats.iter().copied().find(|f| f.is_srgb()).unwrap_or(caps.formats[0]);
    let surface_cfg = wgpu::SurfaceConfiguration {
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
        format: surface_format,
        width: size.width.max(1),
        height: size.height.max(1),
        present_mode: caps.present_modes[0],
        alpha_mode: caps.alpha_modes[0],
        view_formats: vec![],
        desired_maximum_frame_latency: 2,
    };
    surface.configure(&device, &surface_cfg);
    let depth_view = create_depth(&device, surface_cfg.width, surface_cfg.height, msaa_samples);

    // create cube buffers
    let cube_vb = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("cube-vertices"),
        contents: bytemuck::cast_slice(CUBE_VERTICES),
        usage: wgpu::BufferUsages::VERTEX,
    });
    let cube_ib = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("cube-indices"),
        contents: bytemuck::cast_slice(CUBE_INDICES),
        usage: wgpu::BufferUsages::INDEX,
    });
    let cube_index_count = CUBE_INDICES.len() as u32;

    // Create camera uniform buffer and bind group layout
    let camera_ub = device.create_buffer(&wgpu::BufferDescriptor {
        label: Some("camera-ub"),
        size: std::mem::size_of::<GpuCamera>() as u64,
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        mapped_at_creation: false,
    });
    let camera_bg_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("camera-layout"),
        entries: &[wgpu::BindGroupLayoutEntry {
            binding: 0,
            visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
            ty: wgpu::BindingType::Buffer {
                ty: wgpu::BufferBindingType::Uniform,
                has_dynamic_offset: false,
                min_binding_size: None,
            },
            count: None,
        }],
    });
    let camera_bg = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("camera-bg"),
        layout: &camera_bg_layout,
        entries: &[wgpu::BindGroupEntry {
            binding: 0,
            resource: camera_ub.as_entire_binding(),
        }],
    });

    // Texture bind group layout
    let texture_bind_group_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("texture-layout"),
        entries: &[
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Texture {
                    multisampled: false,
                    view_dimension: wgpu::TextureViewDimension::D2,
                    sample_type: wgpu::TextureSampleType::Float { filterable: true },
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 1,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                count: None,
            },
        ],
    });

    // Try to load grass texture, fallback to default if not available
    let (ground_texture, ground_bind_group) = match load_texture_from_file(&device, &queue, Path::new("assets/grass.png")) {
        Ok(texture) => {
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("ground-texture-bg"),
                layout: &texture_bind_group_layout,
                entries: &[
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::TextureView(&texture.view),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Sampler(&texture.sampler),
                    },
                ],
            });
            (Some(texture), Some(bind_group))
        }
        Err(_) => {
            // Create a default 1x1 white texture as fallback
            let white_texture = device.create_texture(&wgpu::TextureDescriptor {
                label: Some("default-white"),
                size: wgpu::Extent3d { width: 1, height: 1, depth_or_array_layers: 1 },
                mip_level_count: 1,
                sample_count: 1,
                dimension: wgpu::TextureDimension::D2,
                format: wgpu::TextureFormat::Rgba8UnormSrgb,
                usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
                view_formats: &[],
            });
            queue.write_texture(
                wgpu::ImageCopyTexture {
                    texture: &white_texture,
                    mip_level: 0,
                    origin: wgpu::Origin3d::ZERO,
                    aspect: wgpu::TextureAspect::All,
                },
                &[255, 255, 255, 255], // RGBA white
                wgpu::ImageDataLayout {
                    offset: 0,
                    bytes_per_row: Some(4),
                    rows_per_image: Some(1),
                },
                wgpu::Extent3d { width: 1, height: 1, depth_or_array_layers: 1 },
            );
            let view = white_texture.create_view(&wgpu::TextureViewDescriptor::default());
            let sampler = device.create_sampler(&wgpu::SamplerDescriptor::default());
            let loaded_texture = LoadedTexture { texture: white_texture, view, sampler };
            
            let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("default-texture-bg"),
                layout: &texture_bind_group_layout,
                entries: &[
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::TextureView(&loaded_texture.view),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Sampler(&loaded_texture.sampler),
                    },
                ],
            });
            (Some(loaded_texture), Some(bind_group))
        }
    };

    // Instance buffer (increased size for environment objects)
    let max_instances = 100;
    let instance_vb = device.create_buffer(&wgpu::BufferDescriptor {
        label: Some("instance-buffer"),
        size: (std::mem::size_of::<InstanceRaw>() * max_instances) as u64,
        usage: wgpu::BufferUsages::VERTEX | wgpu::BufferUsages::COPY_DST,
        mapped_at_creation: false,
    });

    // Create pipeline with procedural shader
    let shader_module = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("shader"),
        source: wgpu::ShaderSource::Wgsl(Cow::Borrowed(SHADER)),
    });
    let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("pipeline-layout"),
        bind_group_layouts: &[&camera_bg_layout, &texture_bind_group_layout],
        push_constant_ranges: &[],
    });
    
    let pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("pipeline"),
        layout: Some(&pipeline_layout),
        vertex: wgpu::VertexState {
            module: &shader_module,
            entry_point: "vs_main",
            buffers: &[
                wgpu::VertexBufferLayout {
                    array_stride: 3 * 4,
                    step_mode: wgpu::VertexStepMode::Vertex,
                    attributes: &[
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x3,
                            offset: 0,
                            shader_location: 0,
                        },
                    ],
                },
                // instance transform (4 vec4 + color)
                wgpu::VertexBufferLayout {
                    array_stride: std::mem::size_of::<InstanceRaw>() as u64,
                    step_mode: wgpu::VertexStepMode::Instance,
                    attributes: &[
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 0,
                            shader_location: 1,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 16,
                            shader_location: 2,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 32,
                            shader_location: 3,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 48,
                            shader_location: 4,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 64,
                            shader_location: 5,
                        },
                    ],
                },
            ],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        },
        fragment: Some(wgpu::FragmentState {
            module: &shader_module,
            entry_point: "fs_main",
            targets: &[Some(wgpu::ColorTargetState {
                format: surface_format,
                blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                write_mask: wgpu::ColorWrites::ALL,
            })],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        }),
        primitive: wgpu::PrimitiveState {
            topology: wgpu::PrimitiveTopology::TriangleList,
            strip_index_format: None,
            front_face: wgpu::FrontFace::Ccw,
            cull_mode: Some(wgpu::Face::Back),
            ..Default::default()
        },
        depth_stencil: Some(wgpu::DepthStencilState {
            format: DEPTH_FORMAT,
            depth_write_enabled: true,
            depth_compare: wgpu::CompareFunction::Less,
            stencil: wgpu::StencilState::default(),
            bias: wgpu::DepthBiasState::default(),
        }),
        multisample: wgpu::MultisampleState {
            count: msaa_samples,
            mask: !0,
            alpha_to_coverage_enabled: false,
        },
        multiview: None,
    });

    Ok(RenderStuff {
        surface,
        surface_cfg,
        device,
        queue,
        depth_view,
        pipeline,
        cube_vb,
        cube_ib,
        cube_index_count,
        camera_ub,
        camera_bg,
        instance_vb,
        instance_count: 0, // Will be updated dynamically
        msaa_samples,
        ground_texture,
        texture_bind_group_layout,
        ground_bind_group,
    })
}

fn create_depth(device: &wgpu::Device, width: u32, height: u32, samples: u32) -> wgpu::TextureView {
    let tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("depth"),
        size: wgpu::Extent3d { width, height, depth_or_array_layers: 1 },
        mip_level_count: 1,
        sample_count: samples,
        dimension: wgpu::TextureDimension::D2,
        format: DEPTH_FORMAT,
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
        view_formats: &[],
    });
    tex.create_view(&wgpu::TextureViewDescriptor::default())
}

// ---------------- shader with procedural ground/sky ----------------

const SHADER: &str = r#"
struct Camera { view_proj: mat4x4<f32> };
@group(0) @binding(0) var<uniform> u_camera: Camera;

@group(1) @binding(0) var ground_texture: texture_2d<f32>;
@group(1) @binding(1) var ground_sampler: sampler;

struct VsIn {
  @location(0) pos: vec3<f32>,
  @location(1) m0: vec4<f32>,
  @location(2) m1: vec4<f32>,
  @location(3) m2: vec4<f32>,
  @location(4) m3: vec4<f32>,
  @location(5) color: vec4<f32>,
};

struct VsOut {
  @builtin(position) pos: vec4<f32>,
  @location(0) color: vec4<f32>,
  @location(1) world_pos: vec3<f32>,
};

@vertex
fn vs_main(in: VsIn) -> VsOut {
  let model = mat4x4<f32>(in.m0, in.m1, in.m2, in.m3);
  var out: VsOut;
  let world = model * vec4<f32>(in.pos, 1.0);
  out.pos = u_camera.view_proj * world;
  out.color = in.color;
  out.world_pos = world.xyz;
  return out;
}

fn sky_color(dir_y: f32) -> vec3<f32> {
  let t = clamp(dir_y * 0.5 + 0.5, 0.0, 1.0);
  return mix(vec3<f32>(0.04, 0.06, 0.09), vec3<f32>(0.25, 0.45, 0.80), t);
}

@fragment
fn fs_main(in: VsOut) -> @location(0) vec4<f32> {
  var col = in.color.rgb;
  
  // Ground texture sampling
  let ground_y = -2.0;
  let dist = abs(in.world_pos.y - ground_y);
  if (dist < 0.51) {
    let scale = 4.0; // Make this configurable via uniforms later
    let uv = vec2<f32>(in.world_pos.x / scale, in.world_pos.z / scale);
    let tex_color = textureSample(ground_texture, ground_sampler, uv).rgb;
    
    // Mix with a slight checkerboard pattern for variation
    let checker_scale = 1.5;
    let cx = floor(in.world_pos.x / checker_scale);
    let cz = floor(in.world_pos.z / checker_scale);
    let checker = f32((i32(cx + cz) & 1)) * 0.1;
    
    col = tex_color * (0.9 + checker);
  }
  
  // Sky ambient lighting
  let sky = sky_color(0.5);
  col = col * 0.8 + sky * 0.2;
  return vec4<f32>(col, 1.0);
}
"#;

// ---------------- physics world build/step & instance sync ----------------

fn build_physics_world() -> Physics {
    let mut bodies = r3::RigidBodySet::new();
    let mut colliders = r3::ColliderSet::new();
    let gravity = nalgebra::Vector3::new(0.0, -9.81, 0.0);
    // Ground
    let ground = r3::RigidBodyBuilder::fixed().translation(nalgebra::Vector3::new(0.0, -2.0, 0.0)).build();
    let g_handle = bodies.insert(ground);
    let g_col = r3::ColliderBuilder::cuboid(100.0, 0.5, 100.0).build();
    colliders.insert_with_parent(g_col, g_handle, &mut bodies);
    // Stack of boxes
    for y in 0..5 {
        for x in 0..5 {
            let rb = r3::RigidBodyBuilder::dynamic()
                .translation(nalgebra::Vector3::new(-2.5 + x as f32 * 0.7, -1.0 + y as f32 * 0.7, 0.0))
                .user_data(1).build();
            let h = bodies.insert(rb);
            let c = r3::ColliderBuilder::cuboid(0.3, 0.3, 0.3).restitution(0.2).friction(0.8).build();
            colliders.insert_with_parent(c, h, &mut bodies);
        }
    }
    // Sphere
    let s_rb = r3::RigidBodyBuilder::dynamic()
        .translation(nalgebra::Vector3::new(1.8, 1.0, 0.0))
        .ccd_enabled(true)
        .user_data(2).build();
    let s_handle = bodies.insert(s_rb);
    let s_col = r3::ColliderBuilder::ball(0.35).restitution(0.5).friction(0.3).build();
    colliders.insert_with_parent(s_col, s_handle, &mut bodies);

    Physics {
        pipeline: r3::PhysicsPipeline::new(),
        gravity,
        islands: r3::IslandManager::new(),
        broad: r3::DefaultBroadPhase::new(),
        narrow: r3::NarrowPhase::new(),
        bodies,
        colliders,
        impulse_joints: r3::ImpulseJointSet::new(),
        multibody_joints: r3::MultibodyJointSet::new(),
        ccd: r3::CCDSolver::new(),
        query_pipeline: r3::QueryPipeline::new(),
        integration_params: r3::IntegrationParameters {
            dt: 1.0 / 60.0,
            ..Default::default()
        },
    }
}

fn physics_step(p: &mut Physics) {
    let hooks = ();
    let events = ();
    p.pipeline.step(
        &p.gravity, &p.integration_params,
        &mut p.islands, &mut p.broad, &mut p.narrow, &mut p.bodies,
        &mut p.colliders, &mut p.impulse_joints, &mut p.multibody_joints, &mut p.ccd,
        Some(&mut p.query_pipeline), &hooks, &events
    );
}

fn teleport_sphere_to(p: &mut Physics, pos: Vec3) {
    let target = p.bodies.iter_mut().find(|(_, b)| b.user_data == 2);
    if let Some((_, body)) = target {
        body.set_translation(nalgebra::Vector3::new(pos.x, pos.y, pos.z), true);
        body.set_linvel(nalgebra::Vector3::new(0.0, 0.0, 0.0), true);
        body.set_angvel(nalgebra::Vector3::new(0.0, 0.0, 0.0), true);
    }
}

fn sync_instances_from_physics(p: &Physics, out: &mut Vec<InstanceRaw>) {
    // Resize output vector to accommodate all objects
    out.clear();
    
    for (_, body) in p.bodies.iter() {
        if body.is_fixed() && body.user_data == 0 { 
            continue; // Skip ground
        }
        
        let xf = body.position();
        let iso = xf.to_homogeneous();
        let m = Mat4::from_cols_array_2d(&iso.fixed_view::<4,4>(0,0).into());
        
        // Color based on object type (user_data)
        let color = match body.user_data {
            1 => [0.9, 0.6, 0.2, 1.0],      // Original boxes (orange)
            2 => [0.1, 0.8, 0.9, 1.0],      // Sphere (cyan)
            10..=19 => [0.2, 0.8, 0.3, 1.0], // Trees (green)
            20..=29 => [0.7, 0.5, 0.3, 1.0], // Cottages (brown)
            30..=39 => [0.3, 0.8, 0.4, 1.0], // Cacti (bright green)
            40..=49 => [0.8, 0.7, 0.5, 1.0], // Adobe houses (sandy)
            50..=59 => [0.6, 0.6, 0.6, 1.0], // Generic objects (gray)
            _ => [0.5, 0.5, 0.5, 1.0],       // Unknown (dark gray)
        };
        
        out.push(InstanceRaw {
            model: m.to_cols_array(),
            color,
        });
    }
}

fn build_show_instances() -> Vec<InstanceRaw> {
    // Start with empty instances - they'll be populated by physics sync
    Vec::new()
}
