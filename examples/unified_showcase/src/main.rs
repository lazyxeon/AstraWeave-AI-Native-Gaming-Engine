#![allow(dead_code)]
//! Modified unified_showcase main file with improved controls, teleport fix, procedural ground, and interaction.
// (Generated by ChatGPT)
mod material;
mod mesh_helpers;
mod texture_manager;
mod material_integration;
mod texture_synth;
mod texture_utils;

use anyhow::{Context, Result};
use astraweave_render::camera::{Camera as RenderCamera, CameraController};
use astraweave_render::{IblManager, IblQuality, MeshRegistry};
use astraweave_render::MeshKey as RenderMeshKey;
use glam::{Mat3, Mat4, Vec2, Vec3};
use image::imageops;
use image::{GenericImageView, RgbaImage};
use noise::{NoiseFn, Perlin};
use rapier3d::prelude as r3;
use rapier3d::prelude::nalgebra; // Add nalgebra import
use serde::Deserialize;
use std::collections::HashMap;
use std::f32::consts::{PI, TAU};
use std::path::PathBuf;
use std::{borrow::Cow, fs, path::Path, time::Instant};
use wgpu::util::DeviceExt;
use winit::{
    event::{DeviceEvent, ElementState, Event, KeyEvent, MouseScrollDelta, WindowEvent},
    event_loop::EventLoop,
    keyboard::{KeyCode, PhysicalKey},
    window::{CursorGrabMode, WindowBuilder},
};

use material::{MaterialGpu, MaterialLibrary};
use texture_manager::TextureManager;
use material_integration::MaterialIntegrator;
use texture_utils::{find_normal_map, resolve_texture_path};

// Import the proper camera system from astraweave-render
fn generate_primitive_crate_mesh() -> MeshData {
    let mut builder = MeshBuilder::new();
    add_box(
        &mut builder,
        Vec3::splat(-0.5),
        Vec3::splat(0.5),
        Vec2::splat(1.0),
    );
    builder.build(false)
}

fn generate_skybox_mesh() -> MeshData {
    mesh_from_vertices(mesh_helpers::create_skybox_vertices())
}

fn generate_tree_mesh(seed: u32) -> MeshData {
    let mut rng = SimpleRng::new(seed as u64 + 0x74656533);
    let segments = 14 + rng.range_u32(0, 5) as usize;
    let trunk_sections = 4 + rng.range_u32(0, 3) as usize;
    let total_height = rng.range_f32(2.6, 3.8);
    let mut builder = MeshBuilder::new();

    let mut section_start = Vec3::new(0.0, -0.5, 0.0);
    let mut radius_start = rng.range_f32(0.16, 0.22);
    let mut branch_origins = Vec::with_capacity(trunk_sections);

    for section in 0..trunk_sections {
        let section_height = total_height / trunk_sections as f32 * rng.range_f32(0.85, 1.15);
        let sway = Vec3::new(
            rng.range_f32(-0.2, 0.2),
            section_height,
            rng.range_f32(-0.2, 0.2),
        );
        let section_end = section_start + sway;
        let radius_end = radius_start * rng.range_f32(0.6, 0.85);
            add_oriented_capped_cylinder(
            &mut builder,
            section_start,
            section_end,
            radius_start,
            radius_end,
            segments,
            Vec2::new(3.0, 1.5),
            section == 0,
            section == trunk_sections - 1,
        );
        branch_origins.push((section_start + section_end) * 0.5);
        section_start = section_end;
        radius_start = radius_end;
    }

    let canopy_center = section_start + Vec3::new(0.0, rng.range_f32(0.3, 0.6), 0.0);
    let canopy_radius = total_height * rng.range_f32(0.33, 0.45);
    add_latlong_sphere(
        &mut builder,
        canopy_center,
        canopy_radius,
        8,
        12,
        Vec2::splat(1.2),
    );

    let branch_count = 7 + rng.range_u32(0, 6) as usize;
    for _ in 0..branch_count {
        let origin_index = rng.range_u32(0, branch_origins.len() as u32) as usize;
        let origin = branch_origins[origin_index];
        let direction = Vec3::new(
            rng.range_f32(-0.9, 0.9),
            rng.range_f32(0.25, 0.85),
            rng.range_f32(-0.9, 0.9),
        )
        .normalize_or_zero();
        if direction.length_squared() < 1e-4 {
            continue;
        }
        let length = rng.range_f32(0.9, 1.6);
        let end = origin + direction * length;
        let branch_base = rng.range_f32(0.05, 0.09);
        let branch_tip = branch_base * rng.range_f32(0.35, 0.55);
        add_oriented_capped_cylinder(
            &mut builder,
            origin,
            end,
            branch_base,
            branch_tip,
            segments / 2,
            Vec2::new(2.5, 1.0),
            false,
            true,
        );

        let leaf_radius = rng.range_f32(0.35, 0.55);
        add_latlong_sphere(
            &mut builder,
            end + direction * 0.15,
            leaf_radius,
            5,
            10,
            Vec2::splat(1.0),
        );

        for _ in 0..2 {
            let offset = Vec3::new(
                rng.range_f32(-leaf_radius * 0.4, leaf_radius * 0.4),
                rng.range_f32(-leaf_radius * 0.2, leaf_radius * 0.35),
                rng.range_f32(-leaf_radius * 0.4, leaf_radius * 0.4),
            );
            add_billboard_cross(
                &mut builder,
                end + offset,
                Vec2::new(leaf_radius * 1.6, leaf_radius * 2.2),
                rng.range_f32(0.0, TAU),
            );
        }
    }

    builder.build(true)
}

fn generate_house_mesh(seed: u32) -> MeshData {
    let mut rng = SimpleRng::new(seed as u64 + 0x484f5553);
    let floor_count = if rng.range_u32(0, 100) < 55 { 2 } else { 1 };
    let base_width = rng.range_f32(1.6, 2.6);
    let base_depth = rng.range_f32(1.4, 2.2);
    let base_y = -0.5;
    let floor_height = rng.range_f32(1.1, 1.35);

    let mut builder = MeshBuilder::new();

    // stone foundation / porch
    add_box(
        &mut builder,
        Vec3::new(-base_width - 0.2, base_y - 0.2, -base_depth - 0.2),
        Vec3::new(base_width + 0.2, base_y, base_depth + 0.2),
        Vec2::new(base_width, base_depth),
    );

    let mut current_min_y = base_y;
    for floor in 0..floor_count {
        let inset = floor as f32 * 0.08;
        let min = Vec3::new(-base_width + inset, current_min_y, -base_depth + inset);
        let max = Vec3::new(base_width - inset, current_min_y + floor_height, base_depth - inset);
        add_box(
            &mut builder,
            min,
            max,
            Vec2::new((base_width - inset) * 1.4, floor_height),
        );

        let window_half = Vec2::new(rng.range_f32(0.28, 0.35), rng.range_f32(0.28, 0.34));
        let window_depth = 0.06;
        let rows = if floor_count > 1 { 2 } else { 1 };
        for row in 0..rows {
            let y_center = current_min_y + 0.45 + row as f32 * 0.6;
            let spacing = (base_width - inset) * 0.55;
            for &side in &[-1.0f32, 1.0] {
                let x_center = side * spacing * 0.5;
                // front windows
                add_box(
                    &mut builder,
                    Vec3::new(
                        x_center - window_half.x,
                        y_center - window_half.y,
                        max.z - 0.02,
                    ),
                    Vec3::new(
                        x_center + window_half.x,
                        y_center + window_half.y,
                        max.z + window_depth,
                    ),
                    Vec2::splat(0.6),
                );
                // back windows
                add_box(
                    &mut builder,
                    Vec3::new(
                        x_center - window_half.x,
                        y_center - window_half.y,
                        min.z - window_depth,
                    ),
                    Vec3::new(
                        x_center + window_half.x,
                        y_center + window_half.y,
                        min.z + 0.02,
                    ),
                    Vec2::splat(0.6),
                );
            }
        }

        let side_rows = 1 + (floor % 2);
        let side_spacing = (base_depth - inset) * 0.45;
        for row in 0..side_rows {
            let y_center = current_min_y + 0.5 + row as f32 * 0.55;
            for &side in &[-1.0f32, 1.0] {
                let z_center = side * side_spacing * 0.5;
                add_box(
                    &mut builder,
                    Vec3::new(
                        min.x - window_depth,
                        y_center - window_half.y * 0.85,
                        z_center - window_half.x,
                    ),
                    Vec3::new(
                        min.x + 0.02,
                        y_center + window_half.y * 0.85,
                        z_center + window_half.x,
                    ),
                    Vec2::splat(0.55),
                );
                add_box(
                    &mut builder,
                    Vec3::new(
                        max.x - 0.02,
                        y_center - window_half.y * 0.85,
                        z_center - window_half.x,
                    ),
                    Vec3::new(
                        max.x + window_depth,
                        y_center + window_half.y * 0.85,
                        z_center + window_half.x,
                    ),
                    Vec2::splat(0.55),
                );
            }
        }

        current_min_y += floor_height;
    }

    // door and porch
    let door_width = rng.range_f32(0.55, 0.75);
    let door_height = rng.range_f32(1.15, 1.35);
    add_box(
        &mut builder,
        Vec3::new(-door_width * 0.5, base_y, base_depth + 0.02),
        Vec3::new(door_width * 0.5, base_y + door_height, base_depth + 0.18),
        Vec2::new(door_width, door_height),
    );
    add_box(
        &mut builder,
        Vec3::new(-door_width * 0.65, base_y - 0.15, base_depth - 0.6),
        Vec3::new(door_width * 0.65, base_y, base_depth + 0.2),
        Vec2::new(door_width * 0.8, 0.4),
    );

    let roof_style = rng.range_u32(0, 3);
    let roof_base_y = base_y + floor_count as f32 * floor_height;
    let eave = 0.35;

    let chimney_base_y = match roof_style {
        0 => {
            let ridge_height = rng.range_f32(0.7, 1.0);
            let roof_peak_y = roof_base_y + ridge_height;
            let front_left = Vec3::new(-base_width - eave, roof_base_y, base_depth + eave);
            let front_right = Vec3::new(base_width + eave, roof_base_y, base_depth + eave);
            let back_left = Vec3::new(-base_width - eave, roof_base_y, -base_depth - eave);
            let back_right = Vec3::new(base_width + eave, roof_base_y, -base_depth - eave);
            let ridge_front =
                Vec3::new(rng.range_f32(-0.15, 0.15), roof_peak_y, base_depth + eave * 0.1);
            let ridge_back =
                Vec3::new(rng.range_f32(-0.15, 0.15), roof_peak_y, -base_depth - eave * 0.1);
            let roof_uv = [
                Vec2::new(0.0, 1.0),
                Vec2::new(1.0, 1.0),
                Vec2::new(1.0, 0.0),
                Vec2::new(0.0, 0.0),
            ];
            add_face(&mut builder, [back_left, front_left, ridge_front, ridge_back], roof_uv);
            add_face(&mut builder, [front_right, back_right, ridge_back, ridge_front], roof_uv);
            add_face(&mut builder, [front_left, back_left, back_right, front_right], roof_uv);

            if rng.range_u32(0, 100) < 40 {
                let dormer_width = base_width * rng.range_f32(0.25, 0.35);
                let dormer_depth = base_depth * rng.range_f32(0.2, 0.3);
                let dormer_base_y = ridge_front.y - rng.range_f32(0.5, 0.65);
                add_box(
                    &mut builder,
                    Vec3::new(
                        -dormer_width * 0.5,
                        dormer_base_y,
                        base_depth - dormer_depth,
                    ),
                    Vec3::new(
                        dormer_width * 0.5,
                        dormer_base_y + rng.range_f32(0.6, 0.8),
                        base_depth + 0.05,
                    ),
                    Vec2::new(dormer_width, dormer_depth),
                );
            }
            roof_base_y + 0.12
        }
        1 => {
            let ridge_height = rng.range_f32(0.5, 0.8);
            let roof_peak_y = roof_base_y + ridge_height;
            let corners = [
                Vec3::new(-base_width - eave, roof_base_y, base_depth + eave),
                Vec3::new(base_width + eave, roof_base_y, base_depth + eave),
                Vec3::new(base_width + eave, roof_base_y, -base_depth - eave),
                Vec3::new(-base_width - eave, roof_base_y, -base_depth - eave),
            ];
            let apex = Vec3::new(0.0, roof_peak_y, 0.0);
            let roof_uv = [
                Vec2::new(0.0, 1.0),
                Vec2::new(1.0, 1.0),
                Vec2::new(0.5, 0.0),
                Vec2::new(0.0, 0.0),
            ];
            for i in 0..4 {
                let next = (i + 1) % 4;
                add_triangle_face(
                    &mut builder,
                    [corners[i], corners[next], apex],
                    [roof_uv[0], roof_uv[1], roof_uv[2]],
                );
            }
            add_face(&mut builder, corners, roof_uv);
            roof_base_y + 0.12
        }
        _ => {
            let parapet_height = rng.range_f32(0.25, 0.35);
            let roof_peak_y = roof_base_y + parapet_height + 0.1;
            add_box(
                &mut builder,
                Vec3::new(-base_width - 0.18, roof_base_y, -base_depth - 0.18),
                Vec3::new(base_width + 0.18, roof_base_y + parapet_height, base_depth + 0.18),
                Vec2::new(base_width, base_depth),
            );
            add_box(
                &mut builder,
                Vec3::new(-base_width + 0.25, roof_peak_y - 0.05, -base_depth + 0.25),
                Vec3::new(base_width - 0.25, roof_peak_y, base_depth - 0.25),
                Vec2::new(base_width * 0.8, base_depth * 0.8),
            );
            if rng.range_u32(0, 100) < 60 {
                add_box(
                    &mut builder,
                    Vec3::new(-0.35, roof_peak_y, -0.35),
                    Vec3::new(0.35, roof_peak_y + 0.3, 0.35),
                    Vec2::splat(0.7),
                );
            }
            roof_base_y + parapet_height
        }
    };

    // chimney
    let chimney_height = rng.range_f32(0.55, 0.9);
    let chimney_base = Vec3::new(
        rng.range_f32(-base_width * 0.4, base_width * 0.3),
        chimney_base_y,
        rng.range_f32(-base_depth * 0.3, base_depth * 0.4),
    );
    add_box(
        &mut builder,
        Vec3::new(chimney_base.x - 0.15, chimney_base.y, chimney_base.z - 0.15),
        Vec3::new(
            chimney_base.x + 0.15,
            chimney_base.y + chimney_height,
            chimney_base.z + 0.15,
        ),
        Vec2::splat(0.35),
    );

    builder.build(false)
}

fn generate_tree_impostor_mesh() -> MeshData {
    let mut builder = MeshBuilder::new();
    add_billboard_cross(
        &mut builder,
        Vec3::new(0.0, 1.8, 0.0),
        Vec2::new(2.8, 4.2),
        0.0,
    );
    add_billboard_cross(
        &mut builder,
        Vec3::new(0.0, 1.8, 0.0),
        Vec2::new(2.8, 4.2),
        PI * 0.25,
    );
    add_box(
        &mut builder,
        Vec3::new(-0.2, -0.5, -0.2),
        Vec3::new(0.2, 0.8, 0.2),
        Vec2::splat(0.5),
    );
    builder.build(false)
}

fn generate_house_impostor_mesh() -> MeshData {
    let mut builder = MeshBuilder::new();
    add_box(
        &mut builder,
        Vec3::new(-1.2, -0.5, -1.0),
        Vec3::new(1.2, 0.6, 1.0),
        Vec2::new(1.5, 1.0),
    );
    add_box(
        &mut builder,
        Vec3::new(-1.0, 0.6, -0.8),
        Vec3::new(1.0, 1.2, 0.8),
        Vec2::new(1.2, 0.8),
    );
    add_billboard_cross(
        &mut builder,
        Vec3::new(0.0, 0.9, 0.0),
        Vec2::new(2.6, 1.2),
        0.0,
    );
    builder.build(false)
}

fn generate_rock_impostor_mesh() -> MeshData {
    let mut builder = MeshBuilder::new();
    add_billboard_cross(
        &mut builder,
        Vec3::new(0.0, 0.4, 0.0),
        Vec2::new(1.6, 1.2),
        0.0,
    );
    add_billboard_cross(
        &mut builder,
        Vec3::new(0.0, 0.4, 0.0),
        Vec2::new(1.6, 1.2),
        PI * 0.25,
    );
    add_box(
        &mut builder,
        Vec3::new(-0.9, -0.4, -0.7),
        Vec3::new(0.9, 0.2, 0.7),
        Vec2::splat(1.0),
    );
    builder.build(false)
}

fn generate_character_impostor_mesh() -> MeshData {
    let mut builder = MeshBuilder::new();
    add_billboard_cross(
        &mut builder,
        Vec3::new(0.0, 1.0, 0.0),
        Vec2::new(0.9, 2.2),
        0.0,
    );
    add_billboard_cross(
        &mut builder,
        Vec3::new(0.0, 1.0, 0.0),
        Vec2::new(0.9, 2.2),
        PI * 0.25,
    );
    builder.build(false)
}

fn generate_rock_mesh(seed: u32) -> MeshData {
    let mut rng = SimpleRng::new(seed as u64 + 0x524f434b);
    let perlin = Perlin::new(seed);

    let lat_segments = 14 + rng.range_u32(0, 6) as usize;
    let lon_segments = 20 + rng.range_u32(0, 8) as usize;
    let radius = rng.range_f32(0.9, 1.8);
    let stretch = Vec3::new(
        rng.range_f32(0.7, 1.35),
        rng.range_f32(0.55, 0.9),
        rng.range_f32(0.75, 1.4),
    );
    let base_plane_y = -radius * stretch.y * rng.range_f32(0.8, 1.1);
    let vertical_adjust = base_plane_y + 0.5;

    let primary_freq = rng.range_f32(0.6, 1.25);
    let detail_freq = primary_freq * rng.range_f32(2.2, 3.6);
    let primary_amp = rng.range_f32(0.25, 0.45);
    let detail_amp = primary_amp * rng.range_f32(0.35, 0.6);
    let noise_offset = [
        rng.range_f32(-80.0, 80.0) as f64,
        rng.range_f32(-80.0, 80.0) as f64,
        rng.range_f32(-80.0, 80.0) as f64,
    ];

    let mut chip_planes = Vec::new();
    let chip_count = 1 + rng.range_u32(0, 3) as usize;
    for _ in 0..chip_count {
        let theta = rng.range_f32(0.0, TAU);
        let phi = rng.range_f32(0.2, PI - 0.2);
        let normal = Vec3::new(theta.cos() * phi.sin(), phi.cos(), theta.sin() * phi.sin())
            .normalize_or_zero();
        let depth = rng.range_f32(0.1, 0.4);
        chip_planes.push((normal, depth));
    }

    let uv_tile = rng.range_f32(2.4, 4.8);

    let mut builder = MeshBuilder::new();
    let mut grid: Vec<Vec<u32>> = Vec::with_capacity(lat_segments + 1);

    for lat in 0..=lat_segments {
        let v = lat as f32 / lat_segments as f32;
        let phi = v * PI;
        let y = phi.cos();
        let ring_radius = phi.sin();
        let mut ring = Vec::with_capacity(lon_segments);
        for lon in 0..lon_segments {
            let u = lon as f32 / lon_segments as f32;
            let theta = u * TAU;
            let direction = Vec3::new(theta.cos() * ring_radius, y, theta.sin() * ring_radius)
                .normalize_or_zero();

            let sample = [
                direction.x as f64 * primary_freq as f64 + noise_offset[0],
                direction.y as f64 * primary_freq as f64 + noise_offset[1],
                direction.z as f64 * primary_freq as f64 + noise_offset[2],
            ];
            let detail_sample = [
                direction.x as f64 * detail_freq as f64 + noise_offset[0],
                direction.y as f64 * detail_freq as f64 + noise_offset[1],
                direction.z as f64 * detail_freq as f64 + noise_offset[2],
            ];
            let displacement = 1.0
                + perlin.get(sample) as f32 * primary_amp
                + perlin.get(detail_sample) as f32 * detail_amp;

            let mut pos = direction * (radius * displacement);
            pos.x *= stretch.x;
            pos.y *= stretch.y;
            pos.z *= stretch.z;

            for (plane_normal, depth) in &chip_planes {
                let distance = pos.dot(*plane_normal);
                if distance > *depth {
                    pos -= *plane_normal * (distance - *depth) * rng.range_f32(0.55, 0.9);
                }
            }

            if pos.y < base_plane_y {
                let blend = ((base_plane_y - pos.y) / (radius * stretch.y * 0.6)).clamp(0.0, 1.0);
                pos.y += (base_plane_y - pos.y) * (blend * 0.8);
            }

            pos.y -= vertical_adjust;
            let uv = Vec2::new(u * uv_tile, v * uv_tile);
            ring.push(builder.push_vertex(pos, uv));
        }
        grid.push(ring);
    }

    for lat in 0..lat_segments {
        let current = &grid[lat];
        let next = &grid[lat + 1];
        for lon in 0..lon_segments {
            let a = current[lon];
            let b = current[(lon + 1) % lon_segments];
            let c = next[(lon + 1) % lon_segments];
            let d = next[lon];
            builder.add_quad(a, b, c, d);
        }
    }

    let lobe_count = rng.range_u32(0, 4);
    for _ in 0..lobe_count {
        let theta = rng.range_f32(0.0, TAU);
        let phi = rng.range_f32(0.0, PI);
        let dir = Vec3::new(theta.cos() * phi.sin(), phi.cos(), theta.sin() * phi.sin());
        let mut center = Vec3::new(
            dir.x * radius * rng.range_f32(0.3, 0.6),
            dir.y * radius * rng.range_f32(0.1, 0.4),
            dir.z * radius * rng.range_f32(0.3, 0.6),
        );
        center.y -= vertical_adjust;
        if center.y < -0.45 {
            center.y = -0.45 + rng.range_f32(0.0, 0.2);
        }
        let lobe_radius = radius * rng.range_f32(0.18, 0.35);
        let lat = 6 + rng.range_u32(0, 4) as usize;
        let lon = 9 + rng.range_u32(0, 6) as usize;
        add_latlong_sphere(
            &mut builder,
            center,
            lobe_radius,
            lat,
            lon,
            Vec2::splat(rng.range_f32(0.6, 1.2)),
        );
    }

    builder.build(true)
}

fn generate_character_mesh(seed: u32) -> MeshData {
    let mut rng = SimpleRng::new(seed as u64 + 0x43484152);
    let mut builder = MeshBuilder::new();

    let foot_y = -0.5;
    let stance_width = rng.range_f32(0.32, 0.46);
    let leg_length = rng.range_f32(1.05, 1.35);
    let knee_height = leg_length * rng.range_f32(0.48, 0.58);
    let leg_segments = 12;

    let thigh_radius = rng.range_f32(0.09, 0.13);
    let calf_radius = thigh_radius * rng.range_f32(0.75, 0.92);
    let ankle_radius = calf_radius * rng.range_f32(0.65, 0.85);

    for side in [-1.0, 1.0] {
        let hip_x = side * stance_width * 0.5;
        let hip_pos = Vec3::new(hip_x, foot_y + leg_length, 0.0);
        let knee_forward = rng.range_f32(-0.12, 0.18);
        let knee_pos = Vec3::new(
            hip_x + side * rng.range_f32(-0.05, 0.05),
            foot_y + knee_height,
            knee_forward,
        );
        let ankle_pos = Vec3::new(
            hip_x + side * rng.range_f32(-0.04, 0.04),
            foot_y,
            rng.range_f32(-0.08, 0.2),
        );

        add_oriented_capped_cylinder(
            &mut builder,
            hip_pos,
            knee_pos,
            thigh_radius,
            calf_radius,
            leg_segments,
            Vec2::new(1.8, 1.2),
            true,
            false,
        );
        add_oriented_capped_cylinder(
            &mut builder,
            knee_pos,
            ankle_pos,
            calf_radius,
            ankle_radius,
            leg_segments - 2,
            Vec2::new(1.6, 1.3),
            false,
            true,
        );

        add_box(
            &mut builder,
            Vec3::new(
                ankle_pos.x - ankle_radius * 0.9,
                foot_y - 0.06,
                ankle_pos.z - ankle_radius * 1.2,
            ),
            Vec3::new(
                ankle_pos.x + ankle_radius * 0.9,
                foot_y + 0.05,
                ankle_pos.z + ankle_radius * 1.8,
            ),
            Vec2::new(0.6, 1.0),
        );
    }

    let pelvis_height = foot_y + leg_length;
    let pelvis_half = Vec3::new(stance_width * 0.5 + thigh_radius * 0.6, thigh_radius * 0.8, 0.18);
    add_box(
        &mut builder,
        Vec3::new(-pelvis_half.x, pelvis_height - pelvis_half.y, -pelvis_half.z),
        Vec3::new(pelvis_half.x, pelvis_height + pelvis_half.y * 0.8, pelvis_half.z),
        Vec2::new(0.8, 0.6),
    );

    let torso_height = rng.range_f32(1.0, 1.35);
    let torso_top = pelvis_height + torso_height;
    let torso_radius_top = thigh_radius * rng.range_f32(0.9, 1.2);
    let torso_radius_bottom = thigh_radius * rng.range_f32(1.4, 1.7);
    add_oriented_capped_cylinder(
        &mut builder,
        Vec3::new(0.0, pelvis_height, 0.0),
        Vec3::new(0.0, torso_top, 0.0),
        torso_radius_bottom,
        torso_radius_top,
        14,
        Vec2::new(1.6, 2.2),
        false,
        true,
    );

    if rng.range_u32(0, 100) < 65 {
        let chest_depth = torso_radius_bottom * rng.range_f32(0.8, 1.1);
        add_box(
            &mut builder,
            Vec3::new(
                -torso_radius_bottom * 1.1,
                pelvis_height + torso_height * 0.35,
                -chest_depth,
            ),
            Vec3::new(
                torso_radius_bottom * 1.1,
                pelvis_height + torso_height * 0.65,
                chest_depth,
            ),
            Vec2::new(1.2, 0.9),
        );
    }

    let shoulder_y = torso_top - rng.range_f32(0.25, 0.35);
    let shoulder_span = stance_width * rng.range_f32(1.1, 1.4);
    let arm_segments = 10;
    let upper_arm_radius = thigh_radius * rng.range_f32(0.75, 0.9);
    let forearm_radius = upper_arm_radius * rng.range_f32(0.75, 0.92);
    let wrist_radius = forearm_radius * rng.range_f32(0.65, 0.85);
    let arm_length = rng.range_f32(0.85, 1.1);

    for side in [-1.0, 1.0] {
        let shoulder = Vec3::new(side * shoulder_span * 0.5, shoulder_y, 0.0);
        let elbow = Vec3::new(
            shoulder.x + side * rng.range_f32(0.18, 0.32),
            shoulder_y - arm_length * 0.55,
            rng.range_f32(-0.25, 0.25),
        );
        let wrist = Vec3::new(
            shoulder.x + side * rng.range_f32(0.28, 0.4),
            shoulder_y - arm_length,
            rng.range_f32(-0.35, 0.2),
        );

        add_oriented_capped_cylinder(
            &mut builder,
            shoulder,
            elbow,
            upper_arm_radius,
            forearm_radius,
            arm_segments,
            Vec2::new(1.3, 1.7),
            true,
            false,
        );
        add_oriented_capped_cylinder(
            &mut builder,
            elbow,
            wrist,
            forearm_radius,
            wrist_radius,
            arm_segments - 1,
            Vec2::new(1.3, 1.5),
            false,
            true,
        );

        add_latlong_sphere(
            &mut builder,
            wrist,
            wrist_radius * rng.range_f32(1.2, 1.5),
            5,
            8,
            Vec2::splat(0.8),
        );

        if rng.range_u32(0, 100) < 45 {
            add_box(
                &mut builder,
                Vec3::new(
                    shoulder.x - upper_arm_radius * 1.4,
                    shoulder_y + upper_arm_radius * 0.3,
                    -upper_arm_radius,
                ),
                Vec3::new(
                    shoulder.x + upper_arm_radius * 1.4,
                    shoulder_y + upper_arm_radius * 1.8,
                    upper_arm_radius,
                ),
                Vec2::new(0.6, 0.6),
            );
        }
    }

    let neck_height = rng.range_f32(0.18, 0.25);
    add_oriented_capped_cylinder(
        &mut builder,
        Vec3::new(0.0, torso_top, 0.0),
        Vec3::new(0.0, torso_top + neck_height, 0.0),
        torso_radius_top * 0.8,
        torso_radius_top * 0.6,
        8,
        Vec2::new(0.5, 0.5),
        false,
        true,
    );

    let head_radius = rng.range_f32(0.28, 0.34);
    add_latlong_sphere(
        &mut builder,
        Vec3::new(0.0, torso_top + neck_height + head_radius * 0.9, 0.0),
        head_radius,
        8,
        12,
        Vec2::splat(1.0),
    );

    if rng.range_u32(0, 100) < 55 {
        let visor_width = head_radius * rng.range_f32(1.1, 1.35);
        add_billboard_cross(
            &mut builder,
            Vec3::new(0.0, torso_top + neck_height + head_radius * 0.65, head_radius * 0.9),
            Vec2::new(visor_width, head_radius * 0.7),
            0.0,
        );
    }

    if rng.range_u32(0, 100) < 30 {
        add_box(
            &mut builder,
            Vec3::new(-torso_radius_bottom * 0.6, pelvis_height + 0.1, -torso_radius_bottom * 1.4),
            Vec3::new(torso_radius_bottom * 0.6, pelvis_height + torso_height * 0.8, -torso_radius_bottom * 0.6),
            Vec2::new(0.8, 1.4),
        );
    }

    builder.build(true)
}

fn load_rgba_image(path: &Path) -> Result<RgbaImage> {
    let dyn_img =
        image::open(path).with_context(|| format!("Failed to open image at {}", path.display()))?;
    Ok(dyn_img.to_rgba8())
}

fn create_solid_rgba_image(width: u32, height: u32, color: [u8; 4]) -> RgbaImage {
    RgbaImage::from_fn(width, height, |_x, _y| image::Rgba(color))
}

// Reload authored materials pack (placeholder; integrator wiring TBD in event loop)
fn reload_texture_pack(_render: &mut RenderStuff, texture_pack_name: &str) -> Result<()> {
    println!("[materials] reload requested for biome pack: {}", texture_pack_name);
    Ok(())
}

fn create_flat_normal_image(width: u32, height: u32) -> RgbaImage {
    create_solid_rgba_image(width, height, [128, 128, 255, 255])
}

fn create_default_mra_image(width: u32, height: u32) -> RgbaImage {
    create_solid_rgba_image(width, height, [255, 255, 0, 255])
}

#[derive(Clone, Copy)]
enum MaterialFallbackPattern {
    Solid([u8; 4]),
    Checker {
        primary: [u8; 4],
        secondary: [u8; 4],
        scale: u32,
    },
    Stripe {
        primary: [u8; 4],
        secondary: [u8; 4],
        frequency: u32,
        vertical: bool,
    },
    Diagonal {
        primary: [u8; 4],
        secondary: [u8; 4],
        frequency: u32,
    },
    Noise {
        base: [u8; 4],
        variance: u8,
        seed: u32,
    },
}

#[derive(Clone, Copy)]
struct MaterialLayerDefinition {
    key: &'static str,
    display_name: &'static str,
    fallback_pattern: MaterialFallbackPattern,
}

impl MaterialFallbackPattern {
    fn representative_color(self) -> [u8; 4] {
        match self {
            MaterialFallbackPattern::Solid(color)
            | MaterialFallbackPattern::Checker { primary: color, .. }
            | MaterialFallbackPattern::Stripe { primary: color, .. }
            | MaterialFallbackPattern::Diagonal { primary: color, .. }
            | MaterialFallbackPattern::Noise { base: color, .. } => color,
        }
    }

    fn generate_image(self, width: u32, height: u32) -> RgbaImage {
        match self {
            MaterialFallbackPattern::Solid(color) => create_solid_rgba_image(width, height, color),
            MaterialFallbackPattern::Checker {
                primary,
                secondary,
                scale,
            } => RgbaImage::from_fn(width, height, |x, y| {
                let tile_x = (x / scale) % 2;
                let tile_y = (y / scale) % 2;
                let color = if tile_x == tile_y { primary } else { secondary };
                image::Rgba(color)
            }),
            MaterialFallbackPattern::Stripe {
                primary,
                secondary,
                frequency,
                vertical,
            } => RgbaImage::from_fn(width, height, |x, y| {
                let coord = if vertical { x } else { y } / frequency;
                let color = if coord % 2 == 0 { primary } else { secondary };
                image::Rgba(color)
            }),
            MaterialFallbackPattern::Diagonal {
                primary,
                secondary,
                frequency,
            } => RgbaImage::from_fn(width, height, |x, y| {
                let band = ((x + y) / frequency) % 2;
                let color = if band == 0 { primary } else { secondary };
                image::Rgba(color)
            }),
            MaterialFallbackPattern::Noise { base, variance, seed } => {
                RgbaImage::from_fn(width, height, |x, y| {
                    let noise = pattern_noise(seed, x, y);
                    let delta = (noise as i16 - 128) * variance as i16 / 128;
                    let mut color = base;
                    for channel in 0..3 {
                        let value = base[channel] as i16 + delta;
                        color[channel] = value.clamp(0, 255) as u8;
                    }
                    image::Rgba(color)
                })
            }
        }
    }
}

impl MaterialLayerDefinition {
    fn fallback_color(&self) -> [u8; 4] {
        self.fallback_pattern.representative_color()
    }

    fn fallback_albedo(&self, width: u32, height: u32) -> RgbaImage {
        self.fallback_pattern.generate_image(width, height)
    }
}

const MATERIAL_LAYERS: [MaterialLayerDefinition; 12] = [
    MaterialLayerDefinition {
        key: "grass",
        display_name: "Grass",
        fallback_pattern: MaterialFallbackPattern::Noise {
            base: [78, 150, 72, 255],
            variance: 24,
            seed: 11,
        },
    },
    MaterialLayerDefinition {
        key: "dirt",
        display_name: "Dirt",
        fallback_pattern: MaterialFallbackPattern::Noise {
            base: [118, 76, 38, 255],
            variance: 30,
            seed: 23,
        },
    },
    MaterialLayerDefinition {
        key: "stone",
        display_name: "Stone",
        fallback_pattern: MaterialFallbackPattern::Noise {
            base: [128, 128, 136, 255],
            variance: 18,
            seed: 41,
        },
    },
    MaterialLayerDefinition {
        key: "sand",
        display_name: "Sand",
        fallback_pattern: MaterialFallbackPattern::Checker {
            primary: [210, 186, 142, 255],
            secondary: [194, 168, 120, 255],
            scale: 16,
        },
    },
    MaterialLayerDefinition {
        key: "forest_floor",
        display_name: "Forest Floor",
        fallback_pattern: MaterialFallbackPattern::Noise {
            base: [74, 92, 58, 255],
            variance: 26,
            seed: 59,
        },
    },
    MaterialLayerDefinition {
        key: "tree_bark",
        display_name: "Tree Bark",
        fallback_pattern: MaterialFallbackPattern::Stripe {
            primary: [92, 64, 44, 255],
            secondary: [70, 48, 30, 255],
            frequency: 8,
            vertical: true,
        },
    },
    MaterialLayerDefinition {
        key: "tree_leaves",
        display_name: "Tree Leaves",
        fallback_pattern: MaterialFallbackPattern::Diagonal {
            primary: [62, 140, 68, 255],
            secondary: [44, 104, 52, 255],
            frequency: 12,
        },
    },
    MaterialLayerDefinition {
        key: "rock_lichen",
        display_name: "Rock Lichen",
        fallback_pattern: MaterialFallbackPattern::Noise {
            base: [132, 134, 118, 255],
            variance: 22,
            seed: 73,
        },
    },
    MaterialLayerDefinition {
        key: "rock_slate",
        display_name: "Rock Slate",
        fallback_pattern: MaterialFallbackPattern::Stripe {
            primary: [92, 102, 120, 255],
            secondary: [70, 78, 96, 255],
            frequency: 6,
            vertical: false,
        },
    },
    MaterialLayerDefinition {
        key: "plaster",
        display_name: "Plaster",
        fallback_pattern: MaterialFallbackPattern::Solid([216, 210, 198, 255]),
    },
    MaterialLayerDefinition {
        key: "roof_tile",
        display_name: "Roof Tile",
        fallback_pattern: MaterialFallbackPattern::Stripe {
            primary: [156, 64, 46, 255],
            secondary: [132, 44, 34, 255],
            frequency: 10,
            vertical: false,
        },
    },
    MaterialLayerDefinition {
        key: "cloth",
        display_name: "Cloth",
        fallback_pattern: MaterialFallbackPattern::Checker {
            primary: [148, 112, 168, 255],
            secondary: [120, 88, 142, 255],
            scale: 12,
        },
    },
];

fn fallback_color_for_material(material: &str) -> [u8; 4] {
    MATERIAL_LAYERS
        .iter()
        .find(|layer| layer.key == material)
        .map(|layer| layer.fallback_color())
        .unwrap_or([200, 50, 200, 255])
}

fn material_layer_index(key: &str) -> Option<usize> {
    MATERIAL_LAYERS
        .iter()
        .position(|layer| layer.key.eq_ignore_ascii_case(key))
}

fn pattern_noise(seed: u32, x: u32, y: u32) -> u8 {
    // Simple hash-based noise; stable per seed and coordinate
    let mut v = x
        .wrapping_mul(374_761_393)
        .rotate_left(5)
        ^ y.wrapping_mul(668_265_263).rotate_left(13)
        ^ seed.wrapping_mul(0x27d4_eb2d);
    v ^= v >> 15;
    (v & 0xFF) as u8
}

fn normalize_texture_key(value: &str) -> String {
    value
    .replace('\\', "/")
        .trim_start_matches("./")
        .trim_start_matches('/')
        .to_ascii_lowercase()
}

fn find_texture_entry_id_for_path(manager: &TextureManager, texture_path: &str) -> Option<String> {
    let target = normalize_texture_key(texture_path);
    manager
        .get_all_textures()
        .iter()
        .find_map(|(id, entry)| {
            if normalize_texture_key(&entry.diffuse_path) == target {
                Some(id.clone())
            } else {
                None
            }
        })
}

fn load_material_images_for_layer_without_manager(
    def: &MaterialLayerDefinition,
    material: &material::Material,
    width: u32,
    height: u32,
    asset_root: &Path,
) -> (RgbaImage, RgbaImage, RgbaImage) {
    let albedo = if let Some(path) = material.albedo_texture.as_ref() {
        if let Some(resolved) = resolve_texture_path(asset_root, path) {
            match load_rgba_image(&resolved) {
                Ok(img) => resize_image_if_needed(&img, width, height),
                Err(err) => {
                    eprintln!(
                        "⚠️ Failed to load albedo '{}' ({}); using fallback.",
                        resolved.display(),
                        err
                    );
                    def.fallback_albedo(width, height)
                }
            }
        } else {
            def.fallback_albedo(width, height)
        }
    } else {
        def.fallback_albedo(width, height)
    };

    let normal = if let Some(path) = material.normal_texture.as_ref() {
        if let Some(resolved) = resolve_texture_path(asset_root, path) {
            match load_rgba_image(&resolved) {
                Ok(img) => resize_image_if_needed(&img, width, height),
                Err(err) => {
                    eprintln!(
                        "⚠️ Failed to load normal '{}' ({}); using flat normal.",
                        resolved.display(),
                        err
                    );
                    create_flat_normal_image(width, height)
                }
            }
        } else {
            create_flat_normal_image(width, height)
        }
    } else {
        let inferred = material
            .albedo_texture
            .as_ref()
            .and_then(|albedo_path| resolve_texture_path(asset_root, albedo_path))
            .and_then(|albedo_path| find_normal_map(&albedo_path));
        if let Some(candidate) = inferred {
            match load_rgba_image(&candidate) {
                Ok(img) => resize_image_if_needed(&img, width, height),
                Err(err) => {
                    eprintln!(
                        "⚠️ Failed to load inferred normal '{}' ({}); using flat normal.",
                        candidate.display(),
                        err
                    );
                    create_flat_normal_image(width, height)
                }
            }
        } else {
            create_flat_normal_image(width, height)
        }
    };

    let mra = create_mra_from_values(width, height, material.roughness, material.metallic);

    (albedo, normal, mra)
}

fn load_material_images_for_layer_with_manager(
    _def: &MaterialLayerDefinition,
    material: &material::Material,
    width: u32,
    height: u32,
    manager: &mut TextureManager,
    asset_root: &Path,
) -> Option<(RgbaImage, RgbaImage, RgbaImage)> {
    let albedo_path = material.albedo_texture.as_ref()?;
    let entry_id = find_texture_entry_id_for_path(manager, albedo_path)?;
    manager.load_texture(&entry_id, asset_root).ok()?;

    let entry = manager.get_all_textures().get(&entry_id)?;
    let diffuse_image = manager.get_image(&entry_id)?;
    let albedo = resize_image_if_needed(&diffuse_image.to_rgba8(), width, height);

    let mut normal = None;
    if let Some(normal_path) = &entry.normal_path {
        let full = asset_root.join(normal_path);
        if full.exists() {
            match load_rgba_image(&full) {
                Ok(img) => normal = Some(resize_image_if_needed(&img, width, height)),
                Err(err) => eprintln!(
                    "⚠️ Failed to load atlas normal '{}' ({}); falling back.",
                    full.display(),
                    err
                ),
            }
        }
    }

    let normal = normal.unwrap_or_else(|| create_flat_normal_image(width, height));
    let mra = create_mra_from_values(width, height, entry.roughness, entry.metallic);

    Some((albedo, normal, mra))
}

fn load_material_layer_from_manager(
    def: &MaterialLayerDefinition,
    width: u32,
    height: u32,
    manager: &mut TextureManager,
    asset_root: &Path,
) -> Option<(RgbaImage, RgbaImage, RgbaImage)> {
    let mat = material::Material::default(); // Placeholder; in legacy path this would be looked up
    load_material_images_for_layer_with_manager(def, &mat, width, height, manager, asset_root)
}

fn create_mra_from_values(width: u32, height: u32, roughness: f32, metallic: f32) -> RgbaImage {
    let r = (metallic.clamp(0.0, 1.0) * 255.0) as u8;
    let g = (roughness.clamp(0.0, 1.0) * 255.0) as u8;
    let b = 255u8; // AO default to 1.0
    RgbaImage::from_fn(width, height, |_x, _y| image::Rgba([r, g, b, 255]))
}

fn load_material_layer_images_fallback(def: &MaterialLayerDefinition, width: u32, height: u32) -> (RgbaImage, RgbaImage, RgbaImage) {
    let albedo = def.fallback_albedo(width, height);
    let normal = create_flat_normal_image(width, height);
    let mra = create_mra_from_values(width, height, 0.5, 0.0);
    (albedo, normal, mra)
}

fn load_material_images_for_layer(
    def: &MaterialLayerDefinition,
    material: &material::Material,
    width: u32,
    height: u32,
    texture_manager: Option<&mut TextureManager>,
    asset_root: &Path,
) -> (RgbaImage, RgbaImage, RgbaImage) {
    if let Some(manager) = texture_manager {
        if let Some(images) = load_material_images_for_layer_with_manager(
            def,
            material,
            width,
            height,
            manager,
            asset_root,
        ) {
            return images;
        }
    }

    load_material_images_for_layer_without_manager(def, material, width, height, asset_root)
}


fn resize_image_if_needed(image: &RgbaImage, desired_width: u32, desired_height: u32) -> RgbaImage {
    if image.width() == desired_width && image.height() == desired_height {
        return image.clone();
    }
    imageops::resize(
        image,
        desired_width,
        desired_height,
        imageops::FilterType::Lanczos3,
    )
}

fn create_array_texture_from_images(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
    images: &[RgbaImage],
    format: wgpu::TextureFormat,
    label: &str,
    sampler_desc: &wgpu::SamplerDescriptor,
) -> Result<ArrayTexture> {
    assert!(
        !images.is_empty(),
        "create_array_texture_from_images requires non-empty images"
    );
    let layer_count = images.len() as u32;
    let width = images[0].width();
    let height = images[0].height();
    for (idx, img) in images.iter().enumerate() {
        if img.width() != width || img.height() != height {
            anyhow::bail!(
                "Image at index {} has mismatched dimensions {}x{} (expected {}x{})",
                idx,
                img.width(),
                img.height(),
                width,
                height
            );
        }
    }

    let size = wgpu::Extent3d {
        width,
        height,
        depth_or_array_layers: layer_count,
    };
    let max_dimension = size.width.max(size.height).max(1);
    let mip_level_count = (max_dimension as f32).log2().floor() as u32 + 1;

    let texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some(label),
        size,
        mip_level_count,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format,
        usage: wgpu::TextureUsages::TEXTURE_BINDING
            | wgpu::TextureUsages::COPY_DST
            | wgpu::TextureUsages::RENDER_ATTACHMENT,
        view_formats: &[],
    });

    let view_label = format!("{label}-view");
    let view = texture.create_view(&wgpu::TextureViewDescriptor {
        label: Some(view_label.as_str()),
        format: Some(format),
        dimension: Some(wgpu::TextureViewDimension::D2Array),
        aspect: wgpu::TextureAspect::All,
        base_mip_level: 0,
        mip_level_count: Some(mip_level_count),
        base_array_layer: 0,
        array_layer_count: Some(layer_count),
    });

    let sampler = device.create_sampler(sampler_desc);

    let array_texture = ArrayTexture {
        texture,
        view,
        sampler,
        format,
        size,
        mip_level_count,
    };

    for (layer, image) in images.iter().enumerate() {
        array_texture.write_layer(device, queue, layer as u32, image.as_raw());
    }

    Ok(array_texture)
}

fn candidate_paths() -> [PathBuf; 6] {
    [
        PathBuf::from("assets"),
        PathBuf::from("../assets"),
        PathBuf::from("../../assets"),
        Path::new(env!("CARGO_MANIFEST_DIR")).join("assets"),
        Path::new(env!("CARGO_MANIFEST_DIR")).join("../assets"),
        Path::new(env!("CARGO_MANIFEST_DIR")).join("../../assets"),
    ]
}

fn asset_dir() -> PathBuf {
    candidate_paths()
        .into_iter()
        .find(|path| path.exists())
        .unwrap_or_else(|| Path::new(env!("CARGO_MANIFEST_DIR")).join("../../assets"))
}

fn resolve_asset_src_path(rel: &str) -> PathBuf {
    let manifest = Path::new(env!("CARGO_MANIFEST_DIR"));
    for base in [
        PathBuf::from("assets_src"),
        manifest.join("assets_src"),
        manifest.join("../../assets_src"),
        PathBuf::from("../assets_src"),
        PathBuf::from("../../assets_src"),
    ] {
        let path = base.join(rel);
        if path.exists() {
            return path;
        }
    }
    manifest.join("../../assets_src").join(rel)
}

fn resolve_asset_path(rel: &str) -> PathBuf {
    let rel_path = Path::new(rel);
    if rel_path.is_absolute() {
        return rel_path.to_path_buf();
    }
    for base in candidate_paths() {
        let path = base.join(rel);
        if path.exists() {
            return path;
        }
    }
    asset_dir().join(rel)
}

const MATERIAL_LAYER_PRIMARY: u32 = 0;
const MATERIAL_LAYER_TREE_BARK: u32 = 5;
const MATERIAL_LAYER_TREE_LEAVES: u32 = 6;
const MATERIAL_LAYER_ROCK_LICHEN: u32 = 7;
const MATERIAL_LAYER_ROCK_SLATE: u32 = 8;
const MATERIAL_LAYER_PLASTER: u32 = 9;
const MATERIAL_LAYER_ROOF_TILE: u32 = 10;
const MATERIAL_LAYER_CLOTH: u32 = 11;
const TOTAL_MATERIAL_LAYERS: u32 = MATERIAL_LAYERS.len() as u32;
const DEPTH_FORMAT: wgpu::TextureFormat = wgpu::TextureFormat::Depth32Float;

#[derive(Debug, Clone, Deserialize)]
pub(crate) struct BiomeToml {
    #[serde(default)]
    biome: BiomeSection,
    #[serde(default)]
    layer: Vec<BiomeLayer>,
}

#[derive(Debug, Clone, Deserialize, Default)]
pub(crate) struct BiomeSection {
    #[serde(default)]
    name: String,
    #[serde(default)]
    default_ext: Option<String>,
}

#[derive(Debug, Clone, Deserialize)]
pub(crate) struct BiomeLayer {
    key: String,
    #[serde(default)]
    albedo: Option<String>,
    #[serde(default)]
    normal: Option<String>,
    #[serde(default)]
    mra: Option<String>,
    #[serde(default)]
    metallic: Option<String>,
    #[serde(default)]
    roughness: Option<String>,
    #[serde(default)]
    ao: Option<String>,
}

pub(crate) fn load_biome_toml(biome_name: &str) -> Option<(BiomeToml, std::path::PathBuf)> {
    // Resolve under the detected assets directory to avoid duplicate `assets` segments
    let base = asset_dir();
    let candidates = [
        base.join("textures").join(biome_name).join("materials.toml"),
        base.join(biome_name).join("materials.toml"),
    ];
    for path in candidates {
        if path.exists() {
            if let Ok(txt) = std::fs::read_to_string(&path) {
                if let Ok(doc) = toml::from_str::<BiomeToml>(&txt) {
                    let dir = path.parent().unwrap_or_else(|| std::path::Path::new(".")).to_path_buf();
                    return Some((doc, dir));
                }
            }
        }
    }
    // Fallback to resolve by relative patterns as before
    for rel in [
        format!("textures/{}/materials.toml", biome_name),
        format!("assets/textures/{}/materials.toml", biome_name),
    ] {
        let path = resolve_asset_path(&rel);
        if path.exists() {
            if let Ok(txt) = std::fs::read_to_string(&path) {
                if let Ok(doc) = toml::from_str::<BiomeToml>(&txt) {
                    let dir = path.parent().unwrap_or_else(|| std::path::Path::new(".")).to_path_buf();
                    return Some((doc, dir));
                }
            }
        }
    }
    None
}

fn try_load_image_relative(base_dir: &std::path::Path, rel: &str, width: u32, height: u32) -> Option<RgbaImage> {
    let path = base_dir.join(rel);
    if path.exists() {
        if let Ok(img) = load_rgba_image(&path) {
            return Some(resize_image_if_needed(&img, width, height));
        }
    }
    None
}

pub(crate) fn pack_mra_from_planes(metal: &[u8], rough: &[u8], ao: &[u8], width: u32, height: u32) -> RgbaImage {
    assert_eq!(metal.len(), (width * height * 4) as usize, "metal plane must be RGBA bytes");
    assert_eq!(rough.len(), (width * height * 4) as usize, "rough plane must be RGBA bytes");
    assert_eq!(ao.len(), (width * height * 4) as usize, "ao plane must be RGBA bytes");
    let mut out = RgbaImage::new(width, height);
    // Read R channel from each plane and pack into RGB
    for y in 0..height {
        for x in 0..width {
            let idx = ((y * width + x) * 4) as usize;
            let mc = metal[idx + 0];
            let rc = rough[idx + 0];
            let ac = ao[idx + 0];
            out.put_pixel(x, y, image::Rgba([mc, rc, ac, 255]));
        }
    }
    out
}

fn pack_mra_from_separate(base_dir: &std::path::Path, metal: &str, rough: &str, ao: &str, width: u32, height: u32) -> Option<RgbaImage> {
    let m = try_load_image_relative(base_dir, metal, width, height)?;
    let r = try_load_image_relative(base_dir, rough, width, height)?;
    let a = try_load_image_relative(base_dir, ao, width, height)?;
    Some(pack_mra_from_planes(m.as_raw(), r.as_raw(), a.as_raw(), width, height))
}

fn load_layer_from_biome_spec(def: &MaterialLayerDefinition, spec: &BiomeLayer, base_dir: &std::path::Path, width: u32, height: u32) -> (RgbaImage, RgbaImage, RgbaImage, bool, bool, bool) {
    let mut albedo_loaded = false;
    let mut normal_loaded = false;
    let mut mra_loaded = false;

    // Albedo
    let albedo = if let Some(path) = &spec.albedo { 
        if let Some(img) = try_load_image_relative(base_dir, path, width, height) { 
            albedo_loaded = true; img 
        } else { 
            eprintln!("[textures] missing albedo for {}/{} → substituting fallback", base_dir.display(), def.key);
            def.fallback_albedo(width, height)
        }
    } else {
        eprintln!("[textures] missing albedo for {}/{} → substituting fallback", base_dir.display(), def.key);
        def.fallback_albedo(width, height)
    };

    // Normal
    let normal = if let Some(path) = &spec.normal { 
        if let Some(img) = try_load_image_relative(base_dir, path, width, height) { 
            normal_loaded = true; img 
        } else { 
            eprintln!("[textures] missing normal for {}/{} → substituting neutral", base_dir.display(), def.key);
            create_flat_normal_image(width, height)
        }
    } else { 
        eprintln!("[textures] missing normal for {}/{} → substituting neutral", base_dir.display(), def.key);
        create_flat_normal_image(width, height)
    };

    // MRA (packed) or separate
    let mra = if let Some(path) = &spec.mra {
        if let Some(img) = try_load_image_relative(base_dir, path, width, height) {
            mra_loaded = true; img
        } else {
            // Try separate if provided
            if let (Some(m), Some(r), Some(ao)) = (&spec.metallic, &spec.roughness, &spec.ao) {
                if let Some(packed) = pack_mra_from_separate(base_dir, m, r, ao, width, height) {
                    mra_loaded = true; packed
                } else {
                    eprintln!("[textures] missing MRA for {}/{} → substituting neutral", base_dir.display(), def.key);
                    create_default_mra_image(width, height)
                }
            } else {
                eprintln!("[textures] missing MRA for {}/{} → substituting neutral", base_dir.display(), def.key);
                create_default_mra_image(width, height)
            }
        }
    } else if let (Some(m), Some(r), Some(ao)) = (&spec.metallic, &spec.roughness, &spec.ao) {
        if let Some(packed) = pack_mra_from_separate(base_dir, m, r, ao, width, height) {
            mra_loaded = true; packed
        } else {
            eprintln!("[textures] missing MRA for {}/{} → substituting neutral", base_dir.display(), def.key);
            create_default_mra_image(width, height)
        }
    } else {
        eprintln!("[textures] missing MRA for {}/{} → substituting neutral", base_dir.display(), def.key);
        create_default_mra_image(width, height)
    };

    (albedo, normal, mra, albedo_loaded, normal_loaded, mra_loaded)
}

fn find_biome_layer<'a>(doc: &'a BiomeToml, key: &str) -> Option<&'a BiomeLayer> {
    doc.layer.iter().find(|l| l.key.eq_ignore_ascii_case(key))
}

fn create_material_array_textures(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
    texture_manager: Option<&mut TextureManager>,
    biome_hint: Option<&str>,
) -> Result<(ArrayTexture, ArrayTexture, ArrayTexture)> {
    let layer_count = TOTAL_MATERIAL_LAYERS;
    let width = 1024;
    let height = 1024;
    let size = wgpu::Extent3d {
        width,
        height,
        depth_or_array_layers: layer_count,
    };
    let mip_level_count = mip_level_count_for(size);

    fn make_array_texture(
        device: &wgpu::Device,
        label: &str,
        size: wgpu::Extent3d,
        mip_level_count: u32,
        format: wgpu::TextureFormat,
        sampler_desc: &wgpu::SamplerDescriptor,
    ) -> ArrayTexture {
        let texture = device.create_texture(&wgpu::TextureDescriptor {
            label: Some(label),
            size,
            mip_level_count,
            sample_count: 1,
            dimension: wgpu::TextureDimension::D2,
            format,
            usage: wgpu::TextureUsages::TEXTURE_BINDING
                | wgpu::TextureUsages::COPY_DST
                | wgpu::TextureUsages::RENDER_ATTACHMENT,
            view_formats: &[],
        });
        let view = texture.create_view(&wgpu::TextureViewDescriptor {
            label: Some(label),
            format: Some(format),
            dimension: Some(wgpu::TextureViewDimension::D2Array),
            aspect: wgpu::TextureAspect::All,
            base_mip_level: 0,
            mip_level_count: Some(mip_level_count),
            base_array_layer: 0,
            array_layer_count: Some(size.depth_or_array_layers),
        });
        let sampler = device.create_sampler(sampler_desc);
        ArrayTexture {
            texture,
            view,
            sampler,
            format,
            size,
            mip_level_count,
        }
    }

    let base_sampler = wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::Repeat,
        address_mode_v: wgpu::AddressMode::Repeat,
        address_mode_w: wgpu::AddressMode::Repeat,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
        anisotropy_clamp: 16,
        ..Default::default()
    };

    let material_albedo = make_array_texture(
        device,
        "material-albedo-layer",
        size,
        mip_level_count,
        wgpu::TextureFormat::Rgba8UnormSrgb,
        &base_sampler,
    );
    // Use RG8 for normal xy with Z reconstructed in shader by default
    // Prefer BC5 in future, but until we have precompressed assets, keep RG8 to allow CPU uploads.
    let _supports_bc = device.features().contains(wgpu::Features::TEXTURE_COMPRESSION_BC);
    let normal_format = wgpu::TextureFormat::Rg8Unorm;
    let material_normal = make_array_texture(
        device,
        "material-normal-layer",
        size,
        mip_level_count,
        normal_format,
        &base_sampler,
    );
    let material_mra = make_array_texture(
        device,
        "material-mra-layer",
        size,
        mip_level_count,
        wgpu::TextureFormat::Rgba8Unorm,
        &base_sampler,
    );

    let asset_root = asset_dir();
    // Optional biome TOML load
    let biome_spec = biome_hint
        .and_then(|b| if b.is_empty() { None } else { Some(b) })
        .and_then(|b| load_biome_toml(b));

    // Stats for validation summary
    let mut stat_layers = 0usize;
    let mut albedo_loaded = 0usize;
    let mut normal_loaded = 0usize;
    let mut mra_loaded = 0usize;

    // create a local reborrowable handle to the optional manager
    let mut tm = texture_manager;
    for (layer, def) in MATERIAL_LAYERS.iter().enumerate() {
        stat_layers += 1;
        let loaded = if let Some((ref doc, ref base_dir)) = biome_spec {
            if let Some(spec) = find_biome_layer(doc, def.key) {
                let (alb, nor, mra, alb_ok, nor_ok, mra_ok) = load_layer_from_biome_spec(def, spec, base_dir, width, height);
                if alb_ok { albedo_loaded += 1; }
                if nor_ok { normal_loaded += 1; }
                if mra_ok { mra_loaded += 1; }
                (alb, nor, mra)
            } else if let Some(manager) = tm.as_deref_mut() {
                // Try atlas manager as secondary source
                if let Some((a, n, m)) = load_material_layer_from_manager(def, width, height, manager, &asset_root) { 
                    albedo_loaded += 1; normal_loaded += 1; mra_loaded += 1; (a, n, m)
                } else {
                    load_material_layer_images_fallback(def, width, height)
                }
            } else {
                load_material_layer_images_fallback(def, width, height)
            }
        } else if let Some(manager) = tm.as_deref_mut() {
            if let Some((a, n, m)) = load_material_layer_from_manager(def, width, height, manager, &asset_root) { 
                albedo_loaded += 1; normal_loaded += 1; mra_loaded += 1; (a, n, m)
            } else {
                load_material_layer_images_fallback(def, width, height)
            }
        } else {
            load_material_layer_images_fallback(def, width, height)
        };

        material_albedo.write_layer(device, queue, layer as u32, loaded.0.as_raw());
        if material_normal.format == wgpu::TextureFormat::Rg8Unorm {
            let rg = rgba_to_rg(&loaded.1);
            material_normal.write_layer(device, queue, layer as u32, &rg);
        } else {
            material_normal.write_layer(device, queue, layer as u32, loaded.1.as_raw());
        }
        material_mra.write_layer(device, queue, layer as u32, loaded.2.as_raw());
    }

    println!(
        "[textures] layers={} | albedo loaded={} substituted={} | normal loaded={} substituted={} | mra loaded/packed={} substituted={}",
        stat_layers,
        albedo_loaded,
        stat_layers.saturating_sub(albedo_loaded),
        normal_loaded,
        stat_layers.saturating_sub(normal_loaded),
        mra_loaded,
        stat_layers.saturating_sub(mra_loaded),
    );

    Ok((material_albedo, material_normal, material_mra))
}

// Pure helper: compute counts of successfully loaded vs substituted images for a biome spec.
// This avoids WGPU by only running the loading/packing path and reporting counts.
#[cfg(test)]
pub(crate) fn stats_for_biome_loading(biome_name: &str, width: u32, height: u32) -> Option<(usize, usize, usize, usize)> {
    let layer_count = TOTAL_MATERIAL_LAYERS as usize;
    let (doc, base_dir) = load_biome_toml(biome_name)?;
    let mut albedo_loaded = 0usize;
    let mut normal_loaded = 0usize;
    let mut mra_loaded = 0usize;
    for def in MATERIAL_LAYERS.iter() {
        if let Some(spec) = find_biome_layer(&doc, def.key) {
            let (_a, _n, _m, a_ok, n_ok, m_ok) = load_layer_from_biome_spec(def, spec, &base_dir, width, height);
            if a_ok { albedo_loaded += 1; }
            if n_ok { normal_loaded += 1; }
            if m_ok { mra_loaded += 1; }
        }
    }
    Some((layer_count, albedo_loaded, normal_loaded, mra_loaded))
}

// Mesh categorization and handles for GPU-resident geometry
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
enum MeshCategory {
    Terrain,
    Tree,
    House,
    Rock,
    Character,
    Skybox,
    Primitive,
}

impl MeshCategory {
    fn as_u32(self) -> u32 {
        match self {
            MeshCategory::Terrain => 0,
            MeshCategory::Tree => 1,
            MeshCategory::House => 2,
            MeshCategory::Rock => 3,
            MeshCategory::Character => 4,
            MeshCategory::Skybox => 5,
            MeshCategory::Primitive => 6,
        }
    }

    fn from_u32(value: u32) -> Option<Self> {
        match value {
            0 => Some(MeshCategory::Terrain),
            1 => Some(MeshCategory::Tree),
            2 => Some(MeshCategory::House),
            3 => Some(MeshCategory::Rock),
            4 => Some(MeshCategory::Character),
            5 => Some(MeshCategory::Skybox),
            6 => Some(MeshCategory::Primitive),
            _ => None,
        }
    }
}

#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
struct MeshKey {
    category: MeshCategory,
    variant: u32,
}

impl MeshKey {
    const fn new(category: MeshCategory, variant: u32) -> Self {
        Self { category, variant }
    }
}

#[derive(Debug, Clone, Deserialize)]
struct TexturePack {
    #[serde(default)]
    ground: TexturePackGround,
    #[serde(default)]
    materials: HashMap<String, MaterialTextureOverride>,
}

#[derive(Debug, Clone, Deserialize)]
struct TexturePackGround {
    #[serde(default = "default_ground_texture")]
    texture: String,
    #[serde(default = "default_ground_scale")]
    scale: f32,
    #[serde(default = "default_ground_tint")]
    color_tint: [f32; 4],
}

fn default_ground_texture() -> String {
    "grass.png".to_string()
}

fn default_ground_scale() -> f32 {
    4.0
}

fn default_ground_tint() -> [f32; 4] {
    [1.0, 1.0, 1.0, 1.0]
}

impl Default for TexturePackGround {
    fn default() -> Self {
        Self {
            texture: default_ground_texture(),
            scale: default_ground_scale(),
            color_tint: default_ground_tint(),
        }
    }
}

#[derive(Debug, Clone, Deserialize, Default)]
struct MaterialTextureOverride {
    albedo: Option<String>,
    normal: Option<String>,
    mra: Option<String>,
}

struct ArrayTexture {
    texture: wgpu::Texture,
    pub view: wgpu::TextureView,
    pub sampler: wgpu::Sampler,
    pub format: wgpu::TextureFormat,
    pub size: wgpu::Extent3d,
    mip_level_count: u32,
}

impl ArrayTexture {
    fn write_layer(&self, device: &wgpu::Device, queue: &wgpu::Queue, layer: u32, data: &[u8]) {
        assert!(layer < self.size.depth_or_array_layers);
        let pixel_stride = match self.format {
            wgpu::TextureFormat::Rgba8Unorm | wgpu::TextureFormat::Rgba8UnormSrgb => 4,
            wgpu::TextureFormat::Rg8Unorm => 2,
            _ => 4, // sensible default for formats we don't explicitly handle here
        };
        let bytes_per_row = pixel_stride * self.size.width;
        let copy_extent = wgpu::Extent3d {
            width: self.size.width,
            height: self.size.height,
            depth_or_array_layers: 1,
        };
        queue.write_texture(
            wgpu::ImageCopyTexture {
                texture: &self.texture,
                mip_level: 0,
                origin: wgpu::Origin3d {
                    x: 0,
                    y: 0,
                    z: layer,
                },
                aspect: wgpu::TextureAspect::All,
            },
            data,
            wgpu::ImageDataLayout {
                offset: 0,
                bytes_per_row: Some(bytes_per_row),
                rows_per_image: Some(self.size.height),
            },
            copy_extent,
        );
        generate_mipmaps(
            device,
            queue,
            &self.texture,
            self.format,
            self.size,
            self.mip_level_count,
            layer,
            1,
        );
    }
}

fn rgba_to_rg(image: &RgbaImage) -> Vec<u8> {
    let width = image.width();
    let height = image.height();
    let mut out = vec![0u8; (width * height * 2) as usize];
    let mut o = 0usize;
    for (_, _, p) in image.enumerate_pixels() {
        out[o] = p[0];
        out[o + 1] = p[1];
        o += 2;
    }
    out
}

struct LoadedTexture {
    texture: wgpu::Texture,
    view: wgpu::TextureView,
    sampler: wgpu::Sampler,
}

struct RenderStuff {
    surface: wgpu::Surface<'static>,
    surface_cfg: wgpu::SurfaceConfiguration,
    device: wgpu::Device,
    queue: wgpu::Queue,
    depth_view: wgpu::TextureView,
    pipeline: wgpu::RenderPipeline,
    meshes: HashMap<MeshKey, Mesh>,
    camera_ub: wgpu::Buffer,
    camera_bg: wgpu::BindGroup,
    instance_vb: wgpu::Buffer,
    instance_count: u32,
    msaa_samples: u32,
    msaa_color_view: Option<wgpu::TextureView>,
    hdr_tex: wgpu::Texture,
    hdr_view: wgpu::TextureView,
    hdr_resolve_view: wgpu::TextureView,
    hdr_msaa_view: Option<wgpu::TextureView>,
    shadow_view: wgpu::TextureView,
    shadow_sampler: wgpu::Sampler,
    shadow_pipeline: wgpu::RenderPipeline,
    shadow_size: u32,
    shadow_params_buf: wgpu::Buffer,
    shadow_bg_layout: wgpu::BindGroupLayout,
    light_ub: wgpu::Buffer,
    light_bg: wgpu::BindGroup,
    shadow_bg: wgpu::BindGroup,
    texture_bind_group_layout: wgpu::BindGroupLayout,
    exposure_buf: wgpu::Buffer,
    scene_params_buf: wgpu::Buffer,
    ground_bind_group: wgpu::BindGroup,
    material_bind_group_layout: wgpu::BindGroupLayout,
    material_buffer: Option<wgpu::Buffer>,
    material_bind_group: Option<wgpu::BindGroup>,
    material_library: Option<MaterialLibrary>,
    texture_manager: Option<TextureManager>,
    current_biome: String,
    post_pipeline: wgpu::RenderPipeline,
    layer_dbg_pipeline: wgpu::RenderPipeline,
    post_bg: wgpu::BindGroup,
    post_bgl: wgpu::BindGroupLayout,
    post_sampler: wgpu::Sampler,
    bloom_ub: wgpu::Buffer,
    debug_buf: wgpu::Buffer,
    // Debug and feature flags
    debug_show_layer_quads: bool,
    normals_are_rg: bool,
    // IBL resources
    ibl_bg_layout: wgpu::BindGroupLayout,
    ibl_bg: wgpu::BindGroup,
    ibl_sampler: wgpu::Sampler,
    ibl_enabled: bool,
    ibl_last_update: f32,
    // Next-gen IBL manager (coexists with existing path for now)
    ibl2_manager: Option<IblManager>,
    // Mesh registry for GPU uploads and caching
    mesh_registry: MeshRegistry,
}

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct GpuCamera {
    view_proj: [[f32; 4]; 4],
}

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct PostParams {
    exposure: f32,
    _pad: [f32; 3],
    _pad2: [f32; 4],
}

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct BloomParams {
    threshold: f32,
    intensity: f32,
    _pad: [f32; 2],
}

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct DebugParamsRust {
    debug_tint: u32,
    _pad: [u32; 3],
    _pad2: [u32; 4],
}

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct SceneParams {
    time: f32,
    camera_height: f32,
    _pad: [f32; 2],
}

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct FaceParams {
    face_index: u32,
    _pad: [u32; 3],
}

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct ShadowParams {
    resolution: f32,
    cascade_count: u32,
    softness: f32,
    bias: f32,
    cascade_splits: [f32; 4],
}

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct InstanceRaw {
    model: [[f32; 4]; 4],
    color: [f32; 4],
    mesh_category: u32,
    mesh_variant: u32,
    lod_flags: u32,
    _padding: u32,
}

struct MeshData {
    vertices: Vec<mesh_helpers::Vertex>,
    indices: Vec<u32>,
}

struct MeshBuilder {
    positions: Vec<Vec3>,
    uvs: Vec<Vec2>,
    indices: Vec<u32>,
}

impl MeshBuilder {
    fn new() -> Self {
        Self {
            positions: Vec::new(),
            uvs: Vec::new(),
            indices: Vec::new(),
        }
    }

    fn push_vertex(&mut self, position: Vec3, uv: Vec2) -> u32 {
        let idx = self.positions.len() as u32;
        self.positions.push(position);
        self.uvs.push(uv);
        idx
    }

    fn add_triangle(&mut self, a: u32, b: u32, c: u32) {
        self.indices.extend_from_slice(&[a, b, c]);
    }

    fn add_quad(&mut self, a: u32, b: u32, c: u32, d: u32) {
        self.add_triangle(a, b, c);
        self.add_triangle(a, c, d);
    }

    fn build(self, smooth: bool) -> MeshData {
        let mut normals = vec![Vec3::ZERO; self.positions.len()];
        for tri in self.indices.chunks(3) {
            if let &[ia, ib, ic] = tri {
                let a = self.positions[ia as usize];
                let b = self.positions[ib as usize];
                let c = self.positions[ic as usize];
                let normal = (b - a).cross(c - a);
                normals[ia as usize] += normal;
                normals[ib as usize] += normal;
                normals[ic as usize] += normal;
            }
        }

        let vertices = self
            .positions
            .into_iter()
            .zip(self.uvs.into_iter())
            .zip(normals.into_iter())
            .map(|((pos, uv), normal)| {
                let n = if smooth {
                    normal.try_normalize().unwrap_or(Vec3::Y)
                } else {
                    normal
                };
                mesh_helpers::Vertex {
                    position: pos.to_array(),
                    normal: n.normalize_or_zero().to_array(),
                    uv: uv.to_array(),
                }
            })
            .collect();

        MeshData {
            vertices,
            indices: self.indices,
        }
    }
}

fn add_face(builder: &mut MeshBuilder, positions: [Vec3; 4], uvs: [Vec2; 4]) {
    let indices: Vec<u32> = positions
        .into_iter()
        .zip(uvs.into_iter())
        .map(|(pos, uv)| builder.push_vertex(pos, uv))
        .collect();
    builder.add_quad(indices[0], indices[1], indices[2], indices[3]);
}

fn add_triangle_face(builder: &mut MeshBuilder, positions: [Vec3; 3], uvs: [Vec2; 3]) {
    let indices: Vec<u32> = positions
        .into_iter()
        .zip(uvs.into_iter())
        .map(|(pos, uv)| builder.push_vertex(pos, uv))
        .collect();
    builder.add_triangle(indices[0], indices[1], indices[2]);
}

fn mesh_from_vertices(vertices: Vec<mesh_helpers::Vertex>) -> MeshData {
    let indices = (0..vertices.len() as u32).collect();
    MeshData { vertices, indices }
}

fn add_box(builder: &mut MeshBuilder, min: Vec3, max: Vec3, uv_scale: Vec2) {
    let uv = [
        Vec2::new(0.0, uv_scale.y),
        Vec2::new(uv_scale.x, uv_scale.y),
        Vec2::new(uv_scale.x, 0.0),
        Vec2::new(0.0, 0.0),
    ];
    // Front
    add_face(
        builder,
        [
            Vec3::new(min.x, min.y, max.z),
            Vec3::new(max.x, min.y, max.z),
            Vec3::new(max.x, max.y, max.z),
            Vec3::new(min.x, max.y, max.z),
        ],
        uv,
    );
    // Back
    add_face(
        builder,
        [
            Vec3::new(max.x, min.y, min.z),
            Vec3::new(min.x, min.y, min.z),
            Vec3::new(min.x, max.y, min.z),
            Vec3::new(max.x, max.y, min.z),
        ],
        uv,
    );
    // Left
    add_face(
        builder,
        [
            Vec3::new(min.x, min.y, min.z),
            Vec3::new(min.x, min.y, max.z),
            Vec3::new(min.x, max.y, max.z),
            Vec3::new(min.x, max.y, min.z),
        ],
        uv,
    );
    // Right
    add_face(
        builder,
        [
            Vec3::new(max.x, min.y, max.z),
            Vec3::new(max.x, min.y, min.z),
            Vec3::new(max.x, max.y, min.z),
            Vec3::new(max.x, max.y, max.z),
        ],
        uv,
    );
    // Top
    add_face(
        builder,
        [
            Vec3::new(min.x, max.y, max.z),
            Vec3::new(max.x, max.y, max.z),
            Vec3::new(max.x, max.y, min.z),
            Vec3::new(min.x, max.y, min.z),
        ],
        uv,
    );
    // Bottom
    add_face(
        builder,
        [
            Vec3::new(min.x, min.y, min.z),
            Vec3::new(max.x, min.y, min.z),
            Vec3::new(max.x, min.y, max.z),
            Vec3::new(min.x, min.y, max.z),
        ],
        uv,
    );
}

fn add_oriented_capped_cylinder(
    builder: &mut MeshBuilder,
    start: Vec3,
    end: Vec3,
    radius_start: f32,
    radius_end: f32,
    segments: usize,
    uv_repeat: Vec2,
    cap_start: bool,
    cap_end: bool,
) -> (Vec<u32>, Vec<u32>) {
    let segments = segments.max(3);
    let axis = end - start;
    let height = axis.length();
    if height <= f32::EPSILON {
        return (Vec::new(), Vec::new());
    }

    let dir = axis / height;
    let mut tangent = if dir.abs().y < 0.99 {
        Vec3::Y.cross(dir)
    } else {
        Vec3::X.cross(dir)
    };
    if tangent.length_squared() < 1e-6 {
        tangent = Vec3::Z.cross(dir);
    }
    tangent = tangent.normalize();
    let bitangent = dir.cross(tangent).normalize();

    let mut start_ring = Vec::with_capacity(segments);
    let mut end_ring = Vec::with_capacity(segments);

    for seg in 0..segments {
        let angle = (seg as f32 / segments as f32) * TAU;
        let (s, c) = angle.sin_cos();
        let offset_start = tangent * c * radius_start + bitangent * s * radius_start;
        let offset_end = tangent * c * radius_end + bitangent * s * radius_end;
        let u = (seg as f32 / segments as f32) * uv_repeat.x;
        start_ring.push(builder.push_vertex(start + offset_start, Vec2::new(u, uv_repeat.y)));
        end_ring.push(builder.push_vertex(end + offset_end, Vec2::new(u, 0.0)));
    }

    for seg in 0..segments {
        let next = (seg + 1) % segments;
        builder.add_quad(
            start_ring[seg],
            start_ring[next],
            end_ring[next],
            end_ring[seg],
        );
    }

    if cap_start {
        let center = builder.push_vertex(start, Vec2::new(uv_repeat.x * 0.5, uv_repeat.y));
        for seg in 0..segments {
            let next = (seg + 1) % segments;
            builder.add_triangle(center, start_ring[seg], start_ring[next]);
        }
    }

    if cap_end {
        let center = builder.push_vertex(end, Vec2::new(uv_repeat.x * 0.5, 0.0));
        for seg in 0..segments {
            let next = (seg + 1) % segments;
            builder.add_triangle(center, end_ring[next], end_ring[seg]);
        }
    }

    (start_ring, end_ring)
}

fn add_latlong_sphere(
    builder: &mut MeshBuilder,
    center: Vec3,
    radius: f32,
    lat_segments: usize,
    lon_segments: usize,
    uv_scale: Vec2,
) {
    let lat_segments = lat_segments.max(3);
    let lon_segments = lon_segments.max(3);

    let mut rings: Vec<Vec<u32>> = Vec::with_capacity(lat_segments - 1);
    for lat in 1..lat_segments {
        let v = lat as f32 / lat_segments as f32;
        let phi = v * PI;
        let y = phi.cos();
        let ring_radius = phi.sin();
        let mut ring = Vec::with_capacity(lon_segments);
        for lon in 0..lon_segments {
            let u = lon as f32 / lon_segments as f32;
            let theta = u * TAU;
            let pos = center
                + Vec3::new(theta.cos() * ring_radius, y, theta.sin() * ring_radius) * radius;
            let uv = Vec2::new(u * uv_scale.x, v * uv_scale.y);
            ring.push(builder.push_vertex(pos, uv));
        }
        rings.push(ring);
    }

    let north = builder.push_vertex(
        center + Vec3::new(0.0, radius, 0.0),
        Vec2::new(uv_scale.x * 0.5, 0.0),
    );
    let south = builder.push_vertex(
        center + Vec3::new(0.0, -radius, 0.0),
        Vec2::new(uv_scale.x * 0.5, uv_scale.y),
    );

    if let Some(first_ring) = rings.first() {
        for lon in 0..lon_segments {
            let next = (lon + 1) % lon_segments;
            builder.add_triangle(north, first_ring[next], first_ring[lon]);
        }
    }

    if let Some(last_ring) = rings.last() {
        for lon in 0..lon_segments {
            let next = (lon + 1) % lon_segments;
            builder.add_triangle(south, last_ring[lon], last_ring[next]);
        }
    }

    for ring_idx in 0..rings.len().saturating_sub(1) {
        let current = &rings[ring_idx];
        let next_ring = &rings[ring_idx + 1];
        for lon in 0..lon_segments {
            let next = (lon + 1) % lon_segments;
            builder.add_quad(
                current[lon],
                current[next],
                next_ring[next],
                next_ring[lon],
            );
        }
    }
}

fn add_billboard_cross(builder: &mut MeshBuilder, center: Vec3, size: Vec2, rotation: f32) {
    let half_w = size.x * 0.5;
    let half_h = size.y * 0.5;
    let rot = Mat3::from_rotation_y(rotation);
    let quads = [
        [
            Vec3::new(-half_w, -half_h, 0.0),
            Vec3::new(half_w, -half_h, 0.0),
            Vec3::new(half_w, half_h, 0.0),
            Vec3::new(-half_w, half_h, 0.0),
        ],
        [
            Vec3::new(0.0, -half_h, -half_w),
            Vec3::new(0.0, -half_h, half_w),
            Vec3::new(0.0, half_h, half_w),
            Vec3::new(0.0, half_h, -half_w),
        ],
    ];
    let uv = [
        Vec2::new(0.0, 1.0),
        Vec2::new(1.0, 1.0),
        Vec2::new(1.0, 0.0),
        Vec2::new(0.0, 0.0),
    ];

    for quad in quads.iter() {
        let mut positions = [Vec3::ZERO; 4];
        for (idx, local) in quad.iter().enumerate() {
            positions[idx] = center + rot * *local;
        }
        add_face(builder, positions, uv);
    }
}

struct Mesh {
    vertex_buffer: wgpu::Buffer,
    index_buffer: wgpu::Buffer,
    index_count: u32,
}

// ------------------------------- Egui wiring -------------------------------

#[allow(dead_code)] // UI state fields may be used in future iterations
struct UiState {
    show_grid: bool,
    show_navmesh: bool,
    show_path: bool,
    physics_paused: bool,
    camera_speed: f32,
    resolution_scale: f32,
    exposure: f32,
    bloom_threshold: f32,
    bloom_intensity: f32,
    fake_ao: bool,
    fake_reflections: bool,
    fps_text: String,
    info_text: String,
    current_texture_pack: String,
    available_texture_packs: Vec<String>,
    debug_material_tint: bool,
    lod_profiles: HashMap<String, BiomeLodSettings>,
    active_lod_category: LodCategory,
    lod_step_near: f32,
    lod_step_far: f32,
    lod_step_keep: f32,
    frustum_culling: bool,
}

impl Default for UiState {
    fn default() -> Self {
        let mut lod_profiles = HashMap::new();
        lod_profiles.insert("grassland".to_string(), BiomeLodSettings::grassland());
        lod_profiles.insert("desert".to_string(), BiomeLodSettings::desert());
        lod_profiles.insert("forest".to_string(), BiomeLodSettings::forest());

        Self {
            show_grid: true,
            show_navmesh: true,
            show_path: true,
            physics_paused: false,
            camera_speed: 8.0,
            resolution_scale: 1.0,
            exposure: 1.0,
            bloom_threshold: 0.7,
            bloom_intensity: 0.6,
            fake_ao: true,
            fake_reflections: false,
            fps_text: String::new(),
            info_text: "AstraWeave Unified Showcase".to_string(),
            current_texture_pack: "grassland".to_string(),
            available_texture_packs: vec![
                "grassland".to_string(),
                "desert".to_string(),
                "forest".to_string(),
            ],
            debug_material_tint: false,
            lod_profiles,
            active_lod_category: LodCategory::Trees,
            lod_step_near: 5.0,
            lod_step_far: 10.0,
            lod_step_keep: 0.05,
            frustum_culling: true,
        }
    }
}

impl UiState {
    fn ensure_lod_profile(&mut self, biome: &str) {
        if !self.lod_profiles.contains_key(biome) {
            let profile = match biome {
                "desert" => BiomeLodSettings::desert(),
                "forest" => BiomeLodSettings::forest(),
                _ => BiomeLodSettings::grassland(),
            };
            self.lod_profiles
                .insert(biome.to_string(), profile);
        }
    }

    fn active_lod_settings(&self) -> &BiomeLodSettings {
        let fallback = self
            .lod_profiles
            .get("grassland")
            .expect("Grassland profile must exist");
        self.lod_profiles
            .get(&self.current_texture_pack)
            .unwrap_or(fallback)
    }

    fn active_lod_settings_mut(&mut self) -> &mut BiomeLodSettings {
        let biome_owned = self.current_texture_pack.clone();
        let biome = biome_owned.as_str();
        if !self.lod_profiles.contains_key(biome) {
            let profile = match biome {
                "desert" => BiomeLodSettings::desert(),
                "forest" => BiomeLodSettings::forest(),
                _ => BiomeLodSettings::grassland(),
            };
            self.lod_profiles.insert(biome.to_string(), profile);
        }
        self.lod_profiles.get_mut(biome).expect("LOD profile must exist for active biome")
    }

    fn cycle_lod_category(&mut self) {
        self.active_lod_category = self.active_lod_category.next();
    }

    fn adjust_near(&mut self, delta: f32) {
        let cat = self.active_lod_category;
        let settings = self.active_lod_settings_mut().for_category_mut(cat);
        settings.adjust_near(delta);
    }

    fn adjust_far(&mut self, delta: f32) {
        let cat = self.active_lod_category;
        let settings = self.active_lod_settings_mut().for_category_mut(cat);
        settings.adjust_far(delta);
    }

    fn adjust_keep(&mut self, delta: f32) {
        let cat = self.active_lod_category;
        let settings = self.active_lod_settings_mut().for_category_mut(cat);
        settings.adjust_keep(delta);
    }

    fn refresh_info_text(&mut self, character_count: usize) {
        let profile = self.active_lod_settings().for_category(self.active_lod_category);
        self.info_text = format!(
            "Environment: {} ({} characters)\nLOD {} → near {:.0}m / far {:.0}m / keep {:.2}",
            self.current_texture_pack,
            character_count,
            self.active_lod_category.label(),
            profile.near,
            profile.far,
            profile.keep,
        );
    }
}

// ------------------------------- Camera -------------------------------
// Use the proper camera system from astraweave-render

// ------------------------------- Character System -------------------------------

#[derive(Clone)]
struct Character {
    position: Vec3,
    velocity: Vec3,
    target_position: Vec3,
    character_type: CharacterType,
    animation_time: f32,
    patrol_points: Vec<Vec3>,
    current_patrol_index: usize,
}

#[derive(Clone, Copy)]
enum CharacterType {
    Villager,
    Guard,
    Merchant,
    Animal,
}

impl CharacterType {
    fn as_u32(self) -> u32 {
        match self {
            CharacterType::Villager => 0,
            CharacterType::Guard => 1,
            CharacterType::Merchant => 2,
            CharacterType::Animal => 3,
        }
    }
}

impl Character {
    fn new(pos: Vec3, char_type: CharacterType) -> Self {
        Self {
            position: pos,
            velocity: Vec3::ZERO,
            target_position: pos,
            character_type: char_type,
            animation_time: 0.0,
            patrol_points: Vec::new(),
            current_patrol_index: 0,
        }
    }

    fn update(&mut self, dt: f32) {
        self.animation_time += dt;

        // Simple AI behavior - move towards target
        let direction = (self.target_position - self.position).normalize_or_zero();
        let speed = match self.character_type {
            CharacterType::Villager => 1.5,
            CharacterType::Guard => 2.0,
            CharacterType::Merchant => 1.2,
            CharacterType::Animal => 2.5,
        };

        self.velocity = direction * speed;
        self.position += self.velocity * dt;

        // Check if reached target and update patrol
        if (self.position - self.target_position).length() < 1.0 && !self.patrol_points.is_empty() {
            self.current_patrol_index = (self.current_patrol_index + 1) % self.patrol_points.len();
            self.target_position = self.patrol_points[self.current_patrol_index];
        }
    }

    fn get_color(&self) -> [f32; 4] {
        match self.character_type {
            CharacterType::Villager => [0.8, 0.6, 0.4, 1.0], // Tan
            CharacterType::Guard => [0.3, 0.3, 0.8, 1.0],    // Blue
            CharacterType::Merchant => [0.6, 0.3, 0.8, 1.0], // Purple
            CharacterType::Animal => [0.9, 0.7, 0.5, 1.0],   // Light brown
        }
    }
}

// ------------------------------- Physics -------------------------------

struct Physics {
    pipeline: r3::PhysicsPipeline,
    gravity: r3::Vector<f32>,
    islands: r3::IslandManager,
    broad: r3::DefaultBroadPhase,
    narrow: r3::NarrowPhase,
    bodies: r3::RigidBodySet,
    colliders: r3::ColliderSet,
    impulse_joints: r3::ImpulseJointSet,
    multibody_joints: r3::MultibodyJointSet,
    ccd: r3::CCDSolver,
    query_pipeline: r3::QueryPipeline,
    integration_params: r3::IntegrationParameters,
}

#[allow(dead_code)] // Type alias may be used in future iterations
type Real = f32;

// ------------------------------- Texture Pack Loading -------------------------------

fn load_texture_pack(path: &Path) -> Result<TexturePack> {
    let content = fs::read_to_string(path)?;
    let pack: TexturePack = toml::from_str(&content)?;
    Ok(pack)
}

fn mip_level_count_for(size: wgpu::Extent3d) -> u32 {
    let max_dim = size.width.max(size.height).max(size.depth_or_array_layers);
    // floor(log2(max_dim)) + 1 for full chain including base level
    let max_dim = max_dim.max(1);
    (f32::log2(max_dim as f32).floor() as u32) + 1
}

fn load_texture_from_bytes_with_format(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
    bytes: &[u8],
    label: &str,
    format: wgpu::TextureFormat,
) -> Result<LoadedTexture> {
    println!("Loading texture '{}' from {} bytes", label, bytes.len());
    let img = image::load_from_memory(bytes)?;
    let rgba = img.to_rgba8();
    let dimensions = img.dimensions();
    println!(
        "Texture '{}' loaded successfully: {}x{} pixels",
        label, dimensions.0, dimensions.1
    );

    let size = wgpu::Extent3d {
        width: dimensions.0,
        height: dimensions.1,
        depth_or_array_layers: 1,
    };

    let mip_levels = mip_level_count_for(size);
    let texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some(label),
        size,
        mip_level_count: mip_levels,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format,
        usage: wgpu::TextureUsages::TEXTURE_BINDING
            | wgpu::TextureUsages::COPY_DST
            | wgpu::TextureUsages::RENDER_ATTACHMENT,
        view_formats: &[],
    });

    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &texture,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &rgba,
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4 * dimensions.0),
            rows_per_image: Some(dimensions.1),
        },
        size,
    );

    // Generate mipmaps using a simple render pass downsampling
    generate_mipmaps(device, queue, &texture, format, size, mip_levels, 0, 1);

    let view = texture.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::Repeat,
        address_mode_v: wgpu::AddressMode::Repeat,
        address_mode_w: wgpu::AddressMode::Repeat,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
        anisotropy_clamp: 16,
        ..Default::default()
    });

    println!("Successfully created texture resources for '{}'", label);

    Ok(LoadedTexture {
        texture,
        view,
        sampler,
    })
}

fn generate_mipmaps(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
    texture: &wgpu::Texture,
    format: wgpu::TextureFormat,
    size: wgpu::Extent3d,
    mip_levels: u32,
    base_layer: u32,
    layer_count: u32,
) {
    if mip_levels <= 1 {
        return;
    }

    // Shader to sample from previous mip level and write into current target level
    const MIPMAP_SHADER: &str = r#"
struct VsOut { @builtin(position) pos: vec4<f32>, @location(0) uv: vec2<f32> };
@vertex fn vs(@builtin(vertex_index) vi: u32) -> VsOut {
  var out: VsOut;
  let xy = vec2<f32>(f32(i32(vi) - 1), f32((i32(vi) & 1) * 2 - 1));
  out.pos = vec4<f32>(xy, 0.0, 1.0);
  out.uv = vec2<f32>( (xy.x+1.0)*0.5, 1.0 - (xy.y+1.0)*0.5 );
  return out;
}

@group(0) @binding(0) var src_tex: texture_2d<f32>;
@group(0) @binding(1) var src_smp: sampler;

@fragment fn fs(in: VsOut) -> @location(0) vec4<f32> {
  // Simple linear sample; hardware does the filtering
  let c = textureSample(src_tex, src_smp, in.uv);
  return c;
}
"#;

    let sm = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("mipmap-gen-shader"),
        source: wgpu::ShaderSource::Wgsl(Cow::Borrowed(MIPMAP_SHADER)),
    });

    let bgl = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("mipmap-bgl"),
        entries: &[
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Texture {
                    multisampled: false,
                    view_dimension: wgpu::TextureViewDimension::D2,
                    sample_type: wgpu::TextureSampleType::Float { filterable: true },
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 1,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                count: None,
            },
        ],
    });

    let pl = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("mipmap-pl"),
        bind_group_layouts: &[&bgl],
        push_constant_ranges: &[],
    });

    let rp = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("mipmap-pipeline"),
        layout: Some(&pl),
        vertex: wgpu::VertexState {
            module: &sm,
            entry_point: "vs",
            buffers: &[],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        },
        fragment: Some(wgpu::FragmentState {
            module: &sm,
            entry_point: "fs",
            targets: &[Some(wgpu::ColorTargetState {
                format,
                blend: None,
                write_mask: wgpu::ColorWrites::ALL,
            })],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        }),
        primitive: wgpu::PrimitiveState::default(),
        depth_stencil: None,
        multisample: wgpu::MultisampleState::default(),
        multiview: None,
    });

    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        label: Some("mipmap-linear-sampler"),
        address_mode_u: wgpu::AddressMode::ClampToEdge,
        address_mode_v: wgpu::AddressMode::ClampToEdge,
        address_mode_w: wgpu::AddressMode::ClampToEdge,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
        ..Default::default()
    });

    let mut encoder = device.create_command_encoder(&wgpu::CommandEncoderDescriptor {
        label: Some("mipmap-encoder"),
    });

    for layer in base_layer..(base_layer + layer_count) {
        let mut src_w = size.width;
        let mut src_h = size.height;
        for level in 1..mip_levels {
            src_w = (src_w.max(1) / 2).max(1);
            src_h = (src_h.max(1) / 2).max(1);

            let src_view = texture.create_view(&wgpu::TextureViewDescriptor {
                label: Some("mip-src-view"),
                format: Some(format),
                dimension: Some(wgpu::TextureViewDimension::D2),
                aspect: wgpu::TextureAspect::All,
                base_mip_level: level - 1,
                mip_level_count: Some(1),
                base_array_layer: layer,
                array_layer_count: Some(1),
            });

            let bind = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("mipmap-bg"),
                layout: &bgl,
                entries: &[
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::TextureView(&src_view),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Sampler(&sampler),
                    },
                ],
            });

            let dst_view = texture.create_view(&wgpu::TextureViewDescriptor {
                label: Some("mip-dst-view"),
                format: Some(format),
                dimension: Some(wgpu::TextureViewDimension::D2),
                aspect: wgpu::TextureAspect::All,
                base_mip_level: level,
                mip_level_count: Some(1),
                base_array_layer: layer,
                array_layer_count: Some(1),
            });

            let mut rpass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                label: Some("mipmap-pass"),
                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                    view: &dst_view,
                    resolve_target: None,
                    ops: wgpu::Operations {
                        load: wgpu::LoadOp::Clear(wgpu::Color::TRANSPARENT),
                        store: wgpu::StoreOp::Store,
                    },
                })],
                depth_stencil_attachment: None,
                timestamp_writes: None,
                occlusion_query_set: None,
            });
            rpass.set_pipeline(&rp);
            rpass.set_bind_group(0, &bind, &[]);
            rpass.draw(0..3, 0..1);
            drop(rpass);
        }
    }

    queue.submit(Some(encoder.finish()));
}

fn load_texture_from_file(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
    path: &Path,
) -> Result<LoadedTexture> {
    println!("Attempting to load texture from file: {}", path.display());
    if !path.exists() {
        eprintln!("ERROR: Texture file does not exist: {}", path.display());
        return Err(anyhow::anyhow!(
            "Texture file not found: {}",
            path.display()
        ));
    }
    let bytes = fs::read(path).map_err(|e| {
        eprintln!("Failed to read texture file: {}", e);
        anyhow::anyhow!("Texture file not found: {}", path.display())
    })?;
    println!(
        "Successfully read {} bytes from {}",
        bytes.len(),
        path.display()
    );
    // Decide texture format by filename convention
    // *_n.* (normal) and *_mra.* should be UNORM; albedo/emissive use sRGB
    let name_lc = path
        .file_stem()
        .and_then(|s| s.to_str())
        .unwrap_or("")
        .to_ascii_lowercase();
    let is_normal = name_lc.ends_with("_n");
    let is_mra = name_lc.ends_with("_mra");
    let format = if is_normal || is_mra {
        println!(
            "Inferred UNORM format (non-sRGB) for texture: {}",
            path.display()
        );
        wgpu::TextureFormat::Rgba8Unorm
    } else {
        println!("Inferred sRGB format for texture: {}", path.display());
        wgpu::TextureFormat::Rgba8UnormSrgb
    };
    load_texture_from_bytes_with_format(device, queue, &bytes, &path.to_string_lossy(), format)
}

fn load_override_material_image(path_str: &str, width: u32, height: u32) -> Option<RgbaImage> {
    let path = resolve_asset_path(path_str);
    if !path.exists() {
        eprintln!(
            "⚠️ Material override '{}' not found at {}.",
            path_str,
            path.display()
        );
        return None;
    }

    match load_rgba_image(&path) {
        Ok(img) => {
            println!(
                "✓ Material override '{}' loaded from {}",
                path_str,
                path.display()
            );
            Some(resize_image_if_needed(&img, width, height))
        }
        Err(err) => {
            eprintln!(
                "⚠️ Failed to read material override {} ({}).",
                path.display(),
                err
            );
            None
        }
    }
}

// apply_material_override: legacy direct GPU writes removed; overrides should be expressed in TOML packs

// legacy reload removed; now handled by MaterialIntegrator

// initialize_biome_materials removed; integrator handles this

fn switch_biome(
    render: &mut RenderStuff,
    physics: &mut Physics,
    biome_name: &str,
) -> Result<Vec<Character>> {
    println!("Switching to biome: {}", biome_name);

    // Materials are managed by MaterialIntegrator now; switching biome will be handled via its reload path in event loop.

    render.current_biome = biome_name.to_string();

    let new_objects = generate_environment_objects(physics, biome_name);
    println!(
        "Successfully switched to biome: {} ({} characters)",
        biome_name,
        new_objects.len()
    );
    Ok(new_objects)
}

struct ShadowRuntimeSettings {
    resolution: u32,
    cascade_count: u32,
    softness: f32,
    bias: f32,
    cascade_splits: [f32; 4],
}

fn compute_shadow_runtime_settings(camera_height: f32) -> ShadowRuntimeSettings {
    let resolution = if camera_height > 60.0 {
        4096
    } else if camera_height > 30.0 {
        2048
    } else {
        1024
    };

    let softness = if camera_height > 60.0 {
        2.0
    } else if camera_height > 30.0 {
        1.6
    } else {
        1.2
    };

    let base_bias = 0.0004 + (camera_height * 0.00001);

    let cascade_count = if camera_height > 55.0 {
        4
    } else if camera_height > 35.0 {
        3
    } else if camera_height > 18.0 {
        2
    } else {
        1
    };

    let splits = [25.0, 80.0, 160.0, 320.0];

    ShadowRuntimeSettings {
        resolution,
        cascade_count,
        softness,
        bias: base_bias,
        cascade_splits: splits,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn loads_grassland_biome_toml() {
        let (doc, _base) = load_biome_toml("grassland").expect("grassland materials.toml should parse");
        assert_eq!(doc.biome.name, "grassland");
        assert!(doc.layer.iter().any(|l| l.key == "grass"));
    }

    #[test]
    fn loads_desert_biome_toml() {
        let (doc, _base) = load_biome_toml("desert").expect("desert materials.toml should parse");
        assert_eq!(doc.biome.name, "desert");
        assert!(doc.layer.iter().any(|l| l.key == "sand"));
    }

    #[test]
    fn loads_forest_biome_toml() {
        let (doc, _base) = load_biome_toml("forest").expect("forest materials.toml should parse");
        assert_eq!(doc.biome.name, "forest");
        assert!(doc.layer.iter().any(|l| l.key == "forest_floor"));
    }
}

fn recreate_shadow_resources(render: &mut RenderStuff, resolution: u32) {
    let shadow_tex = render.device.create_texture(&wgpu::TextureDescriptor {
        label: Some("shadow-map"),
        size: wgpu::Extent3d {
            width: resolution,
            height: resolution,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Depth32Float,
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::TEXTURE_BINDING,
        view_formats: &[],
    });

    render.shadow_view = shadow_tex.create_view(&wgpu::TextureViewDescriptor::default());
    render.shadow_bg = render.device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("shadow-bg"),
        layout: &render.shadow_bg_layout,
        entries: &[
            wgpu::BindGroupEntry {
                binding: 0,
                resource: wgpu::BindingResource::TextureView(&render.shadow_view),
            },
            wgpu::BindGroupEntry {
                binding: 1,
                resource: wgpu::BindingResource::Sampler(&render.shadow_sampler),
            },
        ],
    });

    render.shadow_size = resolution;
}

fn generate_environment_objects(physics: &mut Physics, texture_pack_name: &str) -> Vec<Character> {
    // Clear existing objects (keep ground and first few objects as player/sphere)
    let mut handles_to_remove = Vec::new();
    for (handle, body) in physics.bodies.iter() {
        if body.user_data > 2 {
            // Keep player objects (user_data 1, 2)
            handles_to_remove.push(handle);
        }
    }

    for handle in handles_to_remove {
        physics.bodies.remove(
            handle,
            &mut physics.islands,
            &mut physics.colliders,
            &mut physics.impulse_joints,
            &mut physics.multibody_joints,
            true,
        );
    }

    let mut characters = Vec::new();

    // Generate comprehensive biome environments
    match texture_pack_name {
        "grassland" => {
            // === VEGETATION ===
            // Dense forest areas with varied tree types - significantly increased density
            for i in 0..75 {
                let x = -35.0 + (i as f32) * 1.2 + (i as f32 * 0.7).sin() * 2.5;
                let z = -25.0 + (i % 8) as f32 * 4.0 + (i as f32 * 0.9).cos() * 3.0;

                // Vary tree types and sizes for realistic forest
                let (height, width, _tree_type) = match i % 4 {
                    0 => (2.5, 0.3, "oak"),     // Large oak trees
                    1 => (1.8, 0.2, "pine"),    // Medium pine trees
                    2 => (1.2, 0.15, "birch"),  // Small birch trees
                    _ => (3.0, 0.4, "ancient"), // Ancient giant trees
                };

                let base_y = terrain_surface_y(x, z);
                let tree_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + height, z))
                    .user_data(10 + i)
                    .build();
                let tree_handle = physics.bodies.insert(tree_rb);
                let tree_col = r3::ColliderBuilder::cuboid(width, height, width).build();
                physics
                    .colliders
                    .insert_with_parent(tree_col, tree_handle, &mut physics.bodies);
            }

            // Scattered bushes and undergrowth - increased density
            for i in 0..35 {
                let x = -15.0 + (i as f32) * 2.5 + (i as f32 * 1.3).sin() * 5.0;
                let z = 5.0 + (i as f32 * 1.1).cos() * 12.0;
                let size = 0.2 + (i % 3) as f32 * 0.1;

                let base_y = terrain_surface_y(x, z);
                let bush_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + size * 0.6, z))
                    .user_data(100 + i)
                    .build();
                let bush_handle = physics.bodies.insert(bush_rb);
                let bush_col = r3::ColliderBuilder::cuboid(size, size * 0.6, size).build();
                physics
                    .colliders
                    .insert_with_parent(bush_col, bush_handle, &mut physics.bodies);
            }

            // === STRUCTURES ===
            // Village with varied building types - more structures
            for i in 0..15 {
                let x = 15.0 + (i as f32) * 6.0 + (i as f32).sin() * 4.0;
                let z = -8.0 + (i % 4) as f32 * 8.0 + (i as f32).cos() * 3.0;

                let (width, height, depth, _building_type) = match i % 5 {
                    0 => (2.2, 1.5, 1.8, "manor"),    // Large manor house
                    1 => (1.5, 1.0, 1.2, "cottage"),  // Medium cottage
                    2 => (1.0, 0.8, 1.0, "hut"),      // Small hut
                    3 => (2.8, 2.0, 2.0, "temple"),   // Village temple
                    _ => (1.8, 1.2, 1.5, "workshop"), // Workshops and shops
                };

                let base_y = terrain_surface_y(x, z);
                let house_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + height, z))
                    .user_data(35 + i)
                    .build();
                let house_handle = physics.bodies.insert(house_rb);
                let house_col = r3::ColliderBuilder::cuboid(width, height, depth).build();
                physics
                    .colliders
                    .insert_with_parent(house_col, house_handle, &mut physics.bodies);
            }

            // === GEOLOGICAL FEATURES ===
            // Rolling hills with scattered boulders - increased geological features
            for i in 0..25 {
                let x = -30.0 + (i as f32) * 6.0 + (i as f32 * 2.1).sin() * 8.0;
                let z = 20.0 + (i as f32 * 1.7).cos() * 10.0;
                let size = 0.8 + (i % 4) as f32 * 0.5;

                let base_y = terrain_surface_y(x, z);
                let boulder_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + size * 0.8, z))
                    .user_data(60 + i)
                    .build();
                let boulder_handle = physics.bodies.insert(boulder_rb);
                let boulder_col = r3::ColliderBuilder::cuboid(size, size * 0.8, size * 1.1).build();
                physics.colliders.insert_with_parent(
                    boulder_col,
                    boulder_handle,
                    &mut physics.bodies,
                );
            }

            // Stone circles and ancient ruins
            for i in 0..6 {
                let angle = (i as f32) * std::f32::consts::PI * 2.0 / 6.0;
                let radius = 12.0;
                let x = radius * angle.cos();
                let z = radius * angle.sin() + 30.0;
                let height = 1.5 + (i % 2) as f32 * 0.8;

                let base_y = terrain_surface_y(x, z);
                let stone_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + height, z))
                    .user_data(200 + i)
                    .build();
                let stone_handle = physics.bodies.insert(stone_rb);
                let stone_col = r3::ColliderBuilder::cuboid(0.4, height, 0.3).build();
                physics
                    .colliders
                    .insert_with_parent(stone_col, stone_handle, &mut physics.bodies);
            }

            // === WATER FEATURES ===
            // River with stone banks
            for i in 0..10 {
                let x = -15.0 + (i as f32) * 3.0;
                let z = -30.0 + (i as f32) * 2.0 + (i as f32 * 2.0).sin() * 8.0;
                let size = 0.3 + (i % 2) as f32 * 0.2;

                let base_y = terrain_surface_y(x, z);
                let bank_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y - 0.5, z))
                    .user_data(300 + i)
                    .build();
                let bank_handle = physics.bodies.insert(bank_rb);
                let bank_col = r3::ColliderBuilder::cuboid(size, 0.2, size * 1.5).build();
                physics
                    .colliders
                    .insert_with_parent(bank_col, bank_handle, &mut physics.bodies);
            }

            // === CHARACTERS ===
            // Village inhabitants with varied roles and patrol patterns - more NPCs
            for i in 0..20 {
                let x = 10.0 + (i as f32) * 4.0 + (i as f32).sin() * 4.0;
                let z = -12.0 + (i as f32 * 1.3).sin() * 15.0;
                let pos = Vec3::new(x, terrain_surface_y(x, z) + 0.5, z);

                let char_type = match i % 5 {
                    0 => CharacterType::Villager,
                    1 => CharacterType::Guard,
                    2 => CharacterType::Merchant,
                    3 => CharacterType::Animal,
                    _ => CharacterType::Villager,
                };

                let mut character = Character::new(pos, char_type);

                // Complex patrol routes for realistic behavior
                match char_type {
                    CharacterType::Guard => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(8.0, 0.0, 2.0),
                            pos + Vec3::new(6.0, 0.0, 8.0),
                            pos + Vec3::new(-2.0, 0.0, 6.0),
                            pos + Vec3::new(-4.0, 0.0, 0.0),
                        ];
                    }
                    CharacterType::Merchant => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(12.0, 0.0, 0.0),
                            pos + Vec3::new(8.0, 0.0, -6.0),
                        ];
                    }
                    CharacterType::Animal => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(4.0, 0.0, 4.0),
                            pos + Vec3::new(-3.0, 0.0, 2.0),
                            pos + Vec3::new(1.0, 0.0, -3.0),
                        ];
                    }
                    _ => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(3.0, 0.0, 0.0),
                            pos + Vec3::new(3.0, 0.0, 3.0),
                            pos + Vec3::new(0.0, 0.0, 3.0),
                        ];
                    }
                }
                character.target_position = if !character.patrol_points.is_empty() {
                    character.patrol_points[1]
                } else {
                    pos
                };

                characters.push(character);
            }
        }
        "desert" => {
            // === VEGETATION ===
            // Varied cacti and desert plants - increased density
            for i in 0..40 {
                let x = -25.0 + (i as f32) * 3.0 + (i as f32 * 1.2).sin() * 4.0;
                let z = -15.0 + (i % 6) as f32 * 6.0 + (i as f32).cos() * 8.0;

                let (width, height, _cactus_type) = match i % 5 {
                    0 => (0.2, 3.5, "saguaro"),       // Tall saguaro cactus
                    1 => (0.4, 1.0, "barrel"),        // Barrel cactus
                    2 => (0.15, 2.2, "prickly_pear"), // Prickly pear
                    3 => (0.25, 1.8, "cholla"),       // Cholla cactus
                    _ => (0.3, 0.6, "desert_shrub"),  // Desert shrub
                };

                let base_y = terrain_surface_y(x, z);
                let cactus_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + height, z))
                    .user_data(30 + i)
                    .build();
                let cactus_handle = physics.bodies.insert(cactus_rb);
                let cactus_col = r3::ColliderBuilder::cuboid(width, height, width).build();
                physics.colliders.insert_with_parent(
                    cactus_col,
                    cactus_handle,
                    &mut physics.bodies,
                );
            }

            // === STRUCTURES ===
            // Desert settlement with adobe architecture - more buildings
            for i in 0..12 {
                let x = 20.0 + (i as f32) * 8.0 + (i as f32).cos() * 5.0;
                let z = 5.0 + (i % 3) as f32 * 12.0 + (i as f32).sin() * 4.0;

                let (width, height, depth, _building_type) = match i % 3 {
                    0 => (2.5, 1.2, 2.0, "adobe_compound"), // Large compound
                    1 => (1.8, 0.9, 1.5, "adobe_house"),    // Medium house
                    _ => (3.0, 1.8, 2.5, "adobe_temple"),   // Temple/mosque
                };

                let base_y = terrain_surface_y(x, z);
                let adobe_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + height, z))
                    .user_data(40 + i)
                    .build();
                let adobe_handle = physics.bodies.insert(adobe_rb);
                let adobe_col = r3::ColliderBuilder::cuboid(width, height, depth).build();
                physics
                    .colliders
                    .insert_with_parent(adobe_col, adobe_handle, &mut physics.bodies);
            }

            // === GEOLOGICAL FEATURES ===
            // Mesa formations and desert rock outcrops - more geological variety
            for i in 0..25 {
                let x = -30.0 + (i as f32) * 5.0 + (i as f32 * 1.9).sin() * 10.0;
                let z = 25.0 + (i as f32 * 1.3).cos() * 12.0;
                let size = 1.2 + (i % 5) as f32 * 0.8;

                let (width, height, depth) = match i % 4 {
                    0 => (size, size * 2.0, size * 0.8),       // Tall mesa
                    1 => (size * 1.5, size, size * 1.2),       // Wide plateau
                    2 => (size * 0.6, size * 3.0, size * 0.6), // Spire
                    _ => (size, size * 0.8, size),             // Regular rock
                };

                let base_y = terrain_surface_y(x, z);
                let formation_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + height, z))
                    .user_data(76 + i)
                    .build();
                let formation_handle = physics.bodies.insert(formation_rb);
                let formation_col = r3::ColliderBuilder::cuboid(width, height, depth).build();
                physics.colliders.insert_with_parent(
                    formation_col,
                    formation_handle,
                    &mut physics.bodies,
                );
            }

            // Sand dunes (represented as low, wide formations)
            for i in 0..8 {
                let x = 0.0 + (i as f32) * 15.0 + (i as f32 * 2.5).sin() * 10.0;
                let z = -25.0 + (i as f32 * 1.8).cos() * 15.0;
                let width = 4.0 + (i % 3) as f32 * 2.0;
                let height = 0.5 + (i % 2) as f32 * 0.3;

                let base_y = terrain_surface_y(x, z);
                let dune_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + height, z))
                    .user_data(400 + i)
                    .build();
                let dune_handle = physics.bodies.insert(dune_rb);
                let dune_col = r3::ColliderBuilder::cuboid(width, height, width * 0.6).build();
                physics
                    .colliders
                    .insert_with_parent(dune_col, dune_handle, &mut physics.bodies);
            }

            // === WATER FEATURES ===
            // Oasis with palm-like vegetation
            let oasis_x = 5.0;
            let oasis_z = 10.0;
            for i in 0..5 {
                let angle = (i as f32) * std::f32::consts::PI * 2.0 / 5.0;
                let radius = 3.0;
                let x = oasis_x + radius * angle.cos();
                let z = oasis_z + radius * angle.sin();

                let base_y = terrain_surface_y(x, z);
                let palm_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + 2.0, z))
                    .user_data(500 + i)
                    .build();
                let palm_handle = physics.bodies.insert(palm_rb);
                let palm_col = r3::ColliderBuilder::cuboid(0.2, 2.0, 0.2).build();
                physics
                    .colliders
                    .insert_with_parent(palm_col, palm_handle, &mut physics.bodies);
            }

            // === CHARACTERS ===
            // Desert nomads and traders
            for i in 0..8 {
                let x = 15.0 + (i as f32) * 12.0 + (i as f32).sin() * 5.0;
                let z = -5.0 + (i as f32 * 0.9).sin() * 8.0;
                let pos = Vec3::new(x, terrain_surface_y(x, z) + 0.5, z);

                let char_type = match i % 4 {
                    0 => CharacterType::Merchant,
                    1 => CharacterType::Guard,
                    2 => CharacterType::Animal, // Desert animals (camels, etc.)
                    _ => CharacterType::Villager, // Nomads
                };

                let mut character = Character::new(pos, char_type);

                // Longer patrol routes for desert environment
                match char_type {
                    CharacterType::Merchant => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(20.0, 0.0, 5.0),
                            pos + Vec3::new(15.0, 0.0, 15.0),
                            pos + Vec3::new(-5.0, 0.0, 10.0),
                        ];
                    }
                    CharacterType::Animal => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(8.0, 0.0, 8.0),
                            pos + Vec3::new(-5.0, 0.0, 12.0),
                            pos + Vec3::new(-8.0, 0.0, -3.0),
                        ];
                    }
                    _ => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(10.0, 0.0, 3.0),
                            pos + Vec3::new(6.0, 0.0, 8.0),
                            pos + Vec3::new(-3.0, 0.0, 5.0),
                        ];
                    }
                }
                character.target_position = if !character.patrol_points.is_empty() {
                    character.patrol_points[1]
                } else {
                    pos
                };

                characters.push(character);
            }
        }
        "forest" => {
            // === DENSE FOREST BIOME ===
            // Ancient forest with towering trees and rich undergrowth

            // === VEGETATION ===
            // Ancient towering trees - higher density for deep forest feeling
            for i in 0..95 {
                let x = -40.0 + (i as f32) * 1.1 + (i as f32 * 0.6).sin() * 3.0;
                let z = -30.0 + (i % 10) as f32 * 3.8 + (i as f32 * 0.8).cos() * 4.0;

                // Varied ancient tree types with dramatic height differences
                let (height, width, _tree_type) = match i % 6 {
                    0 => (4.5, 0.6, "ancient_oak"), // Massive ancient oaks
                    1 => (3.8, 0.4, "giant_pine"),  // Tall pines
                    2 => (2.8, 0.3, "elder_birch"), // Elder birch
                    3 => (5.2, 0.8, "world_tree"),  // Mythical world trees
                    4 => (3.2, 0.35, "cedar"),      // Tall cedars
                    _ => (2.2, 0.25, "maple"),      // Forest maples
                };

                let base_y = terrain_surface_y(x, z);
                let tree_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + height, z))
                    .user_data(10 + i)
                    .build();
                let tree_handle = physics.bodies.insert(tree_rb);
                let tree_col = r3::ColliderBuilder::cuboid(width, height, width).build();
                physics
                    .colliders
                    .insert_with_parent(tree_col, tree_handle, &mut physics.bodies);
            }

            // Dense undergrowth and ferns - forest floor vegetation
            for i in 0..60 {
                let x = -25.0 + (i as f32) * 2.0 + (i as f32 * 1.4).sin() * 6.0;
                let z = 8.0 + (i as f32 * 1.2).cos() * 15.0;
                let size = 0.15 + (i % 4) as f32 * 0.08;

                let base_y = terrain_surface_y(x, z);
                let undergrowth_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + size * 0.5, z))
                    .user_data(150 + i)
                    .build();
                let undergrowth_handle = physics.bodies.insert(undergrowth_rb);
                let undergrowth_col = r3::ColliderBuilder::cuboid(size, size * 0.5, size).build();
                physics.colliders.insert_with_parent(
                    undergrowth_col,
                    undergrowth_handle,
                    &mut physics.bodies,
                );
            }

            // === STRUCTURES ===
            // Woodland dwellings and mystical sites
            for i in 0..8 {
                let x = 25.0 + (i as f32) * 8.0 + (i as f32).sin() * 6.0;
                let z = -5.0 + (i % 3) as f32 * 10.0 + (i as f32).cos() * 4.0;

                let (width, height, depth, _building_type) = match i % 4 {
                    0 => (2.0, 1.8, 1.6, "tree_house"),      // Elevated tree houses
                    1 => (1.2, 2.5, 1.2, "wizard_tower"),    // Tall mystical towers
                    2 => (2.5, 1.0, 2.5, "woodland_shrine"), // Ground-level shrines
                    _ => (1.6, 1.4, 1.4, "ranger_cabin"),    // Ranger cabins
                };

                let base_y = terrain_surface_y(x, z);
                let structure_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + height, z))
                    .user_data(200 + i)
                    .build();
                let structure_handle = physics.bodies.insert(structure_rb);
                let structure_col = r3::ColliderBuilder::cuboid(width, height, depth).build();
                physics.colliders.insert_with_parent(
                    structure_col,
                    structure_handle,
                    &mut physics.bodies,
                );
            }

            // === GEOLOGICAL FEATURES ===
            // Moss-covered boulders and ancient stone formations
            for i in 0..18 {
                let x = -35.0 + (i as f32) * 7.0 + (i as f32 * 2.2).sin() * 10.0;
                let z = 25.0 + (i as f32 * 1.8).cos() * 12.0;
                let size = 1.0 + (i % 3) as f32 * 0.6;

                let base_y = terrain_surface_y(x, z);
                let boulder_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + size * 0.8, z))
                    .user_data(250 + i)
                    .build();
                let boulder_handle = physics.bodies.insert(boulder_rb);
                let boulder_col = r3::ColliderBuilder::cuboid(size, size * 0.8, size * 0.9).build();
                physics.colliders.insert_with_parent(
                    boulder_col,
                    boulder_handle,
                    &mut physics.bodies,
                );
            }

            // Ancient stone circles (mystical sites)
            let circle_center_x = 0.0;
            let circle_center_z = 15.0;
            for i in 0..8 {
                let angle = (i as f32) * std::f32::consts::PI * 2.0 / 8.0;
                let radius = 8.0;
                let x = circle_center_x + radius * angle.cos();
                let z = circle_center_z + radius * angle.sin();

                let base_y = terrain_surface_y(x, z);
                let stone_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + 1.5, z))
                    .user_data(300 + i)
                    .build();
                let stone_handle = physics.bodies.insert(stone_rb);
                let stone_col = r3::ColliderBuilder::cuboid(0.5, 1.5, 0.3).build();
                physics
                    .colliders
                    .insert_with_parent(stone_col, stone_handle, &mut physics.bodies);
            }

            // === WATER FEATURES ===
            // Forest streams and pools
            for i in 0..3 {
                let x = -10.0 + (i as f32) * 15.0;
                let z = -12.0 + (i as f32) * 8.0;

                let base_y = terrain_surface_y(x, z);
                let pool_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + 0.2, z))
                    .user_data(350 + i)
                    .build();
                let pool_handle = physics.bodies.insert(pool_rb);
                let pool_col = r3::ColliderBuilder::cuboid(2.0, 0.2, 1.5).build();
                physics
                    .colliders
                    .insert_with_parent(pool_col, pool_handle, &mut physics.bodies);
            }

            // === CHARACTERS ===
            // Forest dwellers and mystical beings
            for i in 0..10 {
                let x = -20.0 + (i as f32) * 8.0 + (i as f32 * 1.1).sin() * 12.0;
                let z = -10.0 + (i as f32 * 0.9).cos() * 18.0;
                let pos = Vec3::new(x, terrain_surface_y(x, z) + 0.5, z);

                let char_type = match i % 5 {
                    0 => CharacterType::Guard,    // Forest rangers
                    1 => CharacterType::Merchant, // Herb gatherers
                    2 => CharacterType::Villager, // Forest dwellers
                    3 => CharacterType::Guard,    // Druids (using guard type)
                    _ => CharacterType::Villager, // Woodland folk
                };

                let mut character = Character::new(pos, char_type);

                // Forest-specific patrol routes through the trees
                match i % 4 {
                    0 => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(6.0, 0.0, 2.0),
                            pos + Vec3::new(4.0, 0.0, 8.0),
                            pos + Vec3::new(-2.0, 0.0, 6.0),
                            pos + Vec3::new(-4.0, 0.0, 2.0),
                        ];
                    }
                    1 => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(-5.0, 0.0, 3.0),
                            pos + Vec3::new(-3.0, 0.0, -4.0),
                            pos + Vec3::new(2.0, 0.0, -2.0),
                        ];
                    }
                    2 => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(8.0, 0.0, -1.0),
                            pos + Vec3::new(5.0, 0.0, -6.0),
                            pos + Vec3::new(-1.0, 0.0, -4.0),
                        ];
                    }
                    _ => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(2.0, 0.0, 7.0),
                            pos + Vec3::new(-3.0, 0.0, 5.0),
                            pos + Vec3::new(-1.0, 0.0, 1.0),
                        ];
                    }
                }

                characters.push(character);
            }
        }
        _ => {
            // Enhanced default environment with mixed biome features
            for i in 0..15 {
                let x = -12.0 + (i as f32) * 2.5;
                let z = 3.0 + (i % 3) as f32 * 6.0 + (i as f32).sin() * 3.0;
                let height = 1.0 + (i % 4) as f32 * 0.8;

                let obj_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(50 + i)
                    .build();
                let obj_handle = physics.bodies.insert(obj_rb);
                let obj_col = r3::ColliderBuilder::cuboid(0.6, height, 0.6).build();
                physics
                    .colliders
                    .insert_with_parent(obj_col, obj_handle, &mut physics.bodies);
            }

            // Default characters with simple behavior
            for i in 0..6 {
                let x = (i as f32) * 6.0;
                let z = (i % 2) as f32 * 4.0;
                let pos = Vec3::new(x, -1.0, z);
                let mut character = Character::new(pos, CharacterType::Villager);
                character.patrol_points = vec![
                    pos,
                    pos + Vec3::new(4.0, 0.0, 0.0),
                    pos + Vec3::new(4.0, 0.0, 4.0),
                    pos + Vec3::new(0.0, 0.0, 4.0),
                ];
                character.target_position = character.patrol_points[1];
                characters.push(character);
            }
        }
    }

    characters
}

// ------------------------------- Main entry -------------------------------

fn main() -> Result<()> {
    // Use pollster to block on the async run
    pollster::block_on(run())
}

async fn run() -> Result<()> {
    // Generate default textures at startup if missing (seed -> vary looks)
    let seed = 0xA57; // change to taste / hook to key for regeneration
    let asset_root = asset_dir();
    // Behind feature flag: keep procedural material generation for dev only
    #[cfg(feature = "procedural_fallback")]
    {
        // Do not overwrite existing high-fidelity assets at startup; only synthesize if missing
        texture_synth::ensure_textures(&asset_root.to_string_lossy(), seed, false)?;

        let materials_runtime_dir = asset_root.join("materials");
        texture_synth::ensure_textures(&materials_runtime_dir.to_string_lossy(), seed, false)?;

        let materials_source_dir = resolve_asset_src_path("materials");
        texture_synth::ensure_textures(&materials_source_dir.to_string_lossy(), seed, false)?;
    }

    // Boilerplate: create event loop and window
    let event_loop = EventLoop::new()?;
    let window = std::sync::Arc::new(
        WindowBuilder::new()
            .with_title("AstraWeave Unified Showcase (Modified)")
            .build(&event_loop)?,
    );
    // Setup renderer, UI, physics
    let mut render = setup_renderer(window.clone()).await?;
    let mut physics = build_physics_world();

    // Initialize default environment via shared texture/material pipeline
    println!("🌱 Initializing with grassland biome...");
    let mut characters = match switch_biome(&mut render, &mut physics, "grassland") {
        Ok(chars) => {
            println!(
                "✅ Successfully initialized grassland biome with {} characters",
                chars.len()
            );
            println!(
                "Controls: WASD+mouse=camera, P=pause physics, T=teleport sphere, E=apply impulse, C=toggle camera mode"
            );
            println!("Mouse wheel: zoom camera | Right-click + mouse: look around");
            println!("Texture packs: Press 1 for grassland, 2 for desert, 3 for forest");
            chars
        }
        Err(e) => {
            println!(
                "⚠ Warning: Failed to initialize grassland biome via material pipeline: {}",
                e
            );
            println!("Continuing with procedural fallback textures...");
            println!(
                "Note: You can still attempt biome switches using keys 1 (grassland), 2 (desert), and 3 (forest)"
            );
            let fallback = generate_environment_objects(&mut physics, "grassland");
            println!(
                "🌿 Generated {} character instances using fallback grassland environment",
                fallback.len()
            );
            fallback
        }
    };

    let mut instances = build_show_instances();
    let mut ui = UiState::default();
    if !render.current_biome.is_empty() {
        ui.current_texture_pack = render.current_biome.clone();
        ui.info_text = format!(
            "Environment: {} ({} characters)",
            render.current_biome,
            characters.len()
        );
    } else {
        ui.info_text = format!(
            "Environment: {} ({} characters)",
            ui.current_texture_pack,
            characters.len()
        );
    }

    // Use proper camera system from astraweave-render with enhanced positioning for optimal biome showcase
    let mut camera = RenderCamera {
        position: Vec3::new(15.0, 12.0, 30.0), // Enhanced position to better showcase biome diversity
        yaw: -0.3,   // Better angle to view village, forest, and terrain features
        pitch: -0.4, // Optimal pitch to see both terrain detail and sky
        fovy: 70f32.to_radians(), // Optimized field of view for biome immersion
        aspect: 1.0,
        znear: 0.01,
        zfar: 10000.0, // Extended far plane for maximum terrain visibility
    };
    let mut camera_controller = CameraController::new(8.0, 0.002);
    let start_time = Instant::now();
    let mut last = Instant::now();
    let mut fps_acc = 0.0;
    let mut fps_cnt = 0u32;

    let elwt = event_loop;
    // Track Shift for ToD controls
    let mut shift_down = false;
    let _ = elwt.run(move |event, elwt_window_target| {
        elwt_window_target.set_control_flow(winit::event_loop::ControlFlow::Poll);
        match event {
            Event::WindowEvent {
                event: win_event, ..
            } => {
                match win_event {
                    WindowEvent::CloseRequested => {
                        elwt_window_target.exit();
                    }
                    WindowEvent::KeyboardInput {
                        event:
                            KeyEvent {
                                physical_key,
                                state,
                                ..
                            },
                        ..
                    } => {
                        let pressed = state == ElementState::Pressed;
                        match physical_key {
                            PhysicalKey::Code(code) => {
                                camera_controller.process_keyboard(code, pressed);
                                match code {
                                    KeyCode::ShiftLeft | KeyCode::ShiftRight => {
                                        shift_down = pressed;
                                    }
                                    KeyCode::Escape => {
                                        if pressed {
                                            elwt_window_target.exit();
                                        }
                                    }
                                    KeyCode::KeyP => {
                                        if pressed {
                                            ui.physics_paused = !ui.physics_paused;
                                        }
                                    }
                                    KeyCode::KeyT => {
                                        if pressed {
                                            // Teleport sphere a few meters in front of camera
                                            let forward = astraweave_render::camera::Camera::dir(
                                                camera.yaw,
                                                camera.pitch,
                                            );
                                            let target = camera.position
                                                + forward * 4.0
                                                + Vec3::new(0.0, -0.5, 0.0);
                                            teleport_sphere_to(&mut physics, target);
                                        }
                                    }
                                    KeyCode::KeyE => {
                                        if pressed {
                                            // Raycast forward and apply impulse to first hit dynamic body
                                            let forward = astraweave_render::camera::Camera::dir(
                                                camera.yaw,
                                                camera.pitch,
                                            );

                                            // Create a ray for the query
                                            let ray_origin = nalgebra::Point3::new(
                                                camera.position.x,
                                                camera.position.y,
                                                camera.position.z,
                                            );
                                            let ray_dir = nalgebra::Vector3::new(
                                                forward.x, forward.y, forward.z,
                                            );
                                            let ray = r3::Ray::new(ray_origin, ray_dir);

                                            // Update the query pipeline with just the colliders
                                            physics.query_pipeline.update(&physics.colliders);

                                            // Cast the ray
                                            if let Some((h, _toi)) =
                                                physics.query_pipeline.cast_ray(
                                                    &physics.bodies,
                                                    &physics.colliders,
                                                    &ray,
                                                    15.0,
                                                    true,
                                                    r3::QueryFilter::default(),
                                                )
                                            {
                                                if let Some(body) =
                                                    physics.bodies.get_mut(r3::RigidBodyHandle(h.0))
                                                {
                                                    if !body.is_fixed() {
                                                        let impulse = nalgebra::Vector3::new(
                                                            forward.x * 3.0,
                                                            1.0,
                                                            forward.z * 3.0,
                                                        );
                                                        body.apply_impulse(impulse, true);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    KeyCode::KeyC => {
                                        if pressed {
                                            camera_controller.toggle_mode(&mut camera);
                                            println!("Camera mode: {:?}", camera_controller.mode);
                                        }
                                    }
                                    KeyCode::KeyM => {
                                        if pressed {
                                            ui.debug_material_tint = !ui.debug_material_tint;
                                            println!("Material debug tint: {}", ui.debug_material_tint);
                                        }
                                    }
                                    KeyCode::F9 => {
                                        if pressed {
                                            render.debug_show_layer_quads = !render.debug_show_layer_quads;
                                            println!("Layer debug overlay: {}", render.debug_show_layer_quads);
                                        }
                                    }
                                    KeyCode::KeyI => {
                                        if pressed {
                                            render.ibl_enabled = !render.ibl_enabled;
                                            println!("IBL {}", if render.ibl_enabled { "ON" } else { "OFF" });
                                        }
                                    }
                                    KeyCode::KeyR => {
                                        if pressed {
                                            // Throttle rebake to avoid spamming GPU work
                                            let secs = start_time.elapsed().as_secs_f32();
                                            if secs - render.ibl_last_update > 0.25 {
                                                render.ibl_last_update = secs;
                                                if let Some(ref mut mgr) = render.ibl2_manager {
                                                    if let Ok(res) = mgr.bake_environment(&render.device, &render.queue, IblQuality::Medium) {
                                                        // Rebuild active IBL bind group from manager outputs
                                                        let new_bg = render.device.create_bind_group(&wgpu::BindGroupDescriptor {
                                                            label: Some("ibl-bg (rebake)"),
                                                            layout: &render.ibl_bg_layout,
                                                            entries: &[
                                                                wgpu::BindGroupEntry { binding: 0, resource: wgpu::BindingResource::TextureView(&res.specular_cube) },
                                                                wgpu::BindGroupEntry { binding: 1, resource: wgpu::BindingResource::TextureView(&res.irradiance_cube) },
                                                                wgpu::BindGroupEntry { binding: 2, resource: wgpu::BindingResource::TextureView(&res.brdf_lut) },
                                                                wgpu::BindGroupEntry { binding: 3, resource: wgpu::BindingResource::Sampler(&render.ibl_sampler) },
                                                            ],
                                                        });
                                                        render.ibl_bg = new_bg;
                                                        println!("IBL rebaked using manager outputs.");
                                                    }
                                                } else {
                                                    println!("IBL manager not initialized; skipping rebake.");
                                                }
                                            }
                                        }
                                    }
                                    KeyCode::Digit1 => {
                                        if pressed {
                                            let biome_name = "grassland";
                                            println!("🌱 Switching to {} biome...", biome_name);
                                            match switch_biome(&mut render, &mut physics, biome_name)
                                            {
                                                Ok(new_chars) => {
                                                    ui.current_texture_pack = biome_name.to_string();
                                                    ui.info_text = format!(
                                                        "Switched to {} environment",
                                                        biome_name
                                                    );
                                                    println!(
                                                        "✅ Successfully switched to {} biome with {} characters",
                                                        biome_name,
                                                        new_chars.len()
                                                    );
                                                    characters = new_chars;
                                                }
                                                Err(e) => {
                                                    println!(
                                                        "❌ Failed to switch to {} biome: {}",
                                                        biome_name,
                                                        e
                                                    );
                                                }
                                            }
                                        }
                                    }
                                    KeyCode::Digit2 => {
                                        if pressed {
                                            let biome_name = "desert";
                                            println!("Attempting to switch to desert biome...");
                                            match switch_biome(&mut render, &mut physics, biome_name)
                                            {
                                                Ok(new_chars) => {
                                                    ui.current_texture_pack = biome_name.to_string();
                                                    ui.info_text = format!(
                                                        "Switched to {} environment",
                                                        biome_name
                                                    );
                                                    println!(
                                                        "✅ Successfully switched to {} biome with {} characters",
                                                        biome_name,
                                                        new_chars.len()
                                                    );
                                                    characters = new_chars;
                                                }
                                                Err(e) => {
                                                    println!(
                                                        "❌ Failed to switch to {} biome: {}",
                                                        biome_name,
                                                        e
                                                    );
                                                }
                                            }
                                        }
                                    }
                                    KeyCode::Digit3 => {
                                        if pressed {
                                            let biome_name = "forest";
                                            println!("Attempting to switch to forest biome...");
                                            match switch_biome(&mut render, &mut physics, biome_name)
                                            {
                                                Ok(new_chars) => {
                                                    ui.current_texture_pack = biome_name.to_string();
                                                    ui.info_text = format!(
                                                        "Switched to {} environment",
                                                        biome_name
                                                    );
                                                    println!(
                                                        "✅ Successfully switched to {} biome with {} characters",
                                                        biome_name,
                                                        new_chars.len()
                                                    );
                                                    characters = new_chars;
                                                }
                                                Err(e) => {
                                                    println!(
                                                        "❌ Failed to switch to {} biome: {}",
                                                        biome_name,
                                                        e
                                                    );
                                                }
                                            }
                                        }
                                    }
                                    KeyCode::Equal => { // '+' to increase exposure
                                        if pressed {
                                            ui.exposure = (ui.exposure * 1.1).clamp(0.1, 5.0);
                                            println!("Exposure: {:.2}", ui.exposure);
                                        }
                                    }
                                    KeyCode::NumpadAdd => { // Numpad '+'
                                        if pressed {
                                            ui.exposure = (ui.exposure * 1.1).clamp(0.1, 5.0);
                                            println!("Exposure: {:.2}", ui.exposure);
                                        }
                                    }
                                    KeyCode::Minus => { // '-' to decrease exposure
                                        if pressed {
                                            ui.exposure = (ui.exposure / 1.1).clamp(0.1, 5.0);
                                            println!("Exposure: {:.2}", ui.exposure);
                                        }
                                    }
                                    KeyCode::NumpadSubtract => { // Numpad '-'
                                        if pressed {
                                            ui.exposure = (ui.exposure / 1.1).clamp(0.1, 5.0);
                                            println!("Exposure: {:.2}", ui.exposure);
                                        }
                                    }
                                    KeyCode::Digit0 => { // Reset exposure to default
                                        if pressed {
                                            ui.exposure = 1.0;
                                            println!("Exposure reset to {:.2}", ui.exposure);
                                        }
                                    }
                                    // removed: handled below with Shift-aware ToD+bloom logic
                                    KeyCode::BracketLeft => {
                                        if pressed {
                                            if shift_down {
                                                // Decrease sun elevation
                                                if let Some(ref mut mgr) = render.ibl2_manager {
                                                    let step = 2.0_f32.to_radians();
                                                    mgr.sun_elevation = (mgr.sun_elevation - step).clamp(0.0_f32.to_radians(), 89.0_f32.to_radians());
                                                    let secs = start_time.elapsed().as_secs_f32();
                                                    if secs - render.ibl_last_update > 0.25 {
                                                        render.ibl_last_update = secs;
                                                        if let Ok(res) = mgr.bake_environment(&render.device, &render.queue, IblQuality::Medium) {
                                                            let new_bg = render.device.create_bind_group(&wgpu::BindGroupDescriptor {
                                                                label: Some("ibl-bg (rebake-elev-dec)"),
                                                                layout: &render.ibl_bg_layout,
                                                                entries: &[
                                                                    wgpu::BindGroupEntry { binding: 0, resource: wgpu::BindingResource::TextureView(&res.specular_cube) },
                                                                    wgpu::BindGroupEntry { binding: 1, resource: wgpu::BindingResource::TextureView(&res.irradiance_cube) },
                                                                    wgpu::BindGroupEntry { binding: 2, resource: wgpu::BindingResource::TextureView(&res.brdf_lut) },
                                                                    wgpu::BindGroupEntry { binding: 3, resource: wgpu::BindingResource::Sampler(&render.ibl_sampler) },
                                                                ],
                                                            });
                                                            render.ibl_bg = new_bg;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Decrease sun azimuth
                                                if let Some(ref mut mgr) = render.ibl2_manager {
                                                    let step = 5.0_f32.to_radians();
                                                    mgr.sun_azimuth = (mgr.sun_azimuth - step) % (std::f32::consts::TAU);
                                                    let secs = start_time.elapsed().as_secs_f32();
                                                    if secs - render.ibl_last_update > 0.25 {
                                                        render.ibl_last_update = secs;
                                                        if let Ok(res) = mgr.bake_environment(&render.device, &render.queue, IblQuality::Medium) {
                                                            let new_bg = render.device.create_bind_group(&wgpu::BindGroupDescriptor {
                                                                label: Some("ibl-bg (rebake-azi-dec)"),
                                                                layout: &render.ibl_bg_layout,
                                                                entries: &[
                                                                    wgpu::BindGroupEntry { binding: 0, resource: wgpu::BindingResource::TextureView(&res.specular_cube) },
                                                                    wgpu::BindGroupEntry { binding: 1, resource: wgpu::BindingResource::TextureView(&res.irradiance_cube) },
                                                                    wgpu::BindGroupEntry { binding: 2, resource: wgpu::BindingResource::TextureView(&res.brdf_lut) },
                                                                    wgpu::BindGroupEntry { binding: 3, resource: wgpu::BindingResource::Sampler(&render.ibl_sampler) },
                                                                ],
                                                            });
                                                            render.ibl_bg = new_bg;
                                                        }
                                                    }
                                                }
                                            }
                                            // Keep existing bloom control when not holding Shift
                                            if !shift_down {
                                                ui.bloom_threshold = (ui.bloom_threshold - 0.05).clamp(0.0, 5.0);
                                                println!("Bloom threshold: {:.2}", ui.bloom_threshold);
                                            }
                                        }
                                    }
                                    KeyCode::BracketRight => {
                                        if pressed {
                                            if shift_down {
                                                // Increase sun elevation
                                                if let Some(ref mut mgr) = render.ibl2_manager {
                                                    let step = 2.0_f32.to_radians();
                                                    mgr.sun_elevation = (mgr.sun_elevation + step).clamp(0.0_f32.to_radians(), 89.0_f32.to_radians());
                                                    let secs = start_time.elapsed().as_secs_f32();
                                                    if secs - render.ibl_last_update > 0.25 {
                                                        render.ibl_last_update = secs;
                                                        if let Ok(res) = mgr.bake_environment(&render.device, &render.queue, IblQuality::Medium) {
                                                            let new_bg = render.device.create_bind_group(&wgpu::BindGroupDescriptor {
                                                                label: Some("ibl-bg (rebake-elev-inc)"),
                                                                layout: &render.ibl_bg_layout,
                                                                entries: &[
                                                                    wgpu::BindGroupEntry { binding: 0, resource: wgpu::BindingResource::TextureView(&res.specular_cube) },
                                                                    wgpu::BindGroupEntry { binding: 1, resource: wgpu::BindingResource::TextureView(&res.irradiance_cube) },
                                                                    wgpu::BindGroupEntry { binding: 2, resource: wgpu::BindingResource::TextureView(&res.brdf_lut) },
                                                                    wgpu::BindGroupEntry { binding: 3, resource: wgpu::BindingResource::Sampler(&render.ibl_sampler) },
                                                                ],
                                                            });
                                                            render.ibl_bg = new_bg;
                                                        }
                                                    }
                                                }
                                            } else {
                                                // Increase sun azimuth
                                                if let Some(ref mut mgr) = render.ibl2_manager {
                                                    let step = 5.0_f32.to_radians();
                                                    mgr.sun_azimuth = (mgr.sun_azimuth + step) % (std::f32::consts::TAU);
                                                    let secs = start_time.elapsed().as_secs_f32();
                                                    if secs - render.ibl_last_update > 0.25 {
                                                        render.ibl_last_update = secs;
                                                        if let Ok(res) = mgr.bake_environment(&render.device, &render.queue, IblQuality::Medium) {
                                                            let new_bg = render.device.create_bind_group(&wgpu::BindGroupDescriptor {
                                                                label: Some("ibl-bg (rebake-azi-inc)"),
                                                                layout: &render.ibl_bg_layout,
                                                                entries: &[
                                                                    wgpu::BindGroupEntry { binding: 0, resource: wgpu::BindingResource::TextureView(&res.specular_cube) },
                                                                    wgpu::BindGroupEntry { binding: 1, resource: wgpu::BindingResource::TextureView(&res.irradiance_cube) },
                                                                    wgpu::BindGroupEntry { binding: 2, resource: wgpu::BindingResource::TextureView(&res.brdf_lut) },
                                                                    wgpu::BindGroupEntry { binding: 3, resource: wgpu::BindingResource::Sampler(&render.ibl_sampler) },
                                                                ],
                                                            });
                                                            render.ibl_bg = new_bg;
                                                        }
                                                    }
                                                }
                                            }
                                            // Keep existing bloom control when not holding Shift
                                            if !shift_down {
                                                ui.bloom_threshold = (ui.bloom_threshold + 0.05).clamp(0.0, 5.0);
                                                println!("Bloom threshold: {:.2}", ui.bloom_threshold);
                                            }
                                        }
                                    }
                                    _ => {}
                            }
                        },
                            _ => {}
                        }
                    }
                    WindowEvent::MouseInput { state, button, .. } => {
                        camera_controller
                            .process_mouse_button(button, state == ElementState::Pressed);
                        if button == winit::event::MouseButton::Right {
                            let pressed = state == ElementState::Pressed;
                            // Grab or release cursor for reliable deltas
                            if pressed {
                                let _ = window.set_cursor_grab(CursorGrabMode::Locked);
                                window.set_cursor_visible(false);
                            } else {
                                let _ = window.set_cursor_grab(CursorGrabMode::None);
                                window.set_cursor_visible(true);
                            }
                        }
                    }
                    WindowEvent::MouseWheel {
                        delta: MouseScrollDelta::LineDelta(_, y),
                        ..
                    } => {
                        // Use camera controller for zoom instead of speed adjustment
                        camera_controller.process_scroll(&mut camera, y);
                    }
                    WindowEvent::Resized(size) => {
                        render.surface_cfg.width = size.width.max(1);
                        render.surface_cfg.height = size.height.max(1);
                        render
                            .surface
                            .configure(&render.device, &render.surface_cfg);
                        render.depth_view = create_depth(
                            &render.device,
                            render.surface_cfg.width,
                            render.surface_cfg.height,
                            render.msaa_samples,
                        );
                        // Recreate MSAA color target
                        render.msaa_color_view = if render.msaa_samples > 1 {
                            Some(create_msaa_color(
                                &render.device,
                                render.surface_cfg.format,
                                render.surface_cfg.width,
                                render.surface_cfg.height,
                                render.msaa_samples,
                            ))
                        } else { None };

                        // Recreate HDR targets for post-processing
                        let hdr_size = wgpu::Extent3d {
                            width: render.surface_cfg.width,
                            height: render.surface_cfg.height,
                            depth_or_array_layers: 1,
                        };
                        let hdr_mips = mip_level_count_for(hdr_size);
                        render.hdr_tex = render.device.create_texture(&wgpu::TextureDescriptor {
                            label: Some("hdr-tex"),
                            size: hdr_size,
                            mip_level_count: hdr_mips,
                            sample_count: 1,
                            dimension: wgpu::TextureDimension::D2,
                            format: wgpu::TextureFormat::Rgba16Float,
                            usage: wgpu::TextureUsages::RENDER_ATTACHMENT
                                | wgpu::TextureUsages::TEXTURE_BINDING
                                | wgpu::TextureUsages::COPY_SRC,
                            view_formats: &[],
                        });
                        render.hdr_view = render
                            .hdr_tex
                            .create_view(&wgpu::TextureViewDescriptor::default());
                        // Single-mip view (level 0) for render/resolve target
                        render.hdr_resolve_view = render.hdr_tex.create_view(&wgpu::TextureViewDescriptor {
                            label: Some("hdr-resolve-view"),
                            format: Some(wgpu::TextureFormat::Rgba16Float),
                            dimension: Some(wgpu::TextureViewDimension::D2),
                            aspect: wgpu::TextureAspect::All,
                            base_mip_level: 0,
                            mip_level_count: Some(1),
                            base_array_layer: 0,
                            array_layer_count: Some(1),
                        });
                        render.hdr_msaa_view = if render.msaa_samples > 1 {
                            let msaa_tex = render.device.create_texture(&wgpu::TextureDescriptor {
                                label: Some("hdr-msaa"),
                                size: hdr_size,
                                mip_level_count: 1,
                                sample_count: render.msaa_samples,
                                dimension: wgpu::TextureDimension::D2,
                                format: wgpu::TextureFormat::Rgba16Float,
                                usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
                                view_formats: &[],
                            });
                            Some(msaa_tex.create_view(&wgpu::TextureViewDescriptor::default()))
                        } else {
                            None
                        };

                        // Recreate post bind group to point at new HDR view
                        render.post_bg = render.device.create_bind_group(&wgpu::BindGroupDescriptor {
                            label: Some("post-bg"),
                            layout: &render.post_bgl,
                            entries: &[
                                wgpu::BindGroupEntry {
                                    binding: 0,
                                    // Post samples from full-mip view
                                    resource: wgpu::BindingResource::TextureView(&render.hdr_view),
                                },
                                wgpu::BindGroupEntry {
                                    binding: 1,
                                    resource: wgpu::BindingResource::Sampler(&render.post_sampler),
                                },
                                wgpu::BindGroupEntry { binding: 2, resource: render.exposure_buf.as_entire_binding() },
                                wgpu::BindGroupEntry { binding: 3, resource: render.bloom_ub.as_entire_binding() },
                            ],
                        });

                        // Update UI info with character count
                        ui.info_text = format!(
                            "Environment: {} ({} characters)",
                            ui.current_texture_pack,
                            characters.len()
                        );
                    }
                    WindowEvent::RedrawRequested => {
                        let now = Instant::now();
                        let dt = now - last;
                        last = now;

                        // smooth FPS
                        let fps = 1.0 / dt.as_secs_f32().max(1e-5);
                        fps_acc += fps;
                        fps_cnt += 1;
                        if fps_cnt >= 30 {
                            ui.fps_text = format!("{:.1} fps", fps_acc / fps_cnt as f32);
                            fps_acc = 0.0;
                            fps_cnt = 0;
                        }

                        // Update camera
                        camera.aspect = (render.surface_cfg.width as f32 * ui.resolution_scale)
                            .max(1.0)
                            / (render.surface_cfg.height as f32 * ui.resolution_scale).max(1.0);

                        // Update camera with controller
                        camera_controller.update_camera(&mut camera, dt.as_secs_f32());

                        let shadow_runtime = compute_shadow_runtime_settings(camera.position.y);
                        if shadow_runtime.resolution != render.shadow_size {
                            recreate_shadow_resources(&mut render, shadow_runtime.resolution);
                        }
                        let shadow_uniform = ShadowParams {
                            resolution: render.shadow_size as f32,
                            cascade_count: shadow_runtime.cascade_count,
                            softness: shadow_runtime.softness,
                            bias: shadow_runtime.bias,
                            cascade_splits: shadow_runtime.cascade_splits,
                        };
                        render.queue.write_buffer(
                            &render.shadow_params_buf,
                            0,
                            bytemuck::bytes_of(&shadow_uniform),
                        );

                        // Update characters
                        for character in &mut characters {
                            character.update(dt.as_secs_f32());
                            // Project to terrain surface to avoid floating/penetration due to slope changes
                            let ground_y = terrain_surface_y(character.position.x, character.position.z);
                            // Maintain a small offset so feet aren't z-fighting the ground
                            character.position.y = ground_y + 0.5;
                        }

                        // Physics
                        if !ui.physics_paused {
                            physics_step(&mut physics);
                        }

                        // Sync sim to render and batch instances by mesh type
                        let lod_settings = ui.active_lod_settings().clone();
                        sync_instances_from_physics(&physics, &characters, camera.position, &lod_settings, &mut instances);
                        render.instance_count = instances.len() as u32;

                        // Batch instances by mesh type for efficient rendering
                        let instance_batches = batch_instances_by_mesh(instances.as_slice());

                        // Camera uniform
                        let cam = GpuCamera {
                            view_proj: camera.vp().to_cols_array_2d(),
                        };
                        render
                            .queue
                            .write_buffer(&render.camera_ub, 0, bytemuck::bytes_of(&cam));

                        // Scene parameters (time, camera height)
                        let scene_params = SceneParams {
                            time: start_time.elapsed().as_secs_f32(),
                            camera_height: camera.position.y,
                            _pad: [0.0; 2],
                        };
                        render.queue.write_buffer(
                            &render.scene_params_buf,
                            0,
                            bytemuck::bytes_of(&scene_params),
                        );

                        // Update exposure uniform buffer from UI state
                        let post = PostParams { exposure: ui.exposure, _pad: [0.0; 3], _pad2: [0.0; 4] };
                        render.queue.write_buffer(&render.exposure_buf, 0, bytemuck::bytes_of(&post));
                        // Update bloom uniform
                        let bloom = BloomParams { threshold: ui.bloom_threshold, intensity: ui.bloom_intensity, _pad: [0.0; 2] };
                        render.queue.write_buffer(&render.bloom_ub, 0, bytemuck::bytes_of(&bloom));

                        // Update debug toggle uniform
                        let mut dbg_bits = 0u32;
                        if ui.debug_material_tint { dbg_bits |= 1; }
                        if render.ibl_enabled { dbg_bits |= 2; }
                        let dbg = DebugParamsRust { debug_tint: dbg_bits, _pad: [0; 3], _pad2: [0; 4] };
                        render.queue.write_buffer(&render.debug_buf, 0, bytemuck::bytes_of(&dbg));

                        // Prepare command encoder (reused for shadow and main passes)
                        let mut encoder = render.device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: Some("frame-encoder") });

                        // Update light matrices (directional light)
                        let light_dir = glam::Vec3::new(0.6, 1.0, 0.4).normalize();
                        let light_view = Mat4::look_at_rh(-light_dir * 150.0, Vec3::ZERO, Vec3::Y);
                        let ortho_extent = 220.0;
                        let light_proj = Mat4::orthographic_rh(
                            -ortho_extent, ortho_extent,
                            -ortho_extent, ortho_extent,
                            0.1, 400.0,
                        );
                        let light_vp = light_proj * light_view;
                        let lcam = GpuCamera {
                            view_proj: light_vp.to_cols_array_2d(),
                        };
                        render.queue.write_buffer(&render.light_ub, 0, bytemuck::bytes_of(&lcam));

                        // Shadow pass
                        {
                            let mut sp = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                                label: Some("shadow-pass"),
                                color_attachments: &[],
                                depth_stencil_attachment: Some(wgpu::RenderPassDepthStencilAttachment {
                                    view: &render.shadow_view,
                                    depth_ops: Some(wgpu::Operations { load: wgpu::LoadOp::Clear(1.0), store: wgpu::StoreOp::Store }),
                                    stencil_ops: None,
                                }),
                                timestamp_writes: None,
                                occlusion_query_set: None,
                            });
                            sp.set_pipeline(&render.shadow_pipeline);
                            sp.set_bind_group(0, &render.light_bg, &[]);
                            for batch in &instance_batches {
                                if matches!(batch.mesh_key.category, MeshCategory::Skybox) {
                                    continue;
                                }
                                if let Some(mesh) = render.meshes.get(&batch.mesh_key) {
                                    render.queue.write_buffer(&render.instance_vb, 0, bytemuck::cast_slice(&batch.instances));
                                    sp.set_vertex_buffer(0, mesh.vertex_buffer.slice(..));
                                    sp.set_vertex_buffer(1, render.instance_vb.slice(..));
                                    sp.set_index_buffer(mesh.index_buffer.slice(..), wgpu::IndexFormat::Uint32);
                                    if !batch.instances.is_empty() {
                                        sp.draw_indexed(0..mesh.index_count, 0, 0..batch.instances.len() as u32);
                                    }
                                }
                            }
                        }

                        // Render
                        let frame = match render.surface.get_current_texture() {
                            Ok(f) => f,
                            Err(_) => {
                                render
                                    .surface
                                    .configure(&render.device, &render.surface_cfg);
                                render.surface.get_current_texture().unwrap()
                            }
                        };
                        let view = frame
                            .texture
                            .create_view(&wgpu::TextureViewDescriptor::default());
                        // Main pass into HDR offscreen target (with MSAA resolve if enabled)
                        {
                            // Use MSAA view if enabled; otherwise render directly to single-mip resolve view
                            let color_view = render
                                .hdr_msaa_view
                                .as_ref()
                                .unwrap_or(&render.hdr_resolve_view);
                            // Resolve into the single-mip resolve view when MSAA is enabled
                            let resolve_target = if render.msaa_samples > 1 {
                                Some(&render.hdr_resolve_view)
                            } else {
                                None
                            };
                            let mut rp = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                                label: Some("main-pass"),
                                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                                    view: color_view,
                                    resolve_target,
                                    ops: wgpu::Operations {
                                        load: wgpu::LoadOp::Clear(wgpu::Color {
                                            r: 0.4,
                                            g: 0.6,
                                            b: 0.9,
                                            a: 1.0,
                                        }),
                                        store: wgpu::StoreOp::Store,
                                    },
                                })],
                                depth_stencil_attachment: Some(
                                    wgpu::RenderPassDepthStencilAttachment {
                                        view: &render.depth_view,
                                        depth_ops: Some(wgpu::Operations {
                                            load: wgpu::LoadOp::Clear(1.0),
                                            store: wgpu::StoreOp::Store,
                                        }),
                                        stencil_ops: None,
                                    },
                                ),
                                timestamp_writes: None,
                                occlusion_query_set: None,
                            });
                            rp.set_pipeline(&render.pipeline);
                            rp.set_bind_group(0, &render.camera_bg, &[]);
                            rp.set_bind_group(1, &render.ground_bind_group, &[]);
                            rp.set_bind_group(2, &render.shadow_bg, &[]);
                            rp.set_bind_group(3, &render.light_bg, &[]);
                            if let Some(material_bg) = render.material_bind_group.as_ref() {
                                rp.set_bind_group(4, material_bg, &[]);
                            }
                            // IBL bind group always set
                            rp.set_bind_group(5, &render.ibl_bg, &[]);
                            // Render skybox first
                            for batch in &instance_batches {
                                if matches!(batch.mesh_key.category, MeshCategory::Skybox) {
                                    if let Some(mesh) = render.meshes.get(&batch.mesh_key) {
                                        render.queue.write_buffer(
                                            &render.instance_vb,
                                            0,
                                            bytemuck::cast_slice(&batch.instances),
                                        );
                                        rp.set_vertex_buffer(0, mesh.vertex_buffer.slice(..));
                                        rp.set_vertex_buffer(1, render.instance_vb.slice(..));
                                        rp.set_index_buffer(
                                            mesh.index_buffer.slice(..),
                                            wgpu::IndexFormat::Uint32,
                                        );
                                        if !batch.instances.is_empty() {
                                            rp.draw_indexed(
                                                0..mesh.index_count,
                                                0,
                                                0..batch.instances.len() as u32,
                                            );
                                        }
                                    }
                                }
                            }
                            // Render other mesh batches
                            for batch in &instance_batches {
                                if !matches!(batch.mesh_key.category, MeshCategory::Skybox) {
                                    if let Some(mesh) = render.meshes.get(&batch.mesh_key) {
                                        render.queue.write_buffer(
                                            &render.instance_vb,
                                            0,
                                            bytemuck::cast_slice(&batch.instances),
                                        );
                                        rp.set_vertex_buffer(0, mesh.vertex_buffer.slice(..));
                                        rp.set_vertex_buffer(1, render.instance_vb.slice(..));
                                        rp.set_index_buffer(
                                            mesh.index_buffer.slice(..),
                                            wgpu::IndexFormat::Uint32,
                                        );
                                        if !batch.instances.is_empty() {
                                            rp.draw_indexed(
                                                0..mesh.index_count,
                                                0,
                                                0..batch.instances.len() as u32,
                                            );
                                        }
                                    }
                                }
                            }
                        }

                        // Submit main pass before generating mips
                        render.queue.submit(Some(encoder.finish()));

                        // Generate mips for HDR color (used by bloom post)
                        let hdr_size = wgpu::Extent3d {
                            width: render.surface_cfg.width,
                            height: render.surface_cfg.height,
                            depth_or_array_layers: 1,
                        };
                        generate_mipmaps(
                            &render.device,
                            &render.queue,
                            &render.hdr_tex,
                            wgpu::TextureFormat::Rgba16Float,
                            hdr_size,
                            mip_level_count_for(hdr_size),
                            0,
                            1,
                        );

                        // Post pass: composite bloom to the swapchain
                        let mut encoder2 = render
                            .device
                            .create_command_encoder(&wgpu::CommandEncoderDescriptor {
                                label: Some("post-encoder"),
                            });
                        {
                            let mut rp = encoder2.begin_render_pass(&wgpu::RenderPassDescriptor {
                                label: Some("post-pass"),
                                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                                    view: &view,
                                    resolve_target: None,
                                    ops: wgpu::Operations {
                                        load: wgpu::LoadOp::Clear(wgpu::Color::BLACK),
                                        store: wgpu::StoreOp::Store,
                                    },
                                })],
                                depth_stencil_attachment: None,
                                timestamp_writes: None,
                                occlusion_query_set: None,
                            });
                            if render.debug_show_layer_quads {
                                rp.set_pipeline(&render.layer_dbg_pipeline);
                                rp.set_bind_group(0, &render.post_bg, &[]);
                                rp.set_bind_group(1, &render.ground_bind_group, &[]);
                                rp.draw(0..3, 0..1);
                            } else {
                                rp.set_pipeline(&render.post_pipeline);
                                rp.set_bind_group(0, &render.post_bg, &[]);
                                rp.draw(0..3, 0..1);
                            }
                        }
                        render.queue.submit(Some(encoder2.finish()));
                        frame.present();
                    }
                    _ => {}
                }
            }
            Event::AboutToWait => {
                window.request_redraw();
            }
            Event::DeviceEvent {
                event: DeviceEvent::MouseMotion { delta },
                ..
            } => {
                // Use proper mouse delta handling for camera controller
                let mouse_delta = Vec2::new(delta.0 as f32, delta.1 as f32);
                camera_controller.process_mouse_delta(&mut camera, mouse_delta);
            }
            _ => {}
        }
    });
    Ok(())
}

// ---------------- Helper functions for default textures ----------------

fn create_default_albedo_texture(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
) -> Result<LoadedTexture> {
    let white_texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("default-white"),
        size: wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Rgba8UnormSrgb,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });
    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &white_texture,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &[255, 255, 255, 255], // RGBA white
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4),
            rows_per_image: Some(1),
        },
        wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
    );
    let view = white_texture.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::Repeat,
        address_mode_v: wgpu::AddressMode::Repeat,
        address_mode_w: wgpu::AddressMode::Repeat,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
        anisotropy_clamp: 8,
        ..Default::default()
    });
    Ok(LoadedTexture {
        texture: white_texture,
        view,
        sampler,
    })
}

fn create_default_normal_texture(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
) -> Result<LoadedTexture> {
    let normal_texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("default-normal"),
        size: wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Rgba8Unorm,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });
    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &normal_texture,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &[128, 128, 255, 255], // Default normal pointing up (0, 0, 1) in normal map encoding
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4),
            rows_per_image: Some(1),
        },
        wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
    );
    let view = normal_texture.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::Repeat,
        address_mode_v: wgpu::AddressMode::Repeat,
        address_mode_w: wgpu::AddressMode::Repeat,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
        anisotropy_clamp: 8,
        ..Default::default()
    });
    Ok(LoadedTexture {
        texture: normal_texture,
        view,
        sampler,
    })
}

// Default MRA texture: R=AO=1.0 (no occlusion), G=Roughness=0.8, B=Metallic=0.0
fn create_default_mra_texture(device: &wgpu::Device, queue: &wgpu::Queue) -> Result<LoadedTexture> {
    let mra_tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("default-mra"),
        size: wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Rgba8Unorm,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });
    // RGBA: AO, Roughness, Metallic, unused
    let ao = (1.0 * 255.0) as u8;
    let rough = (0.8 * 255.0) as u8;
    let metal = (0.0 * 255.0) as u8;
    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &mra_tex,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &[ao, rough, metal, 255],
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4),
            rows_per_image: Some(1),
        },
        wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
    );
    let view = mra_tex.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::Repeat,
        address_mode_v: wgpu::AddressMode::Repeat,
        address_mode_w: wgpu::AddressMode::Repeat,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
        anisotropy_clamp: 8,
        ..Default::default()
    });
    Ok(LoadedTexture {
        texture: mra_tex,
        view,
        sampler,
    })
}

// Default emissive texture: black (no emission)
fn create_default_emissive_texture(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
) -> Result<LoadedTexture> {
    let e_tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("default-emissive"),
        size: wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Rgba8UnormSrgb,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });
    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &e_tex,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &[0, 0, 0, 255],
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4),
            rows_per_image: Some(1),
        },
        wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
    );
    let view = e_tex.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::Repeat,
        address_mode_v: wgpu::AddressMode::Repeat,
        address_mode_w: wgpu::AddressMode::Repeat,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
        anisotropy_clamp: 8,
        ..Default::default()
    });
    Ok(LoadedTexture {
        texture: e_tex,
        view,
        sampler,
    })
}

// Fallback: create a 1x1 texture matching the color of an existing texture's first texel
fn default_albedo_clone(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
    _src: &LoadedTexture,
) -> Result<LoadedTexture> {
    // We don't read from GPU; just make a neutral 1x1 white as a safe stand-in
    create_default_albedo_texture(device, queue)
}

// ---------------- renderer setup ----------------
// Structure to hold batched instance data for efficient rendering
struct InstanceBatch {
    instances: Vec<InstanceRaw>,
    mesh_key: MeshKey,
}

#[derive(Clone, Copy, Debug)]
struct CategoryLod {
    near: f32,
    far: f32,
    keep: f32,
}

impl CategoryLod {
    fn new(near: f32, far: f32, keep: f32) -> Self {
        Self { near, far, keep }
    }

    fn adjust_near(&mut self, delta: f32) {
        self.near = (self.near + delta).clamp(5.0, self.far - 5.0);
    }

    fn adjust_far(&mut self, delta: f32) {
        self.far = (self.far + delta).max(self.near + 5.0);
    }

    fn adjust_keep(&mut self, delta: f32) {
        self.keep = (self.keep + delta).clamp(0.05, 1.0);
    }
}

#[derive(Clone, Debug)]
struct BiomeLodSettings {
    tree: CategoryLod,
    house: CategoryLod,
    rock: CategoryLod,
    character: CategoryLod,
}

impl BiomeLodSettings {
    fn grassland() -> Self {
        Self {
            tree: CategoryLod::new(60.0, 160.0, 0.35),
            house: CategoryLod::new(80.0, 200.0, 0.6),
            rock: CategoryLod::new(50.0, 140.0, 0.3),
            character: CategoryLod::new(40.0, 120.0, 0.2),
        }
    }

    fn desert() -> Self {
        Self {
            tree: CategoryLod::new(55.0, 140.0, 0.25),
            house: CategoryLod::new(90.0, 220.0, 0.55),
            rock: CategoryLod::new(45.0, 150.0, 0.25),
            character: CategoryLod::new(45.0, 130.0, 0.25),
        }
    }

    fn forest() -> Self {
        Self {
            tree: CategoryLod::new(50.0, 150.0, 0.5),
            house: CategoryLod::new(70.0, 180.0, 0.65),
            rock: CategoryLod::new(45.0, 120.0, 0.35),
            character: CategoryLod::new(35.0, 110.0, 0.25),
        }
    }

    fn for_category(&self, category: LodCategory) -> &CategoryLod {
        match category {
            LodCategory::Trees => &self.tree,
            LodCategory::Houses => &self.house,
            LodCategory::Rocks => &self.rock,
            LodCategory::Characters => &self.character,
        }
    }

    fn for_category_mut(&mut self, category: LodCategory) -> &mut CategoryLod {
        match category {
            LodCategory::Trees => &mut self.tree,
            LodCategory::Houses => &mut self.house,
            LodCategory::Rocks => &mut self.rock,
            LodCategory::Characters => &mut self.character,
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum LodCategory {
    Trees,
    Houses,
    Rocks,
    Characters,
}

impl LodCategory {
    fn next(self) -> Self {
        match self {
            LodCategory::Trees => LodCategory::Houses,
            LodCategory::Houses => LodCategory::Rocks,
            LodCategory::Rocks => LodCategory::Characters,
            LodCategory::Characters => LodCategory::Trees,
        }
    }

    fn label(self) -> &'static str {
        match self {
            LodCategory::Trees => "Trees",
            LodCategory::Houses => "Structures",
            LodCategory::Rocks => "Rocks",
            LodCategory::Characters => "Characters",
        }
    }
}

// Shared terrain parameters used by both rendering and physics so visuals and collisions match
const TERRAIN_SIZE: usize = 256; // grid resolution along one axis
const TERRAIN_SCALE: f32 = 6.0; // world units between vertices

const TREE_VARIANT_COUNT: u32 = 5;
const HOUSE_VARIANT_COUNT: u32 = 3;
const ROCK_VARIANT_COUNT: u32 = 6;
const CHARACTER_VARIANT_COUNT: u32 = 4;
const PRIMITIVE_VARIANT_COUNT: u32 = 1;
const MAX_INSTANCE_COUNT: usize = 512;
const TREE_IMPOSTOR_VARIANT: u32 = TREE_VARIANT_COUNT;
const HOUSE_IMPOSTOR_VARIANT: u32 = HOUSE_VARIANT_COUNT;
const ROCK_IMPOSTOR_VARIANT: u32 = ROCK_VARIANT_COUNT;
const CHARACTER_IMPOSTOR_VARIANT: u32 = CHARACTER_VARIANT_COUNT;
const DENSITY_BUCKET_METERS: f32 = 10.0;
const LOD_FLAG_IMPOSTOR: u32 = 0x1;

#[derive(Clone, Copy)]
struct SimpleRng {
    state: u64,
}

impl SimpleRng {
    fn new(seed: u64) -> Self {
        Self { state: seed.max(1) }
    }

    fn next_u32(&mut self) -> u32 {
        // LCG parameters from Numerical Recipes
        self.state = self.state.wrapping_mul(6364136223846793005).wrapping_add(1);
        (self.state >> 32) as u32
    }

    fn next_f32(&mut self) -> f32 {
        const INV_MAX: f32 = 1.0 / (u32::MAX as f32);
        self.next_u32() as f32 * INV_MAX
    }

    fn range_f32(&mut self, min: f32, max: f32) -> f32 {
        min + (max - min) * self.next_f32()
    }

    fn range_u32(&mut self, min: u32, max: u32) -> u32 {
        if min >= max {
            return min;
        }
        min + self.next_u32() % (max - min)
    }
}

fn batch_instances_by_mesh(instances: &[InstanceRaw]) -> Vec<InstanceBatch> {
    use std::collections::HashMap;

    let mut buckets: HashMap<(MeshCategory, u32), Vec<InstanceRaw>> = HashMap::new();
    for instance in instances.iter().copied() {
        if let Some(category) = MeshCategory::from_u32(instance.mesh_category) {
            let key = (category, instance.mesh_variant);
            buckets.entry(key).or_default().push(instance);
        }
    }

    buckets
        .into_iter()
        .map(|((category, variant), instances)| InstanceBatch {
            instances,
            mesh_key: MeshKey::new(category, variant),
        })
        .collect()
}

// Generate terrain mesh with height variations matching the shader logic
fn generate_terrain_mesh(size: usize, scale: f32) -> MeshData {
    let grid_dim = size + 1;
    let vertex_count = grid_dim * grid_dim;
    let mut positions = Vec::with_capacity(vertex_count);
    let mut normals = vec![Vec3::ZERO; vertex_count];
    let mut uvs = Vec::with_capacity(vertex_count);
    let mut indices = Vec::with_capacity(size * size * 6);

    for z in 0..=size {
        for x in 0..=size {
            let world_x = (x as f32 - size as f32 * 0.5) * scale;
            let world_z = (z as f32 - size as f32 * 0.5) * scale;
            let world_pos = [world_x, world_z];
            let biome_type = get_biome_type_rust(world_pos);
            let terrain_height = get_biome_terrain_height_rust(world_pos, biome_type);

            positions.push(Vec3::new(world_x, -2.0 + terrain_height, world_z));
            uvs.push(Vec2::new(x as f32 / size as f32, z as f32 / size as f32));
        }
    }

    for z in 0..size {
        for x in 0..size {
            let i0 = (z * grid_dim + x) as u32;
            let i1 = (z * grid_dim + x + 1) as u32;
            let i2 = ((z + 1) * grid_dim + x) as u32;
            let i3 = ((z + 1) * grid_dim + x + 1) as u32;

            indices.extend_from_slice(&[i0, i2, i1, i1, i2, i3]);

            let p0 = positions[i0 as usize];
            let p1 = positions[i1 as usize];
            let p2 = positions[i2 as usize];
            let p3 = positions[i3 as usize];

            let n0 = (p2 - p0).cross(p1 - p0);
            normals[i0 as usize] += n0;
            normals[i2 as usize] += n0;
            normals[i1 as usize] += n0;

            let n1 = (p3 - p1).cross(p2 - p1);
            normals[i1 as usize] += n1;
            normals[i3 as usize] += n1;
            normals[i2 as usize] += n1;
        }
    }

    let vertices = positions
        .into_iter()
        .zip(normals.into_iter())
        .zip(uvs.into_iter())
        .map(|((pos, normal), uv)| mesh_helpers::Vertex {
            position: pos.to_array(),
            normal: normal.normalize_or_zero().to_array(),
            uv: uv.to_array(),
        })
        .collect();

    MeshData { vertices, indices }
}

// Rust implementation of shader biome detection
fn smooth2_scalar(t: f32) -> f32 {
    t * t * t * (t * (t * 6.0 - 15.0) + 10.0)
}

fn fract_scalar(x: f32) -> f32 {
    x - x.floor()
}

fn hash21_rust(p: [f32; 2]) -> f32 {
    let h = p[0] * 127.1 + p[1] * 311.7;
    fract_scalar((h).sin() * 43758.5453)
}

fn value_noise2_rust(p: [f32; 2]) -> f32 {
    let ix = p[0].floor();
    let iy = p[1].floor();
    let fx = p[0] - ix;
    let fy = p[1] - iy;
    let ux = smooth2_scalar(fx);
    let uy = smooth2_scalar(fy);
    let a = hash21_rust([ix + 0.0, iy + 0.0]);
    let b = hash21_rust([ix + 1.0, iy + 0.0]);
    let c = hash21_rust([ix + 0.0, iy + 1.0]);
    let d = hash21_rust([ix + 1.0, iy + 1.0]);
    let x1 = a + (b - a) * ux;
    let x2 = c + (d - c) * ux;
    x1 + (x2 - x1) * uy
}

fn fbm2_rust(p: [f32; 2], octaves: i32, lacunarity: f32, gain: f32) -> f32 {
    let mut f = 0.0f32;
    let mut amp = 0.5f32;
    let mut freq = 1.0f32;
    let mut i = 0;
    while i < octaves {
        f += value_noise2_rust([p[0] * freq, p[1] * freq]) * amp;
        freq *= lacunarity;
        amp *= gain;
        i += 1;
    }
    f
}

fn fbm_ridge2_rust(p: [f32; 2], octaves: i32, lacunarity: f32, gain: f32) -> f32 {
    let mut f = 0.0f32;
    let mut amp = 0.5f32;
    let mut freq = 1.0f32;
    let mut i = 0;
    while i < octaves {
        let n = value_noise2_rust([p[0] * freq, p[1] * freq]);
        let r = 1.0 - (n * 2.0 - 1.0).abs();
        f += r * amp;
        freq *= lacunarity;
        amp *= gain;
        i += 1;
    }
    f
}

fn get_biome_type_rust(world_pos: [f32; 2]) -> i32 {
    let biome_scale = 0.01;
    let biome_pos = [world_pos[0] * biome_scale, world_pos[1] * biome_scale];
    let n = fbm2_rust(biome_pos, 5, 2.0, 0.5) * 2.0 - 1.0;
    if n > 0.25 {
        1
    } else if n < -0.25 {
        2
    } else {
        0
    }
}

// Rust implementation of shader terrain height generation
fn get_biome_terrain_height_rust(world_pos: [f32; 2], biome_type: i32) -> f32 {
    // Match WGSL FBM-based terrain height generation
    let p = [world_pos[0] * 0.01, world_pos[1] * 0.01];
    let base = (fbm2_rust(p, 5, 2.0, 0.5) * 2.0 - 1.0) * 3.5;
    let detail = (fbm2_rust([p[0] * 3.0, p[1] * 3.0], 3, 2.2, 0.5) - 0.5) * 1.5;
    let h = base + detail;
    match biome_type {
        0 => {
            // Grassland
            let river = fbm_ridge2_rust([p[0] * 0.9, p[1] * 0.9], 3, 2.0, 0.6);
            let valleys = (river - 0.6) * 6.0;
            h + valleys.clamp(-3.5, 0.0)
        }
        1 => {
            // Desert
            let wind_dir = {
                let len = (0.8f32 * 0.8 + 0.6 * 0.6).sqrt();
                [0.8 / len, 0.6 / len]
            };
            let d = p[0] * 6.0 * wind_dir[0] + p[1] * 6.0 * wind_dir[1];
            let dunes = (fbm_ridge2_rust([d, d * 0.3], 4, 2.0, 0.55) - 0.5) * 3.0;
            let mesas = if fbm_ridge2_rust([p[0] * 0.7, p[1] * 0.7], 4, 2.0, 0.5) >= 0.7 {
                6.0
            } else {
                0.0
            };
            h + dunes + mesas
        }
        2 => {
            // Forest
            let soft = fbm2_rust([p[0] * 0.7, p[1] * 0.7], 4, 2.0, 0.5) * 2.0 - 1.0;
            let mounds = if fbm2_rust([p[0] * 1.3 + 12.3, p[1] * 1.3 + 12.3], 4, 2.0, 0.5) >= 0.65 {
                1.6
            } else {
                0.0
            };
            h * 0.9 + soft * 2.2 + mounds
        }
        _ => h,
    }
}

// Compute the visual terrain surface Y at a given world-space (x, z)
fn terrain_surface_y(x: f32, z: f32) -> f32 {
    let biome = get_biome_type_rust([x, z]);
    // Terrain in mesh generation was placed at base -2.0 plus height variation
    -2.0 + get_biome_terrain_height_rust([x, z], biome)
}

fn create_mesh(device: &wgpu::Device, mesh: MeshData) -> Mesh {
    let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("mesh-vertices"),
        contents: bytemuck::cast_slice(&mesh.vertices),
        usage: wgpu::BufferUsages::VERTEX,
    });

    let index_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("mesh-indices"),
        contents: bytemuck::cast_slice(&mesh.indices),
        usage: wgpu::BufferUsages::INDEX,
    });

    Mesh {
        vertex_buffer,
        index_buffer,
        index_count: mesh.indices.len() as u32,
    }
}

fn create_all_meshes(device: &wgpu::Device) -> std::collections::HashMap<MeshKey, Mesh> {
    use std::collections::HashMap;

    let mut meshes = HashMap::new();

    // Terrain base mesh (single variant)
    meshes.insert(
        MeshKey::new(MeshCategory::Terrain, 0),
        create_mesh(device, generate_terrain_mesh(TERRAIN_SIZE, TERRAIN_SCALE)),
    );

    // Primitive crate variants (currently identical, placeholder for future variety)
    for variant in 0..PRIMITIVE_VARIANT_COUNT {
        meshes.insert(
            MeshKey::new(MeshCategory::Primitive, variant),
            create_mesh(device, generate_primitive_crate_mesh()),
        );
    }

    // Skybox
    meshes.insert(
        MeshKey::new(MeshCategory::Skybox, 0),
        create_mesh(device, generate_skybox_mesh()),
    );

    // Trees, Houses, Rocks, Characters - seeded procedural variants
    for variant in 0..TREE_VARIANT_COUNT {
        meshes.insert(
            MeshKey::new(MeshCategory::Tree, variant),
            create_mesh(device, generate_tree_mesh(variant)),
        );
    }
    meshes.insert(
        MeshKey::new(MeshCategory::Tree, TREE_IMPOSTOR_VARIANT),
        create_mesh(device, generate_tree_impostor_mesh()),
    );

    for variant in 0..HOUSE_VARIANT_COUNT {
        meshes.insert(
            MeshKey::new(MeshCategory::House, variant),
            create_mesh(device, generate_house_mesh(variant)),
        );
    }
    meshes.insert(
        MeshKey::new(MeshCategory::House, HOUSE_IMPOSTOR_VARIANT),
        create_mesh(device, generate_house_impostor_mesh()),
    );

    for variant in 0..ROCK_VARIANT_COUNT {
        meshes.insert(
            MeshKey::new(MeshCategory::Rock, variant),
            create_mesh(device, generate_rock_mesh(variant)),
        );
    }
    meshes.insert(
        MeshKey::new(MeshCategory::Rock, ROCK_IMPOSTOR_VARIANT),
        create_mesh(device, generate_rock_impostor_mesh()),
    );

    for variant in 0..CHARACTER_VARIANT_COUNT {
        meshes.insert(
            MeshKey::new(MeshCategory::Character, variant),
            create_mesh(device, generate_character_mesh(variant)),
        );
    }
    meshes.insert(
        MeshKey::new(
            MeshCategory::Character,
            CHARACTER_IMPOSTOR_VARIANT,
        ),
        create_mesh(device, generate_character_impostor_mesh()),
    );

    meshes
}

async fn setup_renderer(window: std::sync::Arc<winit::window::Window>) -> Result<RenderStuff> {
    let size = window.inner_size();
    println!(
        "Setting up wgpu renderer with window size: {}x{}",
        size.width, size.height
    );

    // Enable debug features for better error reporting
    let instance = wgpu::Instance::new(wgpu::InstanceDescriptor {
        backends: wgpu::Backends::all(),
        flags: wgpu::InstanceFlags::DEBUG | wgpu::InstanceFlags::VALIDATION,
        ..Default::default()
    });

    println!("Creating surface...");
    let surface = instance.create_surface(window.clone())?;

    println!("Requesting adapter...");
    let adapter = instance
        .request_adapter(&wgpu::RequestAdapterOptions {
            power_preference: wgpu::PowerPreference::HighPerformance,
            compatible_surface: Some(&surface),
            force_fallback_adapter: false,
        })
        .await
        .unwrap();

    println!("Adapter found: {:?}", adapter.get_info());

    println!("Requesting device...");
    // Prefer BC texture compression for normals if supported
    let bc_supported = adapter
        .features()
        .contains(wgpu::Features::TEXTURE_COMPRESSION_BC);
    let mut required_features = wgpu::Features::empty();
    if bc_supported {
        required_features |= wgpu::Features::TEXTURE_COMPRESSION_BC;
    }
    let (device, queue) = adapter
        .request_device(
            &wgpu::DeviceDescriptor {
                label: Some("device"),
                required_features,
                required_limits: wgpu::Limits::default(),
            },
            None, // Enable validation for debug builds: Some(&std::path::Path::new("wgpu_trace"))
        )
        .await
        .unwrap();

    println!("Device created successfully");

    let msaa_samples = 4u32; // enable 4x MSAA
    let caps = surface.get_capabilities(&adapter);
    println!("Surface capabilities: {:?}", caps);

    let surface_format = caps
        .formats
        .iter()
        .copied()
        .find(|f| f.is_srgb())
        .unwrap_or(caps.formats[0]);

    println!("Selected surface format: {:?}", surface_format);
    let surface_cfg = wgpu::SurfaceConfiguration {
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
        format: surface_format,
        width: size.width.max(1),
        height: size.height.max(1),
        present_mode: caps.present_modes[0],
        alpha_mode: caps.alpha_modes[0],
        view_formats: vec![],
        desired_maximum_frame_latency: 2,
    };
    surface.configure(&device, &surface_cfg);
    let depth_view = create_depth(&device, surface_cfg.width, surface_cfg.height, msaa_samples);
    let msaa_color_view = if msaa_samples > 1 {
        Some(create_msaa_color(
            &device,
            surface_cfg.format,
            surface_cfg.width,
            surface_cfg.height,
            msaa_samples,
        ))
    } else {
        None
    };

    // HDR offscreen color target with mips for bloom
    let hdr_size = wgpu::Extent3d {
        width: surface_cfg.width,
        height: surface_cfg.height,
        depth_or_array_layers: 1,
    };
    let hdr_mips = mip_level_count_for(hdr_size);
    let hdr_tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("hdr-tex"),
        size: hdr_size,
        mip_level_count: hdr_mips,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Rgba16Float,
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT
            | wgpu::TextureUsages::TEXTURE_BINDING
            | wgpu::TextureUsages::COPY_SRC,
        view_formats: &[],
    });
    let hdr_view = hdr_tex.create_view(&wgpu::TextureViewDescriptor::default());
    // Single-mip resolve/render view for mip level 0
    let hdr_resolve_view = hdr_tex.create_view(&wgpu::TextureViewDescriptor {
        label: Some("hdr-resolve-view"),
        format: Some(wgpu::TextureFormat::Rgba16Float),
        dimension: Some(wgpu::TextureViewDimension::D2),
        aspect: wgpu::TextureAspect::All,
        base_mip_level: 0,
        mip_level_count: Some(1),
        base_array_layer: 0,
        array_layer_count: Some(1),
    });
    let hdr_msaa_view = if msaa_samples > 1 {
        let tex = device.create_texture(&wgpu::TextureDescriptor {
            label: Some("hdr-msaa"),
            size: hdr_size,
            mip_level_count: 1,
            sample_count: msaa_samples,
            dimension: wgpu::TextureDimension::D2,
            format: wgpu::TextureFormat::Rgba16Float,
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
            view_formats: &[],
        });
        Some(tex.create_view(&wgpu::TextureViewDescriptor::default()))
    } else {
        None
    };

    // Create all meshes
    let meshes = create_all_meshes(&device);

    // Create camera uniform buffer and bind group layout
    let camera_ub = device.create_buffer(&wgpu::BufferDescriptor {
        label: Some("camera-ub"),
        size: std::mem::size_of::<GpuCamera>() as u64,
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        mapped_at_creation: false,
    });
    // Create exposure uniform buffer (PostParams)
    let exposure_init = PostParams {
        exposure: 1.0,
        _pad: [0.0; 3],
        _pad2: [0.0; 4],
    };
    let exposure_buf = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("exposure-ub"),
        contents: bytemuck::bytes_of(&exposure_init),
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
    });
    let debug_init = DebugParamsRust {
        debug_tint: 0,
        _pad: [0; 3],
        _pad2: [0; 4],
    };
    let debug_buf = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("debug-ub"),
        contents: bytemuck::bytes_of(&debug_init),
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
    });
    let scene_params_init = SceneParams {
        time: 0.0,
        camera_height: 0.0,
        _pad: [0.0; 2],
    };
    let scene_params_buf = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("scene-params-ub"),
        contents: bytemuck::bytes_of(&scene_params_init),
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
    });
    let shadow_params_init = ShadowParams {
        resolution: 2048.0,
        cascade_count: 1,
        softness: 1.5,
        bias: 0.0005,
        cascade_splits: [25.0, 80.0, 160.0, 320.0],
    };
    let shadow_params_buf = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("shadow-params-ub"),
        contents: bytemuck::bytes_of(&shadow_params_init),
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
    });
    let camera_bg_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("camera-layout"),
        entries: &[
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 1,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 2,
                visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: wgpu::BufferSize::new(std::mem::size_of::<SceneParams>() as u64),
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 4,
                visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
        ],
    });
    let camera_bg = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("camera-bg"),
        layout: &camera_bg_layout,
        entries: &[
            wgpu::BindGroupEntry {
                binding: 0,
                resource: camera_ub.as_entire_binding(),
            },
            wgpu::BindGroupEntry {
                binding: 1,
                resource: exposure_buf.as_entire_binding(),
            },
            wgpu::BindGroupEntry {
                binding: 2,
                resource: scene_params_buf.as_entire_binding(),
            },
            wgpu::BindGroupEntry {
                binding: 4,
                resource: debug_buf.as_entire_binding(),
            },
        ],
    });

    // Light uniform and bind group (holds light view-projection)
    let light_ub = device.create_buffer(&wgpu::BufferDescriptor {
        label: Some("light-ub"),
        size: std::mem::size_of::<GpuCamera>() as u64,
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        mapped_at_creation: false,
    });
    let light_bg_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("light-layout"),
        entries: &[
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 1,
                visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: wgpu::BufferSize::new(
                        std::mem::size_of::<ShadowParams>() as u64,
                    ),
                },
                count: None,
            },
        ],
    });
    let light_bg = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("light-bg"),
        layout: &light_bg_layout,
        entries: &[wgpu::BindGroupEntry {
            binding: 0,
            resource: light_ub.as_entire_binding(),
        }, wgpu::BindGroupEntry {
            binding: 1,
            resource: shadow_params_buf.as_entire_binding(),
        }],
    });

    // Post-processing: bloom bind group layout and resources
    let post_bgl = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("post-bgl"),
        entries: &[
            wgpu::BindGroupLayoutEntry {
                // hdr color
                binding: 0,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Texture {
                    multisampled: false,
                    view_dimension: wgpu::TextureViewDimension::D2,
                    sample_type: wgpu::TextureSampleType::Float { filterable: true },
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                // sampler
                binding: 1,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                count: None,
            },
            // exposure params in post
            wgpu::BindGroupLayoutEntry {
                binding: 2,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                // bloom params
                binding: 3,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
        ],
    });
    let post_sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        label: Some("post-sampler"),
        address_mode_u: wgpu::AddressMode::ClampToEdge,
        address_mode_v: wgpu::AddressMode::ClampToEdge,
        address_mode_w: wgpu::AddressMode::ClampToEdge,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
        ..Default::default()
    });
    let bloom_init = BloomParams {
        threshold: 0.7,
        intensity: 0.6,
        _pad: [0.0; 2],
    };
    let bloom_ub = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("bloom-ub"),
        contents: bytemuck::bytes_of(&bloom_init),
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
    });
    let post_bg = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("post-bg"),
        layout: &post_bgl,
        entries: &[
            // Bind full-mip HDR view for sampling in post
            wgpu::BindGroupEntry {
                binding: 0,
                resource: wgpu::BindingResource::TextureView(&hdr_view),
            },
            wgpu::BindGroupEntry {
                binding: 1,
                resource: wgpu::BindingResource::Sampler(&post_sampler),
            },
            wgpu::BindGroupEntry {
                binding: 2,
                resource: exposure_buf.as_entire_binding(),
            },
            wgpu::BindGroupEntry {
                binding: 3,
                resource: bloom_ub.as_entire_binding(),
            },
        ],
    });

    // Fullscreen post shader combining exposure-tonemapped HDR with thresholded bloom from mips
    const POST_SHADER: &str = r#"
struct VsOut { @builtin(position) pos: vec4<f32>, @location(0) uv: vec2<f32> };
@vertex fn vs(@builtin(vertex_index) vi: u32) -> VsOut {
    var out: VsOut;
    // Full-screen covering triangle
    var positions = array<vec2<f32>, 3>(
        vec2<f32>(-1.0, -1.0),
        vec2<f32>( 3.0, -1.0),
        vec2<f32>(-1.0,  3.0)
    );
    let xy = positions[vi];
    out.pos = vec4<f32>(xy, 0.0, 1.0);
    out.uv = vec2<f32>((xy.x + 1.0) * 0.5, 1.0 - (xy.y + 1.0) * 0.5);
    return out;
}
@group(0) @binding(0) var hdr_tex: texture_2d<f32>;
@group(0) @binding(1) var hdr_smp: sampler;
struct PostParams { exposure: f32, _pad: vec3<f32>, };
@group(0) @binding(2) var<uniform> post: PostParams;
struct Bloom { threshold: f32, intensity: f32, _pad: vec2<f32> };
@group(0) @binding(3) var<uniform> bloom: Bloom;
@fragment fn fs(in: VsOut) -> @location(0) vec4<f32> {
  // base color from hdr
    var base = textureSample(hdr_tex, hdr_smp, in.uv).rgb;
  // multi-mip bloom sampling
  var bloom_sum = vec3<f32>(0.0);
  var w = 0.0;
  let levels = 5;
  for (var i: i32 = 1; i <= levels; i = i + 1) {
    let lod = f32(i);
    let c = textureSampleLevel(hdr_tex, hdr_smp, in.uv, lod).rgb;
    let luma = dot(c, vec3<f32>(0.2126, 0.7152, 0.0722));
    let m = max(luma - bloom.threshold, 0.0);
    let val = c * (m / max(luma + 1e-4, 1e-4));
    let weight = 1.0 / (1.0 + f32(i));
    bloom_sum += val * weight; w += weight;
  }
  let bloom_col = bloom_sum / max(w, 1e-4) * bloom.intensity;
    var color = base + bloom_col;
    // Auto-exposure: estimate average scene luminance from a high mip level near 1x1
    // Unrolled taps to avoid dynamic indexing restrictions
    var logLumSum = 0.0;
    let lodProbe = 8.0; // large LOD; will clamp to highest mip available
    {
        let uv0 = clamp(in.uv + vec2<f32>(-0.25, -0.25), vec2<f32>(0.0), vec2<f32>(1.0));
        let c0 = textureSampleLevel(hdr_tex, hdr_smp, uv0, lodProbe).rgb;
        logLumSum = logLumSum + log(max(dot(c0, vec3<f32>(0.2126, 0.7152, 0.0722)), 1e-4));

        let uv1 = clamp(in.uv + vec2<f32>(0.0, -0.25), vec2<f32>(0.0), vec2<f32>(1.0));
        let c1 = textureSampleLevel(hdr_tex, hdr_smp, uv1, lodProbe).rgb;
        logLumSum = logLumSum + log(max(dot(c1, vec3<f32>(0.2126, 0.7152, 0.0722)), 1e-4));

        let uv2 = clamp(in.uv + vec2<f32>(0.25, -0.25), vec2<f32>(0.0), vec2<f32>(1.0));
        let c2 = textureSampleLevel(hdr_tex, hdr_smp, uv2, lodProbe).rgb;
        logLumSum = logLumSum + log(max(dot(c2, vec3<f32>(0.2126, 0.7152, 0.0722)), 1e-4));

        let uv3 = clamp(in.uv + vec2<f32>(-0.25, 0.0), vec2<f32>(0.0), vec2<f32>(1.0));
        let c3 = textureSampleLevel(hdr_tex, hdr_smp, uv3, lodProbe).rgb;
        logLumSum = logLumSum + log(max(dot(c3, vec3<f32>(0.2126, 0.7152, 0.0722)), 1e-4));

        let uv4 = clamp(in.uv + vec2<f32>(0.0, 0.0), vec2<f32>(0.0), vec2<f32>(1.0));
        let c4 = textureSampleLevel(hdr_tex, hdr_smp, uv4, lodProbe).rgb;
        logLumSum = logLumSum + log(max(dot(c4, vec3<f32>(0.2126, 0.7152, 0.0722)), 1e-4));

        let uv5 = clamp(in.uv + vec2<f32>(0.25, 0.0), vec2<f32>(0.0), vec2<f32>(1.0));
        let c5 = textureSampleLevel(hdr_tex, hdr_smp, uv5, lodProbe).rgb;
        logLumSum = logLumSum + log(max(dot(c5, vec3<f32>(0.2126, 0.7152, 0.0722)), 1e-4));

        let uv6 = clamp(in.uv + vec2<f32>(-0.25, 0.25), vec2<f32>(0.0), vec2<f32>(1.0));
        let c6 = textureSampleLevel(hdr_tex, hdr_smp, uv6, lodProbe).rgb;
        logLumSum = logLumSum + log(max(dot(c6, vec3<f32>(0.2126, 0.7152, 0.0722)), 1e-4));

        let uv7 = clamp(in.uv + vec2<f32>(0.0, 0.25), vec2<f32>(0.0), vec2<f32>(1.0));
        let c7 = textureSampleLevel(hdr_tex, hdr_smp, uv7, lodProbe).rgb;
        logLumSum = logLumSum + log(max(dot(c7, vec3<f32>(0.2126, 0.7152, 0.0722)), 1e-4));

        let uv8 = clamp(in.uv + vec2<f32>(0.25, 0.25), vec2<f32>(0.0), vec2<f32>(1.0));
        let c8 = textureSampleLevel(hdr_tex, hdr_smp, uv8, lodProbe).rgb;
        logLumSum = logLumSum + log(max(dot(c8, vec3<f32>(0.2126, 0.7152, 0.0722)), 1e-4));
    }
    let logAvg = logLumSum / 9.0;
    let avgLum = exp(logAvg);
    let targetGray = 0.18;
    let autoScale = clamp(targetGray / avgLum, 0.25, 4.0);

    // Apply manual exposure scaled by auto exposure factor, then tone map
    color = color * (post.exposure * autoScale);
    let aA = 2.51; let bA = 0.03; let cA = 2.43; let dA = 0.59; let eA = 0.14;
    let tone = clamp((color * (aA * color + bA)) / (color * (cA * color + dA) + eA), vec3<f32>(0.0), vec3<f32>(1.0));
    return vec4<f32>(tone, 1.0);
}
"#;
    let post_sm = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("post-sm"),
        source: wgpu::ShaderSource::Wgsl(Cow::Borrowed(POST_SHADER)),
    });
    let post_pl = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("post-pl"),
        bind_group_layouts: &[&post_bgl],
        push_constant_ranges: &[],
    });
    let post_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("post-pipeline"),
        layout: Some(&post_pl),
        vertex: wgpu::VertexState {
            module: &post_sm,
            entry_point: "vs",
            buffers: &[],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        },
        fragment: Some(wgpu::FragmentState {
            module: &post_sm,
            entry_point: "fs",
            targets: &[Some(wgpu::ColorTargetState {
                format: surface_format,
                blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                write_mask: wgpu::ColorWrites::ALL,
            })],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        }),
        primitive: wgpu::PrimitiveState::default(),
        depth_stencil: None,
        multisample: wgpu::MultisampleState::default(),
        multiview: None,
    });

    // Debug overlay shader to draw a grid of material layers (albedo)
    const LAYER_DEBUG_SHADER: &str = r#"
struct VsOut { @builtin(position) pos: vec4<f32>, @location(0) uv: vec2<f32> };
@vertex fn vs(@builtin(vertex_index) vi: u32) -> VsOut {
    var out: VsOut;
    var positions = array<vec2<f32>, 3>(vec2<f32>(-1.0,-1.0), vec2<f32>( 3.0,-1.0), vec2<f32>(-1.0, 3.0));
    let xy = positions[vi]; out.pos = vec4<f32>(xy, 0.0, 1.0); out.uv = vec2<f32>((xy.x+1.0)*0.5, 1.0-(xy.y+1.0)*0.5); return out;
}
@group(0) @binding(0) var hdr_tex: texture_2d<f32>; // unused, keep layout parity
@group(0) @binding(1) var hdr_smp: sampler;         // unused
struct PostParams { exposure: f32, _pad: vec3<f32>, };
@group(0) @binding(2) var<uniform> post: PostParams; // unused
struct Bloom { threshold: f32, intensity: f32, _pad: vec2<f32> };
@group(0) @binding(3) var<uniform> bloom: Bloom; // unused

@group(1) @binding(0) var albedo_layers: texture_2d_array<f32>;
@group(1) @binding(1) var albedo_sampler: sampler;

@fragment fn fs(in: VsOut) -> @location(0) vec4<f32> {
    // 3x4 grid (12 material layers) in bottom-right quadrant
    let grid_cols = 4; let grid_rows = 3; let layers = 12;
    // Position the grid in a 0.6..1.0 corner
    let uv = in.uv;
    let grid_min = vec2<f32>(0.6, 0.6);
    let grid_max = vec2<f32>(1.0, 1.0);
    if (uv.x < grid_min.x || uv.y < grid_min.y) {
        // Darken rest of screen for contrast
        return vec4<f32>(0.0, 0.0, 0.0, 1.0);
    }
    let g = (uv - grid_min) / (grid_max - grid_min);
    let cell = vec2<f32>(1.0 / f32(grid_cols), 1.0 / f32(grid_rows));
    let cxy = clamp(g, vec2<f32>(0.0), vec2<f32>(0.999));
    let col = i32(floor(cxy.x / cell.x));
    let row = i32(floor(cxy.y / cell.y));
    let layer = row * grid_cols + col;
    let layer_idx = clamp(layer, 0, layers - 1);
    let frac = vec2<f32>((cxy.x - f32(col)*cell.x) / cell.x, (cxy.y - f32(row)*cell.y) / cell.y);
    // Draw subtle grid lines for readability
    let border = 0.01;
    if (frac.x < border || frac.y < border || frac.x > 1.0 - border || frac.y > 1.0 - border) {
        return vec4<f32>(0.05, 0.05, 0.05, 1.0);
    }
    let coords = vec3<f32>(frac.x, frac.y, f32(layer_idx));
    let colr = textureSample(albedo_layers, albedo_sampler, coords).rgb;
    // Draw a small index bar at the top of the tile with a color derived from the layer index
    let bar_h = 0.06;
    if (frac.y < bar_h) {
        let t = f32(layer_idx) / f32(layers - 1);
        let idx_col = vec3<f32>(0.2 + 0.8 * fract(t * 3.0), 0.2 + 0.8 * fract(t * 5.0), 0.2 + 0.8 * fract(t * 7.0));
        return vec4<f32>(idx_col, 1.0);
    }
    return vec4<f32>(colr, 1.0);
}
"#;
    // Note: creation of layer debug pipeline is deferred until after texture_bind_group_layout is defined

    // Use shared MaterialIntegrator for layout and pack management
    let mut material_integrator = MaterialIntegrator::new(&device);
    let texture_bind_group_layout = material_integrator.bind_group_layout_owned();

    let material_bind_group_layout = device.create_bind_group_layout(
        &wgpu::BindGroupLayoutDescriptor {
            label: Some("material-uniform-layout"),
            entries: &[wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: wgpu::BufferSize::new(
                        std::mem::size_of::<MaterialGpu>() as u64,
                    ),
                },
                count: None,
            }],
        },
    );

    // Shadow map layout: depth texture + comparison sampler
    let shadow_bg_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("shadow-layout"),
        entries: &[
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Texture {
                    multisampled: false,
                    view_dimension: wgpu::TextureViewDimension::D2,
                    sample_type: wgpu::TextureSampleType::Depth,
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 1,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Comparison),
                count: None,
            },
        ],
    });

    // Create shadow map resources
    let shadow_size = 2048u32;
    let shadow_tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("shadow-map"),
        size: wgpu::Extent3d {
            width: shadow_size,
            height: shadow_size,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Depth32Float,
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::TEXTURE_BINDING,
        view_formats: &[],
    });
    let shadow_view = shadow_tex.create_view(&wgpu::TextureViewDescriptor::default());
    let shadow_sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        label: Some("shadow-sampler"),
        address_mode_u: wgpu::AddressMode::ClampToEdge,
        address_mode_v: wgpu::AddressMode::ClampToEdge,
        address_mode_w: wgpu::AddressMode::ClampToEdge,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Nearest,
        compare: Some(wgpu::CompareFunction::LessEqual),
        ..Default::default()
    });
    let shadow_bg = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("shadow-bg"),
        layout: &shadow_bg_layout,
        entries: &[
            wgpu::BindGroupEntry {
                binding: 0,
                resource: wgpu::BindingResource::TextureView(&shadow_view),
            },
            wgpu::BindGroupEntry {
                binding: 1,
                resource: wgpu::BindingResource::Sampler(&shadow_sampler),
            },
        ],
    });

    let texture_manager = {
        let config_path = asset_dir().join("textures/atlas_config.toml");
        if config_path.exists() {
            match TextureManager::new(&config_path) {
                Ok(mut manager) => {
                    let asset_root = asset_dir();
                    if let Err(err) = manager.preload_all_textures(&asset_root) {
                        eprintln!(
                            "⚠️ Failed to preload textures from atlas '{}': {}",
                            config_path.display(),
                            err
                        );
                    }
                    Some(manager)
                }
                Err(err) => {
                    eprintln!(
                        "⚠️ Failed to initialize TextureManager from '{}': {}",
                        config_path.display(),
                        err
                    );
                    None
                }
            }
        } else {
            println!(
                "⚠️ Texture atlas configuration not found at {}. Falling back to procedural materials.",
                config_path.display()
            );
            None
        }
    };

    // Select initial biome before creating material arrays so TOML-driven layers can load immediately
    let current_biome: &str = "grassland";

    // Build authored pack and use its bind group
    let pack_rt = pollster::block_on(material_integrator.load(&device, &queue, current_biome))?;
    let ground_bind_group = {
        // move the bind group by recreating it from the runtime's gpu views to satisfy ownership here
        device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("materials-pack (scene)"),
            layout: &texture_bind_group_layout,
            entries: &[
                wgpu::BindGroupEntry { binding: 0, resource: wgpu::BindingResource::TextureView(&pack_rt.gpu.albedo) },
                wgpu::BindGroupEntry { binding: 1, resource: wgpu::BindingResource::Sampler(&pack_rt.gpu.sampler_albedo) },
                wgpu::BindGroupEntry { binding: 2, resource: wgpu::BindingResource::TextureView(&pack_rt.gpu.normal) },
                wgpu::BindGroupEntry { binding: 3, resource: wgpu::BindingResource::Sampler(&pack_rt.gpu.sampler_linear) },
                wgpu::BindGroupEntry { binding: 4, resource: wgpu::BindingResource::TextureView(&pack_rt.gpu.mra) },
            ],
        })
    };

    // Now create the layer debug pipeline (requires texture_bind_group_layout)
    let layer_dbg_sm = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("layer-dbg-sm"),
        source: wgpu::ShaderSource::Wgsl(Cow::Borrowed(LAYER_DEBUG_SHADER)),
    });
    let layer_dbg_pl = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("layer-dbg-pl"),
        bind_group_layouts: &[&post_bgl, &texture_bind_group_layout],
        push_constant_ranges: &[],
    });
    let layer_dbg_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("layer-debug-pipeline"),
        layout: Some(&layer_dbg_pl),
        vertex: wgpu::VertexState {
            module: &layer_dbg_sm,
            entry_point: "vs",
            buffers: &[],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        },
        fragment: Some(wgpu::FragmentState {
            module: &layer_dbg_sm,
            entry_point: "fs",
            targets: &[Some(wgpu::ColorTargetState {
                format: surface_format,
                blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                write_mask: wgpu::ColorWrites::ALL,
            })],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        }),
        primitive: wgpu::PrimitiveState::default(),
        depth_stencil: None,
        multisample: wgpu::MultisampleState::default(),
        multiview: None,
    });

    // Instance buffer sized to the LOD-managed instance cap
    let max_instances = MAX_INSTANCE_COUNT;
    let instance_vb = device.create_buffer(&wgpu::BufferDescriptor {
        label: Some("instance-buffer"),
        size: (std::mem::size_of::<InstanceRaw>() * max_instances) as u64,
        usage: wgpu::BufferUsages::VERTEX | wgpu::BufferUsages::COPY_DST,
        mapped_at_creation: false,
    });

    // Create pipeline with procedural shader
    // Create shadow pipeline
    let shadow_shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("shadow-shader"),
        source: wgpu::ShaderSource::Wgsl(Cow::Borrowed(SHADOW_SHADER)),
    });
    let shadow_pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("shadow-pipeline-layout"),
        bind_group_layouts: &[&light_bg_layout],
        push_constant_ranges: &[],
    });
    let shadow_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("shadow-pipeline"),
        layout: Some(&shadow_pipeline_layout),
        vertex: wgpu::VertexState {
            module: &shadow_shader,
            entry_point: "vs_shadow",
            buffers: &[
                wgpu::VertexBufferLayout {
                    array_stride: 3 * 4,
                    step_mode: wgpu::VertexStepMode::Vertex,
                    attributes: &[wgpu::VertexAttribute {
                        format: wgpu::VertexFormat::Float32x3,
                        offset: 0,
                        shader_location: 0,
                    }],
                },
                wgpu::VertexBufferLayout {
                    array_stride: std::mem::size_of::<InstanceRaw>() as u64,
                    step_mode: wgpu::VertexStepMode::Instance,
                    attributes: &[
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 0,
                            shader_location: 1,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 16,
                            shader_location: 2,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 32,
                            shader_location: 3,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 48,
                            shader_location: 4,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 64,
                            shader_location: 5,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Uint32,
                            offset: 80,
                            shader_location: 6,
                        },
                    ],
                },
            ],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        },
        fragment: None,
        primitive: wgpu::PrimitiveState {
            topology: wgpu::PrimitiveTopology::TriangleList,
            front_face: wgpu::FrontFace::Ccw,
            cull_mode: Some(wgpu::Face::Back),
            ..Default::default()
        },
        depth_stencil: Some(wgpu::DepthStencilState {
            format: wgpu::TextureFormat::Depth32Float,
            depth_write_enabled: true,
            depth_compare: wgpu::CompareFunction::LessEqual,
            stencil: wgpu::StencilState::default(),
            bias: wgpu::DepthBiasState {
                constant: 2,
                slope_scale: 2.0,
                clamp: 0.0,
            },
        }),
        multisample: wgpu::MultisampleState {
            count: 1,
            mask: !0,
            alpha_to_coverage_enabled: false,
        },
        multiview: None,
    });

    let shader_module = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("shader"),
        source: wgpu::ShaderSource::Wgsl(Cow::Borrowed(SHADER)),
    });
    // IBL: prefiltered specular, irradiance, BRDF LUT, sampler
    let ibl_bg_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("ibl-layout"),
        entries: &[
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Texture {
                    multisampled: false,
                    view_dimension: wgpu::TextureViewDimension::Cube,
                    sample_type: wgpu::TextureSampleType::Float { filterable: true },
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 1,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Texture {
                    multisampled: false,
                    view_dimension: wgpu::TextureViewDimension::Cube,
                    sample_type: wgpu::TextureSampleType::Float { filterable: true },
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 2,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Texture {
                    multisampled: false,
                    view_dimension: wgpu::TextureViewDimension::D2,
                    sample_type: wgpu::TextureSampleType::Float { filterable: true },
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 3,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                count: None,
            },
        ],
    });

    // IBL sampler (shared)
    let ibl_sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        label: Some("ibl-sampler"),
        address_mode_u: wgpu::AddressMode::ClampToEdge,
        address_mode_v: wgpu::AddressMode::ClampToEdge,
        address_mode_w: wgpu::AddressMode::ClampToEdge,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
        anisotropy_clamp: 16,
        ..Default::default()
    });
    // Temporary IBL bind group using valid dummy resources; will be replaced by manager outputs once baked
    let dummy_cube_tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("ibl-dummy-cube"),
        size: wgpu::Extent3d { width: 1, height: 1, depth_or_array_layers: 6 },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Rgba16Float,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });
    let dummy_cube_view = dummy_cube_tex.create_view(&wgpu::TextureViewDescriptor {
        label: Some("ibl-dummy-cube-view"),
        format: Some(wgpu::TextureFormat::Rgba16Float),
        dimension: Some(wgpu::TextureViewDimension::Cube),
        aspect: wgpu::TextureAspect::All,
        base_mip_level: 0,
        mip_level_count: Some(1),
        base_array_layer: 0,
        array_layer_count: Some(6),
    });
    let dummy_brdf_tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("ibl-dummy-brdf-2d"),
        size: wgpu::Extent3d { width: 1, height: 1, depth_or_array_layers: 1 },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Rgba16Float,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });
    let dummy_brdf_view = dummy_brdf_tex.create_view(&wgpu::TextureViewDescriptor::default());
    let mut ibl_bg = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("ibl-bg (placeholder)"),
        layout: &ibl_bg_layout,
        entries: &[
            wgpu::BindGroupEntry { binding: 0, resource: wgpu::BindingResource::TextureView(&dummy_cube_view) },
            wgpu::BindGroupEntry { binding: 1, resource: wgpu::BindingResource::TextureView(&dummy_cube_view) },
            wgpu::BindGroupEntry { binding: 2, resource: wgpu::BindingResource::TextureView(&dummy_brdf_view) },
            wgpu::BindGroupEntry { binding: 3, resource: wgpu::BindingResource::Sampler(&ibl_sampler) },
        ],
    });

    // Initialize engine-level IBL manager and replace placeholders with baked resources
    let mut ibl2_manager = IblManager::new(&device, IblQuality::Medium).ok();
    if let Some(ref mut mgr) = ibl2_manager {
        if let Ok(res) = mgr.bake_environment(&device, &queue, IblQuality::Medium) {
            // Create a bind group using the pipeline's IBL layout to satisfy layout identity
            let bg = device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some("ibl-bg (manager-resources)"),
                layout: &ibl_bg_layout,
                entries: &[
                    wgpu::BindGroupEntry { binding: 0, resource: wgpu::BindingResource::TextureView(&res.specular_cube) },
                    wgpu::BindGroupEntry { binding: 1, resource: wgpu::BindingResource::TextureView(&res.irradiance_cube) },
                    wgpu::BindGroupEntry { binding: 2, resource: wgpu::BindingResource::TextureView(&res.brdf_lut) },
                    wgpu::BindGroupEntry { binding: 3, resource: wgpu::BindingResource::Sampler(&ibl_sampler) },
                ],
            });
            // Override active IBL
            ibl_bg = bg;
        }
    }

    // Initialize mesh registry
    let mut mesh_registry = MeshRegistry::new();
    // Optional: try to load a tiny model if present; otherwise skip silently
    {
        let obj_path = std::path::Path::new("assets/models/tests/box.obj");
        if obj_path.exists() {
            if let Ok(meshes) = astraweave_render::mesh_obj::load_obj(obj_path) {
                for (i, m) in meshes.iter().enumerate() {
                    let key = RenderMeshKey(format!("obj:box:{}", i));
                    let _ = mesh_registry.fetch_or_upload(&device, &queue, key, m);
                }
            }
        }
    }
    {
        let gltf_path = std::path::Path::new("assets/models/tests/box.gltf");
        if gltf_path.exists() {
            let opts = astraweave_render::mesh_gltf::GltfOptions::default();
            if let Ok(meshes) = astraweave_render::mesh_gltf::load_gltf(gltf_path, &opts) {
                for (i, m) in meshes.iter().enumerate() {
                    let key = RenderMeshKey(format!("gltf:box:{}", i));
                    let _ = mesh_registry.fetch_or_upload(&device, &queue, key, m);
                }
            }
        }
    }
    let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("pipeline-layout"),
        bind_group_layouts: &[
            &camera_bg_layout,
            &texture_bind_group_layout,
            &shadow_bg_layout,
            &light_bg_layout,
            &material_bind_group_layout,
            &ibl_bg_layout,
        ],
        push_constant_ranges: &[],
    });

    let pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("pipeline"),
        layout: Some(&pipeline_layout),
        vertex: wgpu::VertexState {
            module: &shader_module,
            entry_point: "vs_main",
            buffers: &[
                wgpu::VertexBufferLayout {
                    array_stride: 3 * 4,
                    step_mode: wgpu::VertexStepMode::Vertex,
                    attributes: &[wgpu::VertexAttribute {
                        format: wgpu::VertexFormat::Float32x3,
                        offset: 0,
                        shader_location: 0,
                    }],
                },
                // instance transform (4 vec4 + color + mesh_type)
                wgpu::VertexBufferLayout {
                    array_stride: std::mem::size_of::<InstanceRaw>() as u64,
                    step_mode: wgpu::VertexStepMode::Instance,
                    attributes: &[
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 0,
                            shader_location: 1,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 16,
                            shader_location: 2,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 32,
                            shader_location: 3,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 48,
                            shader_location: 4,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 64,
                            shader_location: 5,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Uint32,
                            offset: 80,
                            shader_location: 6,
                        },
                    ],
                },
            ],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        },
        fragment: Some(wgpu::FragmentState {
            module: &shader_module,
            entry_point: "fs_main",
            targets: &[Some(wgpu::ColorTargetState {
                format: wgpu::TextureFormat::Rgba16Float,
                blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                write_mask: wgpu::ColorWrites::ALL,
            })],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        }),
        primitive: wgpu::PrimitiveState {
            topology: wgpu::PrimitiveTopology::TriangleList,
            strip_index_format: None,
            front_face: wgpu::FrontFace::Ccw,
            cull_mode: None, // Disable culling to allow skybox with inverted winding
            ..Default::default()
        },
        depth_stencil: Some(wgpu::DepthStencilState {
            format: DEPTH_FORMAT,
            depth_write_enabled: true,
            depth_compare: wgpu::CompareFunction::Less,
            stencil: wgpu::StencilState::default(),
            bias: wgpu::DepthBiasState::default(),
        }),
        multisample: wgpu::MultisampleState {
            count: msaa_samples,
            mask: !0,
            alpha_to_coverage_enabled: false,
        },
        multiview: None,
    });

    // With shared material manager, normals are stored as RG (Z reconstructed) by policy
    let normals_are_rg = true;
    Ok(RenderStuff {
        surface,
        surface_cfg,
        device,
        queue,
        depth_view,
        pipeline,
        meshes,
        camera_ub,
        camera_bg,
        instance_vb,
        instance_count: 0, // Will be updated dynamically
        msaa_samples,
        msaa_color_view,
        hdr_tex,
        hdr_view,
        hdr_resolve_view,
        hdr_msaa_view,
        shadow_view,
        shadow_sampler,
        shadow_pipeline,
        shadow_size,
        shadow_params_buf,
        shadow_bg_layout,
        light_ub,
        light_bg,
        shadow_bg,
        texture_bind_group_layout,
        exposure_buf,
        scene_params_buf,
    ground_bind_group,
        material_bind_group_layout,
        material_buffer: None,
        material_bind_group: None,
        material_library: None,
        texture_manager,
        current_biome: current_biome.to_string(),
        post_pipeline,
        layer_dbg_pipeline,
        post_bg,
        post_bgl,
        post_sampler,
        bloom_ub,
        debug_buf,
    debug_show_layer_quads: false,
    normals_are_rg,
    // IBL resources
    ibl_bg_layout,
    ibl_bg,
    ibl_sampler,
    ibl_enabled: true,
    ibl_last_update: 0.0,
    ibl2_manager,
    mesh_registry,
    })

}

fn create_depth(device: &wgpu::Device, width: u32, height: u32, samples: u32) -> wgpu::TextureView {
    let tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("depth"),
        size: wgpu::Extent3d {
            width,
            height,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: samples,
        dimension: wgpu::TextureDimension::D2,
        format: DEPTH_FORMAT,
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
        view_formats: &[],
    });
    tex.create_view(&wgpu::TextureViewDescriptor::default())
}

fn create_msaa_color(
    device: &wgpu::Device,
    format: wgpu::TextureFormat,
    width: u32,
    height: u32,
    samples: u32,
) -> wgpu::TextureView {
    let tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("msaa-color"),
        size: wgpu::Extent3d {
            width,
            height,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: samples,
        dimension: wgpu::TextureDimension::D2,
        format,
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
        view_formats: &[],
    });
    tex.create_view(&wgpu::TextureViewDescriptor::default())
}

// ---------------- shader with procedural ground/sky ----------------

// Depth-only shadow map shader
const SHADOW_SHADER: &str = r#"
struct Camera { view_proj: mat4x4<f32> };

@group(0) @binding(0) var<uniform> u_light: Camera;

struct VsIn {
    @location(0) pos: vec3<f32>,
    @location(1) m0: vec4<f32>,
    @location(2) m1: vec4<f32>,
    @location(3) m2: vec4<f32>,
    @location(4) m3: vec4<f32>,
    @location(5) color: vec4<f32>,
    @location(6) mesh_type: u32,
};

struct VsOut { @builtin(position) pos: vec4<f32> };

@vertex
fn vs_shadow(in: VsIn) -> VsOut {
    var out: VsOut;
    // Skip skybox by pushing it out of clip space
    if (in.mesh_type == 5u) {
        out.pos = vec4<f32>(2.0, 2.0, 2.0, 1.0);
        return out;
    }
    let model = mat4x4<f32>(in.m0, in.m1, in.m2, in.m3);
    let world = model * vec4<f32>(in.pos, 1.0);
    out.pos = u_light.view_proj * world;
    return out;
}
"#;

const SHADER: &str = r#"
struct Camera { view_proj: mat4x4<f32> };
struct DebugParams { debug_tint: u32, _pad: vec3<f32> };
struct PostParams { exposure: f32, _pad0: vec3<f32> };
struct SceneParams { time: f32, camera_height: f32, _pad: vec2<f32> };
struct MaterialUniform {
    albedo: vec4<f32>,
    emissive: vec4<f32>,
    roughness_metallic: vec4<f32>,
    flags: u32,
    _pad: vec3<u32>,
};

struct ShadowParams {
    resolution: f32,
    cascade_count: u32,
    softness: f32,
    bias: f32,
    cascade_splits: array<f32, 4>,
};

@group(0) @binding(0) var<uniform> u_camera: Camera;
@group(0) @binding(1) var<uniform> u_post: PostParams;
@group(0) @binding(2) var<uniform> u_scene: SceneParams;
@group(0) @binding(4) var<uniform> u_debug: DebugParams;
const MATERIAL_LAYER_TOTAL: i32 = 12;
const MATERIAL_GRASS: i32 = 0;
const MATERIAL_DIRT: i32 = 1;
const MATERIAL_STONE: i32 = 2;
const MATERIAL_SAND: i32 = 3;
const MATERIAL_FOREST_FLOOR: i32 = 4;
const MATERIAL_TREE_BARK: i32 = 5;
const MATERIAL_TREE_LEAVES: i32 = 6;
const MATERIAL_ROCK_LICHEN: i32 = 7;
const MATERIAL_ROCK_SLATE: i32 = 8;
const MATERIAL_PLASTER: i32 = 9;
const MATERIAL_ROOF_TILE: i32 = 10;
const MATERIAL_CLOTH: i32 = 11;

@group(1) @binding(0) var material_albedo: texture_2d_array<f32>;
@group(1) @binding(1) var material_albedo_sampler: sampler;
@group(1) @binding(2) var material_normal: texture_2d_array<f32>;
@group(1) @binding(3) var material_normal_sampler: sampler;
@group(1) @binding(4) var material_mra: texture_2d_array<f32>;
@group(1) @binding(5) var material_mra_sampler: sampler;

@group(4) @binding(0) var<uniform> u_material: MaterialUniform;

// IBL bindings: prefiltered specular, irradiance, BRDF LUT, sampler
@group(5) @binding(0) var ibl_specular: texture_cube<f32>;
@group(5) @binding(1) var ibl_irradiance: texture_cube<f32>;
@group(5) @binding(2) var brdf_lut: texture_2d<f32>;
@group(5) @binding(3) var ibl_sampler: sampler;

// Shadows
@group(2) @binding(0) var shadow_map: texture_depth_2d;
@group(2) @binding(1) var shadow_sampler: sampler_comparison;
@group(3) @binding(0) var<uniform> u_light: Camera;
@group(3) @binding(1) var<uniform> u_shadow_params: ShadowParams;

// Helper struct and functions for triplanar sampling across texture sets
struct SampleSet { c: vec3<f32>, n: vec3<f32>, m: vec4<f32> };

// -----------------------------------------------------------------------------
// Noise utilities (hash, value noise, FBM) to avoid grid-aligned artifacts
// -----------------------------------------------------------------------------

fn hash21(p: vec2<f32>) -> f32 {
    let h = dot(p, vec2<f32>(127.1, 311.7));
    return fract(sin(h) * 43758.5453);
}

fn smooth2(t: vec2<f32>) -> vec2<f32> {
    // Quintic smoothing for C2 continuity
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

fn value_noise2(p: vec2<f32>) -> f32 {
    let i = floor(p);
    let f = fract(p);
    let u = smooth2(f);

    let a = hash21(i + vec2<f32>(0.0, 0.0));
    let b = hash21(i + vec2<f32>(1.0, 0.0));
    let c = hash21(i + vec2<f32>(0.0, 1.0));
    let d = hash21(i + vec2<f32>(1.0, 1.0));

    let x1 = mix(a, b, u.x);
    let x2 = mix(c, d, u.x);
    return mix(x1, x2, u.y);
}

fn fbm2(p: vec2<f32>, octaves: i32, lacunarity: f32, gain: f32) -> f32 {
    var f = 0.0;
    var amp = 0.5;
    var freq = 1.0;
    var i = 0;
    loop {
        if (i >= octaves) { break; }
        f = f + value_noise2(p * freq) * amp;
        freq = freq * lacunarity;
        amp = amp * gain;
        i = i + 1;
    }
    return f;
}

fn fbm_ridge2(p: vec2<f32>, octaves: i32, lacunarity: f32, gain: f32) -> f32 {
    // Ridged multifractal using absolute value and inversion
    var f = 0.0;
    var amp = 0.5;
    var freq = 1.0;
    var i = 0;
    loop {
        if (i >= octaves) { break; }
        let n = value_noise2(p * freq);
        let r = 1.0 - abs(n * 2.0 - 1.0);
        f = f + r * amp;
        freq = freq * lacunarity;
        amp = amp * gain;
        i = i + 1;
    }
    return f;
}

fn noise_grad2(p: vec2<f32>) -> vec2<f32> {
    // Central differences gradient of value noise
    let e = 0.001;
    let dx = value_noise2(p + vec2<f32>(e, 0.0)) - value_noise2(p - vec2<f32>(e, 0.0));
    let dy = value_noise2(p + vec2<f32>(0.0, e)) - value_noise2(p - vec2<f32>(0.0, e));
    return vec2<f32>(dx, dy) / (2.0 * e);
}

fn reconstruct_normal_from_rg(nrg: vec2<f32>) -> vec3<f32> {
    let nxy = nrg * 2.0 - 1.0;
    let nz = sqrt(max(0.0, 1.0 - dot(nxy, nxy)));
    return vec3<f32>(nxy.x, nxy.y, nz);
}

// IBL helpers
fn sample_ibl_diffuse(N: vec3<f32>) -> vec3<f32> {
    // Diffuse IBL: sample irradiance cubemap at the normal direction (no mip needed)
    return textureSampleLevel(ibl_irradiance, ibl_sampler, N, 0.0).rgb;
}

fn sample_ibl_specular(R: vec3<f32>, roughness: f32, NdotV: f32) -> vec3<f32> {
    // Prefiltered specular: choose mip from roughness and sample specular cubemap
    let max_mips = f32(textureNumLevels(ibl_specular));
    let level = clamp(roughness * max(0.0, max_mips - 1.0), 0.0, max(0.0, max_mips - 1.0));
    let prefiltered = textureSampleLevel(ibl_specular, ibl_sampler, R, level).rgb;
    let brdf = textureSample(brdf_lut, ibl_sampler, vec2<f32>(clamp(NdotV, 0.0, 1.0), clamp(roughness, 0.0, 1.0))).rg;
    // Split-sum: F approx is applied outside; here we return scaled specular
    return prefiltered * vec3<f32>(brdf.x, brdf.x, brdf.x) + vec3<f32>(brdf.y, brdf.y, brdf.y);
}

fn sample_material_layer(layer: i32, uv: vec2<f32>) -> SampleSet {
    let idx = clamp(layer, 0, MATERIAL_LAYER_TOTAL - 1);
    let coords = vec3<f32>(uv.x, uv.y, f32(idx));
    let c = textureSample(material_albedo, material_albedo_sampler, coords).rgb;
    var n_samp = textureSample(material_normal, material_normal_sampler, coords);
    // If normals stored as RG, reconstruct Z; otherwise use RGB
    let n = vec3<f32>(n_samp.rg, sqrt(max(0.0, 1.0 - dot(n_samp.rg * 2.0 - 1.0, n_samp.rg * 2.0 - 1.0))));
    let m = textureSample(material_mra, material_mra_sampler, coords);
    return SampleSet(c, n, m);
}

// by biome (legacy mappings)
fn sample_set(biome: i32, uv: vec2<f32>) -> SampleSet {
    if (biome == 0) { return sample_material_layer(MATERIAL_GRASS, uv); }
    if (biome == 1) { return sample_material_layer(MATERIAL_SAND, uv); }
    return sample_material_layer(MATERIAL_FOREST_FLOOR, uv);
}

// Percentage-closer filtering shadow test
fn sample_shadow(world_pos: vec3<f32>, N: vec3<f32>, L: vec3<f32>) -> f32 {
    let pos_light = u_light.view_proj * vec4<f32>(world_pos, 1.0);
    let proj = pos_light.xyz / pos_light.w;
    // Transform from NDC (-1..1) to 0..1
    let uv = proj.xy * 0.5 + vec2<f32>(0.5, 0.5);
    let depth = proj.z * 0.5 + 0.5;
    let cascade_count = max(u_shadow_params.cascade_count, 1u);
    var cascade_idx: u32 = 0u;
    for (var i: u32 = 0u; i < cascade_count; i = i + 1u) {
        if (depth <= u_shadow_params.cascade_splits[i]) {
            cascade_idx = i;
            break;
        }
        cascade_idx = i;
    }
    cascade_idx = min(cascade_idx, cascade_count - 1u);

    let cascade_factor = 1.0 + f32(cascade_idx) * 0.35;
    let texel = 1.0 / max(u_shadow_params.resolution, 1.0);
    let base_bias = max(u_shadow_params.bias, 1e-5);
    let bias = max(base_bias * (1.0 - dot(N, L)), base_bias * 0.5);
    // Early out if outside light frustum
    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) { return 0.0; }

    // Rotated Poisson-disk PCF (16 taps)
    let softness = u_shadow_params.softness;

    // Random rotation per-fragment derived from UV to reduce banding
    let rnd = fract(sin(dot(uv, vec2<f32>(12.9898, 78.233))) * 43758.5453);
    let angle = rnd * 6.2831853; // 2*pi
    let c = cos(angle);
    let s = sin(angle);
    let rot = mat2x2<f32>(vec2<f32>(c, s), vec2<f32>(-s, c)); // [ [c,-s],[s,c] ] in column form

    // Filter radius: slightly wider at grazing angles to hide stair-steps
    let radius = (softness * cascade_factor + (1.0 - clamp(dot(N, L), 0.0, 1.0)) * 2.0) * texel;

    // Unrolled 16 Poisson taps to avoid dynamic array indexing restrictions
    var occl: f32 = 0.0;
    let p0 = rot * vec2<f32>(-0.94201624, -0.39906216);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p0 * radius * 2.5, depth - bias));
    let p1 = rot * vec2<f32>(0.94558609, -0.76890725);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p1 * radius * 2.5, depth - bias));
    let p2 = rot * vec2<f32>(-0.09418410, -0.92938870);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p2 * radius * 2.5, depth - bias));
    let p3 = rot * vec2<f32>(0.34495938, 0.29387760);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p3 * radius * 2.5, depth - bias));
    let p4 = rot * vec2<f32>(-0.91588581, 0.45771432);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p4 * radius * 2.5, depth - bias));
    let p5 = rot * vec2<f32>(-0.81544232, -0.87912464);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p5 * radius * 2.5, depth - bias));
    let p6 = rot * vec2<f32>(-0.38277543, 0.27676845);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p6 * radius * 2.5, depth - bias));
    let p7 = rot * vec2<f32>(0.97484398, 0.75648379);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p7 * radius * 2.5, depth - bias));
    let p8 = rot * vec2<f32>(0.44323325, -0.97511554);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p8 * radius * 2.5, depth - bias));
    let p9 = rot * vec2<f32>(0.53742981, -0.47373420);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p9 * radius * 2.5, depth - bias));
    let p10 = rot * vec2<f32>(-0.26496911, -0.41893023);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p10 * radius * 2.5, depth - bias));
    let p11 = rot * vec2<f32>(0.79197514, 0.19090188);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p11 * radius * 2.5, depth - bias));
    let p12 = rot * vec2<f32>(-0.24188840, 0.99706507);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p12 * radius * 2.5, depth - bias));
    let p13 = rot * vec2<f32>(-0.81409955, 0.91437590);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p13 * radius * 2.5, depth - bias));
    let p14 = rot * vec2<f32>(0.19984126, 0.78641367);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p14 * radius * 2.5, depth - bias));
    let p15 = rot * vec2<f32>(0.14383161, -0.14100790);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p15 * radius * 2.5, depth - bias));
    return occl / 16.0;
}

// by material: 0=grass,1=dirt,2=stone,3=sand,4=forest
fn sample_material(which: i32, uv: vec2<f32>) -> SampleSet {
    return sample_material_layer(which, uv);
}

// Blend three sample sets with enhanced triplanar weights and material transitions
fn blend3(a: SampleSet, b: SampleSet, c: SampleSet, w: vec3<f32>, transition_width: f32) -> SampleSet {
    // Enhanced weight calculation with smooth transitions
    let w_smooth = pow(w, vec3<f32>(transition_width));
    let wsum = max(w_smooth.x + w_smooth.y + w_smooth.z, 1e-4);
    let wnorm = w_smooth / wsum;

    // Colors are already sampled in linear space (sRGB textures are linearized by the sampler),
    // so blend directly in linear space without manual gamma conversions
    var col = a.c * wnorm.x + b.c * wnorm.y + c.c * wnorm.z;

    // Enhanced normal blending with proper tangent space interpolation
    let na = normalize(a.n * 2.0 - 1.0);
    let nb = normalize(b.n * 2.0 - 1.0);
    let nc = normalize(c.n * 2.0 - 1.0);
    
    // Use weighted average with angle-based weighting for better normal interpolation
    let n_blend = na * wnorm.x + nb * wnorm.y + nc * wnorm.z;
    let nr = normalize(n_blend) * 0.5 + 0.5;
    
    // MRA blending with material property preservation
    let mr = a.m * wnorm.x + b.m * wnorm.y + c.m * wnorm.z;
    
    // Optional debug tint to validate material sampling bindings
    if (u_debug.debug_tint == 1u) {
        let tint_a = vec3<f32>(1.0, 0.0, 0.0);
        let tint_b = vec3<f32>(0.0, 1.0, 0.0);
        let tint_c = vec3<f32>(0.0, 0.0, 1.0);
        col = col * 0.5 + (tint_a * wnorm.x + tint_b * wnorm.y + tint_c * wnorm.z) * 0.5;
    }
    return SampleSet(col, nr, mr);
}

// Enhanced triplanar sampling with detail mapping and micro-variation
fn sample_triplanar_enhanced(material_idx: i32, world_pos: vec3<f32>, normal: vec3<f32>, 
                           scale: f32, detail_scale: f32) -> SampleSet {
    // Base UV coordinates for triplanar mapping
    let uv_x = world_pos.zy * scale;
    let uv_y = world_pos.xz * scale; 
    let uv_z = world_pos.xy * scale;
    // Add micro-variation using FBM noise to break up tiling without grid artifacts
    let n_xy = fbm2(world_pos.xy * detail_scale * 0.15, 4, 2.0, 0.5);
    let n_yz = fbm2(world_pos.yz * detail_scale * 0.15, 4, 2.0, 0.5);
    let n_zx = fbm2(world_pos.zx * detail_scale * 0.15, 4, 2.0, 0.5);
    let v = 0.08; // variation strength
    let uv_x_varied = uv_x + vec2<f32>(n_yz, n_zx) * v;
    let uv_y_varied = uv_y + vec2<f32>(n_zx, n_xy) * v;
    let uv_z_varied = uv_z + vec2<f32>(n_xy, n_yz) * v;
    
    // Sample each axis with variation
    let sample_x = sample_material(material_idx, uv_x_varied);
    let sample_y = sample_material(material_idx, uv_y_varied);
    let sample_z = sample_material(material_idx, uv_z_varied);
    
    // Enhanced weight calculation based on normal with smooth transitions
    let n_abs = abs(normal);
    let weights = pow(n_abs, vec3<f32>(2.0)); // Slightly softer to reduce seams
    let weight_sum = max(weights.x + weights.y + weights.z, 1e-4);
    let wnorm = weights / weight_sum;
    
    // Use enhanced blending with smooth transitions
    return blend3(sample_x, sample_y, sample_z, wnorm, 2.0);
}

// Detail mapping function for micro-surface variation
fn apply_detail_mapping(base_color: vec3<f32>, world_pos: vec3<f32>, detail_scale: f32, detail_strength: f32) -> vec3<f32> {
    // FBM-based subtle albedo variation
    let p = world_pos.xz * detail_scale;
    let n = fbm2(p, 4, 2.0, 0.5);
    let variation = (n - 0.5) * 2.0; // [-1,1]
    let detail_color = base_color * (1.0 + variation * 0.06 * detail_strength);
    return detail_color;
}

// Perturb the surface normal using a simple high-frequency procedural pattern
fn perturb_normal(normal: vec3<f32>, world_pos: vec3<f32>, detail_scale: f32, strength: f32) -> vec3<f32> {
    // Use gradient of FBM to perturb normal in a stable, non-grid way
    let p = world_pos.xz * detail_scale;
    let g = noise_grad2(p);
    // Build tangent basis with up approximation; for terrain N is already close to up
    let T = normalize(cross(normal, vec3<f32>(0.0, 1.0, 0.0)) + vec3<f32>(1e-4, 0.0, 0.0));
    let B = normalize(cross(normal, T));
    let n_perturb = (T * g.x + B * g.y) * strength;
    return normalize(normal + n_perturb);
}

// Calculate tessellation factor based on distance and terrain features
fn calculate_tessellation_factor(world_pos: vec3<f32>, camera_pos: vec3<f32>, slope: f32) -> f32 {
    let distance = length(world_pos - camera_pos);
    
    // Base tessellation decreases with distance
    let distance_factor = clamp(1.0 - distance / 100.0, 0.1, 1.0);
    
    // Increase tessellation on steep slopes for better detail
    let slope_factor = 1.0 + slope * 2.0;
    
    // Combine factors with some noise for natural variation
    let noise_factor = sin(world_pos.x * 0.01) * cos(world_pos.z * 0.01) * 0.1 + 0.9;
    
    return distance_factor * slope_factor * noise_factor;
}

// Vertex inputs aligned with Rust vertex buffers:
// - location(0): position (vec3)
// - locations(1..4): model matrix columns (vec4)
// - location(5): color (vec4)
// - location(6): mesh_type (u32)
struct VsIn {
    @location(0) pos: vec3<f32>,
    @location(1) m0: vec4<f32>,
    @location(2) m1: vec4<f32>,
    @location(3) m2: vec4<f32>,
    @location(4) m3: vec4<f32>,
    @location(5) color: vec4<f32>,
    @location(6) mesh_type: u32,
};

struct VsOut {
  @builtin(position) pos: vec4<f32>,
  @location(0) color: vec4<f32>,
  @location(1) world_pos: vec3<f32>,
  @location(2) view_dir: vec3<f32>,
    @location(3) normal: vec3<f32>,
    @location(4) uv: vec2<f32>,
  @location(5) mesh_type: u32,
    @location(6) local_pos: vec3<f32>,
};

@vertex
fn vs_main(in: VsIn) -> VsOut {
    let model = mat4x4<f32>(in.m0, in.m1, in.m2, in.m3);
  var out: VsOut;
  let world = model * vec4<f32>(in.pos, 1.0);
  
// Special handling for skybox (mesh_type 5) - position at far plane
    if (in.mesh_type == 5u) {
    // For skybox, apply model transform then scale down the large vertices
    let scaled_vertex = vec4<f32>(in.pos * 0.5, 1.0); // Larger skybox for better coverage  
    let world_skybox = model * scaled_vertex; // Apply model transform (camera translation)
    out.pos = u_camera.view_proj * world_skybox;
    // Ensure skybox is always at far plane
    out.pos.z = out.pos.w * 0.999; // At far plane
    out.world_pos = world_skybox.xyz;
    out.local_pos = in.pos;
    
    // For skybox, we use position as texture coordinates
    let pos_normalized = normalize(in.pos);
    out.uv = vec2<f32>(
      0.5 + atan2(pos_normalized.z, pos_normalized.x) / (2.0 * 3.14159),
      0.5 - asin(pos_normalized.y) / 3.14159
    );
  } else {
    out.pos = u_camera.view_proj * world;
    out.world_pos = world.xyz;
        // Derive UVs procedurally from world position (no per-vertex UVs provided)
        let scale = 10.0;
        out.uv = vec2<f32>(world.x / scale, world.z / scale);
      out.local_pos = in.pos;
  }
  
    // Default normal (up). Real meshes should provide normals; this keeps lighting reasonable.
    out.normal = vec3<f32>(0.0, 1.0, 0.0);
  
  out.color = in.color;
  out.mesh_type = in.mesh_type;
  
  // Calculate view direction for sky effects
  let camera_pos = vec3<f32>(0.0, 5.0, 0.0); // Better approximation for typical camera height
  out.view_dir = normalize(world.xyz - camera_pos);
  
  return out;
}

// Enhanced sky color function - generates biome-appropriate sky with atmospheric effects
fn sky_color(direction: vec3<f32>, time: f32) -> vec3<f32> {
    let dir = normalize(direction);
    let y = clamp(dir.y, -1.0, 1.0);
    // Stable daytime blue gradient
    let horizon = vec3<f32>(0.75, 0.85, 1.0);
    let zenith = vec3<f32>(0.15, 0.45, 0.9);
    let t = pow(clamp((y + 1.0) * 0.5, 0.0, 1.0), 0.6);
    let base = mix(horizon, zenith, t);
    // Soft moving clouds
    let n = sin(dir.x * 5.0 + time * 0.2) * cos(dir.z * 4.0 + time * 0.15);
    let clouds = clamp(n, 0.0, 1.0) * 0.12;
    return base + vec3<f32>(clouds, clouds, clouds);
}


// Enhanced water rendering for rivers and lakes
fn get_water_level(world_pos: vec2<f32>, time: f32) -> f32 {
  let wave_scale = 0.5;
  let wave_time = time * 2.0;
  let wave_pos = world_pos * wave_scale + vec2<f32>(wave_time * 0.3, wave_time * 0.5);
  
  // Water surface animation
  let wave1 = sin(wave_pos.x * 4.0) * cos(wave_pos.y * 3.0) * 0.1;
  let wave2 = sin(wave_pos.x * 8.0 + 1.0) * cos(wave_pos.y * 6.0 + 1.5) * 0.05;
  
  return -1.8 + wave1 + wave2; // Base water level with waves
}

// Determine biome type based on world position - FIXED: More consistent biome regions
fn get_biome_type(world_pos: vec2<f32>) -> i32 {
    let biome_scale = 0.01;
    let biome_pos = world_pos * biome_scale;
    // Smooth FBM determines regions; thresholds split into 3 biomes
    let n = fbm2(biome_pos, 5, 2.0, 0.5) * 2.0 - 1.0; // [-1,1]
    if (n > 0.25) {
        return 1; // Desert
    } else if (n < -0.25) {
        return 2; // Dense Forest
    } else {
        return 0; // Grassland
    }
}

// Generate biome-specific terrain height with enhanced variation
fn get_biome_terrain_height(world_pos: vec2<f32>, biome_type: i32) -> f32 {
    // Base FBM terrain: smooth features with octave detail
    let p = world_pos * 0.01;
    let base = (fbm2(p, 5, 2.0, 0.5) * 2.0 - 1.0) * 3.5; // [-3.5,3.5]
    let detail = (fbm2(p * 3.0, 3, 2.2, 0.5) - 0.5) * 1.5;
    var h = base + detail;

    if (biome_type == 0) { // Grassland - rolling hills with river valleys
        // River mask via ridge FBM to carve shallow valleys
        let river = fbm_ridge2(p * 0.9, 3, 2.0, 0.6);
        let valleys = (river - 0.6) * 6.0; // negative mostly
        h = h + clamp(valleys, -3.5, 0.0);
        return h;

    } else if (biome_type == 1) { // Desert - dunes and mesas
        // Dunes via directional ridged noise along wind axis
        let wind_dir = normalize(vec2<f32>(0.8, 0.6));
        let d = dot(p * 6.0, wind_dir);
        let dunes = (fbm_ridge2(vec2<f32>(d, d * 0.3), 4, 2.0, 0.55) - 0.5) * 3.0;
        // Mesas via thresholded ridge noise
        let mesas = step(0.7, fbm_ridge2(p * 0.7, 4, 2.0, 0.5)) * 6.0;
        h = h + dunes + mesas;
        return h;

    } else if (biome_type == 2) { // Dense Forest - softer undulations with mounds
        let soft = fbm2(p * 0.7, 4, 2.0, 0.5) * 2.0 - 1.0;
        let mounds = step(0.65, fbm2(p * 1.3 + 12.3, 4, 2.0, 0.5)) * 1.6;
        h = h * 0.9 + soft * 2.2 + mounds;
        return h;

    } else {
        return h;
    }
}

@fragment
fn fs_main(in: VsOut) -> @location(0) vec4<f32> {
  var col = in.color.rgb;
    let time = u_scene.time;
  
  // Mesh-specific rendering based on mesh type
    if (in.mesh_type == 1u) { // Tree (separate bark and foliage materials)
        let ws_pos = in.world_pos;
        let V = normalize(-in.view_dir);
        let sun_angle = time * 0.1;
        let L = normalize(vec3<f32>(cos(sun_angle) * 0.8, max(sin(sun_angle) * 0.8, 0.2), sin(sun_angle * 0.3) * 0.4));

        // Use local Y to separate trunk vs canopy
        let is_trunk = in.local_pos.y < 0.6;
        var base_sample: SampleSet;
        if (is_trunk) {
            // Trunk: dedicated bark layer with slate detail for normals
            let bark = sample_triplanar_enhanced(MATERIAL_TREE_BARK, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.6, 9.0);
            let slate = sample_triplanar_enhanced(MATERIAL_ROCK_SLATE, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.0, 12.0);
            base_sample = bark;
            base_sample.c = mix(bark.c, slate.c * vec3<f32>(0.8, 0.75, 0.7), 0.25);
            base_sample.n = slate.n;
            base_sample.m = bark.m;
        } else {
            // Leaves: lush canopy layer with forest floor detail tint
            base_sample = sample_triplanar_enhanced(MATERIAL_TREE_LEAVES, ws_pos, vec3<f32>(0.0,1.0,0.0), 1.6, 12.0);
            let understory = sample_triplanar_enhanced(MATERIAL_FOREST_FLOOR, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.2, 9.5);
            base_sample.c = mix(base_sample.c * vec3<f32>(0.92, 1.12, 0.92), understory.c, 0.18);
            base_sample.m.g = clamp(base_sample.m.g + 0.12, 0.0, 1.0);
        }
                // PBR lighting similar to terrain
                let N = normalize(base_sample.n * 2.0 - 1.0);
                let H = normalize(L + V);
                let ao = base_sample.m.r;
                let roughness = clamp(base_sample.m.g, 0.08, 0.98);
                let metallic = clamp(base_sample.m.b * 0.2, 0.0, 0.2);
                let base_color = base_sample.c;
                let ior = mix(1.3, 2.0, metallic);
                let F0 = pow((ior - 1.0) / (ior + 1.0), 2.0);
                let F0_vec = mix(vec3<f32>(F0, F0, F0), base_color, metallic);
                let F = F0_vec + (vec3<f32>(1.0) - F0_vec) * pow(1.0 - clamp(dot(H, V), 0.0, 1.0), 5.0);
                let a = roughness * roughness; let a2 = a * a;
                let NdotH = max(dot(N, H), 0.0); let NdotH2 = NdotH * NdotH;
                let denom = (NdotH2 * (a2 - 1.0) + 1.0);
                let D = a2 / (3.14159 * denom * denom + 1e-5);
                let NdotV = max(dot(N, V), 0.0); let NdotL = max(dot(N, L), 0.0);
                let k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
                let Gv = NdotV / (NdotV * (1.0 - k) + k + 1e-5);
                let Gl = NdotL / (NdotL * (1.0 - k) + k + 1e-5);
                let G_geom = Gv * Gl;
                let kd = (vec3<f32>(1.0) - F) * (1.0 - metallic);
                let diffuse = kd * base_color / 3.14159;
                let specular = (F * D * G_geom) / max(4.0 * NdotV * NdotL + 1e-5, 1e-5);
                let ibl_on = f32((u_debug.debug_tint & 2u) >> 1u);
                let sky_ambient = sky_color(normalize(in.world_pos), time) * 0.2 + sample_ibl_diffuse(N) * 0.15 * ibl_on;
                let enhanced_ao = pow(ao, 0.85);
                let ambient = base_color * enhanced_ao * 0.25 + sky_ambient * enhanced_ao;
                let shadow = sample_shadow(in.world_pos, N, L);
                // Specular IBL term
                let R = reflect(-V, N);
                let spec_ibl = sample_ibl_specular(R, roughness, NdotV) * ibl_on;
                col = ambient + (diffuse + specular) * NdotL * (1.0 - shadow) + spec_ibl * 0.5;
                // Output linear color; surface is sRGB so conversion happens on write
                return vec4<f32>(col, 1.0);
    }
    else if (in.mesh_type == 2u) { // House/Structure (walls vs roof)
                let ws_pos = in.world_pos;
                let V = normalize(-in.view_dir);
                let sun_angle = time * 0.1;
                let L = normalize(vec3<f32>(cos(sun_angle) * 0.8, max(sin(sun_angle) * 0.8, 0.2), sin(sun_angle * 0.3) * 0.4));

                // Separate walls (lower) and roof (upper) by local Y
                let is_roof = in.local_pos.y > 0.6;
                var base_sample: SampleSet;
                if (is_roof) {
            // Roof: dedicated tile layer with subtle sun bleaching
            base_sample = sample_triplanar_enhanced(MATERIAL_ROOF_TILE, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.2, 8.0);
            base_sample.c = base_sample.c * vec3<f32>(1.05, 0.98, 0.92);
                } else {
            // Walls: plaster with stone underlay for weathering
            let plaster = sample_triplanar_enhanced(MATERIAL_PLASTER, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.0, 8.0);
            let stone = sample_triplanar_enhanced(MATERIAL_STONE, ws_pos, vec3<f32>(0.0,1.0,0.0), 1.8, 10.0);
            base_sample = plaster;
            base_sample.c = mix(plaster.c, stone.c, 0.2);
            base_sample.n = mix(plaster.n, stone.n, 0.35);
            base_sample.m = mix(plaster.m, stone.m, vec4<f32>(0.25, 0.25, 0.25, 0.0));
                }
                // PBR shading
                let N = normalize(base_sample.n * 2.0 - 1.0);
                let H = normalize(L + V);
                let ao = base_sample.m.r;
                let roughness = clamp(base_sample.m.g, 0.12, 0.98);
                let metallic = clamp(base_sample.m.b * 0.2, 0.0, 0.2);
                let base_color = base_sample.c;
                let ior = mix(1.3, 2.0, metallic);
                let F0 = pow((ior - 1.0) / (ior + 1.0), 2.0);
                let F0_vec = mix(vec3<f32>(F0, F0, F0), base_color, metallic);
                let F = F0_vec + (vec3<f32>(1.0) - F0_vec) * pow(1.0 - clamp(dot(H, V), 0.0, 1.0), 5.0);
                let a = roughness * roughness; let a2 = a * a;
                let NdotH = max(dot(N, H), 0.0); let NdotH2 = NdotH * NdotH;
                let denom = (NdotH2 * (a2 - 1.0) + 1.0);
                let D = a2 / (3.14159 * denom * denom + 1e-5);
                let NdotV = max(dot(N, V), 0.0); let NdotL = max(dot(N, L), 0.0);
                let k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
                let Gv = NdotV / (NdotV * (1.0 - k) + k + 1e-5);
                let Gl = NdotL / (NdotL * (1.0 - k) + k + 1e-5);
                let G_geom = Gv * Gl;
                let kd = (vec3<f32>(1.0) - F) * (1.0 - metallic);
                let diffuse = kd * base_color / 3.14159;
                let specular = (F * D * G_geom) / max(4.0 * NdotV * NdotL + 1e-5, 1e-5);
                let ibl_on = f32((u_debug.debug_tint & 2u) >> 1u);
                let sky_ambient = sky_color(normalize(in.world_pos), time) * 0.18 + sample_ibl_diffuse(N) * 0.12 * ibl_on;
                let enhanced_ao = pow(ao, 0.85);
                let ambient = base_color * enhanced_ao * 0.25 + sky_ambient * enhanced_ao;
                let shadow = sample_shadow(in.world_pos, N, L);
                let R = reflect(-V, N);
                let spec_ibl = sample_ibl_specular(R, roughness, NdotV) * ibl_on;
                col = ambient + (diffuse + specular) * NdotL * (1.0 - shadow) + spec_ibl * 0.4;
                return vec4<f32>(col, 1.0);
    }
    else if (in.mesh_type == 3u) { // Rock formations and boulders
        let ws_pos = in.world_pos;
        let V = normalize(-in.view_dir);
        let sun_angle = time * 0.1;
        let L = normalize(vec3<f32>(cos(sun_angle) * 0.8, max(sin(sun_angle) * 0.8, 0.2), sin(sun_angle * 0.3) * 0.4));
        let lichen = sample_triplanar_enhanced(MATERIAL_ROCK_LICHEN, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.4, 11.0);
        let slate = sample_triplanar_enhanced(MATERIAL_ROCK_SLATE, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.0, 9.5);
        var base_sample: SampleSet = lichen;
        base_sample.c = mix(lichen.c, slate.c, 0.45);
        base_sample.n = slate.n;
        base_sample.m = mix(lichen.m, slate.m, vec4<f32>(0.4, 0.5, 0.4, 0.0));
        let N = normalize(base_sample.n * 2.0 - 1.0);
        let H = normalize(L + V);
        let ao = base_sample.m.r;
        let roughness = clamp(base_sample.m.g, 0.35, 0.95);
        let metallic = clamp(base_sample.m.b * 0.35, 0.05, 0.45);
        let base_color = base_sample.c;
        let ior = mix(1.35, 2.3, metallic);
        let F0 = pow((ior - 1.0) / (ior + 1.0), 2.0);
        let F0_vec = mix(vec3<f32>(F0, F0, F0), base_color, metallic);
        let F = F0_vec + (vec3<f32>(1.0) - F0_vec) * pow(1.0 - clamp(dot(H, V), 0.0, 1.0), 5.0);
        let a = roughness * roughness; let a2 = a * a;
        let NdotH = max(dot(N, H), 0.0); let NdotH2 = NdotH * NdotH;
        let denom = (NdotH2 * (a2 - 1.0) + 1.0);
        let D = a2 / (3.14159 * denom * denom + 1e-5);
        let NdotV = max(dot(N, V), 0.0); let NdotL = max(dot(N, L), 0.0);
        let k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
        let Gv = NdotV / (NdotV * (1.0 - k) + k + 1e-5);
        let Gl = NdotL / (NdotL * (1.0 - k) + k + 1e-5);
        let G_geom = Gv * Gl;
        let kd = (vec3<f32>(1.0) - F) * (1.0 - metallic);
        let diffuse = kd * base_color / 3.14159;
        let specular = (F * D * G_geom) / max(4.0 * NdotV * NdotL + 1e-5, 1e-5);
    let ibl_on = f32((u_debug.debug_tint & 2u) >> 1u);
    let sky_ambient = sky_color(normalize(in.world_pos), time) * 0.14 + sample_ibl_diffuse(N) * 0.08 * ibl_on;
        let enhanced_ao = pow(ao, 0.9);
        let ambient = base_color * enhanced_ao * 0.28 + sky_ambient * enhanced_ao;
        let shadow = sample_shadow(in.world_pos, N, L);
    let R = reflect(-V, N);
    let spec_ibl = sample_ibl_specular(R, roughness, NdotV) * ibl_on;
    col = ambient + (diffuse + specular) * NdotL * (1.0 - shadow) + spec_ibl * 0.35;
        return vec4<f32>(col, 1.0);
    }
    else if (in.mesh_type == 4u) { // Character - cloth-centric shading tinted per instance
        let ws_pos = in.world_pos;
        let V = normalize(-in.view_dir);
        let sun_angle = time * 0.1;
        let L = normalize(vec3<f32>(cos(sun_angle) * 0.8, max(sin(sun_angle) * 0.8, 0.2), sin(sun_angle * 0.3) * 0.4));
        var base_sample: SampleSet = sample_triplanar_enhanced(MATERIAL_CLOTH, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.3, 9.0);
        base_sample.c = clamp(base_sample.c * in.color.rgb, vec3<f32>(0.05), vec3<f32>(1.0));
        let N = normalize(base_sample.n * 2.0 - 1.0);
        let H = normalize(L + V);
        let ao = base_sample.m.r;
        let roughness = clamp(base_sample.m.g * 1.15, 0.35, 0.9);
        let metallic = clamp(base_sample.m.b * 0.08, 0.0, 0.18);
        let base_color = base_sample.c;
        let ior = mix(1.28, 1.9, metallic);
        let F0 = pow((ior - 1.0) / (ior + 1.0), 2.0);
        let F0_vec = mix(vec3<f32>(F0, F0, F0), base_color, metallic);
        let F = F0_vec + (vec3<f32>(1.0) - F0_vec) * pow(1.0 - clamp(dot(H, V), 0.0, 1.0), 5.0);
        let a = roughness * roughness; let a2 = a * a;
        let NdotH = max(dot(N, H), 0.0); let NdotH2 = NdotH * NdotH;
        let denom = (NdotH2 * (a2 - 1.0) + 1.0);
        let D = a2 / (3.14159 * denom * denom + 1e-5);
        let NdotV = max(dot(N, V), 0.0); let NdotL = max(dot(N, L), 0.0);
        let k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
        let Gv = NdotV / (NdotV * (1.0 - k) + k + 1e-5);
        let Gl = NdotL / (NdotL * (1.0 - k) + k + 1e-5);
        let G_geom = Gv * Gl;
        let kd = (vec3<f32>(1.0) - F) * (1.0 - metallic);
        let diffuse = kd * base_color / 3.14159;
        let specular = (F * D * G_geom) / max(4.0 * NdotV * NdotL + 1e-5, 1e-5);
    let ibl_on = f32((u_debug.debug_tint & 2u) >> 1u);
    let sky_ambient = sky_color(normalize(in.world_pos), time) * 0.16 + sample_ibl_diffuse(N) * 0.11 * ibl_on;
        let enhanced_ao = pow(ao, 0.8);
        let ambient = base_color * enhanced_ao * 0.3 + sky_ambient * enhanced_ao;
        let shadow = sample_shadow(in.world_pos, N, L);
    let R = reflect(-V, N);
    let spec_ibl = sample_ibl_specular(R, roughness, NdotV) * ibl_on;
    col = ambient + (diffuse + specular) * NdotL * (1.0 - shadow) + spec_ibl * 0.3;
        return vec4<f32>(col, 1.0);
    }
  else if (in.mesh_type == 5u) { // Skybox
    // Use procedural sky color based on view direction
    col = sky_color(in.view_dir, time);
    return vec4<f32>(col, 1.0);
  }
  
    // For ground or other unspecified mesh types, use PBR-ish terrain rendering
  // Determine biome type for this world position
  let biome_type = get_biome_type(in.world_pos.xz);
  
  // Enhanced ground rendering with biome-specific terrain
  let ground_y = -2.0;
  let terrain_height = get_biome_terrain_height(in.world_pos.xz, biome_type);
  let water_level = get_water_level(in.world_pos.xz, time);
  let terrain_surface = ground_y + terrain_height;
  let dist_to_terrain = abs(in.world_pos.y - terrain_surface);
  let dist_to_water = abs(in.world_pos.y - water_level);
  
  // Check if we're rendering the terrain surface
  if (dist_to_terrain < 0.8 || (in.mesh_type == 0u && in.world_pos.y < ground_y + 1.0)) {
        // Enhanced triplanar sampling with biome-specific scales and detail mapping
        let ws_pos = in.world_pos;
        let base_scale = 2.0;
        let detail_scale = 8.0;
        
        // Biome-specific texture scaling for more realistic material distribution
        var biome_scale = base_scale;
        if (biome_type == 1) { biome_scale = base_scale * 1.2; } // Desert - slightly larger scale
        else if (biome_type == 2) { biome_scale = base_scale * 0.9; } // Forest - slightly smaller scale
        
        // Enhanced surface normal calculation with better height gradients
        let eps = 0.3;
        let hC = terrain_height;
        let hL = get_biome_terrain_height((ws_pos.xz + vec2<f32>(-eps, 0.0)), biome_type);
        let hR = get_biome_terrain_height((ws_pos.xz + vec2<f32>( eps, 0.0)), biome_type);
        let hD = get_biome_terrain_height((ws_pos.xz + vec2<f32>( 0.0,-eps)), biome_type);
        let hU = get_biome_terrain_height((ws_pos.xz + vec2<f32>( 0.0, eps)), biome_type);
        let dx = (hR - hL) / (2.0 * eps);
        let dz = (hU - hD) / (2.0 * eps);
        let n_world = normalize(vec3<f32>(-dx, 1.0, -dz));

        // Advanced material weight calculation with multiple influencing factors
        let slope = clamp(1.0 - n_world.y, 0.0, 1.0);
        let height_factor = clamp((hC + 2.0) / 4.0, 0.0, 1.0); // Normalized height factor
        let moisture_factor = sin(ws_pos.x * 0.01) * cos(ws_pos.z * 0.008) * 0.5 + 0.5; // Pseudo-moisture
        
        // Base material weights with biome-specific logic
        var w_grass = 0.0;
        var w_dirt = 0.0;
        var w_stone = 0.0;
        var w_sand = 0.0;
        var w_forest = 0.0;
        
        if (biome_type == 0) { // Grassland
            // Grass dominates low slopes and mid elevations
            w_grass = (1.0 - slope) * smoothstep(0.0, 0.6, height_factor) * (1.0 - moisture_factor * 0.3);
            // Dirt appears on steeper slopes and drier areas
            w_dirt = slope * 0.4 + moisture_factor * 0.2;
            // Stone for rocky outcrops
            w_stone = smoothstep(0.3, 0.8, slope) * 0.6;
            
        } else if (biome_type == 1) { // Desert
            // Sand dominates with some variation
            w_sand = 0.7 * (1.0 - smoothstep(0.4, 0.9, slope));
            // Stone for rocky areas and steep slopes
            w_stone = smoothstep(0.2, 0.7, slope) * 0.8;
            // Dirt in transitional areas
            w_dirt = 0.2 * (1.0 - slope) * moisture_factor;
            
        } else if (biome_type == 2) { // Forest
            // Forest floor dominates with organic materials
            w_forest = 0.6 * (1.0 - slope) * smoothstep(0.0, 0.7, height_factor);
            // Grass in clearings
            w_grass = 0.3 * (1.0 - slope) * (1.0 - smoothstep(0.3, 0.8, height_factor));
            // Dirt on slopes
            w_dirt = slope * 0.4;
            // Stone for rocky areas
            w_stone = smoothstep(0.5, 1.0, slope) * 0.5;
        }
        
        // Normalize weights to ensure they sum to 1
        var total_weight = w_grass + w_dirt + w_stone + w_sand + w_forest;
        if (total_weight < 0.1) {
            // Fallback to ensure we always have some material
            w_grass = 0.5;
            w_dirt = 0.3;
            w_stone = 0.2;
            total_weight = 1.0;
        }
        w_grass /= total_weight;
        w_dirt /= total_weight;
        w_stone /= total_weight;
        w_sand /= total_weight;
        w_forest /= total_weight;

        // Enhanced triplanar sampling for each material with detail mapping
    let grass_sample = sample_triplanar_enhanced(MATERIAL_GRASS, ws_pos, n_world, biome_scale, detail_scale);
    let dirt_sample = sample_triplanar_enhanced(MATERIAL_DIRT, ws_pos, n_world, biome_scale, detail_scale);
    let stone_sample = sample_triplanar_enhanced(MATERIAL_STONE, ws_pos, n_world, biome_scale, detail_scale);
    let sand_sample = sample_triplanar_enhanced(MATERIAL_SAND, ws_pos, n_world, biome_scale, detail_scale);
    let forest_sample = sample_triplanar_enhanced(MATERIAL_FOREST_FLOOR, ws_pos, n_world, biome_scale, detail_scale);

        // Combine materials with enhanced blending
        var base_color = grass_sample.c * w_grass + 
                        dirt_sample.c * w_dirt + 
                        stone_sample.c * w_stone + 
                        sand_sample.c * w_sand + 
                        forest_sample.c * w_forest;
    base_color = base_color * mix(vec3<f32>(1.0), u_material.albedo.rgb, 0.2);
        
        var mra = grass_sample.m * w_grass + 
                 dirt_sample.m * w_dirt + 
                 stone_sample.m * w_stone + 
                 sand_sample.m * w_sand + 
                 forest_sample.m * w_forest;
        
        // Enhanced normal blending with proper interpolation
        var normal_blend = (grass_sample.n * 2.0 - 1.0) * w_grass +
                          (dirt_sample.n * 2.0 - 1.0) * w_dirt +
                          (stone_sample.n * 2.0 - 1.0) * w_stone +
                          (sand_sample.n * 2.0 - 1.0) * w_sand +
                          (forest_sample.n * 2.0 - 1.0) * w_forest;
        var normal = normalize(normal_blend);

    // Calculate tessellation factor for geometry detail
        let tessellation_factor = calculate_tessellation_factor(ws_pos, vec3<f32>(0.0, 5.0, 0.0), slope);
        
        // Use tessellation factor to modulate detail mapping strength
    let detail_strength = 0.6; // Base strength for micro detail mapping
    let adaptive_detail_strength = detail_strength * tessellation_factor;
        base_color = apply_detail_mapping(base_color, ws_pos, detail_scale, adaptive_detail_strength);
        
        // Apply normal perturbation with adaptive strength
        let adaptive_normal_strength = 0.1 * tessellation_factor;
        normal = perturb_normal(normal, ws_pos, detail_scale * 2.0, adaptive_normal_strength);

    let ao = mra.r; // ambient occlusion
    var roughness = clamp(mra.g, 0.08, 0.95);
    var metallic = clamp(mra.b, 0.0, 0.2);
    roughness = mix(roughness, clamp(u_material.roughness_metallic.x, 0.05, 1.0), 0.25);
    metallic = mix(metallic, clamp(u_material.roughness_metallic.y, 0.0, 1.0), 0.25);
    let emissive = u_material.emissive.rgb * u_material.emissive.w;
    
    // Biome-specific terrain texturing
        // Note: Removed large flat-color biome overlays; rely on layered PBR materials above
        // Enhanced PBR lighting with improved Cook-Torrance BRDF
        let V = normalize(-in.view_dir);
        let N = normalize(normal);
        let sun_angle = time * 0.1;
        let L = normalize(vec3<f32>(cos(sun_angle) * 0.8, max(sin(sun_angle) * 0.8, 0.2), sin(sun_angle * 0.3) * 0.4));
        let H = normalize(L + V);

        // Enhanced Fresnel with realistic IOR values based on material
        let ior = mix(1.3, 2.5, metallic); // Vary IOR based on metallic content
        let F0 = pow((ior - 1.0) / (ior + 1.0), 2.0);
        let F0_vec = mix(vec3<f32>(F0, F0, F0), base_color, metallic);
        let F = F0_vec + (vec3<f32>(1.0, 1.0, 1.0) - F0_vec) * pow(1.0 - clamp(dot(H, V), 0.0, 1.0), 5.0);
        
        // Improved Normal Distribution Function (GGX)
        let a = roughness * roughness;
        let a2 = a * a;
        let NdotH = max(dot(N, H), 0.0);
        let NdotH2 = NdotH * NdotH;
        let denom = (NdotH2 * (a2 - 1.0) + 1.0);
        let D = a2 / (3.14159 * denom * denom + 1e-5);
        
        // Enhanced Geometry Smith with correlated masking-shadowing
        let NdotV = max(dot(N, V), 0.0);
        let NdotL = max(dot(N, L), 0.0);
        let k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
        let Gv = NdotV / (NdotV * (1.0 - k) + k + 1e-5);
        let Gl = NdotL / (NdotL * (1.0 - k) + k + 1e-5);
        let G_geom = Gv * Gl;

        // Enhanced diffuse with subsurface scattering for organic materials
        let kd = (vec3<f32>(1.0, 1.0, 1.0) - F) * (1.0 - metallic);
        
        // Add subsurface scattering approximation for materials like grass and soil
        let subsurface_factor = 0.15 * (1.0 - roughness) * (1.0 - metallic) * ao;
        let subsurface = subsurface_factor * base_color * max(dot(N, L), 0.0) * 0.5;
        
        let diffuse = kd * base_color / 3.14159 + subsurface;
        let specular = (F * D * G_geom) / max(4.0 * NdotV * NdotL + 1e-5, 1e-5);
        
        // Enhanced ambient lighting with sky contribution and improved AO
    let ibl_on = f32((u_debug.debug_tint & 2u) >> 1u);
    let sky_ambient = sky_color(normalize(in.world_pos), time) * 0.22 + sample_ibl_diffuse(N) * 0.18 * ibl_on;
        let enhanced_ao = pow(ao, 0.8); // Enhance AO contrast
        let ambient = base_color * enhanced_ao * 0.3 + sky_ambient * enhanced_ao;
        
        let shadow = sample_shadow(in.world_pos, N, L);
    let R = reflect(-V, N);
    let spec_ibl = sample_ibl_specular(R, roughness, NdotV) * ibl_on;
    var color = ambient + (diffuse + specular) * NdotL * (1.0 - shadow) + spec_ibl * 0.5 + emissive;

    // Remove crosshatch-like overlay modulation; rely on material detail mapping above

        // Exponential height fog with simple Rayleigh/Mie approximation (apply pre-tone-map)
    let cam_height = u_scene.camera_height;
        let height_falloff = 0.02;
        let base_density = 0.02;
        let view_dir = normalize(in.view_dir);
        let distance_view = length(in.world_pos - vec3<f32>(0.0, cam_height, 0.0));
        let altitude = clamp(in.world_pos.y, -50.0, 500.0);
        let height_term = exp(-height_falloff * (altitude - cam_height));
        let fog_amount = 1.0 - exp(-base_density * height_term * distance_view);
        let cosTheta = clamp(dot(-view_dir, L), -1.0, 1.0);
        let rayleigh_phase = 0.75 * (1.0 + cosTheta * cosTheta);
        let mie_g = 0.5;
        let mie_phase = 1.0 / pow(1.0 + mie_g * mie_g - 2.0 * mie_g * cosTheta, 1.5);
        let fog_sky = sky_color(normalize(in.world_pos), time);
        let fog_color = fog_sky * 0.6 * rayleigh_phase + vec3<f32>(0.9, 0.9, 0.85) * 0.05 * mie_phase;
        color = mix(color, fog_color, clamp(fog_amount, 0.0, 1.0));

        // Leave color in linear HDR here; post pass will apply exposure + tone mapping
        col = color;
        // Atmospheric perspective now handled by height fog above (pre-tonemap)
    
  } else if (dist_to_water < 0.3 && terrain_height < -0.5) {
    // Water rendering for rivers and lakes
    let water_color = vec3<f32>(0.1, 0.3, 0.6);
    let wave_distortion = sin(in.world_pos.x * 2.0 + time) * cos(in.world_pos.z * 1.8 + time * 1.2) * 0.05;
    let water_surface = water_color + vec3<f32>(wave_distortion, wave_distortion * 0.5, -wave_distortion * 0.3);
    
    // Reflection and transparency effects
    let view_angle = abs(dot(normalize(in.view_dir), vec3<f32>(0.0, 1.0, 0.0)));
    let reflection_factor = 1.0 - view_angle;
    let sky = sky_color(reflect(in.view_dir, vec3<f32>(0.0, 1.0, 0.0)), time);
    
    col = mix(water_surface, sky, reflection_factor * 0.6);
    
  } else {
    // Sky rendering for non-terrain objects or background
        if (in.mesh_type == 5u) { // Skybox
      // Full procedural sky rendering
      col = sky_color(in.view_dir, time);
      
    } else if (in.mesh_type == 1u) { // Trees
      // Enhanced tree rendering with seasonal variation
      let tree_base_color = in.color.rgb;
      let seasonal_factor = (sin(time * 0.05) + 1.0) * 0.5;
      let autumn_color = vec3<f32>(0.8, 0.4, 0.1);
      let summer_color = vec3<f32>(0.2, 0.8, 0.3);
      col = mix(tree_base_color, mix(summer_color, autumn_color, seasonal_factor), 0.3);
      
        } else if (in.mesh_type == 2u) { // Houses/Structures
      // Enhanced building rendering with weathering
      col = in.color.rgb;
      let weathering = sin(in.world_pos.x * 0.5) * cos(in.world_pos.z * 0.3) * 0.1;
      col = col * (0.95 + weathering);
      
        } else if (in.mesh_type == 3u) { // Rocks fallback tint
            let rock_tint = vec3<f32>(0.55, 0.56, 0.52);
            col = mix(in.color.rgb, rock_tint, 0.4);
      
    } else {
      // Other objects get sky ambient lighting
      let sky = sky_color(in.view_dir, time);
      col = in.color.rgb * 0.8 + sky * 0.2;
    }
  }
  
  return vec4<f32>(col, 1.0);
}
"#;

// ---------------- physics world build/step & instance sync ----------------

fn build_physics_world() -> Physics {
    let mut bodies = r3::RigidBodySet::new();
    let mut colliders = r3::ColliderSet::new();
    let gravity = nalgebra::Vector3::new(0.0, -9.81, 0.0);
    // Ground collider that matches the rendered terrain using a TriMesh
    // Generate the same terrain data used for rendering
    let MeshData {
        vertices: terrain_vertices,
        indices: terrain_indices,
    } = generate_terrain_mesh(TERRAIN_SIZE, TERRAIN_SCALE);
    // Convert to rapier types
    let mut points: Vec<nalgebra::Point3<f32>> = Vec::with_capacity(terrain_vertices.len());
    for vertex in &terrain_vertices {
        points.push(nalgebra::Point3::new(
            vertex.position[0],
            vertex.position[1],
            vertex.position[2],
        ));
    }
    let mut indices: Vec<[u32; 3]> = Vec::with_capacity(terrain_indices.len() / 3);
    for tri in terrain_indices.chunks_exact(3) {
        indices.push([tri[0], tri[1], tri[2]]);
    }
    let ground = r3::RigidBodyBuilder::fixed()
        .translation(nalgebra::Vector3::new(0.0, 0.0, 0.0))
        .user_data(0)
        .build();
    let g_handle = bodies.insert(ground);
    let g_col = r3::ColliderBuilder::trimesh(points, indices)
        .friction(0.9)
        .restitution(0.1)
        .build();
    colliders.insert_with_parent(g_col, g_handle, &mut bodies);
    // Stack of boxes
    for y in 0..5 {
        for x in 0..5 {
            let rb = r3::RigidBodyBuilder::dynamic()
                .translation(nalgebra::Vector3::new(
                    -2.5 + x as f32 * 0.7,
                    -1.0 + y as f32 * 0.7,
                    0.0,
                ))
                .user_data(1)
                .build();
            let h = bodies.insert(rb);
            let c = r3::ColliderBuilder::cuboid(0.3, 0.3, 0.3)
                .restitution(0.2)
                .friction(0.8)
                .build();
            colliders.insert_with_parent(c, h, &mut bodies);
        }
    }
    // Sphere
    let s_rb = r3::RigidBodyBuilder::dynamic()
        .translation(nalgebra::Vector3::new(1.8, 1.0, 0.0))
        .ccd_enabled(true)
        .user_data(2)
        .build();
    let s_handle = bodies.insert(s_rb);
    let s_col = r3::ColliderBuilder::ball(0.35)
        .restitution(0.5)
        .friction(0.3)
        .build();
    colliders.insert_with_parent(s_col, s_handle, &mut bodies);

    Physics {
        pipeline: r3::PhysicsPipeline::new(),
        gravity,
        islands: r3::IslandManager::new(),
        broad: r3::DefaultBroadPhase::new(),
        narrow: r3::NarrowPhase::new(),
        bodies,
        colliders,
        impulse_joints: r3::ImpulseJointSet::new(),
        multibody_joints: r3::MultibodyJointSet::new(),
        ccd: r3::CCDSolver::new(),
        query_pipeline: r3::QueryPipeline::new(),
        integration_params: r3::IntegrationParameters {
            dt: 1.0 / 60.0,
            ..Default::default()
        },
    }
}

fn physics_step(p: &mut Physics) {
    let hooks = ();
    let events = ();
    p.pipeline.step(
        &p.gravity,
        &p.integration_params,
        &mut p.islands,
        &mut p.broad,
        &mut p.narrow,
        &mut p.bodies,
        &mut p.colliders,
        &mut p.impulse_joints,
        &mut p.multibody_joints,
        &mut p.ccd,
        Some(&mut p.query_pipeline),
        &hooks,
        &events,
    );
}

fn teleport_sphere_to(p: &mut Physics, pos: Vec3) {
    let target = p.bodies.iter_mut().find(|(_, b)| b.user_data == 2);
    if let Some((_, body)) = target {
        body.set_translation(nalgebra::Vector3::new(pos.x, pos.y, pos.z), true);
        body.set_linvel(nalgebra::Vector3::new(0.0, 0.0, 0.0), true);
        body.set_angvel(nalgebra::Vector3::new(0.0, 0.0, 0.0), true);
    }
}

#[derive(Clone, Copy)]
struct LodDecision {
    skip: bool,
    variant_override: Option<u32>,
    scale_multiplier: f32,
}

impl LodDecision {
    fn keep() -> Self {
        Self {
            skip: false,
            variant_override: None,
            scale_multiplier: 1.0,
        }
    }

    fn skip() -> Self {
        Self {
            skip: true,
            variant_override: None,
            scale_multiplier: 1.0,
        }
    }

    fn with_impostor(variant: u32, scale_multiplier: f32) -> Self {
        Self {
            skip: false,
            variant_override: Some(variant),
            scale_multiplier,
        }
    }
}

fn lod_decision_for(
    category: MeshCategory,
    distance: f32,
    seed: u64,
    settings: &BiomeLodSettings,
) -> LodDecision {
    match category {
        MeshCategory::Tree => {
            let tree = &settings.tree;
            if distance > tree.far {
                if should_skip_far(seed, distance, tree.keep) {
                    LodDecision::skip()
                } else {
                    LodDecision::with_impostor(TREE_IMPOSTOR_VARIANT, 1.1)
                }
            } else if distance > tree.near {
                LodDecision::with_impostor(TREE_IMPOSTOR_VARIANT, 1.05)
            } else {
                LodDecision::keep()
            }
        }
        MeshCategory::House => {
            let house = &settings.house;
            if distance > house.far {
                if should_skip_far(seed, distance, house.keep) {
                    LodDecision::skip()
                } else {
                    LodDecision::with_impostor(HOUSE_IMPOSTOR_VARIANT, 1.0)
                }
            } else if distance > house.near {
                LodDecision::with_impostor(HOUSE_IMPOSTOR_VARIANT, 1.0)
            } else {
                LodDecision::keep()
            }
        }
        MeshCategory::Rock => {
            let rock = &settings.rock;
            if distance > rock.far {
                if should_skip_far(seed, distance, rock.keep) {
                    LodDecision::skip()
                } else {
                    LodDecision::with_impostor(ROCK_IMPOSTOR_VARIANT, 1.0)
                }
            } else if distance > rock.near {
                LodDecision::with_impostor(ROCK_IMPOSTOR_VARIANT, 0.95)
            } else {
                LodDecision::keep()
            }
        }
        MeshCategory::Character => {
            let character = &settings.character;
            if distance > character.far {
                if should_skip_far(seed, distance, character.keep) {
                    LodDecision::skip()
                } else {
                    LodDecision::with_impostor(CHARACTER_IMPOSTOR_VARIANT, 0.8)
                }
            } else if distance > character.near {
                LodDecision::with_impostor(CHARACTER_IMPOSTOR_VARIANT, 0.9)
            } else {
                LodDecision::keep()
            }
        }
        _ => LodDecision::keep(),
    }
}

fn should_skip_far(seed: u64, distance: f32, keep_probability: f32) -> bool {
    if keep_probability >= 1.0 {
        return false;
    }
    let bucket = distance_bucket(distance);
    let sample = random_keep_probability(seed, bucket);
    sample > keep_probability
}

fn random_keep_probability(seed: u64, bucket: u32) -> f32 {
    let mut value = seed ^ ((bucket as u64) << 32);
    value = value.wrapping_add(0x9E37_79B9_7F4A_7C15);
    value = (value ^ (value >> 30)).wrapping_mul(0xBF58_476D_1CE4_E5B9);
    value = (value ^ (value >> 27)).wrapping_mul(0x94D0_49BB_1331_11EB);
    value ^= value >> 31;
    let bits = (value & 0xFFFF_FFFF) as u32;
    bits as f32 / u32::MAX as f32
}

fn distance_bucket(distance: f32) -> u32 {
    (distance / DENSITY_BUCKET_METERS).floor().max(0.0) as u32
}

fn classify_body(user_data: u128) -> ([f32; 4], MeshCategory, u32, f32) {
    match user_data {
        0 => ([0.95, 0.95, 0.95, 1.0], MeshCategory::Terrain, 0, 1.0),
        1 => ([0.9, 0.6, 0.2, 1.0], MeshCategory::Primitive, 0, 1.0),
        2 => ([0.2, 0.6, 0.9, 1.0], MeshCategory::Primitive, 0, 1.0),
        10..=34 => (
            [0.20, 0.80, 0.30, 1.0],
            MeshCategory::Tree,
            (user_data - 10) as u32,
            8.0,
        ),
        35..=45 => (
            [0.60, 0.60, 0.60, 1.0],
            MeshCategory::House,
            (user_data - 35) as u32,
            6.0,
        ),
        60..=90 => (
            [0.50, 0.50, 0.50, 1.0],
            MeshCategory::Rock,
            (user_data - 60) as u32,
            3.0,
        ),
        100..=170 => (
            [0.10, 0.50, 0.20, 1.0],
            MeshCategory::Tree,
            (user_data - 100) as u32,
            4.0,
        ),
        200..=309 => (
            [0.40, 0.40, 0.40, 1.0],
            MeshCategory::Rock,
            (user_data - 200) as u32,
            2.5,
        ),
        400..=407 => (
            [0.90, 0.80, 0.60, 1.0],
            MeshCategory::Rock,
            (user_data - 400) as u32,
            2.0,
        ),
        500..=504 => (
            [0.20, 0.70, 0.30, 1.0],
            MeshCategory::Tree,
            (user_data - 500) as u32,
            10.0,
        ),
        _ => (
            [0.80, 0.80, 0.80, 1.0],
            MeshCategory::Primitive,
            (user_data as u32) & 0xFFFF,
            2.0,
        ),
    }
}

fn sync_instances_from_physics(
    p: &Physics,
    characters: &[Character],
    camera_pos: Vec3,
    lod_settings: &BiomeLodSettings,
    out: &mut Vec<InstanceRaw>,
) {
    out.clear();

    let skybox_translation = Mat4::from_translation(camera_pos);
    let skybox_instance = InstanceRaw {
        model: skybox_translation.to_cols_array_2d(),
        color: [0.8, 0.9, 1.0, 1.0],
        mesh_category: MeshCategory::Skybox.as_u32(),
        mesh_variant: 0,
        lod_flags: 0,
        _padding: 0,
    };
    out.push(skybox_instance);

    for (_h, body) in p.bodies.iter() {
        if out.len() >= MAX_INSTANCE_COUNT {
            break;
        }

        let xf = body.position();
        let iso = xf.to_homogeneous();
        let base_m = Mat4::from_cols_array_2d(&iso.fixed_view::<4, 4>(0, 0).into());
        let translation = base_m.w_axis.truncate();
        let distance = (translation - camera_pos).length();

        let (color, category, variant_hint, base_scale) = classify_body(body.user_data);
        let lower = body.user_data as u64;
        let upper = (body.user_data >> 64) as u64;
        let combined_seed = lower ^ upper.rotate_left(17);
        let seed = if combined_seed == 0 {
            lower.wrapping_add(0x9E37_79B9)
        } else {
            combined_seed
        };
    let lod = lod_decision_for(category, distance, seed, lod_settings);

        if lod.skip {
            continue;
        }

        let model_m = if category == MeshCategory::Terrain {
            base_m
        } else {
            let scale = (base_scale * lod.scale_multiplier).max(0.05);
            base_m * Mat4::from_scale(Vec3::splat(scale))
        };

        let mesh_variant = lod.variant_override.unwrap_or_else(|| match category {
            MeshCategory::Terrain => 0,
            MeshCategory::Tree => variant_hint % TREE_VARIANT_COUNT,
            MeshCategory::House => variant_hint % HOUSE_VARIANT_COUNT,
            MeshCategory::Rock => variant_hint % ROCK_VARIANT_COUNT,
            MeshCategory::Character => variant_hint % CHARACTER_VARIANT_COUNT,
            MeshCategory::Skybox => 0,
            MeshCategory::Primitive => variant_hint % PRIMITIVE_VARIANT_COUNT,
        });

        let lod_flags = if lod.variant_override.is_some() { LOD_FLAG_IMPOSTOR } else { 0 };
        out.push(InstanceRaw {
            model: model_m.to_cols_array_2d(),
            color,
            mesh_category: category.as_u32(),
            mesh_variant,
            lod_flags,
            _padding: 0,
        });
    }

    for (idx, character) in characters.iter().enumerate() {
        if out.len() >= MAX_INSTANCE_COUNT {
            break;
        }

        let distance = (character.position - camera_pos).length();
        let seed = ((idx as u64) << 32) | character.character_type.as_u32() as u64;
    let lod = lod_decision_for(MeshCategory::Character, distance, seed, lod_settings);

        if lod.skip {
            continue;
        }

        let base_scale = 5.0;
        let scale = (base_scale * lod.scale_multiplier).max(0.2);
        let translation = Mat4::from_translation(character.position);
        let bob_offset = if lod.variant_override.is_some() {
            0.0
        } else {
            (character.animation_time * 3.0).sin() * 0.1
        };
        let animation_transform = Mat4::from_translation(Vec3::new(0.0, bob_offset, 0.0));
        let scaling = Mat4::from_scale(Vec3::splat(scale));
        let model_matrix = translation * animation_transform * scaling;

        let mesh_variant = lod
            .variant_override
            .unwrap_or(character.character_type.as_u32() % CHARACTER_VARIANT_COUNT);

        let lod_flags = if lod.variant_override.is_some() { LOD_FLAG_IMPOSTOR } else { 0 };
        out.push(InstanceRaw {
            model: model_matrix.to_cols_array_2d(),
            color: character.get_color(),
            mesh_category: MeshCategory::Character.as_u32(),
            mesh_variant,
            lod_flags,
            _padding: 0,
        });
    }

    if out.len() > MAX_INSTANCE_COUNT {
        out.truncate(MAX_INSTANCE_COUNT);
    }
}

fn build_show_instances() -> Vec<InstanceRaw> {
    Vec::with_capacity(MAX_INSTANCE_COUNT)
}
