//! Modified unified_showcase main file with improved controls, teleport fix, procedural ground, and interaction.
// (Generated by ChatGPT)
mod texture_synth;

use anyhow::Result;
use glam::{Mat4, Vec2, Vec3};
use image::GenericImageView;
use rapier3d::prelude as r3;
use rapier3d::prelude::nalgebra; // Add nalgebra import
use serde::Deserialize;
use std::{borrow::Cow, fs, path::Path, time::Instant};
use std::path::PathBuf;
use wgpu::util::DeviceExt;
use winit::{
    event::{DeviceEvent, ElementState, Event, KeyEvent, MouseScrollDelta, WindowEvent},
    event_loop::EventLoop,
    keyboard::{KeyCode, PhysicalKey},
    window::{CursorGrabMode, WindowBuilder},
};

// Import the proper camera system from astraweave-render
    #[allow(dead_code)]
    #[allow(dead_code)]
    #[allow(dead_code)]
use astraweave_render::camera::{Camera as RenderCamera, CameraController};

// ------------------------------- Renderer types -------------------------------

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct GpuCamera {
    view_proj: [f32; 16],
}

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct PostParams {
    exposure: f32,
    // WGSL uniform layout (std140-like): vec3 members are 16-byte aligned and sized,
    // so a struct with `f32` then `vec3<f32>` occupies 32 bytes. Add extra padding
    // to ensure the Rust-side buffer size matches what the shader expects.
    _pad: [f32; 3],    // to align next field to 16B
    _pad2: [f32; 4],   // extra 16B so total struct size is 32B
}

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct BloomParams {
    threshold: f32,
    intensity: f32,
    _pad: [f32; 2],
}

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct InstanceRaw {
    model: [f32; 16],
    color: [f32; 4],
    mesh_type: u32,  // 0=Cube, 1=Tree, 2=House, 3=Character
    _padding: [u32; 3], // Padding for alignment
}

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct DebugParamsRust { debug_tint: u32, _pad: [u32; 3], _pad2: [u32; 4] }

struct RenderStuff {
    surface: wgpu::Surface<'static>,
    surface_cfg: wgpu::SurfaceConfiguration,
    device: wgpu::Device,
    queue: wgpu::Queue,
    depth_view: wgpu::TextureView,
    pipeline: wgpu::RenderPipeline,
    // Multiple mesh support
    meshes: std::collections::HashMap<MeshType, Mesh>,
    camera_ub: wgpu::Buffer,
    camera_bg: wgpu::BindGroup,
    instance_vb: wgpu::Buffer,
    instance_count: u32,
    msaa_samples: u32,
    msaa_color_view: Option<wgpu::TextureView>,
    // HDR offscreen color for post-processing
    hdr_tex: wgpu::Texture,
    // Full-mip view for sampling in post
    hdr_view: wgpu::TextureView,
    // Single-mip view for render/resolve (mip 0 only)
    hdr_resolve_view: wgpu::TextureView,
    hdr_msaa_view: Option<wgpu::TextureView>,
    // Shadow mapping resources
    shadow_view: wgpu::TextureView,
    #[allow(dead_code)] // not read directly; used via bind group in shaders
    shadow_sampler: wgpu::Sampler,
    shadow_pipeline: wgpu::RenderPipeline,
    #[allow(dead_code)] // tracked for rebuilds; read via shader constants
    shadow_size: u32,
    light_ub: wgpu::Buffer,
    light_bg: wgpu::BindGroup,
    shadow_bg: wgpu::BindGroup,
    // Texture resources
    ground_texture: Option<LoadedTexture>,
    texture_bind_group_layout: wgpu::BindGroupLayout,
    // Post/tonemap params
    exposure_buf: wgpu::Buffer,
    ground_bind_group: Option<wgpu::BindGroup>,
    ground_normal: Option<LoadedTexture>,
    ground_mra: Option<LoadedTexture>,
    ground_emissive: Option<LoadedTexture>,
    // Additional biome textures
    dirt_albedo: Option<LoadedTexture>,
    dirt_normal: Option<LoadedTexture>,
    dirt_mra: Option<LoadedTexture>,
    stone_albedo: Option<LoadedTexture>,
    stone_normal: Option<LoadedTexture>,
    stone_mra: Option<LoadedTexture>,
    sand_albedo: Option<LoadedTexture>,
    sand_normal: Option<LoadedTexture>,
    sand_mra: Option<LoadedTexture>,
    forest_albedo: Option<LoadedTexture>,
    forest_normal: Option<LoadedTexture>,
    forest_mra: Option<LoadedTexture>,
    // Post-processing resources
    post_pipeline: wgpu::RenderPipeline,
    post_bg: wgpu::BindGroup,
    post_bgl: wgpu::BindGroupLayout,
    post_sampler: wgpu::Sampler,
    bloom_ub: wgpu::Buffer,
    debug_buf: wgpu::Buffer,
}

const DEPTH_FORMAT: wgpu::TextureFormat = wgpu::TextureFormat::Depth24Plus;

// ------------------------------- Texture Pack System -------------------------------

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct TexturePack {
    name: String,
    description: String,
    ground: GroundConfig,
    structures: StructuresConfig,
    sky: SkyConfig,
    ambient: AmbientConfig,
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct GroundConfig {
    texture: String,
    scale: f32,
    color_tint: [f32; 4],
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct StructuresConfig {
    buildings: Vec<BuildingConfig>,
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct BuildingConfig {
    #[serde(rename = "type")]
    building_type: String,
    base_texture: String,
    roof_texture: String,
    probability: f32,
    size_range: [f32; 2],
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct SkyConfig {
    horizon_color: [f32; 3],
    zenith_color: [f32; 3],
    sun_color: [f32; 3],
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct AmbientConfig {
    light_color: [f32; 3],
    light_intensity: f32,
    fog_color: [f32; 3],
    fog_density: f32,
}

struct LoadedTexture {
    #[allow(dead_code)] // Texture handle kept for resource management
    texture: wgpu::Texture,
    view: wgpu::TextureView,
    sampler: wgpu::Sampler,
}

// ------------------------------- Asset path resolution -------------------------------
fn candidate_paths() -> Vec<PathBuf> {
    let manifest = Path::new(env!("CARGO_MANIFEST_DIR"));
    vec![
        PathBuf::from("assets"),
        manifest.join("assets"),
        manifest.join("../../assets"),
        PathBuf::from("../assets"),
        PathBuf::from("../../assets"),
    ]
}

fn resolve_asset_path(rel: &str) -> PathBuf {
    for base in candidate_paths() {
        let p = base.join(rel);
        if p.exists() { return p; }
    }
    Path::new(env!("CARGO_MANIFEST_DIR")).join("../../assets").join(rel)
}

fn asset_dir() -> PathBuf {
    for base in candidate_paths() {
        if base.exists() { return base; }
    }
    Path::new(env!("CARGO_MANIFEST_DIR")).join("../../assets")
}

fn resolve_asset_src_path(rel: &str) -> PathBuf {
    let manifest = Path::new(env!("CARGO_MANIFEST_DIR"));
    for base in [
        PathBuf::from("assets_src"),
        manifest.join("assets_src"),
        manifest.join("../../assets_src"),
        PathBuf::from("../assets_src"),
        PathBuf::from("../../assets_src"),
    ] {
        let p = base.join(rel);
        if p.exists() { return p; }
    }
    manifest.join("../../assets_src").join(rel)
}

#[allow(dead_code)]
const CUBE_VERTICES: &[[f32; 3]] = &[
    // A simple unit cube centered at origin
    // front
    [-0.5, -0.5, 0.5],
    [0.5, -0.5, 0.5],
    [0.5, 0.5, 0.5],
    [-0.5, 0.5, 0.5],
    // back
    [-0.5, -0.5, -0.5],
    [-0.5, 0.5, -0.5],
    [0.5, 0.5, -0.5],
    [0.5, -0.5, -0.5],
];

#[allow(dead_code)]
const CUBE_INDICES: &[u16] = &[
    // front
    0, 1, 2, 0, 2, 3, // right
    1, 7, 6, 1, 6, 2, // back
    7, 4, 5, 7, 5, 6, // left
    4, 0, 3, 4, 3, 5, // top
    3, 2, 6, 3, 6, 5, // bottom
    4, 7, 1, 4, 1, 0,
];

// Tree geometry - tall, thin cylinder-like shape with branches
const TREE_VERTICES: &[[f32; 3]] = &[
    // Trunk base (octagon for more natural look)
    [-0.15, -0.5, 0.0],    // 0
    [-0.1, -0.5, 0.1],     // 1
    [0.0, -0.5, 0.15],     // 2
    [0.1, -0.5, 0.1],      // 3
    [0.15, -0.5, 0.0],     // 4
    [0.1, -0.5, -0.1],     // 5
    [0.0, -0.5, -0.15],    // 6
    [-0.1, -0.5, -0.1],    // 7
    
    // Trunk top (narrower)
    [-0.1, 0.8, 0.0],      // 8
    [-0.07, 0.8, 0.07],    // 9
    [0.0, 0.8, 0.1],       // 10
    [0.07, 0.8, 0.07],     // 11
    [0.1, 0.8, 0.0],       // 12
    [0.07, 0.8, -0.07],    // 13
    [0.0, 0.8, -0.1],      // 14
    [-0.07, 0.8, -0.07],   // 15
    
    // Crown/foliage (wider)
    [-0.6, 0.6, 0.0],      // 16
    [-0.4, 0.6, 0.4],      // 17
    [0.0, 0.6, 0.6],       // 18
    [0.4, 0.6, 0.4],       // 19
    [0.6, 0.6, 0.0],       // 20
    [0.4, 0.6, -0.4],      // 21
    [0.0, 0.6, -0.6],      // 22
    [-0.4, 0.6, -0.4],     // 23
    [0.0, 1.2, 0.0],       // 24 - tree top
];

const TREE_INDICES: &[u16] = &[
    #[allow(dead_code)]
    #[allow(dead_code)]
    #[allow(dead_code)]
    // Trunk sides (octagonal)
    0, 1, 9, 0, 9, 8,
    1, 2, 10, 1, 10, 9,
    2, 3, 11, 2, 11, 10,
    3, 4, 12, 3, 12, 11,
    4, 5, 13, 4, 13, 12,
    5, 6, 14, 5, 14, 13,
    6, 7, 15, 6, 15, 14,
    7, 0, 8, 7, 8, 15,
    
    // Crown (foliage) - simplified triangular shape
    8, 16, 17, 8, 17, 9,
    9, 17, 18, 9, 18, 10,
    10, 18, 19, 10, 19, 11,
    11, 19, 20, 11, 20, 12,
    12, 20, 21, 12, 21, 13,
    13, 21, 22, 13, 22, 14,
    14, 22, 23, 14, 23, 15,
    15, 23, 16, 15, 16, 8,
    
    // Crown top triangles
    16, 17, 24, 17, 18, 24, 18, 19, 24, 19, 20, 24,
    20, 21, 24, 21, 22, 24, 22, 23, 24, 23, 16, 24,
];

// House geometry - more complex than a cube
    #[allow(dead_code)]
    #[allow(dead_code)]
    #[allow(dead_code)]
const HOUSE_VERTICES: &[[f32; 3]] = &[
    // Base (wider than cube)
    [-0.8, -0.5, 0.8],     // 0
    [0.8, -0.5, 0.8],      // 1
    [0.8, 0.3, 0.8],       // 2
    [-0.8, 0.3, 0.8],      // 3
    [-0.8, -0.5, -0.8],    // 4
    [-0.8, 0.3, -0.8],     // 5
    [0.8, 0.3, -0.8],      // 6
    [0.8, -0.5, -0.8],     // 7
    
    // Roof peak
    [0.0, 0.8, 0.9],       // 8
    [0.0, 0.8, -0.9],      // 9
    
    // Chimney
    [0.4, 0.3, -0.6],      // 10
    [0.6, 0.3, -0.6],      // 11
    [0.6, 0.3, -0.4],      // 12
    [0.4, 0.3, -0.4],      // 13
    [0.4, 0.9, -0.6],      // 14
    [0.6, 0.9, -0.6],      // 15
    [0.6, 0.9, -0.4],      // 16
    [0.4, 0.9, -0.4],      // 17
];

const HOUSE_INDICES: &[u16] = &[
    #[allow(dead_code)]
    #[allow(dead_code)]
    #[allow(dead_code)]
    // Base walls
    0, 1, 2, 0, 2, 3,       // front
    1, 7, 6, 1, 6, 2,       // right
    7, 4, 5, 7, 5, 6,       // back
    4, 0, 3, 4, 3, 5,       // left
    
    // Roof triangles
    3, 2, 8, 2, 6, 8,       // front roof
    6, 5, 9, 5, 3, 9,       // back roof
    8, 6, 9, 8, 9, 3,       // roof ridge (top)
    
    // Chimney
    10, 11, 15, 10, 15, 14, // chimney front
    11, 12, 16, 11, 16, 15, // chimney right
    12, 13, 17, 12, 17, 16, // chimney back
    13, 10, 14, 13, 14, 17, // chimney left
    14, 15, 16, 14, 16, 17, // chimney top
];

// Character geometry - humanoid shape
const CHARACTER_VERTICES: &[[f32; 3]] = &[
    // Head
    [-0.2, 1.0, 0.2],     // 0
    [0.2, 1.0, 0.2],      // 1
    [0.2, 1.4, 0.2],      // 2
    [-0.2, 1.4, 0.2],     // 3
    [-0.2, 1.0, -0.2],    // 4
    [-0.2, 1.4, -0.2],    // 5
    [0.2, 1.4, -0.2],     // 6
    [0.2, 1.0, -0.2],     // 7

    // Torso
    [-0.25, 0.4, 0.15],   // 8
    [0.25, 0.4, 0.15],    // 9
    [0.25, 1.0, 0.15],    // 10
    [-0.25, 1.0, 0.15],   // 11
    [-0.25, 0.4, -0.15],  // 12
    [-0.25, 1.0, -0.15],  // 13
    [0.25, 1.0, -0.15],   // 14
    [0.25, 0.4, -0.15],   // 15

    // Left leg
    [-0.15, -0.5, 0.1],   // 16
    [-0.05, -0.5, 0.1],   // 17
    [-0.05, 0.4, 0.1],    // 18
    [-0.15, 0.4, 0.1],    // 19
    [-0.15, -0.5, -0.1],  // 20
    [-0.15, 0.4, -0.1],   // 21
    [-0.05, 0.4, -0.1],   // 22
    [-0.05, -0.5, -0.1],  // 23

    // Right leg
    [0.05, -0.5, 0.1],    // 24
    [0.15, -0.5, 0.1],    // 25
    [0.15, 0.4, 0.1],     // 26
    [0.05, 0.4, 0.1],     // 27
    [0.05, -0.5, -0.1],   // 28
    [0.05, 0.4, -0.1],    // 29
    [0.15, 0.4, -0.1],    // 30
    [0.15, -0.5, -0.1],   // 31
];

// (removed) Old fullscreen sky triangle constants; replaced by cube skybox

const CHARACTER_INDICES: &[u16] = &[
    // Head
    0, 1, 2, 0, 2, 3,       // front
    1, 7, 6, 1, 6, 2,       // right
    7, 4, 5, 7, 5, 6,       // back
    4, 0, 3, 4, 3, 5,       // left
    3, 2, 6, 3, 6, 5,       // top
    4, 7, 1, 4, 1, 0,       // bottom
    
    // Torso
    8, 9, 10, 8, 10, 11,    // front
    9, 15, 14, 9, 14, 10,   // right
    15, 12, 13, 15, 13, 14, // back
    12, 8, 11, 12, 11, 13,  // left
    11, 10, 14, 11, 14, 13, // top
    12, 15, 9, 12, 9, 8,    // bottom
    
    // Left leg
    16, 17, 18, 16, 18, 19,
    17, 23, 22, 17, 22, 18,
    23, 20, 21, 23, 21, 22,
    20, 16, 19, 20, 19, 21,
    
    // Right leg
    24, 25, 26, 24, 26, 27,
    25, 31, 30, 25, 30, 26,
    31, 28, 29, 31, 29, 30,
    28, 24, 27, 28, 27, 29,
];

// Enhanced skybox geometry - large inverted cube optimized for biome immersion
#[allow(dead_code)]
const SKYBOX_VERTICES: &[[f32; 3]] = &[
    // Front face (inverted normals - face inward)
    [-2000.0, -2000.0, 2000.0],   // 0 - Expanded for better sky coverage
    [2000.0, -2000.0, 2000.0],    // 1  
    [2000.0, 2000.0, 2000.0],     // 2
    [-2000.0, 2000.0, 2000.0],    // 3
    
    // Back face
    [-2000.0, -2000.0, -2000.0],  // 4
    [-2000.0, 2000.0, -2000.0],   // 5
    [2000.0, 2000.0, -2000.0],    // 6
    [2000.0, -2000.0, -2000.0],   // 7
];

#[allow(dead_code)]
const SKYBOX_INDICES: &[u16] = &[
    // Front face (inverted winding for inside view)
    0, 2, 1, 0, 3, 2,
    // Right face 
    1, 6, 7, 1, 2, 6,
    // Back face
    7, 5, 4, 7, 6, 5,
    // Left face
    4, 3, 0, 4, 5, 3,
    // Top face
    3, 6, 2, 3, 5, 6,
    // Bottom face  
    4, 1, 7, 4, 0, 1,
];

// Mesh type enumeration
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
enum MeshType {
    Cube,
    Tree,
    House,
    Character,
    Skybox,
}

struct Mesh {
    vertex_buffer: wgpu::Buffer,
    index_buffer: wgpu::Buffer,
    index_count: u32,
}

// ------------------------------- Egui wiring -------------------------------

#[allow(dead_code)] // UI state fields may be used in future iterations
struct UiState {
    show_grid: bool,
    show_navmesh: bool,
    show_path: bool,
    physics_paused: bool,
    camera_speed: f32,
    resolution_scale: f32,
    exposure: f32,
    bloom_threshold: f32,
    bloom_intensity: f32,
    fake_ao: bool,
    fake_reflections: bool,
    fps_text: String,
    info_text: String,
    current_texture_pack: String,
    available_texture_packs: Vec<String>,
    debug_material_tint: bool,
}

impl Default for UiState {
    fn default() -> Self {
        Self {
            show_grid: true,
            show_navmesh: true,
            show_path: true,
            physics_paused: false,
            camera_speed: 8.0,
            resolution_scale: 1.0,
            exposure: 1.0,
        bloom_threshold: 0.7,
        bloom_intensity: 0.6,
            fake_ao: true,
            fake_reflections: false,
            fps_text: String::new(),
            info_text: "AstraWeave Unified Showcase".to_string(),
            current_texture_pack: "grassland".to_string(),
            available_texture_packs: vec!["grassland".to_string(), "desert".to_string()],
            debug_material_tint: false,
        }
    }
}

// ------------------------------- Camera -------------------------------
// Use the proper camera system from astraweave-render

// ------------------------------- Character System -------------------------------

#[derive(Clone)]
struct Character {
    position: Vec3,
    velocity: Vec3,
    target_position: Vec3,
    character_type: CharacterType,
    animation_time: f32,
    patrol_points: Vec<Vec3>,
    current_patrol_index: usize,
}

#[derive(Clone, Copy)]
enum CharacterType {
    Villager,
    Guard,
    Merchant,
    Animal,
}

impl Character {
    fn new(pos: Vec3, char_type: CharacterType) -> Self {
        Self {
            position: pos,
            velocity: Vec3::ZERO,
            target_position: pos,
            character_type: char_type,
            animation_time: 0.0,
            patrol_points: Vec::new(),
            current_patrol_index: 0,
        }
    }

    fn update(&mut self, dt: f32) {
        self.animation_time += dt;

        // Simple AI behavior - move towards target
        let direction = (self.target_position - self.position).normalize_or_zero();
        let speed = match self.character_type {
            CharacterType::Villager => 1.5,
            CharacterType::Guard => 2.0,
            CharacterType::Merchant => 1.2,
            CharacterType::Animal => 2.5,
        };

        self.velocity = direction * speed;
        self.position += self.velocity * dt;

        // Check if reached target and update patrol
        if (self.position - self.target_position).length() < 1.0 && !self.patrol_points.is_empty() {
            self.current_patrol_index = (self.current_patrol_index + 1) % self.patrol_points.len();
            self.target_position = self.patrol_points[self.current_patrol_index];
        }
    }

    fn get_color(&self) -> [f32; 4] {
        match self.character_type {
            CharacterType::Villager => [0.8, 0.6, 0.4, 1.0], // Tan
            CharacterType::Guard => [0.3, 0.3, 0.8, 1.0],    // Blue
            CharacterType::Merchant => [0.6, 0.3, 0.8, 1.0], // Purple
            CharacterType::Animal => [0.9, 0.7, 0.5, 1.0],   // Light brown
        }
    }
}

// ------------------------------- Physics -------------------------------

struct Physics {
    pipeline: r3::PhysicsPipeline,
    gravity: r3::Vector<f32>,
    islands: r3::IslandManager,
    broad: r3::DefaultBroadPhase,
    narrow: r3::NarrowPhase,
    bodies: r3::RigidBodySet,
    colliders: r3::ColliderSet,
    impulse_joints: r3::ImpulseJointSet,
    multibody_joints: r3::MultibodyJointSet,
    ccd: r3::CCDSolver,
    query_pipeline: r3::QueryPipeline,
    integration_params: r3::IntegrationParameters,
}

#[allow(dead_code)] // Type alias may be used in future iterations
type Real = f32;

// ------------------------------- Texture Pack Loading -------------------------------

fn load_texture_pack(path: &Path) -> Result<TexturePack> {
    let content = fs::read_to_string(path)?;
    let pack: TexturePack = toml::from_str(&content)?;
    Ok(pack)
}

fn mip_level_count_for(size: wgpu::Extent3d) -> u32 {
    let max_dim = size.width.max(size.height).max(size.depth_or_array_layers);
    // floor(log2(max_dim)) + 1 for full chain including base level
    let max_dim = max_dim.max(1);
    (f32::log2(max_dim as f32).floor() as u32) + 1
}

fn load_texture_from_bytes_with_format(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
    bytes: &[u8],
    label: &str,
    format: wgpu::TextureFormat,
) -> Result<LoadedTexture> {
    println!("Loading texture '{}' from {} bytes", label, bytes.len());
    let img = image::load_from_memory(bytes)?;
    let rgba = img.to_rgba8();
    let dimensions = img.dimensions();
    println!(
        "Texture '{}' loaded successfully: {}x{} pixels",
        label, dimensions.0, dimensions.1
    );

    let size = wgpu::Extent3d {
        width: dimensions.0,
        height: dimensions.1,
        depth_or_array_layers: 1,
    };

    let mip_levels = mip_level_count_for(size);
    let texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some(label),
        size,
        mip_level_count: mip_levels,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST | wgpu::TextureUsages::RENDER_ATTACHMENT,
        view_formats: &[],
    });

    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &texture,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &rgba,
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4 * dimensions.0),
            rows_per_image: Some(dimensions.1),
        },
        size,
    );

    // Generate mipmaps using a simple render pass downsampling
    generate_mipmaps(device, queue, &texture, format, size, mip_levels);

    let view = texture.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::Repeat,
        address_mode_v: wgpu::AddressMode::Repeat,
        address_mode_w: wgpu::AddressMode::Repeat,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
        anisotropy_clamp: 16,
        ..Default::default()
    });

    println!("Successfully created texture resources for '{}'", label);

    Ok(LoadedTexture {
        texture,
        view,
        sampler,
    })
}

fn generate_mipmaps(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
    texture: &wgpu::Texture,
    format: wgpu::TextureFormat,
    size: wgpu::Extent3d,
    mip_levels: u32,
) {
    if mip_levels <= 1 {
        return;
    }

    // Shader to sample from previous mip level and write into current target level
    const MIPMAP_SHADER: &str = r#"
struct VsOut { @builtin(position) pos: vec4<f32>, @location(0) uv: vec2<f32> };
@vertex fn vs(@builtin(vertex_index) vi: u32) -> VsOut {
  var out: VsOut;
  let xy = vec2<f32>(f32(i32(vi) - 1), f32((i32(vi) & 1) * 2 - 1));
  out.pos = vec4<f32>(xy, 0.0, 1.0);
  out.uv = vec2<f32>( (xy.x+1.0)*0.5, 1.0 - (xy.y+1.0)*0.5 );
  return out;
}

@group(0) @binding(0) var src_tex: texture_2d<f32>;
@group(0) @binding(1) var src_smp: sampler;

@fragment fn fs(in: VsOut) -> @location(0) vec4<f32> {
  // Simple linear sample; hardware does the filtering
  let c = textureSample(src_tex, src_smp, in.uv);
  return c;
}
"#;

    let sm = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("mipmap-gen-shader"),
        source: wgpu::ShaderSource::Wgsl(Cow::Borrowed(MIPMAP_SHADER)),
    });

    let bgl = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("mipmap-bgl"),
        entries: &[
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Texture {
                    multisampled: false,
                    view_dimension: wgpu::TextureViewDimension::D2,
                    sample_type: wgpu::TextureSampleType::Float { filterable: true },
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 1,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                count: None,
            },
        ],
    });

    let pl = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("mipmap-pl"),
        bind_group_layouts: &[&bgl],
        push_constant_ranges: &[],
    });

    let rp = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("mipmap-pipeline"),
        layout: Some(&pl),
        vertex: wgpu::VertexState { module: &sm, entry_point: "vs", buffers: &[], compilation_options: wgpu::PipelineCompilationOptions::default() },
        fragment: Some(wgpu::FragmentState {
            module: &sm,
            entry_point: "fs",
            targets: &[Some(wgpu::ColorTargetState { format, blend: None, write_mask: wgpu::ColorWrites::ALL })],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        }),
        primitive: wgpu::PrimitiveState::default(),
        depth_stencil: None,
        multisample: wgpu::MultisampleState::default(),
        multiview: None,
    });

    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        label: Some("mipmap-linear-sampler"),
        address_mode_u: wgpu::AddressMode::ClampToEdge,
        address_mode_v: wgpu::AddressMode::ClampToEdge,
        address_mode_w: wgpu::AddressMode::ClampToEdge,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
        ..Default::default()
    });

    let mut encoder = device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: Some("mipmap-encoder") });

    let mut src_w = size.width;
    let mut src_h = size.height;
    for level in 1..mip_levels {
    // next level dimensions
        src_w = (src_w.max(1) / 2).max(1);
        src_h = (src_h.max(1) / 2).max(1);

        let src_view = texture.create_view(&wgpu::TextureViewDescriptor {
            label: Some("mip-src-view"),
            format: Some(format),
            dimension: Some(wgpu::TextureViewDimension::D2),
            aspect: wgpu::TextureAspect::All,
            base_mip_level: level - 1,
            mip_level_count: Some(1),
            base_array_layer: 0,
            array_layer_count: Some(1),
        });

        let bind = device.create_bind_group(&wgpu::BindGroupDescriptor {
            label: Some("mipmap-bg"),
            layout: &bgl,
            entries: &[
                wgpu::BindGroupEntry { binding: 0, resource: wgpu::BindingResource::TextureView(&src_view) },
                wgpu::BindGroupEntry { binding: 1, resource: wgpu::BindingResource::Sampler(&sampler) },
            ],
        });

        let dst_view = texture.create_view(&wgpu::TextureViewDescriptor {
            label: Some("mip-dst-view"),
            format: Some(format),
            dimension: Some(wgpu::TextureViewDimension::D2),
            aspect: wgpu::TextureAspect::All,
            base_mip_level: level,
            mip_level_count: Some(1),
            base_array_layer: 0,
            array_layer_count: Some(1),
        });

        let mut rpass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
            label: Some("mipmap-pass"),
            color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                view: &dst_view,
                resolve_target: None,
                ops: wgpu::Operations { load: wgpu::LoadOp::Clear(wgpu::Color::TRANSPARENT), store: wgpu::StoreOp::Store },
            })],
            depth_stencil_attachment: None,
            timestamp_writes: None,
            occlusion_query_set: None,
        });
        rpass.set_pipeline(&rp);
        rpass.set_bind_group(0, &bind, &[]);
        rpass.draw(0..3, 0..1);
        drop(rpass);
    }

    queue.submit(Some(encoder.finish()));
}

fn load_texture_from_file(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
    path: &Path,
) -> Result<LoadedTexture> {
    println!("Attempting to load texture from file: {}", path.display());
    if !path.exists() {
        eprintln!("ERROR: Texture file does not exist: {}", path.display());
        return Err(anyhow::anyhow!(
            "Texture file not found: {}",
            path.display()
        ));
    }
        let bytes = fs::read(path).map_err(|e| {
            eprintln!("Failed to read texture file: {}", e);
            anyhow::anyhow!("Texture file not found: {}", path.display())
        })?;
    println!(
        "Successfully read {} bytes from {}",
        bytes.len(),
        path.display()
    );
    // Decide texture format by filename convention
    // *_n.* (normal) and *_mra.* should be UNORM; albedo/emissive use sRGB
    let name_lc = path.file_stem().and_then(|s| s.to_str()).unwrap_or("").to_ascii_lowercase();
    let is_normal = name_lc.ends_with("_n");
    let is_mra = name_lc.ends_with("_mra");
    let format = if is_normal || is_mra {
        println!(
            "Inferred UNORM format (non-sRGB) for texture: {}",
            path.display()
        );
        wgpu::TextureFormat::Rgba8Unorm
    } else {
        println!(
            "Inferred sRGB format for texture: {}",
            path.display()
        );
        wgpu::TextureFormat::Rgba8UnormSrgb
    };
    load_texture_from_bytes_with_format(device, queue, &bytes, &path.to_string_lossy(), format)
}

fn reload_texture_pack(render: &mut RenderStuff, texture_pack_name: &str) -> Result<()> {
    // Load texture pack configuration
    let pack_path = resolve_asset_src_path(&format!("environments/{}.toml", texture_pack_name));
    let pack = load_texture_pack(&pack_path)?;

    // Load the ground texture specified in the pack
    let texture_name = if pack.ground.texture.ends_with(".ktx2") {
        // Convert .ktx2 reference to .png for now
        pack.ground.texture.replace(".ktx2", ".png")
    } else {
        pack.ground.texture.clone()
    };

    // Resolve the ground/albedo texture path via our asset resolution logic
    let texture_path = resolve_asset_path(&texture_name);
    println!(
        "Loading texture pack '{}' with ground texture: {}",
        texture_pack_name,
        texture_path.display()
    );
    
    // Debug: Check if texture file exists
    if !texture_path.exists() {
        eprintln!(
            "ERROR: Texture file not found: {}",
            texture_path.display()
        );
        return Err(anyhow::anyhow!("Texture file not found: {}", texture_path.display()));
    }

    match load_texture_from_file(&render.device, &render.queue, &texture_path) {
        Ok(new_texture) => {
            println!("âœ“ Successfully loaded albedo texture: {}", texture_path.display());
            
            // Construct normal map path by replacing extension with _n.png
            let tex_stem = Path::new(&texture_name)
                .file_stem()
                .and_then(|s| s.to_str())
                .unwrap_or("texture");
            let npath = resolve_asset_path(&format!("{}_n.png", tex_stem));
            let normal_tex = if npath.exists() {
                println!("Using normal map: {}", npath.display());
                load_texture_from_file(&render.device, &render.queue, &npath)?
            } else {
                let default_npath = resolve_asset_path("default_n.png");
                eprintln!(
                    "Warning: Normal map not found at {}. Falling back to {}",
                    npath.display(),
                    default_npath.display()
                );
                load_texture_from_file(&render.device, &render.queue, &default_npath)?
            };

            // Load optional MRA and emissive textures based on base texture stem
            let mra_path = resolve_asset_path(&format!("{}_mra.png", tex_stem));
            let emissive_path = resolve_asset_path(&format!("{}_e.png", tex_stem));
            let mra_tex = if mra_path.exists() {
                println!("Using MRA map: {}", mra_path.display());
                load_texture_from_file(&render.device, &render.queue, &mra_path)?
            } else {
                eprintln!(
                    "Info: MRA map not found at {}. Using default MRA.",
                    mra_path.display()
                );
                create_default_mra_texture(&render.device, &render.queue)?
            };
            let emissive_tex = if emissive_path.exists() {
                println!("Using emissive map: {}", emissive_path.display());
                load_texture_from_file(&render.device, &render.queue, &emissive_path)?
            } else {
                eprintln!(
                    "Info: Emissive map not found at {}. Using default emissive (black).",
                    emissive_path.display()
                );
                create_default_emissive_texture(&render.device, &render.queue)?
            };

            // Prepare additional biome textures (use existing ones or fall back to ground)
            let dirt_albedo_ref = render.dirt_albedo.as_ref().unwrap_or(&new_texture);
            let dirt_normal_ref = render.dirt_normal.as_ref().unwrap_or(&normal_tex);
            let dirt_mra_ref = render.dirt_mra.as_ref().unwrap_or(&mra_tex);
            let stone_albedo_ref = render.stone_albedo.as_ref().unwrap_or(&new_texture);
            let stone_normal_ref = render.stone_normal.as_ref().unwrap_or(&normal_tex);
            let stone_mra_ref = render.stone_mra.as_ref().unwrap_or(&mra_tex);
            let sand_albedo_ref = render.sand_albedo.as_ref().unwrap_or(&new_texture);
            let sand_normal_ref = render.sand_normal.as_ref().unwrap_or(&normal_tex);
            let sand_mra_ref = render.sand_mra.as_ref().unwrap_or(&mra_tex);
            let forest_albedo_ref = render.forest_albedo.as_ref().unwrap_or(&new_texture);
            let forest_normal_ref = render.forest_normal.as_ref().unwrap_or(&normal_tex);
            let forest_mra_ref = render.forest_mra.as_ref().unwrap_or(&mra_tex);

            // Create bind group with albedo, normal, MRA, emissive and biome sets
            let combined_bg = render.device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some(&format!("{}-albedo-normal", texture_pack_name)),
                layout: &render.texture_bind_group_layout,
                entries: &[
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::TextureView(&new_texture.view),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Sampler(&new_texture.sampler),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::TextureView(&normal_tex.view),
                    },
                    wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Sampler(&normal_tex.sampler),
                    },
                    wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::TextureView(&mra_tex.view),
                    },
                    wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Sampler(&mra_tex.sampler),
                    },
                    wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::TextureView(&emissive_tex.view),
                    },
                    wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Sampler(&emissive_tex.sampler),
                    },
                    // Dirt
                    wgpu::BindGroupEntry { binding: 8, resource: wgpu::BindingResource::TextureView(&dirt_albedo_ref.view) },
                    wgpu::BindGroupEntry { binding: 9, resource: wgpu::BindingResource::TextureView(&dirt_normal_ref.view) },
                    wgpu::BindGroupEntry { binding: 10, resource: wgpu::BindingResource::TextureView(&dirt_mra_ref.view) },
                    // Stone
                    wgpu::BindGroupEntry { binding: 11, resource: wgpu::BindingResource::TextureView(&stone_albedo_ref.view) },
                    wgpu::BindGroupEntry { binding: 12, resource: wgpu::BindingResource::TextureView(&stone_normal_ref.view) },
                    wgpu::BindGroupEntry { binding: 13, resource: wgpu::BindingResource::TextureView(&stone_mra_ref.view) },
                    // Sand
                    wgpu::BindGroupEntry { binding: 14, resource: wgpu::BindingResource::TextureView(&sand_albedo_ref.view) },
                    wgpu::BindGroupEntry { binding: 15, resource: wgpu::BindingResource::TextureView(&sand_normal_ref.view) },
                    wgpu::BindGroupEntry { binding: 16, resource: wgpu::BindingResource::TextureView(&sand_mra_ref.view) },
                    // Forest
                    wgpu::BindGroupEntry { binding: 17, resource: wgpu::BindingResource::TextureView(&forest_albedo_ref.view) },
                    wgpu::BindGroupEntry { binding: 18, resource: wgpu::BindingResource::TextureView(&forest_normal_ref.view) },
                    wgpu::BindGroupEntry { binding: 19, resource: wgpu::BindingResource::TextureView(&forest_mra_ref.view) },
                ],
            });

            // Update render state
            render.ground_texture = Some(new_texture);
            render.ground_normal = Some(normal_tex);
            render.ground_bind_group = Some(combined_bg);
            render.ground_mra = Some(mra_tex);
            render.ground_emissive = Some(emissive_tex);

            println!("Successfully loaded texture pack: {}", texture_pack_name);
            Ok(())
        }
        Err(e) => {
            println!(
                "âŒ Failed to load texture for pack '{}' from path '{}': {}",
                texture_pack_name, texture_path.display(), e
            );
            
            // More detailed error information
            if !texture_path.exists() {
                println!("âŒ Texture file does not exist: {}", texture_path.display());
            } else {
                println!("ðŸ“„ Texture file exists but failed to load: {}", texture_path.display());
            }
            
            // Try to fallback to grass texture if loading desert/other fails
            if texture_pack_name != "grassland" {
                println!("ðŸ”„ Attempting fallback to grassland texture...");
                let fallback_path = Path::new("assets").join("grass.png");
                match load_texture_from_file(&render.device, &render.queue, &fallback_path) {
                    Ok(fallback_texture) => {
                        println!("âœ“ Successfully loaded fallback grass texture");
                        let fallback_normal = create_default_normal_texture(&render.device, &render.queue)?;
                        
                        let combined_bg = render.device.create_bind_group(&wgpu::BindGroupDescriptor {
                            label: Some(&format!("{}-fallback-bind-group", texture_pack_name)),
                            layout: &render.texture_bind_group_layout,
                            entries: &[
                                wgpu::BindGroupEntry {
                                    binding: 0,
                                    resource: wgpu::BindingResource::TextureView(&fallback_texture.view),
                                },
                                wgpu::BindGroupEntry {
                                    binding: 1,
                                    resource: wgpu::BindingResource::Sampler(&fallback_texture.sampler),
                                },
                                wgpu::BindGroupEntry {
                                    binding: 2,
                                    resource: wgpu::BindingResource::TextureView(&fallback_normal.view),
                                },
                                wgpu::BindGroupEntry {
                                    binding: 3,
                                    resource: wgpu::BindingResource::Sampler(&fallback_normal.sampler),
                                },
                            ],
                        });
                        
                        render.ground_texture = Some(fallback_texture);
                        render.ground_normal = Some(fallback_normal);
                        render.ground_bind_group = Some(combined_bg);
                        
                        println!("âœ“ Successfully set fallback texture for pack: {}", texture_pack_name);
                        return Ok(());
                    }
                    Err(fallback_e) => {
                        println!("âŒ Fallback texture also failed: {}", fallback_e);
                    }
                }
            }
            
            Err(e)
        }
    }
}

fn generate_environment_objects(physics: &mut Physics, texture_pack_name: &str) -> Vec<Character> {
    // Clear existing objects (keep ground and first few objects as player/sphere)
    let mut handles_to_remove = Vec::new();
    for (handle, body) in physics.bodies.iter() {
        if body.user_data > 2 {
            // Keep player objects (user_data 1, 2)
            handles_to_remove.push(handle);
        }
    }

    for handle in handles_to_remove {
        physics.bodies.remove(
            handle,
            &mut physics.islands,
            &mut physics.colliders,
            &mut physics.impulse_joints,
            &mut physics.multibody_joints,
            true,
        );
    }

    let mut characters = Vec::new();

    // Generate comprehensive biome environments
    match texture_pack_name {
        "grassland" => {
            // === VEGETATION ===
            // Dense forest areas with varied tree types - significantly increased density
            for i in 0..75 {
                let x = -35.0 + (i as f32) * 1.2 + (i as f32 * 0.7).sin() * 2.5;
                let z = -25.0 + (i % 8) as f32 * 4.0 + (i as f32 * 0.9).cos() * 3.0;

                // Vary tree types and sizes for realistic forest
                let (height, width, _tree_type) = match i % 4 {
                    0 => (2.5, 0.3, "oak"),      // Large oak trees
                    1 => (1.8, 0.2, "pine"),     // Medium pine trees  
                    2 => (1.2, 0.15, "birch"),   // Small birch trees
                    _ => (3.0, 0.4, "ancient"),  // Ancient giant trees
                };

                let base_y = terrain_surface_y(x, z);
                let tree_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + height, z))
                    .user_data(10 + i)
                    .build();
                let tree_handle = physics.bodies.insert(tree_rb);
                let tree_col = r3::ColliderBuilder::cuboid(width, height, width).build();
                physics
                    .colliders
                    .insert_with_parent(tree_col, tree_handle, &mut physics.bodies);
            }

            // Scattered bushes and undergrowth - increased density
            for i in 0..35 {
                let x = -15.0 + (i as f32) * 2.5 + (i as f32 * 1.3).sin() * 5.0;
                let z = 5.0 + (i as f32 * 1.1).cos() * 12.0;
                let size = 0.2 + (i % 3) as f32 * 0.1;

                let base_y = terrain_surface_y(x, z);
                let bush_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + size * 0.6, z))
                    .user_data(100 + i)
                    .build();
                let bush_handle = physics.bodies.insert(bush_rb);
                let bush_col = r3::ColliderBuilder::cuboid(size, size * 0.6, size).build();
                physics
                    .colliders
                    .insert_with_parent(bush_col, bush_handle, &mut physics.bodies);
            }

            // === STRUCTURES ===
            // Village with varied building types - more structures
            for i in 0..15 {
                let x = 15.0 + (i as f32) * 6.0 + (i as f32).sin() * 4.0;
                let z = -8.0 + (i % 4) as f32 * 8.0 + (i as f32).cos() * 3.0;

                let (width, height, depth, _building_type) = match i % 5 {
                    0 => (2.2, 1.5, 1.8, "manor"),      // Large manor house
                    1 => (1.5, 1.0, 1.2, "cottage"),    // Medium cottage
                    2 => (1.0, 0.8, 1.0, "hut"),        // Small hut
                    3 => (2.8, 2.0, 2.0, "temple"),     // Village temple
                    _ => (1.8, 1.2, 1.5, "workshop"),   // Workshops and shops
                };

                let base_y = terrain_surface_y(x, z);
                let house_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + height, z))
                    .user_data(35 + i)
                    .build();
                let house_handle = physics.bodies.insert(house_rb);
                let house_col = r3::ColliderBuilder::cuboid(width, height, depth).build();
                physics
                    .colliders
                    .insert_with_parent(house_col, house_handle, &mut physics.bodies);
            }

            // === GEOLOGICAL FEATURES ===
            // Rolling hills with scattered boulders - increased geological features
            for i in 0..25 {
                let x = -30.0 + (i as f32) * 6.0 + (i as f32 * 2.1).sin() * 8.0;
                let z = 20.0 + (i as f32 * 1.7).cos() * 10.0;
                let size = 0.8 + (i % 4) as f32 * 0.5;

                let base_y = terrain_surface_y(x, z);
                let boulder_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + size * 0.8, z))
                    .user_data(60 + i)
                    .build();
                let boulder_handle = physics.bodies.insert(boulder_rb);
                let boulder_col = r3::ColliderBuilder::cuboid(size, size * 0.8, size * 1.1).build();
                physics
                    .colliders
                    .insert_with_parent(boulder_col, boulder_handle, &mut physics.bodies);
            }

            // Stone circles and ancient ruins
            for i in 0..6 {
                let angle = (i as f32) * std::f32::consts::PI * 2.0 / 6.0;
                let radius = 12.0;
                let x = radius * angle.cos();
                let z = radius * angle.sin() + 30.0;
                let height = 1.5 + (i % 2) as f32 * 0.8;

                let base_y = terrain_surface_y(x, z);
                let stone_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + height, z))
                    .user_data(200 + i)
                    .build();
                let stone_handle = physics.bodies.insert(stone_rb);
                let stone_col = r3::ColliderBuilder::cuboid(0.4, height, 0.3).build();
                physics
                    .colliders
                    .insert_with_parent(stone_col, stone_handle, &mut physics.bodies);
            }

            // === WATER FEATURES ===
            // River with stone banks
            for i in 0..10 {
                let x = -15.0 + (i as f32) * 3.0;
                let z = -30.0 + (i as f32) * 2.0 + (i as f32 * 2.0).sin() * 8.0;
                let size = 0.3 + (i % 2) as f32 * 0.2;

                let base_y = terrain_surface_y(x, z);
                let bank_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y - 0.5, z))
                    .user_data(300 + i)
                    .build();
                let bank_handle = physics.bodies.insert(bank_rb);
                let bank_col = r3::ColliderBuilder::cuboid(size, 0.2, size * 1.5).build();
                physics
                    .colliders
                    .insert_with_parent(bank_col, bank_handle, &mut physics.bodies);
            }

            // === CHARACTERS ===
            // Village inhabitants with varied roles and patrol patterns - more NPCs
            for i in 0..20 {
                let x = 10.0 + (i as f32) * 4.0 + (i as f32).sin() * 4.0;
                let z = -12.0 + (i as f32 * 1.3).sin() * 15.0;
                let pos = Vec3::new(x, terrain_surface_y(x, z) + 0.5, z);

                let char_type = match i % 5 {
                    0 => CharacterType::Villager,
                    1 => CharacterType::Guard,
                    2 => CharacterType::Merchant,
                    3 => CharacterType::Animal,
                    _ => CharacterType::Villager,
                };

                let mut character = Character::new(pos, char_type);

                // Complex patrol routes for realistic behavior
                match char_type {
                    CharacterType::Guard => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(8.0, 0.0, 2.0),
                            pos + Vec3::new(6.0, 0.0, 8.0),
                            pos + Vec3::new(-2.0, 0.0, 6.0),
                            pos + Vec3::new(-4.0, 0.0, 0.0),
                        ];
                    }
                    CharacterType::Merchant => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(12.0, 0.0, 0.0),
                            pos + Vec3::new(8.0, 0.0, -6.0),
                        ];
                    }
                    CharacterType::Animal => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(4.0, 0.0, 4.0),
                            pos + Vec3::new(-3.0, 0.0, 2.0),
                            pos + Vec3::new(1.0, 0.0, -3.0),
                        ];
                    }
                    _ => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(3.0, 0.0, 0.0),
                            pos + Vec3::new(3.0, 0.0, 3.0),
                            pos + Vec3::new(0.0, 0.0, 3.0),
                        ];
                    }
                }
                character.target_position = if !character.patrol_points.is_empty() {
                    character.patrol_points[1]
                } else {
                    pos
                };

                characters.push(character);
            }
        }
        "desert" => {
            // === VEGETATION ===
            // Varied cacti and desert plants - increased density
            for i in 0..40 {
                let x = -25.0 + (i as f32) * 3.0 + (i as f32 * 1.2).sin() * 4.0;
                let z = -15.0 + (i % 6) as f32 * 6.0 + (i as f32).cos() * 8.0;

                let (width, height, _cactus_type) = match i % 5 {
                    0 => (0.2, 3.5, "saguaro"),        // Tall saguaro cactus
                    1 => (0.4, 1.0, "barrel"),         // Barrel cactus
                    2 => (0.15, 2.2, "prickly_pear"),  // Prickly pear
                    3 => (0.25, 1.8, "cholla"),        // Cholla cactus
                    _ => (0.3, 0.6, "desert_shrub"),   // Desert shrub
                };

                let base_y = terrain_surface_y(x, z);
                let cactus_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + height, z))
                    .user_data(30 + i)
                    .build();
                let cactus_handle = physics.bodies.insert(cactus_rb);
                let cactus_col = r3::ColliderBuilder::cuboid(width, height, width).build();
                physics.colliders.insert_with_parent(
                    cactus_col,
                    cactus_handle,
                    &mut physics.bodies,
                );
            }

            // === STRUCTURES ===
            // Desert settlement with adobe architecture - more buildings
            for i in 0..12 {
                let x = 20.0 + (i as f32) * 8.0 + (i as f32).cos() * 5.0;
                let z = 5.0 + (i % 3) as f32 * 12.0 + (i as f32).sin() * 4.0;

                let (width, height, depth, _building_type) = match i % 3 {
                    0 => (2.5, 1.2, 2.0, "adobe_compound"), // Large compound
                    1 => (1.8, 0.9, 1.5, "adobe_house"),    // Medium house
                    _ => (3.0, 1.8, 2.5, "adobe_temple"),   // Temple/mosque
                };

                let base_y = terrain_surface_y(x, z);
                let adobe_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + height, z))
                    .user_data(40 + i)
                    .build();
                let adobe_handle = physics.bodies.insert(adobe_rb);
                let adobe_col = r3::ColliderBuilder::cuboid(width, height, depth).build();
                physics
                    .colliders
                    .insert_with_parent(adobe_col, adobe_handle, &mut physics.bodies);
            }

            // === GEOLOGICAL FEATURES ===
            // Mesa formations and desert rock outcrops - more geological variety
            for i in 0..25 {
                let x = -30.0 + (i as f32) * 5.0 + (i as f32 * 1.9).sin() * 10.0;
                let z = 25.0 + (i as f32 * 1.3).cos() * 12.0;
                let size = 1.2 + (i % 5) as f32 * 0.8;

                let (width, height, depth) = match i % 4 {
                    0 => (size, size * 2.0, size * 0.8), // Tall mesa
                    1 => (size * 1.5, size, size * 1.2), // Wide plateau
                    2 => (size * 0.6, size * 3.0, size * 0.6), // Spire
                    _ => (size, size * 0.8, size), // Regular rock
                };

                let base_y = terrain_surface_y(x, z);
                let formation_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + height, z))
                    .user_data(76 + i)
                    .build();
                let formation_handle = physics.bodies.insert(formation_rb);
                let formation_col = r3::ColliderBuilder::cuboid(width, height, depth).build();
                physics.colliders.insert_with_parent(
                    formation_col,
                    formation_handle,
                    &mut physics.bodies,
                );
            }

            // Sand dunes (represented as low, wide formations)
            for i in 0..8 {
                let x = 0.0 + (i as f32) * 15.0 + (i as f32 * 2.5).sin() * 10.0;
                let z = -25.0 + (i as f32 * 1.8).cos() * 15.0;
                let width = 4.0 + (i % 3) as f32 * 2.0;
                let height = 0.5 + (i % 2) as f32 * 0.3;

                let base_y = terrain_surface_y(x, z);
                let dune_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + height, z))
                    .user_data(400 + i)
                    .build();
                let dune_handle = physics.bodies.insert(dune_rb);
                let dune_col = r3::ColliderBuilder::cuboid(width, height, width * 0.6).build();
                physics
                    .colliders
                    .insert_with_parent(dune_col, dune_handle, &mut physics.bodies);
            }

            // === WATER FEATURES ===
            // Oasis with palm-like vegetation
            let oasis_x = 5.0;
            let oasis_z = 10.0;
            for i in 0..5 {
                let angle = (i as f32) * std::f32::consts::PI * 2.0 / 5.0;
                let radius = 3.0;
                let x = oasis_x + radius * angle.cos();
                let z = oasis_z + radius * angle.sin();

                let base_y = terrain_surface_y(x, z);
                let palm_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + 2.0, z))
                    .user_data(500 + i)
                    .build();
                let palm_handle = physics.bodies.insert(palm_rb);
                let palm_col = r3::ColliderBuilder::cuboid(0.2, 2.0, 0.2).build();
                physics
                    .colliders
                    .insert_with_parent(palm_col, palm_handle, &mut physics.bodies);
            }

            // === CHARACTERS ===
            // Desert nomads and traders
            for i in 0..8 {
                let x = 15.0 + (i as f32) * 12.0 + (i as f32).sin() * 5.0;
                let z = -5.0 + (i as f32 * 0.9).sin() * 8.0;
                let pos = Vec3::new(x, terrain_surface_y(x, z) + 0.5, z);

                let char_type = match i % 4 {
                    0 => CharacterType::Merchant,
                    1 => CharacterType::Guard,
                    2 => CharacterType::Animal, // Desert animals (camels, etc.)
                    _ => CharacterType::Villager, // Nomads
                };

                let mut character = Character::new(pos, char_type);

                // Longer patrol routes for desert environment
                match char_type {
                    CharacterType::Merchant => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(20.0, 0.0, 5.0),
                            pos + Vec3::new(15.0, 0.0, 15.0),
                            pos + Vec3::new(-5.0, 0.0, 10.0),
                        ];
                    }
                    CharacterType::Animal => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(8.0, 0.0, 8.0),
                            pos + Vec3::new(-5.0, 0.0, 12.0),
                            pos + Vec3::new(-8.0, 0.0, -3.0),
                        ];
                    }
                    _ => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(10.0, 0.0, 3.0),
                            pos + Vec3::new(6.0, 0.0, 8.0),
                            pos + Vec3::new(-3.0, 0.0, 5.0),
                        ];
                    }
                }
                character.target_position = if !character.patrol_points.is_empty() {
                    character.patrol_points[1]
                } else {
                    pos
                };

                characters.push(character);
            }
        }
        "forest" => {
            // === DENSE FOREST BIOME ===
            // Ancient forest with towering trees and rich undergrowth
            
            // === VEGETATION ===
            // Ancient towering trees - higher density for deep forest feeling
            for i in 0..95 {
                let x = -40.0 + (i as f32) * 1.1 + (i as f32 * 0.6).sin() * 3.0;
                let z = -30.0 + (i % 10) as f32 * 3.8 + (i as f32 * 0.8).cos() * 4.0;

                // Varied ancient tree types with dramatic height differences
                let (height, width, _tree_type) = match i % 6 {
                    0 => (4.5, 0.6, "ancient_oak"),     // Massive ancient oaks
                    1 => (3.8, 0.4, "giant_pine"),     // Tall pines
                    2 => (2.8, 0.3, "elder_birch"),    // Elder birch
                    3 => (5.2, 0.8, "world_tree"),     // Mythical world trees
                    4 => (3.2, 0.35, "cedar"),         // Tall cedars
                    _ => (2.2, 0.25, "maple"),          // Forest maples
                };

                let base_y = terrain_surface_y(x, z);
                let tree_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + height, z))
                    .user_data(10 + i)
                    .build();
                let tree_handle = physics.bodies.insert(tree_rb);
                let tree_col = r3::ColliderBuilder::cuboid(width, height, width).build();
                physics
                    .colliders
                    .insert_with_parent(tree_col, tree_handle, &mut physics.bodies);
            }

            // Dense undergrowth and ferns - forest floor vegetation
            for i in 0..60 {
                let x = -25.0 + (i as f32) * 2.0 + (i as f32 * 1.4).sin() * 6.0;
                let z = 8.0 + (i as f32 * 1.2).cos() * 15.0;
                let size = 0.15 + (i % 4) as f32 * 0.08;

                let base_y = terrain_surface_y(x, z);
                let undergrowth_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + size * 0.5, z))
                    .user_data(150 + i)
                    .build();
                let undergrowth_handle = physics.bodies.insert(undergrowth_rb);
                let undergrowth_col = r3::ColliderBuilder::cuboid(size, size * 0.5, size).build();
                physics
                    .colliders
                    .insert_with_parent(undergrowth_col, undergrowth_handle, &mut physics.bodies);
            }

            // === STRUCTURES ===
            // Woodland dwellings and mystical sites
            for i in 0..8 {
                let x = 25.0 + (i as f32) * 8.0 + (i as f32).sin() * 6.0;
                let z = -5.0 + (i % 3) as f32 * 10.0 + (i as f32).cos() * 4.0;

                let (width, height, depth, _building_type) = match i % 4 {
                    0 => (2.0, 1.8, 1.6, "tree_house"),      // Elevated tree houses
                    1 => (1.2, 2.5, 1.2, "wizard_tower"),    // Tall mystical towers
                    2 => (2.5, 1.0, 2.5, "woodland_shrine"), // Ground-level shrines
                    _ => (1.6, 1.4, 1.4, "ranger_cabin"),    // Ranger cabins
                };

                let base_y = terrain_surface_y(x, z);
                let structure_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + height, z))
                    .user_data(200 + i)
                    .build();
                let structure_handle = physics.bodies.insert(structure_rb);
                let structure_col = r3::ColliderBuilder::cuboid(width, height, depth).build();
                physics
                    .colliders
                    .insert_with_parent(structure_col, structure_handle, &mut physics.bodies);
            }

            // === GEOLOGICAL FEATURES ===
            // Moss-covered boulders and ancient stone formations
            for i in 0..18 {
                let x = -35.0 + (i as f32) * 7.0 + (i as f32 * 2.2).sin() * 10.0;
                let z = 25.0 + (i as f32 * 1.8).cos() * 12.0;
                let size = 1.0 + (i % 3) as f32 * 0.6;

                let base_y = terrain_surface_y(x, z);
                let boulder_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + size * 0.8, z))
                    .user_data(250 + i)
                    .build();
                let boulder_handle = physics.bodies.insert(boulder_rb);
                let boulder_col = r3::ColliderBuilder::cuboid(size, size * 0.8, size * 0.9).build();
                physics
                    .colliders
                    .insert_with_parent(boulder_col, boulder_handle, &mut physics.bodies);
            }

            // Ancient stone circles (mystical sites)
            let circle_center_x = 0.0;
            let circle_center_z = 15.0;
            for i in 0..8 {
                let angle = (i as f32) * std::f32::consts::PI * 2.0 / 8.0;
                let radius = 8.0;
                let x = circle_center_x + radius * angle.cos();
                let z = circle_center_z + radius * angle.sin();

                let base_y = terrain_surface_y(x, z);
                let stone_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + 1.5, z))
                    .user_data(300 + i)
                    .build();
                let stone_handle = physics.bodies.insert(stone_rb);
                let stone_col = r3::ColliderBuilder::cuboid(0.5, 1.5, 0.3).build();
                physics
                    .colliders
                    .insert_with_parent(stone_col, stone_handle, &mut physics.bodies);
            }

            // === WATER FEATURES ===
            // Forest streams and pools
            for i in 0..3 {
                let x = -10.0 + (i as f32) * 15.0;
                let z = -12.0 + (i as f32) * 8.0;

                let base_y = terrain_surface_y(x, z);
                let pool_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, base_y + 0.2, z))
                    .user_data(350 + i)
                    .build();
                let pool_handle = physics.bodies.insert(pool_rb);
                let pool_col = r3::ColliderBuilder::cuboid(2.0, 0.2, 1.5).build();
                physics
                    .colliders
                    .insert_with_parent(pool_col, pool_handle, &mut physics.bodies);
            }

            // === CHARACTERS ===
            // Forest dwellers and mystical beings
            for i in 0..10 {
                let x = -20.0 + (i as f32) * 8.0 + (i as f32 * 1.1).sin() * 12.0;
                let z = -10.0 + (i as f32 * 0.9).cos() * 18.0;
                let pos = Vec3::new(x, terrain_surface_y(x, z) + 0.5, z);

                let char_type = match i % 5 {
                    0 => CharacterType::Guard,    // Forest rangers
                    1 => CharacterType::Merchant, // Herb gatherers
                    2 => CharacterType::Villager, // Forest dwellers  
                    3 => CharacterType::Guard,    // Druids (using guard type)
                    _ => CharacterType::Villager, // Woodland folk
                };

                let mut character = Character::new(pos, char_type);

                // Forest-specific patrol routes through the trees
                match i % 4 {
                    0 => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(6.0, 0.0, 2.0),
                            pos + Vec3::new(4.0, 0.0, 8.0),
                            pos + Vec3::new(-2.0, 0.0, 6.0),
                            pos + Vec3::new(-4.0, 0.0, 2.0),
                        ];
                    }
                    1 => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(-5.0, 0.0, 3.0),
                            pos + Vec3::new(-3.0, 0.0, -4.0),
                            pos + Vec3::new(2.0, 0.0, -2.0),
                        ];
                    }
                    2 => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(8.0, 0.0, -1.0),
                            pos + Vec3::new(5.0, 0.0, -6.0),
                            pos + Vec3::new(-1.0, 0.0, -4.0),
                        ];
                    }
                    _ => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(2.0, 0.0, 7.0),
                            pos + Vec3::new(-3.0, 0.0, 5.0),
                            pos + Vec3::new(-1.0, 0.0, 1.0),
                        ];
                    }
                }

                characters.push(character);
            }
        }
        _ => {
            // Enhanced default environment with mixed biome features
            for i in 0..15 {
                let x = -12.0 + (i as f32) * 2.5;
                let z = 3.0 + (i % 3) as f32 * 6.0 + (i as f32).sin() * 3.0;
                let height = 1.0 + (i % 4) as f32 * 0.8;

                let obj_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(50 + i)
                    .build();
                let obj_handle = physics.bodies.insert(obj_rb);
                let obj_col = r3::ColliderBuilder::cuboid(0.6, height, 0.6).build();
                physics
                    .colliders
                    .insert_with_parent(obj_col, obj_handle, &mut physics.bodies);
            }

            // Default characters with simple behavior
            for i in 0..6 {
                let x = (i as f32) * 6.0;
                let z = (i % 2) as f32 * 4.0;
                let pos = Vec3::new(x, -1.0, z);
                let mut character = Character::new(pos, CharacterType::Villager);
                character.patrol_points = vec![
                    pos,
                    pos + Vec3::new(4.0, 0.0, 0.0),
                    pos + Vec3::new(4.0, 0.0, 4.0),
                    pos + Vec3::new(0.0, 0.0, 4.0),
                ];
                character.target_position = character.patrol_points[1];
                characters.push(character);
            }
        }
    }

    characters
}

// ------------------------------- Main entry -------------------------------

fn main() -> Result<()> {
    // Use pollster to block on the async run
    pollster::block_on(run())
}

async fn run() -> Result<()> {
    // Generate default textures at startup if missing (seed -> vary looks)
    let seed = 0xA57; // change to taste / hook to key for regeneration
    let out_dir = asset_dir();
    // Do not overwrite existing high-fidelity assets at startup; only synthesize if missing
    texture_synth::ensure_textures(&out_dir.to_string_lossy(), seed, false)?;

    // Boilerplate: create event loop and window
    let event_loop = EventLoop::new()?;
    let window = std::sync::Arc::new(
        WindowBuilder::new()
            .with_title("AstraWeave Unified Showcase (Modified)")
            .build(&event_loop)?,
    );
    // Setup renderer, UI, physics
    let mut render = setup_renderer(window.clone()).await?;
    let mut physics = build_physics_world();

    // Initialize default environment and texture pack
    let mut characters = generate_environment_objects(&mut physics, "grassland");
    println!("ðŸŒ¿ Generated {} character instances for initial grassland environment", characters.len());

    // Load the initial grassland texture pack
    println!("ðŸŒ± Initializing with grassland texture pack...");
    if let Err(e) = reload_texture_pack(&mut render, "grassland") {
        println!(
            "âš  Warning: Failed to load initial grassland texture pack: {}",
            e
        );
        println!("Continuing with default textures...");
        println!(
            "Note: You can still switch texture packs using keys 1 (grassland) and 2 (desert)"
        );
    } else {
        println!("âœ… Successfully loaded initial grassland texture pack");
        println!(
            "Controls: WASD+mouse=camera, P=pause physics, T=teleport sphere, E=apply impulse, C=toggle camera mode"
        );
        println!("Mouse wheel: zoom camera | Right-click + mouse: look around");
        println!("Texture packs: Press 1 for grassland, 2 for desert, 3 for forest");
    }

    let mut instances = build_show_instances();
    let mut ui = UiState::default();

    // Use proper camera system from astraweave-render with enhanced positioning for optimal biome showcase
    let mut camera = RenderCamera {
        position: Vec3::new(15.0, 12.0, 30.0), // Enhanced position to better showcase biome diversity
        yaw: -0.3,    // Better angle to view village, forest, and terrain features
        pitch: -0.4,  // Optimal pitch to see both terrain detail and sky
        fovy: 70f32.to_radians(), // Optimized field of view for biome immersion
        aspect: 1.0,
        znear: 0.01,
        zfar: 10000.0, // Extended far plane for maximum terrain visibility
    };
    let mut camera_controller = CameraController::new(8.0, 0.002);
    let mut last = Instant::now();
    let mut fps_acc = 0.0;
    let mut fps_cnt = 0u32;

    let elwt = event_loop;
    let _ = elwt.run(move |event, elwt_window_target| {
        elwt_window_target.set_control_flow(winit::event_loop::ControlFlow::Poll);
        match event {
            Event::WindowEvent {
                event: win_event, ..
            } => {
                match win_event {
                    WindowEvent::CloseRequested => {
                        elwt_window_target.exit();
                    }
                    WindowEvent::KeyboardInput {
                        event:
                            KeyEvent {
                                physical_key,
                                state,
                                ..
                            },
                        ..
                    } => {
                        let pressed = state == ElementState::Pressed;
                        match physical_key {
                            PhysicalKey::Code(code) => {
                                camera_controller.process_keyboard(code, pressed);
                                match code {
                                    KeyCode::Escape => {
                                        if pressed {
                                            elwt_window_target.exit();
                                        }
                                    }
                                    KeyCode::KeyP => {
                                        if pressed {
                                            ui.physics_paused = !ui.physics_paused;
                                        }
                                    }
                                    KeyCode::KeyT => {
                                        if pressed {
                                            // Teleport sphere a few meters in front of camera
                                            let forward = astraweave_render::camera::Camera::dir(
                                                camera.yaw,
                                                camera.pitch,
                                            );
                                            let target = camera.position
                                                + forward * 4.0
                                                + Vec3::new(0.0, -0.5, 0.0);
                                            teleport_sphere_to(&mut physics, target);
                                        }
                                    }
                                    KeyCode::KeyE => {
                                        if pressed {
                                            // Raycast forward and apply impulse to first hit dynamic body
                                            let forward = astraweave_render::camera::Camera::dir(
                                                camera.yaw,
                                                camera.pitch,
                                            );

                                            // Create a ray for the query
                                            let ray_origin = nalgebra::Point3::new(
                                                camera.position.x,
                                                camera.position.y,
                                                camera.position.z,
                                            );
                                            let ray_dir = nalgebra::Vector3::new(
                                                forward.x, forward.y, forward.z,
                                            );
                                            let ray = r3::Ray::new(ray_origin, ray_dir);

                                            // Update the query pipeline with just the colliders
                                            physics.query_pipeline.update(&physics.colliders);

                                            // Cast the ray
                                            if let Some((h, _toi)) =
                                                physics.query_pipeline.cast_ray(
                                                    &physics.bodies,
                                                    &physics.colliders,
                                                    &ray,
                                                    15.0,
                                                    true,
                                                    r3::QueryFilter::default(),
                                                )
                                            {
                                                if let Some(body) =
                                                    physics.bodies.get_mut(r3::RigidBodyHandle(h.0))
                                                {
                                                    if !body.is_fixed() {
                                                        let impulse = nalgebra::Vector3::new(
                                                            forward.x * 3.0,
                                                            1.0,
                                                            forward.z * 3.0,
                                                        );
                                                        body.apply_impulse(impulse, true);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    KeyCode::KeyC => {
                                        if pressed {
                                            camera_controller.toggle_mode(&mut camera);
                                            println!("Camera mode: {:?}", camera_controller.mode);
                                        }
                                    }
                                    KeyCode::KeyM => {
                                        if pressed {
                                            ui.debug_material_tint = !ui.debug_material_tint;
                                            println!("Material debug tint: {}", ui.debug_material_tint);
                                        }
                                    }
                                    KeyCode::Digit1 => {
                                        if pressed {
                                            let pack_name = "grassland";
                                            println!("ðŸŒ± Switching to {} texture pack...", pack_name);
                                            if let Err(e) =
                                                reload_texture_pack(&mut render, pack_name)
                                            {
                                                println!(
                                                    "âŒ Failed to switch to {} texture pack: {}",
                                                    pack_name, e
                                                );
                                            } else {
                                                ui.current_texture_pack = pack_name.to_string();
                                                ui.info_text = format!(
                                                    "Switched to {} environment",
                                                    pack_name
                                                );
                                                characters = generate_environment_objects(
                                                    &mut physics,
                                                    pack_name,
                                                );
                                                println!("âœ… Successfully switched to {} environment with {} characters", pack_name, characters.len());
                                            }
                                        }
                                    }
                                    KeyCode::Digit2 => {
                                        if pressed {
                                            let pack_name = "desert";
                                            println!("Attempting to switch to desert texture pack...");
                                            if let Err(e) =
                                                reload_texture_pack(&mut render, pack_name)
                                            {
                                                println!(
                                                    "âŒ Failed to switch to {} texture pack: {}",
                                                    pack_name, e
                                                );
                                            } else {
                                                ui.current_texture_pack = pack_name.to_string();
                                                ui.info_text = format!(
                                                    "Switched to {} environment",
                                                    pack_name
                                                );
                                                println!("Successfully switched to desert texture pack");
                                                characters = generate_environment_objects(
                                                    &mut physics,
                                                    pack_name,
                                                );
                                                println!("Regenerated {} desert environment objects", characters.len());
                                            }
                                        }
                                    }
                                    KeyCode::Digit3 => {
                                        if pressed {
                                            let pack_name = "forest";
                                            if let Err(e) =
                                                reload_texture_pack(&mut render, pack_name)
                                            {
                                                println!(
                                                    "Failed to switch to {} texture pack: {}",
                                                    pack_name, e
                                                );
                                            } else {
                                                println!(
                                                    "Switched to {} environment",
                                                    pack_name
                                                );
                                                characters = generate_environment_objects(
                                                    &mut physics,
                                                    pack_name,
                                                );
                                            }
                                        }
                                    }
                                    KeyCode::Equal => { // '+' to increase exposure
                                        if pressed {
                                            ui.exposure = (ui.exposure * 1.1).clamp(0.1, 5.0);
                                            println!("Exposure: {:.2}", ui.exposure);
                                        }
                                    }
                                    KeyCode::NumpadAdd => { // Numpad '+'
                                        if pressed {
                                            ui.exposure = (ui.exposure * 1.1).clamp(0.1, 5.0);
                                            println!("Exposure: {:.2}", ui.exposure);
                                        }
                                    }
                                    KeyCode::Minus => { // '-' to decrease exposure
                                        if pressed {
                                            ui.exposure = (ui.exposure / 1.1).clamp(0.1, 5.0);
                                            println!("Exposure: {:.2}", ui.exposure);
                                        }
                                    }
                                    KeyCode::NumpadSubtract => { // Numpad '-'
                                        if pressed {
                                            ui.exposure = (ui.exposure / 1.1).clamp(0.1, 5.0);
                                            println!("Exposure: {:.2}", ui.exposure);
                                        }
                                    }
                                    KeyCode::Digit0 => { // Reset exposure to default
                                        if pressed {
                                            ui.exposure = 1.0;
                                            println!("Exposure reset to {:.2}", ui.exposure);
                                        }
                                    }
                                    KeyCode::BracketLeft => { // decrease bloom threshold
                                        if pressed {
                                            ui.bloom_threshold = (ui.bloom_threshold - 0.05).clamp(0.0, 5.0);
                                            println!("Bloom threshold: {:.2}", ui.bloom_threshold);
                                        }
                                    }
                                    KeyCode::BracketRight => { // increase bloom threshold
                                        if pressed {
                                            ui.bloom_threshold = (ui.bloom_threshold + 0.05).clamp(0.0, 5.0);
                                            println!("Bloom threshold: {:.2}", ui.bloom_threshold);
                                        }
                                    }
                                    KeyCode::Semicolon => { // decrease bloom intensity
                                        if pressed {
                                            ui.bloom_intensity = (ui.bloom_intensity - 0.05).clamp(0.0, 2.0);
                                            println!("Bloom intensity: {:.2}", ui.bloom_intensity);
                                        }
                                    }
                                    KeyCode::Quote => { // increase bloom intensity
                                        if pressed {
                                            ui.bloom_intensity = (ui.bloom_intensity + 0.05).clamp(0.0, 2.0);
                                            println!("Bloom intensity: {:.2}", ui.bloom_intensity);
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            _ => {}
                        }
                    }
                    WindowEvent::MouseInput { state, button, .. } => {
                        camera_controller
                            .process_mouse_button(button, state == ElementState::Pressed);
                        if button == winit::event::MouseButton::Right {
                            let pressed = state == ElementState::Pressed;
                            // Grab or release cursor for reliable deltas
                            if pressed {
                                let _ = window.set_cursor_grab(CursorGrabMode::Locked);
                                window.set_cursor_visible(false);
                            } else {
                                let _ = window.set_cursor_grab(CursorGrabMode::None);
                                window.set_cursor_visible(true);
                            }
                        }
                    }
                    WindowEvent::MouseWheel {
                        delta: MouseScrollDelta::LineDelta(_, y),
                        ..
                    } => {
                        // Use camera controller for zoom instead of speed adjustment
                        camera_controller.process_scroll(&mut camera, y);
                    }
                    WindowEvent::Resized(size) => {
                        render.surface_cfg.width = size.width.max(1);
                        render.surface_cfg.height = size.height.max(1);
                        render
                            .surface
                            .configure(&render.device, &render.surface_cfg);
                        render.depth_view = create_depth(
                            &render.device,
                            render.surface_cfg.width,
                            render.surface_cfg.height,
                            render.msaa_samples,
                        );
                        // Recreate MSAA color target
                        render.msaa_color_view = if render.msaa_samples > 1 {
                            Some(create_msaa_color(
                                &render.device,
                                render.surface_cfg.format,
                                render.surface_cfg.width,
                                render.surface_cfg.height,
                                render.msaa_samples,
                            ))
                        } else { None };

                        // Recreate HDR targets for post-processing
                        let hdr_size = wgpu::Extent3d {
                            width: render.surface_cfg.width,
                            height: render.surface_cfg.height,
                            depth_or_array_layers: 1,
                        };
                        let hdr_mips = mip_level_count_for(hdr_size);
                        render.hdr_tex = render.device.create_texture(&wgpu::TextureDescriptor {
                            label: Some("hdr-tex"),
                            size: hdr_size,
                            mip_level_count: hdr_mips,
                            sample_count: 1,
                            dimension: wgpu::TextureDimension::D2,
                            format: wgpu::TextureFormat::Rgba16Float,
                            usage: wgpu::TextureUsages::RENDER_ATTACHMENT
                                | wgpu::TextureUsages::TEXTURE_BINDING
                                | wgpu::TextureUsages::COPY_SRC,
                            view_formats: &[],
                        });
                        render.hdr_view = render
                            .hdr_tex
                            .create_view(&wgpu::TextureViewDescriptor::default());
                        // Single-mip view (level 0) for render/resolve target
                        render.hdr_resolve_view = render.hdr_tex.create_view(&wgpu::TextureViewDescriptor {
                            label: Some("hdr-resolve-view"),
                            format: Some(wgpu::TextureFormat::Rgba16Float),
                            dimension: Some(wgpu::TextureViewDimension::D2),
                            aspect: wgpu::TextureAspect::All,
                            base_mip_level: 0,
                            mip_level_count: Some(1),
                            base_array_layer: 0,
                            array_layer_count: Some(1),
                        });
                        render.hdr_msaa_view = if render.msaa_samples > 1 {
                            let msaa_tex = render.device.create_texture(&wgpu::TextureDescriptor {
                                label: Some("hdr-msaa"),
                                size: hdr_size,
                                mip_level_count: 1,
                                sample_count: render.msaa_samples,
                                dimension: wgpu::TextureDimension::D2,
                                format: wgpu::TextureFormat::Rgba16Float,
                                usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
                                view_formats: &[],
                            });
                            Some(msaa_tex.create_view(&wgpu::TextureViewDescriptor::default()))
                        } else {
                            None
                        };

                        // Recreate post bind group to point at new HDR view
                        render.post_bg = render.device.create_bind_group(&wgpu::BindGroupDescriptor {
                            label: Some("post-bg"),
                            layout: &render.post_bgl,
                            entries: &[
                                wgpu::BindGroupEntry {
                                    binding: 0,
                                    // Post samples from full-mip view
                                    resource: wgpu::BindingResource::TextureView(&render.hdr_view),
                                },
                                wgpu::BindGroupEntry {
                                    binding: 1,
                                    resource: wgpu::BindingResource::Sampler(&render.post_sampler),
                                },
                                wgpu::BindGroupEntry { binding: 2, resource: render.exposure_buf.as_entire_binding() },
                                wgpu::BindGroupEntry { binding: 3, resource: render.bloom_ub.as_entire_binding() },
                            ],
                        });

                        // Update UI info with character count
                        ui.info_text = format!(
                            "Environment: {} ({} characters)",
                            ui.current_texture_pack,
                            characters.len()
                        );
                    }
                    WindowEvent::RedrawRequested => {
                        let now = Instant::now();
                        let dt = now - last;
                        last = now;

                        // smooth FPS
                        let fps = 1.0 / dt.as_secs_f32().max(1e-5);
                        fps_acc += fps;
                        fps_cnt += 1;
                        if fps_cnt >= 30 {
                            ui.fps_text = format!("{:.1} fps", fps_acc / fps_cnt as f32);
                            fps_acc = 0.0;
                            fps_cnt = 0;
                        }

                        // Update camera
                        camera.aspect = (render.surface_cfg.width as f32 * ui.resolution_scale)
                            .max(1.0)
                            / (render.surface_cfg.height as f32 * ui.resolution_scale).max(1.0);

                        // Update camera with controller
                        camera_controller.update_camera(&mut camera, dt.as_secs_f32());

                        // Update characters
                        for character in &mut characters {
                            character.update(dt.as_secs_f32());
                            // Project to terrain surface to avoid floating/penetration due to slope changes
                            let ground_y = terrain_surface_y(character.position.x, character.position.z);
                            // Maintain a small offset so feet aren't z-fighting the ground
                            character.position.y = ground_y + 0.5;
                        }

                        // Physics
                        if !ui.physics_paused {
                            physics_step(&mut physics);
                        }

                        // Sync sim to render and batch instances by mesh type
                        sync_instances_from_physics(&physics, &characters, camera.position, &mut instances);
                        render.instance_count = instances.len() as u32;
                        
                        // Batch instances by mesh type for efficient rendering
                        let instance_batches = batch_instances_by_mesh_type(&instances);

                        // Camera uniform
                        let cam = GpuCamera {
                            view_proj: camera.vp().to_cols_array(),
                        };
                        render
                            .queue
                            .write_buffer(&render.camera_ub, 0, bytemuck::bytes_of(&cam));

                        // Update exposure uniform buffer from UI state
                        let post = PostParams { exposure: ui.exposure, _pad: [0.0; 3], _pad2: [0.0; 4] };
                        render.queue.write_buffer(&render.exposure_buf, 0, bytemuck::bytes_of(&post));
                        // Update bloom uniform
                        let bloom = BloomParams { threshold: ui.bloom_threshold, intensity: ui.bloom_intensity, _pad: [0.0; 2] };
                        render.queue.write_buffer(&render.bloom_ub, 0, bytemuck::bytes_of(&bloom));

                        // Update debug toggle uniform
                        let dbg = DebugParamsRust { debug_tint: if ui.debug_material_tint { 1 } else { 0 }, _pad: [0; 3], _pad2: [0; 4] };
                        render.queue.write_buffer(&render.debug_buf, 0, bytemuck::bytes_of(&dbg));

                        // Prepare command encoder (reused for shadow and main passes)
                        let mut encoder = render.device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: Some("frame-encoder") });

                        // Update light matrices (directional light)
                        let light_dir = glam::Vec3::new(0.6, 1.0, 0.4).normalize();
                        let light_view = Mat4::look_at_rh(-light_dir * 150.0, Vec3::ZERO, Vec3::Y);
                        let ortho_extent = 220.0;
                        let light_proj = Mat4::orthographic_rh(
                            -ortho_extent, ortho_extent,
                            -ortho_extent, ortho_extent,
                            0.1, 400.0,
                        );
                        let light_vp = light_proj * light_view;
                        let lcam = GpuCamera { view_proj: light_vp.to_cols_array() };
                        render.queue.write_buffer(&render.light_ub, 0, bytemuck::bytes_of(&lcam));

                        // Shadow pass
                        {
                            let mut sp = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                                label: Some("shadow-pass"),
                                color_attachments: &[],
                                depth_stencil_attachment: Some(wgpu::RenderPassDepthStencilAttachment {
                                    view: &render.shadow_view,
                                    depth_ops: Some(wgpu::Operations { load: wgpu::LoadOp::Clear(1.0), store: wgpu::StoreOp::Store }),
                                    stencil_ops: None,
                                }),
                                timestamp_writes: None,
                                occlusion_query_set: None,
                            });
                            sp.set_pipeline(&render.shadow_pipeline);
                            sp.set_bind_group(0, &render.light_bg, &[]);
                            for batch in &instance_batches {
                                if batch.mesh_type == MeshType::Skybox { continue; }
                                if let Some(mesh) = render.meshes.get(&batch.mesh_type) {
                                    render.queue.write_buffer(&render.instance_vb, 0, bytemuck::cast_slice(&batch.instances));
                                    sp.set_vertex_buffer(0, mesh.vertex_buffer.slice(..));
                                    sp.set_vertex_buffer(1, render.instance_vb.slice(..));
                                    sp.set_index_buffer(mesh.index_buffer.slice(..), wgpu::IndexFormat::Uint32);
                                    if !batch.instances.is_empty() {
                                        sp.draw_indexed(0..mesh.index_count, 0, 0..batch.instances.len() as u32);
                                    }
                                }
                            }
                        }

                        // Render
                        let frame = match render.surface.get_current_texture() {
                            Ok(f) => f,
                            Err(_) => {
                                render
                                    .surface
                                    .configure(&render.device, &render.surface_cfg);
                                render.surface.get_current_texture().unwrap()
                            }
                        };
                        let view = frame
                            .texture
                            .create_view(&wgpu::TextureViewDescriptor::default());
                        // Main pass into HDR offscreen target (with MSAA resolve if enabled)
                        {
                            // Use MSAA view if enabled; otherwise render directly to single-mip resolve view
                            let color_view = render
                                .hdr_msaa_view
                                .as_ref()
                                .unwrap_or(&render.hdr_resolve_view);
                            // Resolve into the single-mip resolve view when MSAA is enabled
                            let resolve_target = if render.msaa_samples > 1 {
                                Some(&render.hdr_resolve_view)
                            } else {
                                None
                            };
                            let mut rp = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                                label: Some("main-pass"),
                                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                                    view: color_view,
                                    resolve_target,
                                    ops: wgpu::Operations {
                                        load: wgpu::LoadOp::Clear(wgpu::Color {
                                            r: 0.4,
                                            g: 0.6,
                                            b: 0.9,
                                            a: 1.0,
                                        }),
                                        store: wgpu::StoreOp::Store,
                                    },
                                })],
                                depth_stencil_attachment: Some(
                                    wgpu::RenderPassDepthStencilAttachment {
                                        view: &render.depth_view,
                                        depth_ops: Some(wgpu::Operations {
                                            load: wgpu::LoadOp::Clear(1.0),
                                            store: wgpu::StoreOp::Store,
                                        }),
                                        stencil_ops: None,
                                    },
                                ),
                                timestamp_writes: None,
                                occlusion_query_set: None,
                            });
                            rp.set_pipeline(&render.pipeline);
                            rp.set_bind_group(0, &render.camera_bg, &[]);
                            if let Some(ref texture_bg) = render.ground_bind_group {
                                rp.set_bind_group(1, texture_bg, &[]);
                            }
                            rp.set_bind_group(2, &render.shadow_bg, &[]);
                            rp.set_bind_group(3, &render.light_bg, &[]);
                            // Render skybox first
                            for batch in &instance_batches {
                                if batch.mesh_type == MeshType::Skybox {
                                    if let Some(mesh) = render.meshes.get(&batch.mesh_type) {
                                        render.queue.write_buffer(
                                            &render.instance_vb,
                                            0,
                                            bytemuck::cast_slice(&batch.instances),
                                        );
                                        rp.set_vertex_buffer(0, mesh.vertex_buffer.slice(..));
                                        rp.set_vertex_buffer(1, render.instance_vb.slice(..));
                                        rp.set_index_buffer(
                                            mesh.index_buffer.slice(..),
                                            wgpu::IndexFormat::Uint32,
                                        );
                                        if !batch.instances.is_empty() {
                                            rp.draw_indexed(
                                                0..mesh.index_count,
                                                0,
                                                0..batch.instances.len() as u32,
                                            );
                                        }
                                    }
                                }
                            }
                            // Render other mesh batches
                            for batch in &instance_batches {
                                if batch.mesh_type != MeshType::Skybox {
                                    if let Some(mesh) = render.meshes.get(&batch.mesh_type) {
                                        render.queue.write_buffer(
                                            &render.instance_vb,
                                            0,
                                            bytemuck::cast_slice(&batch.instances),
                                        );
                                        rp.set_vertex_buffer(0, mesh.vertex_buffer.slice(..));
                                        rp.set_vertex_buffer(1, render.instance_vb.slice(..));
                                        rp.set_index_buffer(
                                            mesh.index_buffer.slice(..),
                                            wgpu::IndexFormat::Uint32,
                                        );
                                        if !batch.instances.is_empty() {
                                            rp.draw_indexed(
                                                0..mesh.index_count,
                                                0,
                                                0..batch.instances.len() as u32,
                                            );
                                        }
                                    }
                                }
                            }
                        }

                        // Submit main pass before generating mips
                        render.queue.submit(Some(encoder.finish()));

                        // Generate mips for HDR color (used by bloom post)
                        let hdr_size = wgpu::Extent3d {
                            width: render.surface_cfg.width,
                            height: render.surface_cfg.height,
                            depth_or_array_layers: 1,
                        };
                        generate_mipmaps(
                            &render.device,
                            &render.queue,
                            &render.hdr_tex,
                            wgpu::TextureFormat::Rgba16Float,
                            hdr_size,
                            mip_level_count_for(hdr_size),
                        );

                        // Post pass: composite bloom to the swapchain
                        let mut encoder2 = render
                            .device
                            .create_command_encoder(&wgpu::CommandEncoderDescriptor {
                                label: Some("post-encoder"),
                            });
                        {
                            let mut rp = encoder2.begin_render_pass(&wgpu::RenderPassDescriptor {
                                label: Some("post-pass"),
                                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                                    view: &view,
                                    resolve_target: None,
                                    ops: wgpu::Operations {
                                        load: wgpu::LoadOp::Clear(wgpu::Color::BLACK),
                                        store: wgpu::StoreOp::Store,
                                    },
                                })],
                                depth_stencil_attachment: None,
                                timestamp_writes: None,
                                occlusion_query_set: None,
                            });
                            rp.set_pipeline(&render.post_pipeline);
                            rp.set_bind_group(0, &render.post_bg, &[]);
                            rp.draw(0..3, 0..1);
                        }
                        render.queue.submit(Some(encoder2.finish()));
                        frame.present();
                    }
                    _ => {}
                }
            }
            Event::AboutToWait => {
                window.request_redraw();
            }
            Event::DeviceEvent {
                event: DeviceEvent::MouseMotion { delta },
                ..
            } => {
                // Use proper mouse delta handling for camera controller
                let mouse_delta = Vec2::new(delta.0 as f32, delta.1 as f32);
                camera_controller.process_mouse_delta(&mut camera, mouse_delta);
            }
            _ => {}
        }
    });
    Ok(())
}

// ---------------- Helper functions for default textures ----------------

fn create_default_albedo_texture(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
) -> Result<LoadedTexture> {
    let white_texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("default-white"),
        size: wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Rgba8UnormSrgb,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });
    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &white_texture,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &[255, 255, 255, 255], // RGBA white
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4),
            rows_per_image: Some(1),
        },
        wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
    );
    let view = white_texture.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::Repeat,
        address_mode_v: wgpu::AddressMode::Repeat,
        address_mode_w: wgpu::AddressMode::Repeat,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
        anisotropy_clamp: 8,
        ..Default::default()
    });
    Ok(LoadedTexture {
        texture: white_texture,
        view,
        sampler,
    })
}

fn create_default_normal_texture(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
) -> Result<LoadedTexture> {
    let normal_texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("default-normal"),
        size: wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
    format: wgpu::TextureFormat::Rgba8Unorm,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });
    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &normal_texture,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &[128, 128, 255, 255], // Default normal pointing up (0, 0, 1) in normal map encoding
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4),
            rows_per_image: Some(1),
        },
        wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
    );
    let view = normal_texture.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::Repeat,
        address_mode_v: wgpu::AddressMode::Repeat,
        address_mode_w: wgpu::AddressMode::Repeat,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
    anisotropy_clamp: 8,
        ..Default::default()
    });
    Ok(LoadedTexture {
        texture: normal_texture,
        view,
        sampler,
    })
}

// Default MRA texture: R=AO=1.0 (no occlusion), G=Roughness=0.8, B=Metallic=0.0
fn create_default_mra_texture(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
) -> Result<LoadedTexture> {
    let mra_tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("default-mra"),
        size: wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
    format: wgpu::TextureFormat::Rgba8Unorm,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });
    // RGBA: AO, Roughness, Metallic, unused
    let ao = (1.0 * 255.0) as u8;
    let rough = (0.8 * 255.0) as u8;
    let metal = (0.0 * 255.0) as u8;
    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &mra_tex,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &[ao, rough, metal, 255],
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4),
            rows_per_image: Some(1),
        },
        wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
    );
    let view = mra_tex.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::Repeat,
        address_mode_v: wgpu::AddressMode::Repeat,
        address_mode_w: wgpu::AddressMode::Repeat,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
        anisotropy_clamp: 8,
        ..Default::default()
    });
    Ok(LoadedTexture { texture: mra_tex, view, sampler })
}

// Default emissive texture: black (no emission)
fn create_default_emissive_texture(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
) -> Result<LoadedTexture> {
    let e_tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("default-emissive"),
        size: wgpu::Extent3d { width: 1, height: 1, depth_or_array_layers: 1 },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
    format: wgpu::TextureFormat::Rgba8UnormSrgb,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });
    queue.write_texture(
        wgpu::ImageCopyTexture { texture: &e_tex, mip_level: 0, origin: wgpu::Origin3d::ZERO, aspect: wgpu::TextureAspect::All },
        &[0, 0, 0, 255],
        wgpu::ImageDataLayout { offset: 0, bytes_per_row: Some(4), rows_per_image: Some(1) },
        wgpu::Extent3d { width: 1, height: 1, depth_or_array_layers: 1 },
    );
    let view = e_tex.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::Repeat,
        address_mode_v: wgpu::AddressMode::Repeat,
        address_mode_w: wgpu::AddressMode::Repeat,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
        anisotropy_clamp: 8,
        ..Default::default()
    });
    Ok(LoadedTexture { texture: e_tex, view, sampler })
}

// Fallback: create a 1x1 texture matching the color of an existing texture's first texel
fn default_albedo_clone(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
    _src: &LoadedTexture,
) -> Result<LoadedTexture> {
    // We don't read from GPU; just make a neutral 1x1 white as a safe stand-in
    create_default_albedo_texture(device, queue)
}

// ---------------- renderer setup ----------------
// Structure to hold batched instance data for efficient rendering
struct InstanceBatch {
    instances: Vec<InstanceRaw>,
    mesh_type: MeshType,
}

// Shared terrain parameters used by both rendering and physics so visuals and collisions match
const TERRAIN_SIZE: usize = 256; // grid resolution along one axis
const TERRAIN_SCALE: f32 = 6.0;  // world units between vertices

fn batch_instances_by_mesh_type(instances: &[InstanceRaw]) -> Vec<InstanceBatch> {
    let mut batches = Vec::new();
    
    // Create separate batches for each mesh type including skybox
    for &mesh_type_val in &[MeshType::Skybox as u32, MeshType::Cube as u32, MeshType::Tree as u32, MeshType::House as u32, MeshType::Character as u32] {
        let mesh_type = match mesh_type_val {
            0 => MeshType::Cube,
            1 => MeshType::Tree,
            2 => MeshType::House,
            3 => MeshType::Character,
            4 => MeshType::Skybox,
            _ => MeshType::Cube,
        };
        
        let filtered_instances: Vec<InstanceRaw> = instances
            .iter()
            .filter(|instance| instance.mesh_type == mesh_type_val)
            .copied()
            .collect();
            
        if !filtered_instances.is_empty() {
            batches.push(InstanceBatch {
                instances: filtered_instances,
                mesh_type,
            });
        }
    }
    
    batches
}

// Generate terrain mesh with height variations matching the shader logic
fn generate_terrain_mesh(size: usize, scale: f32) -> (Vec<[f32; 3]>, Vec<u32>) {
    let mut vertices = Vec::new();
    let mut indices = Vec::new();
    
    // Generate vertices with height variation
    for z in 0..=size {
        for x in 0..=size {
            let world_x = (x as f32 - size as f32 * 0.5) * scale;
            let world_z = (z as f32 - size as f32 * 0.5) * scale;
            
            // Match the shader's biome and terrain height logic
            let world_pos = [world_x, world_z];
            let biome_type = get_biome_type_rust(world_pos);
            let terrain_height = get_biome_terrain_height_rust(world_pos, biome_type);
            
            vertices.push([world_x, -2.0 + terrain_height, world_z]);
        }
    }
    
    // Generate indices for triangles
    for z in 0..size {
        for x in 0..size {
            let i0 = (z * (size + 1) + x) as u32;
            let i1 = (z * (size + 1) + x + 1) as u32;
            let i2 = ((z + 1) * (size + 1) + x) as u32;
            let i3 = ((z + 1) * (size + 1) + x + 1) as u32;
            
            // Two triangles per quad
            indices.extend_from_slice(&[i0, i2, i1, i1, i2, i3]);
        }
    }
    
    (vertices, indices)
}

// Rust implementation of shader biome detection
fn smooth2_scalar(t: f32) -> f32 { t * t * t * (t * (t * 6.0 - 15.0) + 10.0) }

fn fract_scalar(x: f32) -> f32 { x - x.floor() }

fn hash21_rust(p: [f32; 2]) -> f32 {
    let h = p[0] * 127.1 + p[1] * 311.7;
    fract_scalar((h).sin() * 43758.5453)
}

fn value_noise2_rust(p: [f32; 2]) -> f32 {
    let ix = p[0].floor();
    let iy = p[1].floor();
    let fx = p[0] - ix;
    let fy = p[1] - iy;
    let ux = smooth2_scalar(fx);
    let uy = smooth2_scalar(fy);
    let a = hash21_rust([ix + 0.0, iy + 0.0]);
    let b = hash21_rust([ix + 1.0, iy + 0.0]);
    let c = hash21_rust([ix + 0.0, iy + 1.0]);
    let d = hash21_rust([ix + 1.0, iy + 1.0]);
    let x1 = a + (b - a) * ux;
    let x2 = c + (d - c) * ux;
    x1 + (x2 - x1) * uy
}

fn fbm2_rust(p: [f32; 2], octaves: i32, lacunarity: f32, gain: f32) -> f32 {
    let mut f = 0.0f32;
    let mut amp = 0.5f32;
    let mut freq = 1.0f32;
    let mut i = 0;
    while i < octaves {
        f += value_noise2_rust([p[0] * freq, p[1] * freq]) * amp;
        freq *= lacunarity;
        amp *= gain;
        i += 1;
    }
    f
}

fn fbm_ridge2_rust(p: [f32; 2], octaves: i32, lacunarity: f32, gain: f32) -> f32 {
    let mut f = 0.0f32;
    let mut amp = 0.5f32;
    let mut freq = 1.0f32;
    let mut i = 0;
    while i < octaves {
        let n = value_noise2_rust([p[0] * freq, p[1] * freq]);
        let r = 1.0 - (n * 2.0 - 1.0).abs();
        f += r * amp;
        freq *= lacunarity;
        amp *= gain;
        i += 1;
    }
    f
}

fn get_biome_type_rust(world_pos: [f32; 2]) -> i32 {
    let biome_scale = 0.01;
    let biome_pos = [world_pos[0] * biome_scale, world_pos[1] * biome_scale];
    let n = fbm2_rust(biome_pos, 5, 2.0, 0.5) * 2.0 - 1.0;
    if n > 0.25 { 1 } else if n < -0.25 { 2 } else { 0 }
}

// Rust implementation of shader terrain height generation
fn get_biome_terrain_height_rust(world_pos: [f32; 2], biome_type: i32) -> f32 {
    // Match WGSL FBM-based terrain height generation
    let p = [world_pos[0] * 0.01, world_pos[1] * 0.01];
    let base = (fbm2_rust(p, 5, 2.0, 0.5) * 2.0 - 1.0) * 3.5;
    let detail = (fbm2_rust([p[0] * 3.0, p[1] * 3.0], 3, 2.2, 0.5) - 0.5) * 1.5;
    let h = base + detail;
    match biome_type {
        0 => { // Grassland
            let river = fbm_ridge2_rust([p[0] * 0.9, p[1] * 0.9], 3, 2.0, 0.6);
            let valleys = (river - 0.6) * 6.0;
            h + valleys.clamp(-3.5, 0.0)
        }
        1 => { // Desert
            let wind_dir = {
                let len = (0.8f32 * 0.8 + 0.6 * 0.6).sqrt();
                [0.8 / len, 0.6 / len]
            };
            let d = p[0] * 6.0 * wind_dir[0] + p[1] * 6.0 * wind_dir[1];
            let dunes = (fbm_ridge2_rust([d, d * 0.3], 4, 2.0, 0.55) - 0.5) * 3.0;
            let mesas = if fbm_ridge2_rust([p[0] * 0.7, p[1] * 0.7], 4, 2.0, 0.5) >= 0.7 { 6.0 } else { 0.0 };
            h + dunes + mesas
        }
        2 => { // Forest
            let soft = fbm2_rust([p[0] * 0.7, p[1] * 0.7], 4, 2.0, 0.5) * 2.0 - 1.0;
            let mounds = if fbm2_rust([p[0] * 1.3 + 12.3, p[1] * 1.3 + 12.3], 4, 2.0, 0.5) >= 0.65 { 1.6 } else { 0.0 };
            h * 0.9 + soft * 2.2 + mounds
        }
        _ => h,
    }
}

// Compute the visual terrain surface Y at a given world-space (x, z)
fn terrain_surface_y(x: f32, z: f32) -> f32 {
    let biome = get_biome_type_rust([x, z]);
    // Terrain in mesh generation was placed at base -2.0 plus height variation
    -2.0 + get_biome_terrain_height_rust([x, z], biome)
}

fn create_mesh(device: &wgpu::Device, vertices: &[[f32; 3]], indices: &[u32]) -> Mesh {
    let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("mesh-vertices"),
        contents: bytemuck::cast_slice(vertices),
        usage: wgpu::BufferUsages::VERTEX,
    });
    
    let index_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("mesh-indices"),
        contents: bytemuck::cast_slice(indices),
        usage: wgpu::BufferUsages::INDEX,
    });
    
    Mesh {
        vertex_buffer,
        index_buffer,
        index_count: indices.len() as u32,
    }
}

fn to_u32_indices(src: &[u16]) -> Vec<u32> { src.iter().map(|&i| i as u32).collect() }

fn create_all_meshes(device: &wgpu::Device) -> std::collections::HashMap<MeshType, Mesh> {
    let mut meshes = std::collections::HashMap::new();
    
    // Generate terrain mesh instead of simple cube for ground
    let (terrain_vertices, terrain_indices) = generate_terrain_mesh(TERRAIN_SIZE, TERRAIN_SCALE);
    
    // Create terrain mesh as Cube type (since ground uses MeshType::Cube)
    meshes.insert(MeshType::Cube, create_mesh(device, &terrain_vertices, &terrain_indices));
    meshes.insert(MeshType::Tree, create_mesh(device, TREE_VERTICES, &to_u32_indices(TREE_INDICES)));
    meshes.insert(MeshType::House, create_mesh(device, HOUSE_VERTICES, &to_u32_indices(HOUSE_INDICES)));
    meshes.insert(MeshType::Character, create_mesh(device, CHARACTER_VERTICES, &to_u32_indices(CHARACTER_INDICES)));
    meshes.insert(MeshType::Skybox, create_mesh(device, SKYBOX_VERTICES, &to_u32_indices(SKYBOX_INDICES)));
    
    meshes
}

async fn setup_renderer(window: std::sync::Arc<winit::window::Window>) -> Result<RenderStuff> {
    let size = window.inner_size();
    println!(
        "Setting up wgpu renderer with window size: {}x{}",
        size.width, size.height
    );

    // Enable debug features for better error reporting
    let instance = wgpu::Instance::new(wgpu::InstanceDescriptor {
        backends: wgpu::Backends::all(),
        flags: wgpu::InstanceFlags::DEBUG | wgpu::InstanceFlags::VALIDATION,
        ..Default::default()
    });

    println!("Creating surface...");
    let surface = instance.create_surface(window.clone())?;

    println!("Requesting adapter...");
    let adapter = instance
        .request_adapter(&wgpu::RequestAdapterOptions {
            power_preference: wgpu::PowerPreference::HighPerformance,
            compatible_surface: Some(&surface),
            force_fallback_adapter: false,
        })
        .await
        .unwrap();

    println!("Adapter found: {:?}", adapter.get_info());

    println!("Requesting device...");
    let (device, queue) = adapter
        .request_device(
            &wgpu::DeviceDescriptor {
                label: Some("device"),
                required_features: wgpu::Features::empty(),
                required_limits: wgpu::Limits::default(),
            },
            None, // Enable validation for debug builds: Some(&std::path::Path::new("wgpu_trace"))
        )
        .await
        .unwrap();

    println!("Device created successfully");

    let msaa_samples = 4u32; // enable 4x MSAA
    let caps = surface.get_capabilities(&adapter);
    println!("Surface capabilities: {:?}", caps);

    let surface_format = caps
        .formats
        .iter()
        .copied()
        .find(|f| f.is_srgb())
        .unwrap_or(caps.formats[0]);

    println!("Selected surface format: {:?}", surface_format);
    let surface_cfg = wgpu::SurfaceConfiguration {
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
        format: surface_format,
        width: size.width.max(1),
        height: size.height.max(1),
        present_mode: caps.present_modes[0],
        alpha_mode: caps.alpha_modes[0],
        view_formats: vec![],
        desired_maximum_frame_latency: 2,
    };
    surface.configure(&device, &surface_cfg);
    let depth_view = create_depth(&device, surface_cfg.width, surface_cfg.height, msaa_samples);
    let msaa_color_view = if msaa_samples > 1 {
        Some(create_msaa_color(
            &device,
            surface_cfg.format,
            surface_cfg.width,
            surface_cfg.height,
            msaa_samples,
        ))
    } else {
        None
    };

    // HDR offscreen color target with mips for bloom
    let hdr_size = wgpu::Extent3d { width: surface_cfg.width, height: surface_cfg.height, depth_or_array_layers: 1 };
    let hdr_mips = mip_level_count_for(hdr_size);
    let hdr_tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("hdr-tex"),
        size: hdr_size,
        mip_level_count: hdr_mips,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Rgba16Float,
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_SRC,
        view_formats: &[],
    });
    let hdr_view = hdr_tex.create_view(&wgpu::TextureViewDescriptor::default());
    // Single-mip resolve/render view for mip level 0
    let hdr_resolve_view = hdr_tex.create_view(&wgpu::TextureViewDescriptor {
        label: Some("hdr-resolve-view"),
        format: Some(wgpu::TextureFormat::Rgba16Float),
        dimension: Some(wgpu::TextureViewDimension::D2),
        aspect: wgpu::TextureAspect::All,
        base_mip_level: 0,
        mip_level_count: Some(1),
        base_array_layer: 0,
        array_layer_count: Some(1),
    });
    let hdr_msaa_view = if msaa_samples > 1 {
        let tex = device.create_texture(&wgpu::TextureDescriptor {
            label: Some("hdr-msaa"),
            size: hdr_size,
            mip_level_count: 1,
            sample_count: msaa_samples,
            dimension: wgpu::TextureDimension::D2,
            format: wgpu::TextureFormat::Rgba16Float,
            usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
            view_formats: &[],
        });
        Some(tex.create_view(&wgpu::TextureViewDescriptor::default()))
    } else { None };

    // Create all meshes
    let meshes = create_all_meshes(&device);

    // Create camera uniform buffer and bind group layout
    let camera_ub = device.create_buffer(&wgpu::BufferDescriptor {
        label: Some("camera-ub"),
        size: std::mem::size_of::<GpuCamera>() as u64,
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        mapped_at_creation: false,
    });
    // Create exposure uniform buffer (PostParams)
    let exposure_init = PostParams { exposure: 1.0, _pad: [0.0; 3], _pad2: [0.0; 4] };
    let exposure_buf = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("exposure-ub"),
        contents: bytemuck::bytes_of(&exposure_init),
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
    });
    let debug_init = DebugParamsRust { debug_tint: 0, _pad: [0; 3], _pad2: [0; 4] };
    let debug_buf = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("debug-ub"),
        contents: bytemuck::bytes_of(&debug_init),
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
    });
    let camera_bg_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("camera-layout"),
        entries: &[
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 1,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 4,
                visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer {
                    ty: wgpu::BufferBindingType::Uniform,
                    has_dynamic_offset: false,
                    min_binding_size: None,
                },
                count: None,
            },
        ],
    });
    let camera_bg = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("camera-bg"),
        layout: &camera_bg_layout,
        entries: &[
            wgpu::BindGroupEntry {
                binding: 0,
                resource: camera_ub.as_entire_binding(),
            },
            wgpu::BindGroupEntry {
                binding: 1,
                resource: exposure_buf.as_entire_binding(),
            },
            wgpu::BindGroupEntry {
                binding: 4,
                resource: debug_buf.as_entire_binding(),
            },
        ],
    });

    // Light uniform and bind group (holds light view-projection)
    let light_ub = device.create_buffer(&wgpu::BufferDescriptor {
        label: Some("light-ub"),
        size: std::mem::size_of::<GpuCamera>() as u64,
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        mapped_at_creation: false,
    });
    let light_bg_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("light-layout"),
        entries: &[wgpu::BindGroupLayoutEntry {
            binding: 0,
            visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
            ty: wgpu::BindingType::Buffer {
                ty: wgpu::BufferBindingType::Uniform,
                has_dynamic_offset: false,
                min_binding_size: None,
            },
            count: None,
        }],
    });
    let light_bg = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("light-bg"),
        layout: &light_bg_layout,
        entries: &[wgpu::BindGroupEntry { binding: 0, resource: light_ub.as_entire_binding() }],
    });

    // Post-processing: bloom bind group layout and resources
    let post_bgl = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("post-bgl"),
        entries: &[
            wgpu::BindGroupLayoutEntry { // hdr color
                binding: 0,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } },
                count: None,
            },
            wgpu::BindGroupLayoutEntry { // sampler
                binding: 1,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                count: None,
            },
            // exposure params in post
            wgpu::BindGroupLayoutEntry {
                binding: 2,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer { ty: wgpu::BufferBindingType::Uniform, has_dynamic_offset: false, min_binding_size: None },
                count: None,
            },
            wgpu::BindGroupLayoutEntry { // bloom params
                binding: 3,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Buffer { ty: wgpu::BufferBindingType::Uniform, has_dynamic_offset: false, min_binding_size: None },
                count: None,
            },
        ],
    });
    let post_sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        label: Some("post-sampler"),
        address_mode_u: wgpu::AddressMode::ClampToEdge,
        address_mode_v: wgpu::AddressMode::ClampToEdge,
        address_mode_w: wgpu::AddressMode::ClampToEdge,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
        ..Default::default()
    });
    let bloom_init = BloomParams { threshold: 0.7, intensity: 0.6, _pad: [0.0; 2] };
    let bloom_ub = device.create_buffer_init(&wgpu::util::BufferInitDescriptor { label: Some("bloom-ub"), contents: bytemuck::bytes_of(&bloom_init), usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST });
    let post_bg = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("post-bg"),
        layout: &post_bgl,
        entries: &[
            // Bind full-mip HDR view for sampling in post
            wgpu::BindGroupEntry { binding: 0, resource: wgpu::BindingResource::TextureView(&hdr_view) },
            wgpu::BindGroupEntry { binding: 1, resource: wgpu::BindingResource::Sampler(&post_sampler) },
            wgpu::BindGroupEntry { binding: 2, resource: exposure_buf.as_entire_binding() },
            wgpu::BindGroupEntry { binding: 3, resource: bloom_ub.as_entire_binding() },
        ],
    });

    // Fullscreen post shader combining exposure-tonemapped HDR with thresholded bloom from mips
        const POST_SHADER: &str = r#"
struct VsOut { @builtin(position) pos: vec4<f32>, @location(0) uv: vec2<f32> };
@vertex fn vs(@builtin(vertex_index) vi: u32) -> VsOut {
    var out: VsOut;
    // Full-screen covering triangle
    var positions = array<vec2<f32>, 3>(
        vec2<f32>(-1.0, -1.0),
        vec2<f32>( 3.0, -1.0),
        vec2<f32>(-1.0,  3.0)
    );
    let xy = positions[vi];
    out.pos = vec4<f32>(xy, 0.0, 1.0);
    out.uv = vec2<f32>((xy.x + 1.0) * 0.5, 1.0 - (xy.y + 1.0) * 0.5);
    return out;
}
@group(0) @binding(0) var hdr_tex: texture_2d<f32>;
@group(0) @binding(1) var hdr_smp: sampler;
struct PostParams { exposure: f32, _pad: vec3<f32>, };
@group(0) @binding(2) var<uniform> post: PostParams;
struct Bloom { threshold: f32, intensity: f32, _pad: vec2<f32> };
@group(0) @binding(3) var<uniform> bloom: Bloom;
@fragment fn fs(in: VsOut) -> @location(0) vec4<f32> {
  // base color from hdr
    var base = textureSample(hdr_tex, hdr_smp, in.uv).rgb;
  // multi-mip bloom sampling
  var bloom_sum = vec3<f32>(0.0);
  var w = 0.0;
  let levels = 5;
  for (var i: i32 = 1; i <= levels; i = i + 1) {
    let lod = f32(i);
    let c = textureSampleLevel(hdr_tex, hdr_smp, in.uv, lod).rgb;
    let luma = dot(c, vec3<f32>(0.2126, 0.7152, 0.0722));
    let m = max(luma - bloom.threshold, 0.0);
    let val = c * (m / max(luma + 1e-4, 1e-4));
    let weight = 1.0 / (1.0 + f32(i));
    bloom_sum += val * weight; w += weight;
  }
  let bloom_col = bloom_sum / max(w, 1e-4) * bloom.intensity;
    var color = base + bloom_col;
    // Auto-exposure: estimate average scene luminance from a high mip level near 1x1
    // Unrolled taps to avoid dynamic indexing restrictions
    var logLumSum = 0.0;
    let lodProbe = 8.0; // large LOD; will clamp to highest mip available
    {
        let uv0 = clamp(in.uv + vec2<f32>(-0.25, -0.25), vec2<f32>(0.0), vec2<f32>(1.0));
        let c0 = textureSampleLevel(hdr_tex, hdr_smp, uv0, lodProbe).rgb;
        logLumSum = logLumSum + log(max(dot(c0, vec3<f32>(0.2126, 0.7152, 0.0722)), 1e-4));

        let uv1 = clamp(in.uv + vec2<f32>(0.0, -0.25), vec2<f32>(0.0), vec2<f32>(1.0));
        let c1 = textureSampleLevel(hdr_tex, hdr_smp, uv1, lodProbe).rgb;
        logLumSum = logLumSum + log(max(dot(c1, vec3<f32>(0.2126, 0.7152, 0.0722)), 1e-4));

        let uv2 = clamp(in.uv + vec2<f32>(0.25, -0.25), vec2<f32>(0.0), vec2<f32>(1.0));
        let c2 = textureSampleLevel(hdr_tex, hdr_smp, uv2, lodProbe).rgb;
        logLumSum = logLumSum + log(max(dot(c2, vec3<f32>(0.2126, 0.7152, 0.0722)), 1e-4));

        let uv3 = clamp(in.uv + vec2<f32>(-0.25, 0.0), vec2<f32>(0.0), vec2<f32>(1.0));
        let c3 = textureSampleLevel(hdr_tex, hdr_smp, uv3, lodProbe).rgb;
        logLumSum = logLumSum + log(max(dot(c3, vec3<f32>(0.2126, 0.7152, 0.0722)), 1e-4));

        let uv4 = clamp(in.uv + vec2<f32>(0.0, 0.0), vec2<f32>(0.0), vec2<f32>(1.0));
        let c4 = textureSampleLevel(hdr_tex, hdr_smp, uv4, lodProbe).rgb;
        logLumSum = logLumSum + log(max(dot(c4, vec3<f32>(0.2126, 0.7152, 0.0722)), 1e-4));

        let uv5 = clamp(in.uv + vec2<f32>(0.25, 0.0), vec2<f32>(0.0), vec2<f32>(1.0));
        let c5 = textureSampleLevel(hdr_tex, hdr_smp, uv5, lodProbe).rgb;
        logLumSum = logLumSum + log(max(dot(c5, vec3<f32>(0.2126, 0.7152, 0.0722)), 1e-4));

        let uv6 = clamp(in.uv + vec2<f32>(-0.25, 0.25), vec2<f32>(0.0), vec2<f32>(1.0));
        let c6 = textureSampleLevel(hdr_tex, hdr_smp, uv6, lodProbe).rgb;
        logLumSum = logLumSum + log(max(dot(c6, vec3<f32>(0.2126, 0.7152, 0.0722)), 1e-4));

        let uv7 = clamp(in.uv + vec2<f32>(0.0, 0.25), vec2<f32>(0.0), vec2<f32>(1.0));
        let c7 = textureSampleLevel(hdr_tex, hdr_smp, uv7, lodProbe).rgb;
        logLumSum = logLumSum + log(max(dot(c7, vec3<f32>(0.2126, 0.7152, 0.0722)), 1e-4));

        let uv8 = clamp(in.uv + vec2<f32>(0.25, 0.25), vec2<f32>(0.0), vec2<f32>(1.0));
        let c8 = textureSampleLevel(hdr_tex, hdr_smp, uv8, lodProbe).rgb;
        logLumSum = logLumSum + log(max(dot(c8, vec3<f32>(0.2126, 0.7152, 0.0722)), 1e-4));
    }
    let logAvg = logLumSum / 9.0;
    let avgLum = exp(logAvg);
    let targetGray = 0.18;
    let autoScale = clamp(targetGray / avgLum, 0.25, 4.0);

    // Apply manual exposure scaled by auto exposure factor, then tone map
    color = color * (post.exposure * autoScale);
    let aA = 2.51; let bA = 0.03; let cA = 2.43; let dA = 0.59; let eA = 0.14;
    let tone = clamp((color * (aA * color + bA)) / (color * (cA * color + dA) + eA), vec3<f32>(0.0), vec3<f32>(1.0));
    return vec4<f32>(tone, 1.0);
}
"#;
    let post_sm = device.create_shader_module(wgpu::ShaderModuleDescriptor { label: Some("post-sm"), source: wgpu::ShaderSource::Wgsl(Cow::Borrowed(POST_SHADER)) });
    let post_pl = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor { label: Some("post-pl"), bind_group_layouts: &[&post_bgl], push_constant_ranges: &[] });
    let post_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("post-pipeline"),
        layout: Some(&post_pl),
        vertex: wgpu::VertexState { module: &post_sm, entry_point: "vs", buffers: &[], compilation_options: wgpu::PipelineCompilationOptions::default() },
        fragment: Some(wgpu::FragmentState { module: &post_sm, entry_point: "fs", targets: &[Some(wgpu::ColorTargetState { format: surface_format, blend: Some(wgpu::BlendState::ALPHA_BLENDING), write_mask: wgpu::ColorWrites::ALL })], compilation_options: wgpu::PipelineCompilationOptions::default() }),
        primitive: wgpu::PrimitiveState::default(), depth_stencil: None, multisample: wgpu::MultisampleState::default(), multiview: None,
    });

    // Texture bind group layout (for PBR: albedo + normal + MRA + emissive)
    let texture_bind_group_layout =
        device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("pbr-textures"),
            entries: &[
                // binding 0: albedo texture
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        multisampled: false,
                        view_dimension: wgpu::TextureViewDimension::D2,
                        sample_type: wgpu::TextureSampleType::Float { filterable: true },
                    },
                    count: None,
                },
                // binding 1: albedo sampler
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                    count: None,
                },
                // binding 2: normal texture
                wgpu::BindGroupLayoutEntry {
                    binding: 2,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        multisampled: false,
                        view_dimension: wgpu::TextureViewDimension::D2,
                        sample_type: wgpu::TextureSampleType::Float { filterable: true },
                    },
                    count: None,
                },
                // binding 3: normal sampler
                wgpu::BindGroupLayoutEntry {
                    binding: 3,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                    count: None,
                },
                // binding 4: MRA (metallic in B, roughness in G, occlusion in R)
                wgpu::BindGroupLayoutEntry {
                    binding: 4,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        multisampled: false,
                        view_dimension: wgpu::TextureViewDimension::D2,
                        sample_type: wgpu::TextureSampleType::Float { filterable: true },
                    },
                    count: None,
                },
                // binding 5: MRA sampler
                wgpu::BindGroupLayoutEntry {
                    binding: 5,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                    count: None,
                },
                // binding 6: emissive texture
                wgpu::BindGroupLayoutEntry {
                    binding: 6,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        multisampled: false,
                        view_dimension: wgpu::TextureViewDimension::D2,
                        sample_type: wgpu::TextureSampleType::Float { filterable: true },
                    },
                    count: None,
                },
                // binding 7: emissive sampler
                wgpu::BindGroupLayoutEntry {
                    binding: 7,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                    count: None,
                },
                // Dirt set: albedo, normal, mra
                wgpu::BindGroupLayoutEntry { binding: 8, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                wgpu::BindGroupLayoutEntry { binding: 9, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                wgpu::BindGroupLayoutEntry { binding: 10, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                // Stone set
                wgpu::BindGroupLayoutEntry { binding: 11, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                wgpu::BindGroupLayoutEntry { binding: 12, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                wgpu::BindGroupLayoutEntry { binding: 13, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                // Sand set
                wgpu::BindGroupLayoutEntry { binding: 14, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                wgpu::BindGroupLayoutEntry { binding: 15, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                wgpu::BindGroupLayoutEntry { binding: 16, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                // Forest floor set
                wgpu::BindGroupLayoutEntry { binding: 17, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                wgpu::BindGroupLayoutEntry { binding: 18, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                wgpu::BindGroupLayoutEntry { binding: 19, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
            ],
        });

    // Shadow map layout: depth texture + comparison sampler
    let shadow_bg_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("shadow-layout"),
        entries: &[
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Texture {
                    multisampled: false,
                    view_dimension: wgpu::TextureViewDimension::D2,
                    sample_type: wgpu::TextureSampleType::Depth,
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 1,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Comparison),
                count: None,
            },
        ],
    });

    // Create shadow map resources
    let shadow_size = 2048u32;
    let shadow_tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("shadow-map"),
        size: wgpu::Extent3d { width: shadow_size, height: shadow_size, depth_or_array_layers: 1 },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Depth32Float,
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::TEXTURE_BINDING,
        view_formats: &[],
    });
    let shadow_view = shadow_tex.create_view(&wgpu::TextureViewDescriptor::default());
    let shadow_sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        label: Some("shadow-sampler"),
        address_mode_u: wgpu::AddressMode::ClampToEdge,
        address_mode_v: wgpu::AddressMode::ClampToEdge,
        address_mode_w: wgpu::AddressMode::ClampToEdge,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Nearest,
        compare: Some(wgpu::CompareFunction::LessEqual),
        ..Default::default()
    });
    let shadow_bg = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("shadow-bg"),
        layout: &shadow_bg_layout,
        entries: &[
            wgpu::BindGroupEntry { binding: 0, resource: wgpu::BindingResource::TextureView(&shadow_view) },
            wgpu::BindGroupEntry { binding: 1, resource: wgpu::BindingResource::Sampler(&shadow_sampler) },
        ],
    });

    // Try to load grass texture, fallback to default if not available
    let (ground_texture, ground_normal, ground_mra, ground_emissive, ground_bind_group,
         dirt_albedo, dirt_normal, dirt_mra,
         stone_albedo, stone_normal, stone_mra,
         sand_albedo, sand_normal, sand_mra,
         forest_albedo, forest_normal, forest_mra) =
    match load_texture_from_file(&device, &queue, &resolve_asset_path("grass.png")) {
            Ok(texture) => {
                // Try to load corresponding normal map
                let normal_texture = match load_texture_from_file(
                    &device,
                    &queue,
                    &resolve_asset_path("grass_n.png"),
                ) {
                    Ok(normal) => normal,
                    Err(_) => create_default_normal_texture(&device, &queue)?,
                };
                // Load MRA and emissive if present
                let mra_texture = match load_texture_from_file(
                    &device,
                    &queue,
                    &resolve_asset_path("grass_mra.png"),
                ) {
                    Ok(tex) => tex,
                    Err(_) => create_default_mra_texture(&device, &queue)?,
                };
                let emissive_texture = match load_texture_from_file(
                    &device,
                    &queue,
                    &resolve_asset_path("grass_e.png"),
                ) {
                    Ok(tex) => tex,
                    Err(_) => create_default_emissive_texture(&device, &queue)?,
                };

                // Load additional biome textures (with fallbacks)
                let dirt_albedo = load_texture_from_file(&device, &queue, &resolve_asset_path("dirt.png")).unwrap_or_else(|_| default_albedo_clone(&device, &queue, &texture).unwrap());
                let dirt_normal = load_texture_from_file(&device, &queue, &resolve_asset_path("dirt_n.png")).unwrap_or_else(|_| create_default_normal_texture(&device, &queue).unwrap());
                let dirt_mra = load_texture_from_file(&device, &queue, &resolve_asset_path("dirt_mra.png")).unwrap_or_else(|_| create_default_mra_texture(&device, &queue).unwrap());

                let stone_albedo = load_texture_from_file(&device, &queue, &resolve_asset_path("stone.png")).unwrap_or_else(|_| default_albedo_clone(&device, &queue, &texture).unwrap());
                let stone_normal = load_texture_from_file(&device, &queue, &resolve_asset_path("stone_n.png")).unwrap_or_else(|_| create_default_normal_texture(&device, &queue).unwrap());
                let stone_mra = load_texture_from_file(&device, &queue, &resolve_asset_path("stone_mra.png")).unwrap_or_else(|_| create_default_mra_texture(&device, &queue).unwrap());

                let sand_albedo = load_texture_from_file(&device, &queue, &resolve_asset_path("sand.png")).unwrap_or_else(|_| default_albedo_clone(&device, &queue, &texture).unwrap());
                let sand_normal = load_texture_from_file(&device, &queue, &resolve_asset_path("sand_n.png")).unwrap_or_else(|_| create_default_normal_texture(&device, &queue).unwrap());
                let sand_mra = load_texture_from_file(&device, &queue, &resolve_asset_path("sand_mra.png")).unwrap_or_else(|_| create_default_mra_texture(&device, &queue).unwrap());

                let forest_albedo = load_texture_from_file(&device, &queue, &resolve_asset_path("forest_floor.png")).unwrap_or_else(|_| default_albedo_clone(&device, &queue, &texture).unwrap());
                let forest_normal = load_texture_from_file(&device, &queue, &resolve_asset_path("forest_floor_n.png")).unwrap_or_else(|_| create_default_normal_texture(&device, &queue).unwrap());
                let forest_mra = load_texture_from_file(&device, &queue, &resolve_asset_path("forest_floor_mra.png")).unwrap_or_else(|_| create_default_mra_texture(&device, &queue).unwrap());

                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("ground-texture-bg"),
                    layout: &texture_bind_group_layout,
                    entries: &[
                        wgpu::BindGroupEntry {
                            binding: 0,
                            resource: wgpu::BindingResource::TextureView(&texture.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 1,
                            resource: wgpu::BindingResource::Sampler(&texture.sampler),
                        },
                        wgpu::BindGroupEntry {
                            binding: 2,
                            resource: wgpu::BindingResource::TextureView(&normal_texture.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 3,
                            resource: wgpu::BindingResource::Sampler(&normal_texture.sampler),
                        },
                        wgpu::BindGroupEntry {
                            binding: 4,
                            resource: wgpu::BindingResource::TextureView(&mra_texture.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 5,
                            resource: wgpu::BindingResource::Sampler(&mra_texture.sampler),
                        },
                        wgpu::BindGroupEntry {
                            binding: 6,
                            resource: wgpu::BindingResource::TextureView(&emissive_texture.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 7,
                            resource: wgpu::BindingResource::Sampler(&emissive_texture.sampler),
                        },
                        // Dirt
                        wgpu::BindGroupEntry { binding: 8, resource: wgpu::BindingResource::TextureView(&dirt_albedo.view) },
                        wgpu::BindGroupEntry { binding: 9, resource: wgpu::BindingResource::TextureView(&dirt_normal.view) },
                        wgpu::BindGroupEntry { binding: 10, resource: wgpu::BindingResource::TextureView(&dirt_mra.view) },
                        // Stone
                        wgpu::BindGroupEntry { binding: 11, resource: wgpu::BindingResource::TextureView(&stone_albedo.view) },
                        wgpu::BindGroupEntry { binding: 12, resource: wgpu::BindingResource::TextureView(&stone_normal.view) },
                        wgpu::BindGroupEntry { binding: 13, resource: wgpu::BindingResource::TextureView(&stone_mra.view) },
                        // Sand
                        wgpu::BindGroupEntry { binding: 14, resource: wgpu::BindingResource::TextureView(&sand_albedo.view) },
                        wgpu::BindGroupEntry { binding: 15, resource: wgpu::BindingResource::TextureView(&sand_normal.view) },
                        wgpu::BindGroupEntry { binding: 16, resource: wgpu::BindingResource::TextureView(&sand_mra.view) },
                        // Forest floor
                        wgpu::BindGroupEntry { binding: 17, resource: wgpu::BindingResource::TextureView(&forest_albedo.view) },
                        wgpu::BindGroupEntry { binding: 18, resource: wgpu::BindingResource::TextureView(&forest_normal.view) },
                        wgpu::BindGroupEntry { binding: 19, resource: wgpu::BindingResource::TextureView(&forest_mra.view) },
                    ],
                });
                (
                    Some(texture),
                    Some(normal_texture),
                    Some(mra_texture),
                    Some(emissive_texture),
                    Some(bind_group),
                    Some(dirt_albedo), Some(dirt_normal), Some(dirt_mra),
                    Some(stone_albedo), Some(stone_normal), Some(stone_mra),
                    Some(sand_albedo), Some(sand_normal), Some(sand_mra),
                    Some(forest_albedo), Some(forest_normal), Some(forest_mra),
                )
            }
            Err(_) => {
                // Create default textures as fallback
                let default_albedo = create_default_albedo_texture(&device, &queue)?;
                let default_normal = create_default_normal_texture(&device, &queue)?;
                let default_mra = create_default_mra_texture(&device, &queue)?;
                let default_emissive = create_default_emissive_texture(&device, &queue)?;

                // Fallbacks: we will reuse default textures directly in the bind group

                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("default-texture-bg"),
                    layout: &texture_bind_group_layout,
                    entries: &[
                        wgpu::BindGroupEntry {
                            binding: 0,
                            resource: wgpu::BindingResource::TextureView(&default_albedo.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 1,
                            resource: wgpu::BindingResource::Sampler(&default_albedo.sampler),
                        },
                        wgpu::BindGroupEntry {
                            binding: 2,
                            resource: wgpu::BindingResource::TextureView(&default_normal.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 3,
                            resource: wgpu::BindingResource::Sampler(&default_normal.sampler),
                        },
                        wgpu::BindGroupEntry {
                            binding: 4,
                            resource: wgpu::BindingResource::TextureView(&default_mra.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 5,
                            resource: wgpu::BindingResource::Sampler(&default_mra.sampler),
                        },
                        wgpu::BindGroupEntry {
                            binding: 6,
                            resource: wgpu::BindingResource::TextureView(&default_emissive.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 7,
                            resource: wgpu::BindingResource::Sampler(&default_emissive.sampler),
                        },
                        // Dirt (defaults)
                        wgpu::BindGroupEntry { binding: 8, resource: wgpu::BindingResource::TextureView(&default_albedo.view) },
                        wgpu::BindGroupEntry { binding: 9, resource: wgpu::BindingResource::TextureView(&default_normal.view) },
                        wgpu::BindGroupEntry { binding: 10, resource: wgpu::BindingResource::TextureView(&default_mra.view) },
                        // Stone (defaults)
                        wgpu::BindGroupEntry { binding: 11, resource: wgpu::BindingResource::TextureView(&default_albedo.view) },
                        wgpu::BindGroupEntry { binding: 12, resource: wgpu::BindingResource::TextureView(&default_normal.view) },
                        wgpu::BindGroupEntry { binding: 13, resource: wgpu::BindingResource::TextureView(&default_mra.view) },
                        // Sand (defaults)
                        wgpu::BindGroupEntry { binding: 14, resource: wgpu::BindingResource::TextureView(&default_albedo.view) },
                        wgpu::BindGroupEntry { binding: 15, resource: wgpu::BindingResource::TextureView(&default_normal.view) },
                        wgpu::BindGroupEntry { binding: 16, resource: wgpu::BindingResource::TextureView(&default_mra.view) },
                        // Forest (defaults)
                        wgpu::BindGroupEntry { binding: 17, resource: wgpu::BindingResource::TextureView(&default_albedo.view) },
                        wgpu::BindGroupEntry { binding: 18, resource: wgpu::BindingResource::TextureView(&default_normal.view) },
                        wgpu::BindGroupEntry { binding: 19, resource: wgpu::BindingResource::TextureView(&default_mra.view) },
                    ],
                });
                (
                    Some(default_albedo),
                    Some(default_normal),
                    Some(default_mra),
                    Some(default_emissive),
                    Some(bind_group),
                    None, None, None,
                    None, None, None,
                    None, None, None,
                    None, None, None,
                )
            }
        };

    // Instance buffer (increased size for enhanced environment objects)
    let max_instances = 200; // Increased from 100 to accommodate more objects
    let instance_vb = device.create_buffer(&wgpu::BufferDescriptor {
        label: Some("instance-buffer"),
        size: (std::mem::size_of::<InstanceRaw>() * max_instances) as u64,
        usage: wgpu::BufferUsages::VERTEX | wgpu::BufferUsages::COPY_DST,
        mapped_at_creation: false,
    });

    // Create pipeline with procedural shader
    // Create shadow pipeline
    let shadow_shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("shadow-shader"),
        source: wgpu::ShaderSource::Wgsl(Cow::Borrowed(SHADOW_SHADER)),
    });
    let shadow_pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("shadow-pipeline-layout"),
        bind_group_layouts: &[&light_bg_layout],
        push_constant_ranges: &[],
    });
    let shadow_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("shadow-pipeline"),
        layout: Some(&shadow_pipeline_layout),
        vertex: wgpu::VertexState {
            module: &shadow_shader,
            entry_point: "vs_shadow",
            buffers: &[
                wgpu::VertexBufferLayout {
                    array_stride: 3 * 4,
                    step_mode: wgpu::VertexStepMode::Vertex,
                    attributes: &[wgpu::VertexAttribute { format: wgpu::VertexFormat::Float32x3, offset: 0, shader_location: 0 }],
                },
                wgpu::VertexBufferLayout {
                    array_stride: std::mem::size_of::<InstanceRaw>() as u64,
                    step_mode: wgpu::VertexStepMode::Instance,
                    attributes: &[
                        wgpu::VertexAttribute { format: wgpu::VertexFormat::Float32x4, offset: 0, shader_location: 1 },
                        wgpu::VertexAttribute { format: wgpu::VertexFormat::Float32x4, offset: 16, shader_location: 2 },
                        wgpu::VertexAttribute { format: wgpu::VertexFormat::Float32x4, offset: 32, shader_location: 3 },
                        wgpu::VertexAttribute { format: wgpu::VertexFormat::Float32x4, offset: 48, shader_location: 4 },
                        wgpu::VertexAttribute { format: wgpu::VertexFormat::Float32x4, offset: 64, shader_location: 5 },
                        wgpu::VertexAttribute { format: wgpu::VertexFormat::Uint32, offset: 80, shader_location: 6 },
                    ],
                },
            ],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        },
        fragment: None,
        primitive: wgpu::PrimitiveState { topology: wgpu::PrimitiveTopology::TriangleList, front_face: wgpu::FrontFace::Ccw, cull_mode: Some(wgpu::Face::Back), ..Default::default() },
        depth_stencil: Some(wgpu::DepthStencilState {
            format: wgpu::TextureFormat::Depth32Float,
            depth_write_enabled: true,
            depth_compare: wgpu::CompareFunction::LessEqual,
            stencil: wgpu::StencilState::default(),
            bias: wgpu::DepthBiasState { constant: 2, slope_scale: 2.0, clamp: 0.0 },
        }),
        multisample: wgpu::MultisampleState { count: 1, mask: !0, alpha_to_coverage_enabled: false },
        multiview: None,
    });

    let shader_module = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("shader"),
        source: wgpu::ShaderSource::Wgsl(Cow::Borrowed(SHADER)),
    });
    let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("pipeline-layout"),
        bind_group_layouts: &[&camera_bg_layout, &texture_bind_group_layout, &shadow_bg_layout, &light_bg_layout],
        push_constant_ranges: &[],
    });

    let pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("pipeline"),
        layout: Some(&pipeline_layout),
        vertex: wgpu::VertexState {
            module: &shader_module,
            entry_point: "vs_main",
            buffers: &[
                wgpu::VertexBufferLayout {
                    array_stride: 3 * 4,
                    step_mode: wgpu::VertexStepMode::Vertex,
                    attributes: &[wgpu::VertexAttribute {
                        format: wgpu::VertexFormat::Float32x3,
                        offset: 0,
                        shader_location: 0,
                    }],
                },
                // instance transform (4 vec4 + color + mesh_type)
                wgpu::VertexBufferLayout {
                    array_stride: std::mem::size_of::<InstanceRaw>() as u64,
                    step_mode: wgpu::VertexStepMode::Instance,
                    attributes: &[
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 0,
                            shader_location: 1,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 16,
                            shader_location: 2,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 32,
                            shader_location: 3,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 48,
                            shader_location: 4,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 64,
                            shader_location: 5,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Uint32,
                            offset: 80,
                            shader_location: 6,
                        },
                    ],
                },
            ],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        },
        fragment: Some(wgpu::FragmentState {
            module: &shader_module,
            entry_point: "fs_main",
            targets: &[Some(wgpu::ColorTargetState {
                format: wgpu::TextureFormat::Rgba16Float,
                blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                write_mask: wgpu::ColorWrites::ALL,
            })],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        }),
        primitive: wgpu::PrimitiveState {
            topology: wgpu::PrimitiveTopology::TriangleList,
            strip_index_format: None,
            front_face: wgpu::FrontFace::Ccw,
            cull_mode: None, // Disable culling to allow skybox with inverted winding
            ..Default::default()
        },
        depth_stencil: Some(wgpu::DepthStencilState {
            format: DEPTH_FORMAT,
            depth_write_enabled: true,
            depth_compare: wgpu::CompareFunction::Less,
            stencil: wgpu::StencilState::default(),
            bias: wgpu::DepthBiasState::default(),
        }),
        multisample: wgpu::MultisampleState {
            count: msaa_samples,
            mask: !0,
            alpha_to_coverage_enabled: false,
        },
        multiview: None,
    });

    Ok(RenderStuff {
        surface,
        surface_cfg,
        device,
        queue,
        depth_view,
        pipeline,
        meshes,
        camera_ub,
        camera_bg,
        instance_vb,
        instance_count: 0, // Will be updated dynamically
        msaa_samples,
        msaa_color_view,
        hdr_tex,
        hdr_view,
    hdr_resolve_view,
        hdr_msaa_view,
        shadow_view,
        shadow_sampler,
        shadow_pipeline,
        shadow_size,
        light_ub,
        light_bg,
        shadow_bg,
        ground_texture,
        texture_bind_group_layout,
    exposure_buf,
        ground_bind_group,
        ground_normal,
        ground_mra,
        ground_emissive,
        // Additional biome textures
        dirt_albedo,
        dirt_normal,
        dirt_mra,
        stone_albedo,
        stone_normal,
        stone_mra,
        sand_albedo,
        sand_normal,
        sand_mra,
        forest_albedo,
        forest_normal,
        forest_mra,
        post_pipeline,
        post_bg,
        post_bgl,
        post_sampler,
        bloom_ub,
        debug_buf,
    })
}

fn create_depth(device: &wgpu::Device, width: u32, height: u32, samples: u32) -> wgpu::TextureView {
    let tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("depth"),
        size: wgpu::Extent3d {
            width,
            height,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: samples,
        dimension: wgpu::TextureDimension::D2,
        format: DEPTH_FORMAT,
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
        view_formats: &[],
    });
    tex.create_view(&wgpu::TextureViewDescriptor::default())
}

fn create_msaa_color(
    device: &wgpu::Device,
    format: wgpu::TextureFormat,
    width: u32,
    height: u32,
    samples: u32,
) -> wgpu::TextureView {
    let tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("msaa-color"),
        size: wgpu::Extent3d { width, height, depth_or_array_layers: 1 },
        mip_level_count: 1,
        sample_count: samples,
        dimension: wgpu::TextureDimension::D2,
        format,
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
        view_formats: &[],
    });
    tex.create_view(&wgpu::TextureViewDescriptor::default())
}

// ---------------- shader with procedural ground/sky ----------------

// Depth-only shadow map shader
const SHADOW_SHADER: &str = r#"
struct Camera { view_proj: mat4x4<f32> };

@group(0) @binding(0) var<uniform> u_light: Camera;

struct VsIn {
    @location(0) pos: vec3<f32>,
    @location(1) m0: vec4<f32>,
    @location(2) m1: vec4<f32>,
    @location(3) m2: vec4<f32>,
    @location(4) m3: vec4<f32>,
    @location(5) color: vec4<f32>,
    @location(6) mesh_type: u32,
};

struct VsOut { @builtin(position) pos: vec4<f32> };

@vertex
fn vs_shadow(in: VsIn) -> VsOut {
    var out: VsOut;
    // Skip skybox by pushing it out of clip space
    if (in.mesh_type == 4u) {
        out.pos = vec4<f32>(2.0, 2.0, 2.0, 1.0);
        return out;
    }
    let model = mat4x4<f32>(in.m0, in.m1, in.m2, in.m3);
    let world = model * vec4<f32>(in.pos, 1.0);
    out.pos = u_light.view_proj * world;
    return out;
}
"#;

const SHADER: &str = r#"
struct Camera { view_proj: mat4x4<f32> };
struct TimeUniform { time: f32, _padding: vec3<f32> };
struct DebugParams { debug_tint: u32, _pad: vec3<f32> };

@group(0) @binding(0) var<uniform> u_camera: Camera;
@group(0) @binding(4) var<uniform> u_debug: DebugParams;
struct PostParams { exposure: f32, _pad0: vec3<f32>, } // 16-byte aligned
@group(0) @binding(1) var<uniform> u_post: PostParams;
@group(1) @binding(0) var ground_texture: texture_2d<f32>;
@group(1) @binding(1) var ground_sampler: sampler;
@group(1) @binding(2) var ground_normal: texture_2d<f32>;
@group(1) @binding(3) var normal_sampler: sampler;
@group(1) @binding(4) var ground_mra: texture_2d<f32>; // R: AO, G: Roughness, B: Metallic
@group(1) @binding(5) var mra_sampler: sampler;
@group(1) @binding(6) var ground_emissive: texture_2d<f32>;
@group(1) @binding(7) var emissive_sampler: sampler;
// Additional biome textures (share samplers above)
@group(1) @binding(8) var dirt_albedo: texture_2d<f32>;
@group(1) @binding(9) var dirt_normal: texture_2d<f32>;
@group(1) @binding(10) var dirt_mra: texture_2d<f32>;
@group(1) @binding(11) var stone_albedo: texture_2d<f32>;
@group(1) @binding(12) var stone_normal: texture_2d<f32>;
@group(1) @binding(13) var stone_mra: texture_2d<f32>;
@group(1) @binding(14) var sand_albedo: texture_2d<f32>;
@group(1) @binding(15) var sand_normal: texture_2d<f32>;
@group(1) @binding(16) var sand_mra: texture_2d<f32>;
@group(1) @binding(17) var forest_albedo: texture_2d<f32>;
@group(1) @binding(18) var forest_normal: texture_2d<f32>;
@group(1) @binding(19) var forest_mra: texture_2d<f32>;

// Shadows
@group(2) @binding(0) var shadow_map: texture_depth_2d;
@group(2) @binding(1) var shadow_sampler: sampler_comparison;
@group(3) @binding(0) var<uniform> u_light: Camera;

// Note: Time uniform would be @group(2) @binding(0) in a full implementation
// For now, we'll use a constant or calculated time

// Helper struct and functions for triplanar sampling across texture sets
struct SampleSet { c: vec3<f32>, n: vec3<f32>, m: vec4<f32> };

// -----------------------------------------------------------------------------
// Noise utilities (hash, value noise, FBM) to avoid grid-aligned artifacts
// -----------------------------------------------------------------------------

fn hash21(p: vec2<f32>) -> f32 {
    let h = dot(p, vec2<f32>(127.1, 311.7));
    return fract(sin(h) * 43758.5453);
}

fn smooth2(t: vec2<f32>) -> vec2<f32> {
    // Quintic smoothing for C2 continuity
    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
}

fn value_noise2(p: vec2<f32>) -> f32 {
    let i = floor(p);
    let f = fract(p);
    let u = smooth2(f);

    let a = hash21(i + vec2<f32>(0.0, 0.0));
    let b = hash21(i + vec2<f32>(1.0, 0.0));
    let c = hash21(i + vec2<f32>(0.0, 1.0));
    let d = hash21(i + vec2<f32>(1.0, 1.0));

    let x1 = mix(a, b, u.x);
    let x2 = mix(c, d, u.x);
    return mix(x1, x2, u.y);
}

fn fbm2(p: vec2<f32>, octaves: i32, lacunarity: f32, gain: f32) -> f32 {
    var f = 0.0;
    var amp = 0.5;
    var freq = 1.0;
    var i = 0;
    loop {
        if (i >= octaves) { break; }
        f = f + value_noise2(p * freq) * amp;
        freq = freq * lacunarity;
        amp = amp * gain;
        i = i + 1;
    }
    return f;
}

fn fbm_ridge2(p: vec2<f32>, octaves: i32, lacunarity: f32, gain: f32) -> f32 {
    // Ridged multifractal using absolute value and inversion
    var f = 0.0;
    var amp = 0.5;
    var freq = 1.0;
    var i = 0;
    loop {
        if (i >= octaves) { break; }
        let n = value_noise2(p * freq);
        let r = 1.0 - abs(n * 2.0 - 1.0);
        f = f + r * amp;
        freq = freq * lacunarity;
        amp = amp * gain;
        i = i + 1;
    }
    return f;
}

fn noise_grad2(p: vec2<f32>) -> vec2<f32> {
    // Central differences gradient of value noise
    let e = 0.001;
    let dx = value_noise2(p + vec2<f32>(e, 0.0)) - value_noise2(p - vec2<f32>(e, 0.0));
    let dy = value_noise2(p + vec2<f32>(0.0, e)) - value_noise2(p - vec2<f32>(0.0, e));
    return vec2<f32>(dx, dy) / (2.0 * e);
}

// by biome (legacy)
fn sample_set(biome: i32, uv: vec2<f32>) -> SampleSet {
    var c = vec3<f32>(1.0,1.0,1.0);
    var n = vec3<f32>(0.5,0.5,1.0);
    var m = vec4<f32>(1.0,0.8,0.0,1.0);
    if (biome == 0) {
        c = textureSample(ground_texture, ground_sampler, uv).rgb;
        n = textureSample(ground_normal, normal_sampler, uv).rgb;
        m = textureSample(ground_mra, mra_sampler, uv);
    } else if (biome == 1) {
        c = textureSample(sand_albedo, ground_sampler, uv).rgb;
        n = textureSample(sand_normal, normal_sampler, uv).rgb;
        m = textureSample(sand_mra, mra_sampler, uv);
    } else {
        c = textureSample(forest_albedo, ground_sampler, uv).rgb;
        n = textureSample(forest_normal, normal_sampler, uv).rgb;
        m = textureSample(forest_mra, mra_sampler, uv);
    }
    return SampleSet(c, n, m);
}

// Percentage-closer filtering shadow test
fn sample_shadow(world_pos: vec3<f32>, N: vec3<f32>, L: vec3<f32>) -> f32 {
    let pos_light = u_light.view_proj * vec4<f32>(world_pos, 1.0);
    let proj = pos_light.xyz / pos_light.w;
    // Transform from NDC (-1..1) to 0..1
    let uv = proj.xy * 0.5 + vec2<f32>(0.5, 0.5);
    let depth = proj.z * 0.5 + 0.5;
    // Receiver bias to reduce acne (slightly angle-dependent)
    let bias = max(0.0005 * (1.0 - dot(N, L)), 0.0005);
    // Early out if outside light frustum
    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) { return 0.0; }

    // Rotated Poisson-disk PCF (16 taps)
    let texel = 1.0 / 2048.0; // matches shadow map size

    // Random rotation per-fragment derived from UV to reduce banding
    let rnd = fract(sin(dot(uv, vec2<f32>(12.9898, 78.233))) * 43758.5453);
    let angle = rnd * 6.2831853; // 2*pi
    let c = cos(angle);
    let s = sin(angle);
    let rot = mat2x2<f32>(vec2<f32>(c, s), vec2<f32>(-s, c)); // [ [c,-s],[s,c] ] in column form

    // Filter radius: slightly wider at grazing angles to hide stair-steps
    let radius = (2.0 + (1.0 - clamp(dot(N, L), 0.0, 1.0)) * 2.0) * texel;

    // Unrolled 16 Poisson taps to avoid dynamic array indexing restrictions
    var occl: f32 = 0.0;
    let p0 = rot * vec2<f32>(-0.94201624, -0.39906216);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p0 * radius * 2.5, depth - bias));
    let p1 = rot * vec2<f32>(0.94558609, -0.76890725);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p1 * radius * 2.5, depth - bias));
    let p2 = rot * vec2<f32>(-0.09418410, -0.92938870);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p2 * radius * 2.5, depth - bias));
    let p3 = rot * vec2<f32>(0.34495938, 0.29387760);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p3 * radius * 2.5, depth - bias));
    let p4 = rot * vec2<f32>(-0.91588581, 0.45771432);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p4 * radius * 2.5, depth - bias));
    let p5 = rot * vec2<f32>(-0.81544232, -0.87912464);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p5 * radius * 2.5, depth - bias));
    let p6 = rot * vec2<f32>(-0.38277543, 0.27676845);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p6 * radius * 2.5, depth - bias));
    let p7 = rot * vec2<f32>(0.97484398, 0.75648379);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p7 * radius * 2.5, depth - bias));
    let p8 = rot * vec2<f32>(0.44323325, -0.97511554);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p8 * radius * 2.5, depth - bias));
    let p9 = rot * vec2<f32>(0.53742981, -0.47373420);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p9 * radius * 2.5, depth - bias));
    let p10 = rot * vec2<f32>(-0.26496911, -0.41893023);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p10 * radius * 2.5, depth - bias));
    let p11 = rot * vec2<f32>(0.79197514, 0.19090188);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p11 * radius * 2.5, depth - bias));
    let p12 = rot * vec2<f32>(-0.24188840, 0.99706507);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p12 * radius * 2.5, depth - bias));
    let p13 = rot * vec2<f32>(-0.81409955, 0.91437590);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p13 * radius * 2.5, depth - bias));
    let p14 = rot * vec2<f32>(0.19984126, 0.78641367);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p14 * radius * 2.5, depth - bias));
    let p15 = rot * vec2<f32>(0.14383161, -0.14100790);
    occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + p15 * radius * 2.5, depth - bias));
    return occl / 16.0;
}

// by material: 0=grass,1=dirt,2=stone,3=sand,4=forest
fn sample_material(which: i32, uv: vec2<f32>) -> SampleSet {
    if (which == 0) { return SampleSet(textureSample(ground_texture, ground_sampler, uv).rgb,
                                       textureSample(ground_normal, normal_sampler, uv).rgb,
                                       textureSample(ground_mra, mra_sampler, uv)); }
    if (which == 1) { return SampleSet(textureSample(dirt_albedo, ground_sampler, uv).rgb,
                                       textureSample(dirt_normal, normal_sampler, uv).rgb,
                                       textureSample(dirt_mra, mra_sampler, uv)); }
    if (which == 2) { return SampleSet(textureSample(stone_albedo, ground_sampler, uv).rgb,
                                       textureSample(stone_normal, normal_sampler, uv).rgb,
                                       textureSample(stone_mra, mra_sampler, uv)); }
    if (which == 3) { return SampleSet(textureSample(sand_albedo, ground_sampler, uv).rgb,
                                       textureSample(sand_normal, normal_sampler, uv).rgb,
                                       textureSample(sand_mra, mra_sampler, uv)); }
    /* which == 4 */  return SampleSet(textureSample(forest_albedo, ground_sampler, uv).rgb,
                                       textureSample(forest_normal, normal_sampler, uv).rgb,
                                       textureSample(forest_mra, mra_sampler, uv));
}

// Blend three sample sets with enhanced triplanar weights and material transitions
fn blend3(a: SampleSet, b: SampleSet, c: SampleSet, w: vec3<f32>, transition_width: f32) -> SampleSet {
    // Enhanced weight calculation with smooth transitions
    let w_smooth = pow(w, vec3<f32>(transition_width));
    let wsum = max(w_smooth.x + w_smooth.y + w_smooth.z, 1e-4);
    let wnorm = w_smooth / wsum;

    // Colors are already sampled in linear space (sRGB textures are linearized by the sampler),
    // so blend directly in linear space without manual gamma conversions
    var col = a.c * wnorm.x + b.c * wnorm.y + c.c * wnorm.z;

    // Enhanced normal blending with proper tangent space interpolation
    let na = normalize(a.n * 2.0 - 1.0);
    let nb = normalize(b.n * 2.0 - 1.0);
    let nc = normalize(c.n * 2.0 - 1.0);
    
    // Use weighted average with angle-based weighting for better normal interpolation
    let n_blend = na * wnorm.x + nb * wnorm.y + nc * wnorm.z;
    let nr = normalize(n_blend) * 0.5 + 0.5;
    
    // MRA blending with material property preservation
    let mr = a.m * wnorm.x + b.m * wnorm.y + c.m * wnorm.z;
    
    // Optional debug tint to validate material sampling bindings
    if (u_debug.debug_tint == 1u) {
        let tint_a = vec3<f32>(1.0, 0.0, 0.0);
        let tint_b = vec3<f32>(0.0, 1.0, 0.0);
        let tint_c = vec3<f32>(0.0, 0.0, 1.0);
        col = col * 0.5 + (tint_a * wnorm.x + tint_b * wnorm.y + tint_c * wnorm.z) * 0.5;
    }
    return SampleSet(col, nr, mr);
}

// Enhanced triplanar sampling with detail mapping and micro-variation
fn sample_triplanar_enhanced(material_idx: i32, world_pos: vec3<f32>, normal: vec3<f32>, 
                           scale: f32, detail_scale: f32) -> SampleSet {
    // Base UV coordinates for triplanar mapping
    let uv_x = world_pos.zy * scale;
    let uv_y = world_pos.xz * scale; 
    let uv_z = world_pos.xy * scale;
    // Add micro-variation using FBM noise to break up tiling without grid artifacts
    let n_xy = fbm2(world_pos.xy * detail_scale * 0.15, 4, 2.0, 0.5);
    let n_yz = fbm2(world_pos.yz * detail_scale * 0.15, 4, 2.0, 0.5);
    let n_zx = fbm2(world_pos.zx * detail_scale * 0.15, 4, 2.0, 0.5);
    let v = 0.08; // variation strength
    let uv_x_varied = uv_x + vec2<f32>(n_yz, n_zx) * v;
    let uv_y_varied = uv_y + vec2<f32>(n_zx, n_xy) * v;
    let uv_z_varied = uv_z + vec2<f32>(n_xy, n_yz) * v;
    
    // Sample each axis with variation
    let sample_x = sample_material(material_idx, uv_x_varied);
    let sample_y = sample_material(material_idx, uv_y_varied);
    let sample_z = sample_material(material_idx, uv_z_varied);
    
    // Enhanced weight calculation based on normal with smooth transitions
    let n_abs = abs(normal);
    let weights = pow(n_abs, vec3<f32>(2.0)); // Slightly softer to reduce seams
    let weight_sum = max(weights.x + weights.y + weights.z, 1e-4);
    let wnorm = weights / weight_sum;
    
    // Use enhanced blending with smooth transitions
    return blend3(sample_x, sample_y, sample_z, wnorm, 2.0);
}

// Detail mapping function for micro-surface variation
fn apply_detail_mapping(base_color: vec3<f32>, world_pos: vec3<f32>, detail_scale: f32, detail_strength: f32) -> vec3<f32> {
    // FBM-based subtle albedo variation
    let p = world_pos.xz * detail_scale;
    let n = fbm2(p, 4, 2.0, 0.5);
    let variation = (n - 0.5) * 2.0; // [-1,1]
    let detail_color = base_color * (1.0 + variation * 0.06 * detail_strength);
    return detail_color;
}

// Perturb the surface normal using a simple high-frequency procedural pattern
fn perturb_normal(normal: vec3<f32>, world_pos: vec3<f32>, detail_scale: f32, strength: f32) -> vec3<f32> {
    // Use gradient of FBM to perturb normal in a stable, non-grid way
    let p = world_pos.xz * detail_scale;
    let g = noise_grad2(p);
    // Build tangent basis with up approximation; for terrain N is already close to up
    let T = normalize(cross(normal, vec3<f32>(0.0, 1.0, 0.0)) + vec3<f32>(1e-4, 0.0, 0.0));
    let B = normalize(cross(normal, T));
    let n_perturb = (T * g.x + B * g.y) * strength;
    return normalize(normal + n_perturb);
}

// Calculate tessellation factor based on distance and terrain features
fn calculate_tessellation_factor(world_pos: vec3<f32>, camera_pos: vec3<f32>, slope: f32) -> f32 {
    let distance = length(world_pos - camera_pos);
    
    // Base tessellation decreases with distance
    let distance_factor = clamp(1.0 - distance / 100.0, 0.1, 1.0);
    
    // Increase tessellation on steep slopes for better detail
    let slope_factor = 1.0 + slope * 2.0;
    
    // Combine factors with some noise for natural variation
    let noise_factor = sin(world_pos.x * 0.01) * cos(world_pos.z * 0.01) * 0.1 + 0.9;
    
    return distance_factor * slope_factor * noise_factor;
}

// Vertex inputs aligned with Rust vertex buffers:
// - location(0): position (vec3)
// - locations(1..4): model matrix columns (vec4)
// - location(5): color (vec4)
// - location(6): mesh_type (u32)
struct VsIn {
    @location(0) pos: vec3<f32>,
    @location(1) m0: vec4<f32>,
    @location(2) m1: vec4<f32>,
    @location(3) m2: vec4<f32>,
    @location(4) m3: vec4<f32>,
    @location(5) color: vec4<f32>,
    @location(6) mesh_type: u32,
};

struct VsOut {
  @builtin(position) pos: vec4<f32>,
  @location(0) color: vec4<f32>,
  @location(1) world_pos: vec3<f32>,
  @location(2) view_dir: vec3<f32>,
    @location(3) normal: vec3<f32>,
    @location(4) uv: vec2<f32>,
  @location(5) mesh_type: u32,
    @location(6) local_pos: vec3<f32>,
};

@vertex
fn vs_main(in: VsIn) -> VsOut {
    let model = mat4x4<f32>(in.m0, in.m1, in.m2, in.m3);
  var out: VsOut;
  let world = model * vec4<f32>(in.pos, 1.0);
  
  // Special handling for skybox (mesh_type 4) - position at far plane
  if (in.mesh_type == 4u) {
    // For skybox, apply model transform then scale down the large vertices
    let scaled_vertex = vec4<f32>(in.pos * 0.5, 1.0); // Larger skybox for better coverage  
    let world_skybox = model * scaled_vertex; // Apply model transform (camera translation)
    out.pos = u_camera.view_proj * world_skybox;
    // Ensure skybox is always at far plane
    out.pos.z = out.pos.w * 0.999; // At far plane
    out.world_pos = world_skybox.xyz;
    out.local_pos = in.pos;
    
    // For skybox, we use position as texture coordinates
    let pos_normalized = normalize(in.pos);
    out.uv = vec2<f32>(
      0.5 + atan2(pos_normalized.z, pos_normalized.x) / (2.0 * 3.14159),
      0.5 - asin(pos_normalized.y) / 3.14159
    );
  } else {
    out.pos = u_camera.view_proj * world;
    out.world_pos = world.xyz;
        // Derive UVs procedurally from world position (no per-vertex UVs provided)
        let scale = 10.0;
        out.uv = vec2<f32>(world.x / scale, world.z / scale);
      out.local_pos = in.pos;
  }
  
    // Default normal (up). Real meshes should provide normals; this keeps lighting reasonable.
    out.normal = vec3<f32>(0.0, 1.0, 0.0);
  
  out.color = in.color;
  out.mesh_type = in.mesh_type;
  
  // Calculate view direction for sky effects
  let camera_pos = vec3<f32>(0.0, 5.0, 0.0); // Better approximation for typical camera height
  out.view_dir = normalize(world.xyz - camera_pos);
  
  return out;
}

// Enhanced sky color function - generates biome-appropriate sky with atmospheric effects
fn sky_color(direction: vec3<f32>, time: f32) -> vec3<f32> {
    let dir = normalize(direction);
    let y = clamp(dir.y, -1.0, 1.0);
    // Stable daytime blue gradient
    let horizon = vec3<f32>(0.75, 0.85, 1.0);
    let zenith = vec3<f32>(0.15, 0.45, 0.9);
    let t = pow(clamp((y + 1.0) * 0.5, 0.0, 1.0), 0.6);
    let base = mix(horizon, zenith, t);
    // Soft moving clouds
    let n = sin(dir.x * 5.0 + time * 0.2) * cos(dir.z * 4.0 + time * 0.15);
    let clouds = clamp(n, 0.0, 1.0) * 0.12;
    return base + vec3<f32>(clouds, clouds, clouds);
}


// Enhanced water rendering for rivers and lakes
fn get_water_level(world_pos: vec2<f32>, time: f32) -> f32 {
  let wave_scale = 0.5;
  let wave_time = time * 2.0;
  let wave_pos = world_pos * wave_scale + vec2<f32>(wave_time * 0.3, wave_time * 0.5);
  
  // Water surface animation
  let wave1 = sin(wave_pos.x * 4.0) * cos(wave_pos.y * 3.0) * 0.1;
  let wave2 = sin(wave_pos.x * 8.0 + 1.0) * cos(wave_pos.y * 6.0 + 1.5) * 0.05;
  
  return -1.8 + wave1 + wave2; // Base water level with waves
}

// Determine biome type based on world position - FIXED: More consistent biome regions
fn get_biome_type(world_pos: vec2<f32>) -> i32 {
    let biome_scale = 0.01;
    let biome_pos = world_pos * biome_scale;
    // Smooth FBM determines regions; thresholds split into 3 biomes
    let n = fbm2(biome_pos, 5, 2.0, 0.5) * 2.0 - 1.0; // [-1,1]
    if (n > 0.25) {
        return 1; // Desert
    } else if (n < -0.25) {
        return 2; // Dense Forest
    } else {
        return 0; // Grassland
    }
}

// Generate biome-specific terrain height with enhanced variation
fn get_biome_terrain_height(world_pos: vec2<f32>, biome_type: i32) -> f32 {
    // Base FBM terrain: smooth features with octave detail
    let p = world_pos * 0.01;
    let base = (fbm2(p, 5, 2.0, 0.5) * 2.0 - 1.0) * 3.5; // [-3.5,3.5]
    let detail = (fbm2(p * 3.0, 3, 2.2, 0.5) - 0.5) * 1.5;
    var h = base + detail;

    if (biome_type == 0) { // Grassland - rolling hills with river valleys
        // River mask via ridge FBM to carve shallow valleys
        let river = fbm_ridge2(p * 0.9, 3, 2.0, 0.6);
        let valleys = (river - 0.6) * 6.0; // negative mostly
        h = h + clamp(valleys, -3.5, 0.0);
        return h;

    } else if (biome_type == 1) { // Desert - dunes and mesas
        // Dunes via directional ridged noise along wind axis
        let wind_dir = normalize(vec2<f32>(0.8, 0.6));
        let d = dot(p * 6.0, wind_dir);
        let dunes = (fbm_ridge2(vec2<f32>(d, d * 0.3), 4, 2.0, 0.55) - 0.5) * 3.0;
        // Mesas via thresholded ridge noise
        let mesas = step(0.7, fbm_ridge2(p * 0.7, 4, 2.0, 0.5)) * 6.0;
        h = h + dunes + mesas;
        return h;

    } else if (biome_type == 2) { // Dense Forest - softer undulations with mounds
        let soft = fbm2(p * 0.7, 4, 2.0, 0.5) * 2.0 - 1.0;
        let mounds = step(0.65, fbm2(p * 1.3 + 12.3, 4, 2.0, 0.5)) * 1.6;
        h = h * 0.9 + soft * 2.2 + mounds;
        return h;

    } else {
        return h;
    }
}

@fragment
fn fs_main(in: VsOut) -> @location(0) vec4<f32> {
  var col = in.color.rgb;
  let time = 100.0; // TODO: Pass actual time as uniform
  
  // Mesh-specific rendering based on mesh type
        if (in.mesh_type == 1u) { // Tree (PBR triplanar using existing materials)
                let ws_pos = in.world_pos;
                let V = normalize(-in.view_dir);
                let sun_angle = time * 0.1;
                let L = normalize(vec3<f32>(cos(sun_angle) * 0.8, max(sin(sun_angle) * 0.8, 0.2), sin(sun_angle * 0.3) * 0.4));
        
                // Use local Y to separate trunk vs canopy
                let is_trunk = in.local_pos.y < 0.6;
            var base_sample: SampleSet = sample_triplanar_enhanced(1, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.5, 8.0);
                if (is_trunk) {
                        // Trunk: use dirt color with stone normal characteristics
                let dirt = sample_triplanar_enhanced(1, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.5, 8.0);
                        let stone = sample_triplanar_enhanced(2, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.5, 8.0);
                        base_sample.c = mix(dirt.c, dirt.c * vec3<f32>(0.55, 0.45, 0.35), 0.4);
                        base_sample.n = stone.n;
                        base_sample.m = dirt.m; // use dirt MRA
                } else {
                        // Leaves: use forest floor material as proxy leaves
                        base_sample = sample_triplanar_enhanced(4, ws_pos, vec3<f32>(0.0,1.0,0.0), 1.8, 10.0);
                        // Slightly boost saturation/green
                        base_sample.c = base_sample.c * vec3<f32>(0.9, 1.15, 0.9);
                        // Make rougher, more diffuse
                        base_sample.m.g = clamp(base_sample.m.g + 0.15, 0.0, 1.0);
                }
                // PBR lighting similar to terrain
                let N = normalize(base_sample.n * 2.0 - 1.0);
                let H = normalize(L + V);
                let ao = base_sample.m.r;
                let roughness = clamp(base_sample.m.g, 0.08, 0.98);
                let metallic = clamp(base_sample.m.b * 0.2, 0.0, 0.2);
                let base_color = base_sample.c;
                let ior = mix(1.3, 2.0, metallic);
                let F0 = pow((ior - 1.0) / (ior + 1.0), 2.0);
                let F0_vec = mix(vec3<f32>(F0, F0, F0), base_color, metallic);
                let F = F0_vec + (vec3<f32>(1.0) - F0_vec) * pow(1.0 - clamp(dot(H, V), 0.0, 1.0), 5.0);
                let a = roughness * roughness; let a2 = a * a;
                let NdotH = max(dot(N, H), 0.0); let NdotH2 = NdotH * NdotH;
                let denom = (NdotH2 * (a2 - 1.0) + 1.0);
                let D = a2 / (3.14159 * denom * denom + 1e-5);
                let NdotV = max(dot(N, V), 0.0); let NdotL = max(dot(N, L), 0.0);
                let k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
                let Gv = NdotV / (NdotV * (1.0 - k) + k + 1e-5);
                let Gl = NdotL / (NdotL * (1.0 - k) + k + 1e-5);
                let G_geom = Gv * Gl;
                let kd = (vec3<f32>(1.0) - F) * (1.0 - metallic);
                let diffuse = kd * base_color / 3.14159;
                let specular = (F * D * G_geom) / max(4.0 * NdotV * NdotL + 1e-5, 1e-5);
                let sky_ambient = sky_color(normalize(in.world_pos), time) * 0.35;
                let enhanced_ao = pow(ao, 0.85);
                let ambient = base_color * enhanced_ao * 0.25 + sky_ambient * enhanced_ao;
                let shadow = sample_shadow(in.world_pos, N, L);
                col = ambient + (diffuse + specular) * NdotL * (1.0 - shadow);
                // Output linear color; surface is sRGB so conversion happens on write
                return vec4<f32>(col, 1.0);
    }
        else if (in.mesh_type == 2u) { // House/Structure (walls vs roof)
                let ws_pos = in.world_pos;
                let V = normalize(-in.view_dir);
                let sun_angle = time * 0.1;
                let L = normalize(vec3<f32>(cos(sun_angle) * 0.8, max(sin(sun_angle) * 0.8, 0.2), sin(sun_angle * 0.3) * 0.4));

                // Separate walls (lower) and roof (upper) by local Y
                let is_roof = in.local_pos.y > 0.6;
                var base_sample: SampleSet;
                if (is_roof) {
                        // Roof: use sand material tinted
                        base_sample = sample_triplanar_enhanced(3, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.2, 8.0);
                        base_sample.c = base_sample.c * vec3<f32>(1.0, 0.95, 0.85);
                } else {
                        // Walls: use stone material
                        base_sample = sample_triplanar_enhanced(2, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.0, 8.0);
                }
                // PBR shading
                let N = normalize(base_sample.n * 2.0 - 1.0);
                let H = normalize(L + V);
                let ao = base_sample.m.r;
                let roughness = clamp(base_sample.m.g, 0.12, 0.98);
                let metallic = clamp(base_sample.m.b * 0.2, 0.0, 0.2);
                let base_color = base_sample.c;
                let ior = mix(1.3, 2.0, metallic);
                let F0 = pow((ior - 1.0) / (ior + 1.0), 2.0);
                let F0_vec = mix(vec3<f32>(F0, F0, F0), base_color, metallic);
                let F = F0_vec + (vec3<f32>(1.0) - F0_vec) * pow(1.0 - clamp(dot(H, V), 0.0, 1.0), 5.0);
                let a = roughness * roughness; let a2 = a * a;
                let NdotH = max(dot(N, H), 0.0); let NdotH2 = NdotH * NdotH;
                let denom = (NdotH2 * (a2 - 1.0) + 1.0);
                let D = a2 / (3.14159 * denom * denom + 1e-5);
                let NdotV = max(dot(N, V), 0.0); let NdotL = max(dot(N, L), 0.0);
                let k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
                let Gv = NdotV / (NdotV * (1.0 - k) + k + 1e-5);
                let Gl = NdotL / (NdotL * (1.0 - k) + k + 1e-5);
                let G_geom = Gv * Gl;
                let kd = (vec3<f32>(1.0) - F) * (1.0 - metallic);
                let diffuse = kd * base_color / 3.14159;
                let specular = (F * D * G_geom) / max(4.0 * NdotV * NdotL + 1e-5, 1e-5);
                let sky_ambient = sky_color(normalize(in.world_pos), time) * 0.3;
                let enhanced_ao = pow(ao, 0.85);
                let ambient = base_color * enhanced_ao * 0.25 + sky_ambient * enhanced_ao;
                let shadow = sample_shadow(in.world_pos, N, L);
                col = ambient + (diffuse + specular) * NdotL * (1.0 - shadow);
                return vec4<f32>(col, 1.0);
    }
        else if (in.mesh_type == 3u) { // Character - simple PBR triplanar with tint
                let ws_pos = in.world_pos;
                let V = normalize(-in.view_dir);
                let sun_angle = time * 0.1;
                let L = normalize(vec3<f32>(cos(sun_angle) * 0.8, max(sin(sun_angle) * 0.8, 0.2), sin(sun_angle * 0.3) * 0.4));
                // Use dirt as baseline material, tinted by instance color
                var base_sample: SampleSet = sample_triplanar_enhanced(1, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.2, 9.0);
                base_sample.c = clamp(base_sample.c * in.color.rgb, vec3<f32>(0.0), vec3<f32>(1.0));
                // PBR shading
                let N = normalize(base_sample.n * 2.0 - 1.0);
                let H = normalize(L + V);
                let ao = base_sample.m.r;
                let roughness = clamp(base_sample.m.g, 0.2, 0.95);
                let metallic = clamp(base_sample.m.b * 0.1, 0.0, 0.15);
                let base_color = base_sample.c;
                let ior = mix(1.3, 2.0, metallic);
                let F0 = pow((ior - 1.0) / (ior + 1.0), 2.0);
                let F0_vec = mix(vec3<f32>(F0, F0, F0), base_color, metallic);
                let F = F0_vec + (vec3<f32>(1.0) - F0_vec) * pow(1.0 - clamp(dot(H, V), 0.0, 1.0), 5.0);
                let a = roughness * roughness; let a2 = a * a;
                let NdotH = max(dot(N, H), 0.0); let NdotH2 = NdotH * NdotH;
                let denom = (NdotH2 * (a2 - 1.0) + 1.0);
                let D = a2 / (3.14159 * denom * denom + 1e-5);
                let NdotV = max(dot(N, V), 0.0); let NdotL = max(dot(N, L), 0.0);
                let k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
                let Gv = NdotV / (NdotV * (1.0 - k) + k + 1e-5);
                let Gl = NdotL / (NdotL * (1.0 - k) + k + 1e-5);
                let G_geom = Gv * Gl;
                let kd = (vec3<f32>(1.0) - F) * (1.0 - metallic);
                let diffuse = kd * base_color / 3.14159;
                let specular = (F * D * G_geom) / max(4.0 * NdotV * NdotL + 1e-5, 1e-5);
                let sky_ambient = sky_color(normalize(in.world_pos), time) * 0.25;
                let enhanced_ao = pow(ao, 0.85);
                let ambient = base_color * enhanced_ao * 0.25 + sky_ambient * enhanced_ao;
                let shadow = sample_shadow(in.world_pos, N, L);
                col = ambient + (diffuse + specular) * NdotL * (1.0 - shadow);
                return vec4<f32>(col, 1.0);
    }
  else if (in.mesh_type == 4u) { // Skybox
    // Use procedural sky color based on view direction
    col = sky_color(in.view_dir, time);
    return vec4<f32>(col, 1.0);
  }
  
    // For ground or other unspecified mesh types, use PBR-ish terrain rendering
  // Determine biome type for this world position
  let biome_type = get_biome_type(in.world_pos.xz);
  
  // Enhanced ground rendering with biome-specific terrain
  let ground_y = -2.0;
  let terrain_height = get_biome_terrain_height(in.world_pos.xz, biome_type);
  let water_level = get_water_level(in.world_pos.xz, time);
  let terrain_surface = ground_y + terrain_height;
  let dist_to_terrain = abs(in.world_pos.y - terrain_surface);
  let dist_to_water = abs(in.world_pos.y - water_level);
  
  // Check if we're rendering the terrain surface
  if (dist_to_terrain < 0.8 || (in.mesh_type == 0u && in.world_pos.y < ground_y + 1.0)) {
        // Enhanced triplanar sampling with biome-specific scales and detail mapping
        let ws_pos = in.world_pos;
        let base_scale = 2.0;
        let detail_scale = 8.0;
        
        // Biome-specific texture scaling for more realistic material distribution
        var biome_scale = base_scale;
        if (biome_type == 1) { biome_scale = base_scale * 1.2; } // Desert - slightly larger scale
        else if (biome_type == 2) { biome_scale = base_scale * 0.9; } // Forest - slightly smaller scale
        
        // Enhanced surface normal calculation with better height gradients
        let eps = 0.3;
        let hC = terrain_height;
        let hL = get_biome_terrain_height((ws_pos.xz + vec2<f32>(-eps, 0.0)), biome_type);
        let hR = get_biome_terrain_height((ws_pos.xz + vec2<f32>( eps, 0.0)), biome_type);
        let hD = get_biome_terrain_height((ws_pos.xz + vec2<f32>( 0.0,-eps)), biome_type);
        let hU = get_biome_terrain_height((ws_pos.xz + vec2<f32>( 0.0, eps)), biome_type);
        let dx = (hR - hL) / (2.0 * eps);
        let dz = (hU - hD) / (2.0 * eps);
        let n_world = normalize(vec3<f32>(-dx, 1.0, -dz));

        // Advanced material weight calculation with multiple influencing factors
        let slope = clamp(1.0 - n_world.y, 0.0, 1.0);
        let height_factor = clamp((hC + 2.0) / 4.0, 0.0, 1.0); // Normalized height factor
        let moisture_factor = sin(ws_pos.x * 0.01) * cos(ws_pos.z * 0.008) * 0.5 + 0.5; // Pseudo-moisture
        
        // Base material weights with biome-specific logic
        var w_grass = 0.0;
        var w_dirt = 0.0;
        var w_stone = 0.0;
        var w_sand = 0.0;
        var w_forest = 0.0;
        
        if (biome_type == 0) { // Grassland
            // Grass dominates low slopes and mid elevations
            w_grass = (1.0 - slope) * smoothstep(0.0, 0.6, height_factor) * (1.0 - moisture_factor * 0.3);
            // Dirt appears on steeper slopes and drier areas
            w_dirt = slope * 0.4 + moisture_factor * 0.2;
            // Stone for rocky outcrops
            w_stone = smoothstep(0.3, 0.8, slope) * 0.6;
            
        } else if (biome_type == 1) { // Desert
            // Sand dominates with some variation
            w_sand = 0.7 * (1.0 - smoothstep(0.4, 0.9, slope));
            // Stone for rocky areas and steep slopes
            w_stone = smoothstep(0.2, 0.7, slope) * 0.8;
            // Dirt in transitional areas
            w_dirt = 0.2 * (1.0 - slope) * moisture_factor;
            
        } else if (biome_type == 2) { // Forest
            // Forest floor dominates with organic materials
            w_forest = 0.6 * (1.0 - slope) * smoothstep(0.0, 0.7, height_factor);
            // Grass in clearings
            w_grass = 0.3 * (1.0 - slope) * (1.0 - smoothstep(0.3, 0.8, height_factor));
            // Dirt on slopes
            w_dirt = slope * 0.4;
            // Stone for rocky areas
            w_stone = smoothstep(0.5, 1.0, slope) * 0.5;
        }
        
        // Normalize weights to ensure they sum to 1
        var total_weight = w_grass + w_dirt + w_stone + w_sand + w_forest;
        if (total_weight < 0.1) {
            // Fallback to ensure we always have some material
            w_grass = 0.5;
            w_dirt = 0.3;
            w_stone = 0.2;
            total_weight = 1.0;
        }
        w_grass /= total_weight;
        w_dirt /= total_weight;
        w_stone /= total_weight;
        w_sand /= total_weight;
        w_forest /= total_weight;

        // Enhanced triplanar sampling for each material with detail mapping
        let grass_sample = sample_triplanar_enhanced(0, ws_pos, n_world, biome_scale, detail_scale);
        let dirt_sample = sample_triplanar_enhanced(1, ws_pos, n_world, biome_scale, detail_scale);
        let stone_sample = sample_triplanar_enhanced(2, ws_pos, n_world, biome_scale, detail_scale);
        let sand_sample = sample_triplanar_enhanced(3, ws_pos, n_world, biome_scale, detail_scale);
        let forest_sample = sample_triplanar_enhanced(4, ws_pos, n_world, biome_scale, detail_scale);

        // Combine materials with enhanced blending
        var base_color = grass_sample.c * w_grass + 
                        dirt_sample.c * w_dirt + 
                        stone_sample.c * w_stone + 
                        sand_sample.c * w_sand + 
                        forest_sample.c * w_forest;
        
        var mra = grass_sample.m * w_grass + 
                 dirt_sample.m * w_dirt + 
                 stone_sample.m * w_stone + 
                 sand_sample.m * w_sand + 
                 forest_sample.m * w_forest;
        
        // Enhanced normal blending with proper interpolation
        var normal_blend = (grass_sample.n * 2.0 - 1.0) * w_grass +
                          (dirt_sample.n * 2.0 - 1.0) * w_dirt +
                          (stone_sample.n * 2.0 - 1.0) * w_stone +
                          (sand_sample.n * 2.0 - 1.0) * w_sand +
                          (forest_sample.n * 2.0 - 1.0) * w_forest;
        var normal = normalize(normal_blend);

    // Calculate tessellation factor for geometry detail
        let tessellation_factor = calculate_tessellation_factor(ws_pos, vec3<f32>(0.0, 5.0, 0.0), slope);
        
        // Use tessellation factor to modulate detail mapping strength
    let detail_strength = 0.6; // Base strength for micro detail mapping
    let adaptive_detail_strength = detail_strength * tessellation_factor;
        base_color = apply_detail_mapping(base_color, ws_pos, detail_scale, adaptive_detail_strength);
        
        // Apply normal perturbation with adaptive strength
        let adaptive_normal_strength = 0.1 * tessellation_factor;
        normal = perturb_normal(normal, ws_pos, detail_scale * 2.0, adaptive_normal_strength);

        let ao = mra.r; // ambient occlusion
        let roughness = clamp(mra.g, 0.08, 0.95);
        let metallic = clamp(mra.b, 0.0, 0.2);
        let emissive = vec3<f32>(0.0); // disable emissive for terrain by default
    
    // Biome-specific terrain texturing
        // Note: Removed large flat-color biome overlays; rely on layered PBR materials above
        // Enhanced PBR lighting with improved Cook-Torrance BRDF
        let V = normalize(-in.view_dir);
        let N = normalize(normal);
        let sun_angle = time * 0.1;
        let L = normalize(vec3<f32>(cos(sun_angle) * 0.8, max(sin(sun_angle) * 0.8, 0.2), sin(sun_angle * 0.3) * 0.4));
        let H = normalize(L + V);

        // Enhanced Fresnel with realistic IOR values based on material
        let ior = mix(1.3, 2.5, metallic); // Vary IOR based on metallic content
        let F0 = pow((ior - 1.0) / (ior + 1.0), 2.0);
        let F0_vec = mix(vec3<f32>(F0, F0, F0), base_color, metallic);
        let F = F0_vec + (vec3<f32>(1.0, 1.0, 1.0) - F0_vec) * pow(1.0 - clamp(dot(H, V), 0.0, 1.0), 5.0);
        
        // Improved Normal Distribution Function (GGX)
        let a = roughness * roughness;
        let a2 = a * a;
        let NdotH = max(dot(N, H), 0.0);
        let NdotH2 = NdotH * NdotH;
        let denom = (NdotH2 * (a2 - 1.0) + 1.0);
        let D = a2 / (3.14159 * denom * denom + 1e-5);
        
        // Enhanced Geometry Smith with correlated masking-shadowing
        let NdotV = max(dot(N, V), 0.0);
        let NdotL = max(dot(N, L), 0.0);
        let k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
        let Gv = NdotV / (NdotV * (1.0 - k) + k + 1e-5);
        let Gl = NdotL / (NdotL * (1.0 - k) + k + 1e-5);
        let G_geom = Gv * Gl;

        // Enhanced diffuse with subsurface scattering for organic materials
        let kd = (vec3<f32>(1.0, 1.0, 1.0) - F) * (1.0 - metallic);
        
        // Add subsurface scattering approximation for materials like grass and soil
        let subsurface_factor = 0.15 * (1.0 - roughness) * (1.0 - metallic) * ao;
        let subsurface = subsurface_factor * base_color * max(dot(N, L), 0.0) * 0.5;
        
        let diffuse = kd * base_color / 3.14159 + subsurface;
        let specular = (F * D * G_geom) / max(4.0 * NdotV * NdotL + 1e-5, 1e-5);
        
        // Enhanced ambient lighting with sky contribution and improved AO
        let sky_ambient = sky_color(normalize(in.world_pos), time) * 0.4;
        let enhanced_ao = pow(ao, 0.8); // Enhance AO contrast
        let ambient = base_color * enhanced_ao * 0.3 + sky_ambient * enhanced_ao;
        
        let shadow = sample_shadow(in.world_pos, N, L);
        var color = ambient + (diffuse + specular) * NdotL * (1.0 - shadow) + emissive;

    // Remove crosshatch-like overlay modulation; rely on material detail mapping above

        // Exponential height fog with simple Rayleigh/Mie approximation (apply pre-tone-map)
        let cam_height = 5.0; // TODO: pass actual camera height
        let height_falloff = 0.02;
        let base_density = 0.02;
        let view_dir = normalize(in.view_dir);
        let distance_view = length(in.world_pos - vec3<f32>(0.0, cam_height, 0.0));
        let altitude = clamp(in.world_pos.y, -50.0, 500.0);
        let height_term = exp(-height_falloff * (altitude - cam_height));
        let fog_amount = 1.0 - exp(-base_density * height_term * distance_view);
        let cosTheta = clamp(dot(-view_dir, L), -1.0, 1.0);
        let rayleigh_phase = 0.75 * (1.0 + cosTheta * cosTheta);
        let mie_g = 0.5;
        let mie_phase = 1.0 / pow(1.0 + mie_g * mie_g - 2.0 * mie_g * cosTheta, 1.5);
        let fog_sky = sky_color(normalize(in.world_pos), time);
        let fog_color = fog_sky * 0.6 * rayleigh_phase + vec3<f32>(0.9, 0.9, 0.85) * 0.05 * mie_phase;
        color = mix(color, fog_color, clamp(fog_amount, 0.0, 1.0));

        // Leave color in linear HDR here; post pass will apply exposure + tone mapping
        col = color;
        // Atmospheric perspective now handled by height fog above (pre-tonemap)
    
  } else if (dist_to_water < 0.3 && terrain_height < -0.5) {
    // Water rendering for rivers and lakes
    let water_color = vec3<f32>(0.1, 0.3, 0.6);
    let wave_distortion = sin(in.world_pos.x * 2.0 + time) * cos(in.world_pos.z * 1.8 + time * 1.2) * 0.05;
    let water_surface = water_color + vec3<f32>(wave_distortion, wave_distortion * 0.5, -wave_distortion * 0.3);
    
    // Reflection and transparency effects
    let view_angle = abs(dot(normalize(in.view_dir), vec3<f32>(0.0, 1.0, 0.0)));
    let reflection_factor = 1.0 - view_angle;
    let sky = sky_color(reflect(in.view_dir, vec3<f32>(0.0, 1.0, 0.0)), time);
    
    col = mix(water_surface, sky, reflection_factor * 0.6);
    
  } else {
    // Sky rendering for non-terrain objects or background
    if (in.mesh_type == 4u) { // Skybox
      // Full procedural sky rendering
      col = sky_color(in.view_dir, time);
      
    } else if (in.mesh_type == 1u) { // Trees
      // Enhanced tree rendering with seasonal variation
      let tree_base_color = in.color.rgb;
      let seasonal_factor = (sin(time * 0.05) + 1.0) * 0.5;
      let autumn_color = vec3<f32>(0.8, 0.4, 0.1);
      let summer_color = vec3<f32>(0.2, 0.8, 0.3);
      col = mix(tree_base_color, mix(summer_color, autumn_color, seasonal_factor), 0.3);
      
    } else if (in.mesh_type == 2u) { // Houses/Structures
      // Enhanced building rendering with weathering
      col = in.color.rgb;
      let weathering = sin(in.world_pos.x * 0.5) * cos(in.world_pos.z * 0.3) * 0.1;
      col = col * (0.95 + weathering);
      
    } else {
      // Other objects get sky ambient lighting
      let sky = sky_color(in.view_dir, time);
      col = in.color.rgb * 0.8 + sky * 0.2;
    }
  }
  
  return vec4<f32>(col, 1.0);
}
"#;

// ---------------- physics world build/step & instance sync ----------------

fn build_physics_world() -> Physics {
    let mut bodies = r3::RigidBodySet::new();
    let mut colliders = r3::ColliderSet::new();
    let gravity = nalgebra::Vector3::new(0.0, -9.81, 0.0);
    // Ground collider that matches the rendered terrain using a TriMesh
    // Generate the same terrain data used for rendering
    let (terrain_vertices, terrain_indices) = generate_terrain_mesh(TERRAIN_SIZE, TERRAIN_SCALE);
    // Convert to rapier types
    let mut points: Vec<nalgebra::Point3<f32>> = Vec::with_capacity(terrain_vertices.len());
    for v in &terrain_vertices {
        points.push(nalgebra::Point3::new(v[0], v[1], v[2]));
    }
    let mut indices: Vec<[u32; 3]> = Vec::with_capacity(terrain_indices.len() / 3);
    for tri in terrain_indices.chunks_exact(3) {
        indices.push([tri[0], tri[1], tri[2]]);
    }
    let ground = r3::RigidBodyBuilder::fixed()
        .translation(nalgebra::Vector3::new(0.0, 0.0, 0.0))
        .user_data(0)
        .build();
    let g_handle = bodies.insert(ground);
    let g_col = r3::ColliderBuilder::trimesh(points, indices)
        .friction(0.9)
        .restitution(0.1)
        .build();
    colliders.insert_with_parent(g_col, g_handle, &mut bodies);
    // Stack of boxes
    for y in 0..5 {
        for x in 0..5 {
            let rb = r3::RigidBodyBuilder::dynamic()
                .translation(nalgebra::Vector3::new(
                    -2.5 + x as f32 * 0.7,
                    -1.0 + y as f32 * 0.7,
                    0.0,
                ))
                .user_data(1)
                .build();
            let h = bodies.insert(rb);
            let c = r3::ColliderBuilder::cuboid(0.3, 0.3, 0.3)
                .restitution(0.2)
                .friction(0.8)
                .build();
            colliders.insert_with_parent(c, h, &mut bodies);
        }
    }
    // Sphere
    let s_rb = r3::RigidBodyBuilder::dynamic()
        .translation(nalgebra::Vector3::new(1.8, 1.0, 0.0))
        .ccd_enabled(true)
        .user_data(2)
        .build();
    let s_handle = bodies.insert(s_rb);
    let s_col = r3::ColliderBuilder::ball(0.35)
        .restitution(0.5)
        .friction(0.3)
        .build();
    colliders.insert_with_parent(s_col, s_handle, &mut bodies);

    Physics {
        pipeline: r3::PhysicsPipeline::new(),
        gravity,
        islands: r3::IslandManager::new(),
        broad: r3::DefaultBroadPhase::new(),
        narrow: r3::NarrowPhase::new(),
        bodies,
        colliders,
        impulse_joints: r3::ImpulseJointSet::new(),
        multibody_joints: r3::MultibodyJointSet::new(),
        ccd: r3::CCDSolver::new(),
        query_pipeline: r3::QueryPipeline::new(),
        integration_params: r3::IntegrationParameters {
            dt: 1.0 / 60.0,
            ..Default::default()
        },
    }
}

fn physics_step(p: &mut Physics) {
    let hooks = ();
    let events = ();
    p.pipeline.step(
        &p.gravity,
        &p.integration_params,
        &mut p.islands,
        &mut p.broad,
        &mut p.narrow,
        &mut p.bodies,
        &mut p.colliders,
        &mut p.impulse_joints,
        &mut p.multibody_joints,
        &mut p.ccd,
        Some(&mut p.query_pipeline),
        &hooks,
        &events,
    );
}

fn teleport_sphere_to(p: &mut Physics, pos: Vec3) {
    let target = p.bodies.iter_mut().find(|(_, b)| b.user_data == 2);
    if let Some((_, body)) = target {
        body.set_translation(nalgebra::Vector3::new(pos.x, pos.y, pos.z), true);
        body.set_linvel(nalgebra::Vector3::new(0.0, 0.0, 0.0), true);
        body.set_angvel(nalgebra::Vector3::new(0.0, 0.0, 0.0), true);
    }
}

fn sync_instances_from_physics(p: &Physics, characters: &[Character], camera_pos: Vec3, out: &mut Vec<InstanceRaw>) {
    // Resize output vector to accommodate all objects
    out.clear();

    // Enhanced skybox instance - positioned to follow camera for optimal immersion
    // Create a transform that follows the camera position to ensure the skybox
    // always encompasses the view without creating depth buffer conflicts
    let skybox_translation = Mat4::from_translation(camera_pos); // Position skybox at camera location
    let skybox_instance = InstanceRaw {
        model: skybox_translation.to_cols_array(),
        color: [0.8, 0.9, 1.0, 1.0], // Enhanced sky blue for better atmospheric feel
        mesh_type: MeshType::Skybox as u32,
        _padding: [0, 0, 0],
    };
    out.push(skybox_instance);

    // Add physics objects
    for (_h, body) in p.bodies.iter() {
        // No skipping â€” we want the ground cube drawn so the ground shader branch runs.

        let xf = body.position();
        let iso = xf.to_homogeneous();
        let base_m = Mat4::from_cols_array_2d(&iso.fixed_view::<4, 4>(0, 0).into());

        // Handle scaling for different object types
        let model_m = if body.is_fixed() && body.user_data == 0 {
            // Ground uses the terrain mesh which is already correctly sized - no scaling needed
            base_m
        } else {
            // Scale objects based on their type for better visibility
            let object_scale = match body.user_data {
                1..=2 => 1.0,           // Original demo objects - keep normal size
                10..=34 => 8.0,         // Trees - scale up significantly  
                35..=45 => 6.0,         // Houses - scale up for visibility
                60..=90 => 3.0,         // Rocks and boulders - moderate scaling
                100..=170 => 4.0,       // Bushes and undergrowth - medium scale
                200..=309 => 2.5,       // Stone circles and river banks
                400..=407 => 2.0,       // Sand dunes  
                500..=504 => 10.0,      // Oasis palms - very tall
                _ => 2.0,               // Default moderate scaling
            };
            let scale_m = Mat4::from_scale(Vec3::splat(object_scale));
            base_m * scale_m
        };

        // Color and mesh type based on object type
        let (color, mesh_type) = match body.user_data {
            0 => ([0.95, 0.95, 0.95, 1.0], MeshType::Cube),     // Ground
            1 => ([0.9, 0.6, 0.2, 1.0], MeshType::Cube),        // Original boxes (orange)
            2 => ([0.2, 0.6, 0.9, 1.0], MeshType::Cube),        // Sphere (use cube mesh fallback)
            10..=34 => ([0.20, 0.80, 0.30, 1.0], MeshType::Tree),   // Trees
            35..=45 => ([0.60, 0.60, 0.60, 1.0], MeshType::House),  // Houses
            60..=90 => ([0.50, 0.50, 0.50, 1.0], MeshType::Cube),   // Rocks/Boulders
            100..=170 => ([0.10, 0.50, 0.20, 1.0], MeshType::Tree), // Bushes/Undergrowth (tree as proxy)
            200..=309 => ([0.40, 0.40, 0.40, 1.0], MeshType::Cube), // Stone features
            400..=407 => ([0.90, 0.80, 0.60, 1.0], MeshType::Cube), // Sand dunes
            500..=504 => ([0.20, 0.70, 0.30, 1.0], MeshType::Tree), // Oasis palms
            _ => ([0.80, 0.80, 0.80, 1.0], MeshType::Cube),         // Default
        };

        // Push instance for this physics body
        out.push(InstanceRaw {
            model: model_m.to_cols_array(),
            color,
            mesh_type: mesh_type as u32,
            _padding: [0; 3],
        });
    }

    // Add character instances
    for character in characters {
        // Create a transform matrix for the character - scale up significantly for visibility
        let scale = 5.0; // Characters need to be much larger to be visible on the terrain
        let translation = Mat4::from_translation(character.position);
        let scaling = Mat4::from_scale(Vec3::splat(scale));

        // Add some simple animation based on time
        let bob_offset = (character.animation_time * 3.0).sin() * 0.1;
        let animation_transform = Mat4::from_translation(Vec3::new(0.0, bob_offset, 0.0));

        let model_matrix = translation * animation_transform * scaling;

        out.push(InstanceRaw {
            model: model_matrix.to_cols_array(),
            color: character.get_color(),
            mesh_type: MeshType::Character as u32,
            _padding: [0; 3],
        });
    }
}

fn build_show_instances() -> Vec<InstanceRaw> {
    // Start with empty instances - they'll be populated by physics sync
    Vec::new()
}
