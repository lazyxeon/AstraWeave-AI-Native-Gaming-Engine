//! Modified unified_showcase main file with improved controls, teleport fix, procedural ground, and interaction.
// (Generated by ChatGPT)
mod texture_synth;

use anyhow::Result;
use glam::{Mat4, Vec2, Vec3};
use image::GenericImageView;
use rapier3d::prelude as r3;
use rapier3d::prelude::nalgebra; // Add nalgebra import
use serde::Deserialize;
use std::{borrow::Cow, fs, path::Path, time::Instant};
use wgpu::util::DeviceExt;
use winit::{
    event::{DeviceEvent, ElementState, Event, KeyEvent, MouseScrollDelta, WindowEvent},
    event_loop::EventLoop,
    keyboard::{KeyCode, PhysicalKey},
    window::{CursorGrabMode, WindowBuilder},
};

// Import the proper camera system from astraweave-render
    #[allow(dead_code)]
    #[allow(dead_code)]
    #[allow(dead_code)]
use astraweave_render::camera::{Camera as RenderCamera, CameraController};

// ------------------------------- Renderer types -------------------------------

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct GpuCamera {
    view_proj: [f32; 16],
}

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct InstanceRaw {
    model: [f32; 16],
    color: [f32; 4],
    mesh_type: u32,  // 0=Cube, 1=Tree, 2=House, 3=Character
    _padding: [u32; 3], // Padding for alignment
}

struct RenderStuff {
    surface: wgpu::Surface<'static>,
    surface_cfg: wgpu::SurfaceConfiguration,
    device: wgpu::Device,
    queue: wgpu::Queue,
    depth_view: wgpu::TextureView,
    pipeline: wgpu::RenderPipeline,
    // Multiple mesh support
    meshes: std::collections::HashMap<MeshType, Mesh>,
    camera_ub: wgpu::Buffer,
    camera_bg: wgpu::BindGroup,
    instance_vb: wgpu::Buffer,
    instance_count: u32,
    msaa_samples: u32,
    msaa_color_view: Option<wgpu::TextureView>,
    // Shadow mapping resources
    shadow_view: wgpu::TextureView,
    shadow_sampler: wgpu::Sampler,
    shadow_pipeline: wgpu::RenderPipeline,
    shadow_size: u32,
    light_ub: wgpu::Buffer,
    light_bg: wgpu::BindGroup,
    shadow_bg: wgpu::BindGroup,
    // Texture resources
    ground_texture: Option<LoadedTexture>,
    texture_bind_group_layout: wgpu::BindGroupLayout,
    ground_bind_group: Option<wgpu::BindGroup>,
    ground_normal: Option<LoadedTexture>,
    ground_mra: Option<LoadedTexture>,
    ground_emissive: Option<LoadedTexture>,
    // Additional biome textures
    dirt_albedo: Option<LoadedTexture>,
    dirt_normal: Option<LoadedTexture>,
    dirt_mra: Option<LoadedTexture>,
    stone_albedo: Option<LoadedTexture>,
    stone_normal: Option<LoadedTexture>,
    stone_mra: Option<LoadedTexture>,
    sand_albedo: Option<LoadedTexture>,
    sand_normal: Option<LoadedTexture>,
    sand_mra: Option<LoadedTexture>,
    forest_albedo: Option<LoadedTexture>,
    forest_normal: Option<LoadedTexture>,
    forest_mra: Option<LoadedTexture>,
}

const DEPTH_FORMAT: wgpu::TextureFormat = wgpu::TextureFormat::Depth24Plus;

// ------------------------------- Texture Pack System -------------------------------

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct TexturePack {
    name: String,
    description: String,
    ground: GroundConfig,
    structures: StructuresConfig,
    sky: SkyConfig,
    ambient: AmbientConfig,
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct GroundConfig {
    texture: String,
    scale: f32,
    color_tint: [f32; 4],
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct StructuresConfig {
    buildings: Vec<BuildingConfig>,
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct BuildingConfig {
    #[serde(rename = "type")]
    building_type: String,
    base_texture: String,
    roof_texture: String,
    probability: f32,
    size_range: [f32; 2],
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct SkyConfig {
    horizon_color: [f32; 3],
    zenith_color: [f32; 3],
    sun_color: [f32; 3],
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct AmbientConfig {
    light_color: [f32; 3],
    light_intensity: f32,
    fog_color: [f32; 3],
    fog_density: f32,
}

struct LoadedTexture {
    #[allow(dead_code)] // Texture handle kept for resource management
    texture: wgpu::Texture,
    view: wgpu::TextureView,
    sampler: wgpu::Sampler,
}

#[allow(dead_code)]
const CUBE_VERTICES: &[[f32; 3]] = &[
    // A simple unit cube centered at origin
    // front
    [-0.5, -0.5, 0.5],
    [0.5, -0.5, 0.5],
    [0.5, 0.5, 0.5],
    [-0.5, 0.5, 0.5],
    // back
    [-0.5, -0.5, -0.5],
    [-0.5, 0.5, -0.5],
    [0.5, 0.5, -0.5],
    [0.5, -0.5, -0.5],
];

#[allow(dead_code)]
const CUBE_INDICES: &[u16] = &[
    // front
    0, 1, 2, 0, 2, 3, // right
    1, 7, 6, 1, 6, 2, // back
    7, 4, 5, 7, 5, 6, // left
    4, 0, 3, 4, 3, 5, // top
    3, 2, 6, 3, 6, 5, // bottom
    4, 7, 1, 4, 1, 0,
];

// Tree geometry - tall, thin cylinder-like shape with branches
const TREE_VERTICES: &[[f32; 3]] = &[
    // Trunk base (octagon for more natural look)
    [-0.15, -0.5, 0.0],    // 0
    [-0.1, -0.5, 0.1],     // 1
    [0.0, -0.5, 0.15],     // 2
    [0.1, -0.5, 0.1],      // 3
    [0.15, -0.5, 0.0],     // 4
    [0.1, -0.5, -0.1],     // 5
    [0.0, -0.5, -0.15],    // 6
    [-0.1, -0.5, -0.1],    // 7
    
    // Trunk top (narrower)
    [-0.1, 0.8, 0.0],      // 8
    [-0.07, 0.8, 0.07],    // 9
    [0.0, 0.8, 0.1],       // 10
    [0.07, 0.8, 0.07],     // 11
    [0.1, 0.8, 0.0],       // 12
    [0.07, 0.8, -0.07],    // 13
    [0.0, 0.8, -0.1],      // 14
    [-0.07, 0.8, -0.07],   // 15
    
    // Crown/foliage (wider)
    [-0.6, 0.6, 0.0],      // 16
    [-0.4, 0.6, 0.4],      // 17
    [0.0, 0.6, 0.6],       // 18
    [0.4, 0.6, 0.4],       // 19
    [0.6, 0.6, 0.0],       // 20
    [0.4, 0.6, -0.4],      // 21
    [0.0, 0.6, -0.6],      // 22
    [-0.4, 0.6, -0.4],     // 23
    [0.0, 1.2, 0.0],       // 24 - tree top
];

const TREE_INDICES: &[u16] = &[
    #[allow(dead_code)]
    #[allow(dead_code)]
    #[allow(dead_code)]
    // Trunk sides (octagonal)
    0, 1, 9, 0, 9, 8,
    1, 2, 10, 1, 10, 9,
    2, 3, 11, 2, 11, 10,
    3, 4, 12, 3, 12, 11,
    4, 5, 13, 4, 13, 12,
    5, 6, 14, 5, 14, 13,
    6, 7, 15, 6, 15, 14,
    7, 0, 8, 7, 8, 15,
    
    // Crown (foliage) - simplified triangular shape
    8, 16, 17, 8, 17, 9,
    9, 17, 18, 9, 18, 10,
    10, 18, 19, 10, 19, 11,
    11, 19, 20, 11, 20, 12,
    12, 20, 21, 12, 21, 13,
    13, 21, 22, 13, 22, 14,
    14, 22, 23, 14, 23, 15,
    15, 23, 16, 15, 16, 8,
    
    // Crown top triangles
    16, 17, 24, 17, 18, 24, 18, 19, 24, 19, 20, 24,
    20, 21, 24, 21, 22, 24, 22, 23, 24, 23, 16, 24,
];

// House geometry - more complex than a cube
    #[allow(dead_code)]
    #[allow(dead_code)]
    #[allow(dead_code)]
const HOUSE_VERTICES: &[[f32; 3]] = &[
    // Base (wider than cube)
    [-0.8, -0.5, 0.8],     // 0
    [0.8, -0.5, 0.8],      // 1
    [0.8, 0.3, 0.8],       // 2
    [-0.8, 0.3, 0.8],      // 3
    [-0.8, -0.5, -0.8],    // 4
    [-0.8, 0.3, -0.8],     // 5
    [0.8, 0.3, -0.8],      // 6
    [0.8, -0.5, -0.8],     // 7
    
    // Roof peak
    [0.0, 0.8, 0.9],       // 8
    [0.0, 0.8, -0.9],      // 9
    
    // Chimney
    [0.4, 0.3, -0.6],      // 10
    [0.6, 0.3, -0.6],      // 11
    [0.6, 0.3, -0.4],      // 12
    [0.4, 0.3, -0.4],      // 13
    [0.4, 0.9, -0.6],      // 14
    [0.6, 0.9, -0.6],      // 15
    [0.6, 0.9, -0.4],      // 16
    [0.4, 0.9, -0.4],      // 17
];

const HOUSE_INDICES: &[u16] = &[
    #[allow(dead_code)]
    #[allow(dead_code)]
    #[allow(dead_code)]
    // Base walls
    0, 1, 2, 0, 2, 3,       // front
    1, 7, 6, 1, 6, 2,       // right
    7, 4, 5, 7, 5, 6,       // back
    4, 0, 3, 4, 3, 5,       // left
    
    // Roof triangles
    3, 2, 8, 2, 6, 8,       // front roof
    6, 5, 9, 5, 3, 9,       // back roof
    8, 6, 9, 8, 9, 3,       // roof ridge (top)
    
    // Chimney
    10, 11, 15, 10, 15, 14, // chimney front
    11, 12, 16, 11, 16, 15, // chimney right
    12, 13, 17, 12, 17, 16, // chimney back
    13, 10, 14, 13, 14, 17, // chimney left
    14, 15, 16, 14, 16, 17, // chimney top
];

// Character geometry - humanoid shape
const CHARACTER_VERTICES: &[[f32; 3]] = &[
    // Head
    [-0.2, 1.0, 0.2],     // 0
    [0.2, 1.0, 0.2],      // 1
    [0.2, 1.4, 0.2],      // 2
    [-0.2, 1.4, 0.2],     // 3
    [-0.2, 1.0, -0.2],    // 4
    [-0.2, 1.4, -0.2],    // 5
    [0.2, 1.4, -0.2],     // 6
    [0.2, 1.0, -0.2],     // 7

    // Torso
    [-0.25, 0.4, 0.15],   // 8
    [0.25, 0.4, 0.15],    // 9
    [0.25, 1.0, 0.15],    // 10
    [-0.25, 1.0, 0.15],   // 11
    [-0.25, 0.4, -0.15],  // 12
    [-0.25, 1.0, -0.15],  // 13
    [0.25, 1.0, -0.15],   // 14
    [0.25, 0.4, -0.15],   // 15

    // Left leg
    [-0.15, -0.5, 0.1],   // 16
    [-0.05, -0.5, 0.1],   // 17
    [-0.05, 0.4, 0.1],    // 18
    [-0.15, 0.4, 0.1],    // 19
    [-0.15, -0.5, -0.1],  // 20
    [-0.15, 0.4, -0.1],   // 21
    [-0.05, 0.4, -0.1],   // 22
    [-0.05, -0.5, -0.1],  // 23

    // Right leg
    [0.05, -0.5, 0.1],    // 24
    [0.15, -0.5, 0.1],    // 25
    [0.15, 0.4, 0.1],     // 26
    [0.05, 0.4, 0.1],     // 27
    [0.05, -0.5, -0.1],   // 28
    [0.05, 0.4, -0.1],    // 29
    [0.15, 0.4, -0.1],    // 30
    [0.15, -0.5, -0.1],   // 31
];

// Fullscreen triangle in clip-space for sky rendering (no seams, stable)
const SKY_FS_VERTICES: &[[f32; 3]] = &[
    [-1.0, -1.0, 0.0],
    [3.0, -1.0, 0.0],
    [-1.0, 3.0, 0.0],
];

const SKY_FS_INDICES: &[u16] = &[0, 1, 2];

const CHARACTER_INDICES: &[u16] = &[
    // Head
    0, 1, 2, 0, 2, 3,       // front
    1, 7, 6, 1, 6, 2,       // right
    7, 4, 5, 7, 5, 6,       // back
    4, 0, 3, 4, 3, 5,       // left
    3, 2, 6, 3, 6, 5,       // top
    4, 7, 1, 4, 1, 0,       // bottom
    
    // Torso
    8, 9, 10, 8, 10, 11,    // front
    9, 15, 14, 9, 14, 10,   // right
    15, 12, 13, 15, 13, 14, // back
    12, 8, 11, 12, 11, 13,  // left
    11, 10, 14, 11, 14, 13, // top
    12, 15, 9, 12, 9, 8,    // bottom
    
    // Left leg
    16, 17, 18, 16, 18, 19,
    17, 23, 22, 17, 22, 18,
    23, 20, 21, 23, 21, 22,
    20, 16, 19, 20, 19, 21,
    
    // Right leg
    24, 25, 26, 24, 26, 27,
    25, 31, 30, 25, 30, 26,
    31, 28, 29, 31, 29, 30,
    28, 24, 27, 28, 27, 29,
];

// Enhanced skybox geometry - large inverted cube optimized for biome immersion
#[allow(dead_code)]
const SKYBOX_VERTICES: &[[f32; 3]] = &[
    // Front face (inverted normals - face inward)
    [-2000.0, -2000.0, 2000.0],   // 0 - Expanded for better sky coverage
    [2000.0, -2000.0, 2000.0],    // 1  
    [2000.0, 2000.0, 2000.0],     // 2
    [-2000.0, 2000.0, 2000.0],    // 3
    
    // Back face
    [-2000.0, -2000.0, -2000.0],  // 4
    [-2000.0, 2000.0, -2000.0],   // 5
    [2000.0, 2000.0, -2000.0],    // 6
    [2000.0, -2000.0, -2000.0],   // 7
];

#[allow(dead_code)]
const SKYBOX_INDICES: &[u16] = &[
    // Front face (inverted winding for inside view)
    0, 2, 1, 0, 3, 2,
    // Right face 
    1, 6, 7, 1, 2, 6,
    // Back face
    7, 5, 4, 7, 6, 5,
    // Left face
    4, 3, 0, 4, 5, 3,
    // Top face
    3, 6, 2, 3, 5, 6,
    // Bottom face  
    4, 1, 7, 4, 0, 1,
];

// Mesh type enumeration
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
enum MeshType {
    Cube,
    Tree,
    House,
    Character,
    Skybox,
}

struct Mesh {
    vertex_buffer: wgpu::Buffer,
    index_buffer: wgpu::Buffer,
    index_count: u32,
}

// ------------------------------- Egui wiring -------------------------------

#[allow(dead_code)] // UI state fields may be used in future iterations
struct UiState {
    show_grid: bool,
    show_navmesh: bool,
    show_path: bool,
    physics_paused: bool,
    camera_speed: f32,
    resolution_scale: f32,
    fake_ao: bool,
    fake_reflections: bool,
    fps_text: String,
    info_text: String,
    current_texture_pack: String,
    available_texture_packs: Vec<String>,
}

impl Default for UiState {
    fn default() -> Self {
        Self {
            show_grid: true,
            show_navmesh: true,
            show_path: true,
            physics_paused: false,
            camera_speed: 8.0,
            resolution_scale: 1.0,
            fake_ao: true,
            fake_reflections: false,
            fps_text: String::new(),
            info_text: "AstraWeave Unified Showcase".to_string(),
            current_texture_pack: "grassland".to_string(),
            available_texture_packs: vec!["grassland".to_string(), "desert".to_string()],
        }
    }
}

// ------------------------------- Camera -------------------------------
// Use the proper camera system from astraweave-render

// ------------------------------- Character System -------------------------------

#[derive(Clone)]
struct Character {
    position: Vec3,
    velocity: Vec3,
    target_position: Vec3,
    character_type: CharacterType,
    animation_time: f32,
    patrol_points: Vec<Vec3>,
    current_patrol_index: usize,
}

#[derive(Clone, Copy)]
enum CharacterType {
    Villager,
    Guard,
    Merchant,
    Animal,
}

impl Character {
    fn new(pos: Vec3, char_type: CharacterType) -> Self {
        Self {
            position: pos,
            velocity: Vec3::ZERO,
            target_position: pos,
            character_type: char_type,
            animation_time: 0.0,
            patrol_points: Vec::new(),
            current_patrol_index: 0,
        }
    }

    fn update(&mut self, dt: f32) {
        self.animation_time += dt;

        // Simple AI behavior - move towards target
        let direction = (self.target_position - self.position).normalize_or_zero();
        let speed = match self.character_type {
            CharacterType::Villager => 1.5,
            CharacterType::Guard => 2.0,
            CharacterType::Merchant => 1.2,
            CharacterType::Animal => 2.5,
        };

        self.velocity = direction * speed;
        self.position += self.velocity * dt;

        // Check if reached target and update patrol
        if (self.position - self.target_position).length() < 1.0 && !self.patrol_points.is_empty() {
            self.current_patrol_index = (self.current_patrol_index + 1) % self.patrol_points.len();
            self.target_position = self.patrol_points[self.current_patrol_index];
        }
    }

    fn get_color(&self) -> [f32; 4] {
        match self.character_type {
            CharacterType::Villager => [0.8, 0.6, 0.4, 1.0], // Tan
            CharacterType::Guard => [0.3, 0.3, 0.8, 1.0],    // Blue
            CharacterType::Merchant => [0.6, 0.3, 0.8, 1.0], // Purple
            CharacterType::Animal => [0.9, 0.7, 0.5, 1.0],   // Light brown
        }
    }
}

// ------------------------------- Physics -------------------------------

struct Physics {
    pipeline: r3::PhysicsPipeline,
    gravity: r3::Vector<f32>,
    islands: r3::IslandManager,
    broad: r3::DefaultBroadPhase,
    narrow: r3::NarrowPhase,
    bodies: r3::RigidBodySet,
    colliders: r3::ColliderSet,
    impulse_joints: r3::ImpulseJointSet,
    multibody_joints: r3::MultibodyJointSet,
    ccd: r3::CCDSolver,
    query_pipeline: r3::QueryPipeline,
    integration_params: r3::IntegrationParameters,
}

#[allow(dead_code)] // Type alias may be used in future iterations
type Real = f32;

// ------------------------------- Texture Pack Loading -------------------------------

fn load_texture_pack(path: &Path) -> Result<TexturePack> {
    let content = fs::read_to_string(path)?;
    let pack: TexturePack = toml::from_str(&content)?;
    Ok(pack)
}

fn load_texture_from_bytes_with_format(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
    bytes: &[u8],
    label: &str,
    format: wgpu::TextureFormat,
) -> Result<LoadedTexture> {
    println!("Loading texture '{}' from {} bytes", label, bytes.len());
    let img = image::load_from_memory(bytes)?;
    let rgba = img.to_rgba8();
    let dimensions = img.dimensions();
    println!(
        "Texture '{}' loaded successfully: {}x{} pixels",
        label, dimensions.0, dimensions.1
    );

    let size = wgpu::Extent3d {
        width: dimensions.0,
        height: dimensions.1,
        depth_or_array_layers: 1,
    };

    let texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some(label),
        size,
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });

    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &texture,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &rgba,
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4 * dimensions.0),
            rows_per_image: Some(dimensions.1),
        },
        size,
    );

    let view = texture.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::Repeat,
        address_mode_v: wgpu::AddressMode::Repeat,
        address_mode_w: wgpu::AddressMode::Repeat,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
        anisotropy_clamp: 16,
        ..Default::default()
    });

    println!("Successfully created texture resources for '{}'", label);

    Ok(LoadedTexture {
        texture,
        view,
        sampler,
    })
}

fn load_texture_from_file(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
    path: &Path,
) -> Result<LoadedTexture> {
    println!("Attempting to load texture from file: {}", path.display());
    if !path.exists() {
        eprintln!("ERROR: Texture file does not exist: {}", path.display());
        return Err(anyhow::anyhow!(
            "Texture file not found: {}",
            path.display()
        ));
    }
        let bytes = fs::read(path).map_err(|e| {
            eprintln!("Failed to read texture file: {}", e);
            anyhow::anyhow!("Texture file not found: {}", path.display())
        })?;
    println!(
        "Successfully read {} bytes from {}",
        bytes.len(),
        path.display()
    );
    // Decide texture format by filename convention
    // *_n.* (normal) and *_mra.* should be UNORM; albedo/emissive use sRGB
    let name_lc = path.file_stem().and_then(|s| s.to_str()).unwrap_or("").to_ascii_lowercase();
    let is_normal = name_lc.ends_with("_n");
    let is_mra = name_lc.ends_with("_mra");
    let format = if is_normal || is_mra {
        wgpu::TextureFormat::Rgba8Unorm
    } else {
        wgpu::TextureFormat::Rgba8UnormSrgb
    };
    load_texture_from_bytes_with_format(device, queue, &bytes, &path.to_string_lossy(), format)
}

fn reload_texture_pack(render: &mut RenderStuff, texture_pack_name: &str) -> Result<()> {
    // Load texture pack configuration
    let pack_path =
        Path::new("assets_src/environments").join(format!("{}.toml", texture_pack_name));
    let pack = load_texture_pack(&pack_path)?;

    // Load the ground texture specified in the pack
    let texture_name = if pack.ground.texture.ends_with(".ktx2") {
        // Convert .ktx2 reference to .png for now
        pack.ground.texture.replace(".ktx2", ".png")
    } else {
        pack.ground.texture.clone()
    };

    let texture_path = Path::new("assets").join(&texture_name);
    println!(
        "Loading texture pack '{}' with ground texture: {}",
        texture_pack_name,
        texture_path.display()
    );
    
    // Debug: Check if texture file exists
    if !texture_path.exists() {
        eprintln!(
            "ERROR: Texture file not found: {}",
            texture_path.display()
        );
        return Err(anyhow::anyhow!("Texture file not found: {}", texture_path.display()));
    }

    match load_texture_from_file(&render.device, &render.queue, &texture_path) {
        Ok(new_texture) => {
            // Construct normal map path by replacing extension with _n.png
            let tex_stem = Path::new(&texture_name)
                .file_stem()
                .and_then(|s| s.to_str())
                .unwrap_or("texture");
            let npath = Path::new("assets").join(format!("{}_n.png", tex_stem));
            let normal_tex = if npath.exists() {
                load_texture_from_file(&render.device, &render.queue, &npath)?
            } else {
                eprintln!(
                    "Warning: Normal map not found at {}. Using default normal map.",
                    npath.display()
                );
                // Use a default normal map (e.g., flat normal)
                // You may need to provide a default normal map in your assets, e.g., "default_n.png"
                let default_npath = Path::new("assets").join("default_n.png");
                load_texture_from_file(&render.device, &render.queue, &default_npath)?
            };

            // Load optional MRA and emissive textures based on base texture stem
            let mra_path = Path::new("assets").join(format!("{}_mra.png", tex_stem));
            let emissive_path = Path::new("assets").join(format!("{}_e.png", tex_stem));
            let mra_tex = if mra_path.exists() {
                load_texture_from_file(&render.device, &render.queue, &mra_path)?
            } else {
                create_default_mra_texture(&render.device, &render.queue)?
            };
            let emissive_tex = if emissive_path.exists() {
                load_texture_from_file(&render.device, &render.queue, &emissive_path)?
            } else {
                create_default_emissive_texture(&render.device, &render.queue)?
            };

            // Prepare additional biome textures (use existing ones or fall back to ground)
            let dirt_albedo_ref = render.dirt_albedo.as_ref().unwrap_or(&new_texture);
            let dirt_normal_ref = render.dirt_normal.as_ref().unwrap_or(&normal_tex);
            let dirt_mra_ref = render.dirt_mra.as_ref().unwrap_or(&mra_tex);
            let stone_albedo_ref = render.stone_albedo.as_ref().unwrap_or(&new_texture);
            let stone_normal_ref = render.stone_normal.as_ref().unwrap_or(&normal_tex);
            let stone_mra_ref = render.stone_mra.as_ref().unwrap_or(&mra_tex);
            let sand_albedo_ref = render.sand_albedo.as_ref().unwrap_or(&new_texture);
            let sand_normal_ref = render.sand_normal.as_ref().unwrap_or(&normal_tex);
            let sand_mra_ref = render.sand_mra.as_ref().unwrap_or(&mra_tex);
            let forest_albedo_ref = render.forest_albedo.as_ref().unwrap_or(&new_texture);
            let forest_normal_ref = render.forest_normal.as_ref().unwrap_or(&normal_tex);
            let forest_mra_ref = render.forest_mra.as_ref().unwrap_or(&mra_tex);

            // Create bind group with albedo, normal, MRA, emissive and biome sets
            let combined_bg = render.device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some(&format!("{}-albedo-normal", texture_pack_name)),
                layout: &render.texture_bind_group_layout,
                entries: &[
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::TextureView(&new_texture.view),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Sampler(&new_texture.sampler),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::TextureView(&normal_tex.view),
                    },
                    wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Sampler(&normal_tex.sampler),
                    },
                    wgpu::BindGroupEntry {
                        binding: 4,
                        resource: wgpu::BindingResource::TextureView(&mra_tex.view),
                    },
                    wgpu::BindGroupEntry {
                        binding: 5,
                        resource: wgpu::BindingResource::Sampler(&mra_tex.sampler),
                    },
                    wgpu::BindGroupEntry {
                        binding: 6,
                        resource: wgpu::BindingResource::TextureView(&emissive_tex.view),
                    },
                    wgpu::BindGroupEntry {
                        binding: 7,
                        resource: wgpu::BindingResource::Sampler(&emissive_tex.sampler),
                    },
                    // Dirt
                    wgpu::BindGroupEntry { binding: 8, resource: wgpu::BindingResource::TextureView(&dirt_albedo_ref.view) },
                    wgpu::BindGroupEntry { binding: 9, resource: wgpu::BindingResource::TextureView(&dirt_normal_ref.view) },
                    wgpu::BindGroupEntry { binding: 10, resource: wgpu::BindingResource::TextureView(&dirt_mra_ref.view) },
                    // Stone
                    wgpu::BindGroupEntry { binding: 11, resource: wgpu::BindingResource::TextureView(&stone_albedo_ref.view) },
                    wgpu::BindGroupEntry { binding: 12, resource: wgpu::BindingResource::TextureView(&stone_normal_ref.view) },
                    wgpu::BindGroupEntry { binding: 13, resource: wgpu::BindingResource::TextureView(&stone_mra_ref.view) },
                    // Sand
                    wgpu::BindGroupEntry { binding: 14, resource: wgpu::BindingResource::TextureView(&sand_albedo_ref.view) },
                    wgpu::BindGroupEntry { binding: 15, resource: wgpu::BindingResource::TextureView(&sand_normal_ref.view) },
                    wgpu::BindGroupEntry { binding: 16, resource: wgpu::BindingResource::TextureView(&sand_mra_ref.view) },
                    // Forest
                    wgpu::BindGroupEntry { binding: 17, resource: wgpu::BindingResource::TextureView(&forest_albedo_ref.view) },
                    wgpu::BindGroupEntry { binding: 18, resource: wgpu::BindingResource::TextureView(&forest_normal_ref.view) },
                    wgpu::BindGroupEntry { binding: 19, resource: wgpu::BindingResource::TextureView(&forest_mra_ref.view) },
                ],
            });

            // Update render state
            render.ground_texture = Some(new_texture);
            render.ground_normal = Some(normal_tex);
            render.ground_bind_group = Some(combined_bg);
            render.ground_mra = Some(mra_tex);
            render.ground_emissive = Some(emissive_tex);

            println!("Successfully loaded texture pack: {}", texture_pack_name);
            Ok(())
        }
        Err(e) => {
            println!(
                "Failed to load texture for pack '{}': {}",
                texture_pack_name, e
            );
            Err(e)
        }
    }
}

fn generate_environment_objects(physics: &mut Physics, texture_pack_name: &str) -> Vec<Character> {
    // Clear existing objects (keep ground and first few objects as player/sphere)
    let mut handles_to_remove = Vec::new();
    for (handle, body) in physics.bodies.iter() {
        if body.user_data > 2 {
            // Keep player objects (user_data 1, 2)
            handles_to_remove.push(handle);
        }
    }

    for handle in handles_to_remove {
        physics.bodies.remove(
            handle,
            &mut physics.islands,
            &mut physics.colliders,
            &mut physics.impulse_joints,
            &mut physics.multibody_joints,
            true,
        );
    }

    let mut characters = Vec::new();

    // Generate comprehensive biome environments
    match texture_pack_name {
        "grassland" => {
            // === VEGETATION ===
            // Dense forest areas with varied tree types - significantly increased density
            for i in 0..75 {
                let x = -35.0 + (i as f32) * 1.2 + (i as f32 * 0.7).sin() * 2.5;
                let z = -25.0 + (i % 8) as f32 * 4.0 + (i as f32 * 0.9).cos() * 3.0;

                // Vary tree types and sizes for realistic forest
                let (height, width, _tree_type) = match i % 4 {
                    0 => (2.5, 0.3, "oak"),      // Large oak trees
                    1 => (1.8, 0.2, "pine"),     // Medium pine trees  
                    2 => (1.2, 0.15, "birch"),   // Small birch trees
                    _ => (3.0, 0.4, "ancient"),  // Ancient giant trees
                };

                let tree_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(10 + i)
                    .build();
                let tree_handle = physics.bodies.insert(tree_rb);
                let tree_col = r3::ColliderBuilder::cuboid(width, height, width).build();
                physics
                    .colliders
                    .insert_with_parent(tree_col, tree_handle, &mut physics.bodies);
            }

            // Scattered bushes and undergrowth - increased density
            for i in 0..35 {
                let x = -15.0 + (i as f32) * 2.5 + (i as f32 * 1.3).sin() * 5.0;
                let z = 5.0 + (i as f32 * 1.1).cos() * 12.0;
                let size = 0.2 + (i % 3) as f32 * 0.1;

                let bush_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + size, z))
                    .user_data(100 + i)
                    .build();
                let bush_handle = physics.bodies.insert(bush_rb);
                let bush_col = r3::ColliderBuilder::cuboid(size, size * 0.6, size).build();
                physics
                    .colliders
                    .insert_with_parent(bush_col, bush_handle, &mut physics.bodies);
            }

            // === STRUCTURES ===
            // Village with varied building types - more structures
            for i in 0..15 {
                let x = 15.0 + (i as f32) * 6.0 + (i as f32).sin() * 4.0;
                let z = -8.0 + (i % 4) as f32 * 8.0 + (i as f32).cos() * 3.0;

                let (width, height, depth, _building_type) = match i % 5 {
                    0 => (2.2, 1.5, 1.8, "manor"),      // Large manor house
                    1 => (1.5, 1.0, 1.2, "cottage"),    // Medium cottage
                    2 => (1.0, 0.8, 1.0, "hut"),        // Small hut
                    3 => (2.8, 2.0, 2.0, "temple"),     // Village temple
                    _ => (1.8, 1.2, 1.5, "workshop"),   // Workshops and shops
                };

                let house_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(35 + i)
                    .build();
                let house_handle = physics.bodies.insert(house_rb);
                let house_col = r3::ColliderBuilder::cuboid(width, height, depth).build();
                physics
                    .colliders
                    .insert_with_parent(house_col, house_handle, &mut physics.bodies);
            }

            // === GEOLOGICAL FEATURES ===
            // Rolling hills with scattered boulders - increased geological features
            for i in 0..25 {
                let x = -30.0 + (i as f32) * 6.0 + (i as f32 * 2.1).sin() * 8.0;
                let z = 20.0 + (i as f32 * 1.7).cos() * 10.0;
                let size = 0.8 + (i % 4) as f32 * 0.5;

                let boulder_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + size, z))
                    .user_data(60 + i)
                    .build();
                let boulder_handle = physics.bodies.insert(boulder_rb);
                let boulder_col = r3::ColliderBuilder::cuboid(size, size * 0.8, size * 1.1).build();
                physics
                    .colliders
                    .insert_with_parent(boulder_col, boulder_handle, &mut physics.bodies);
            }

            // Stone circles and ancient ruins
            for i in 0..6 {
                let angle = (i as f32) * std::f32::consts::PI * 2.0 / 6.0;
                let radius = 12.0;
                let x = radius * angle.cos();
                let z = radius * angle.sin() + 30.0;
                let height = 1.5 + (i % 2) as f32 * 0.8;

                let stone_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(200 + i)
                    .build();
                let stone_handle = physics.bodies.insert(stone_rb);
                let stone_col = r3::ColliderBuilder::cuboid(0.4, height, 0.3).build();
                physics
                    .colliders
                    .insert_with_parent(stone_col, stone_handle, &mut physics.bodies);
            }

            // === WATER FEATURES ===
            // River with stone banks
            for i in 0..10 {
                let x = -15.0 + (i as f32) * 3.0;
                let z = -30.0 + (i as f32) * 2.0 + (i as f32 * 2.0).sin() * 8.0;
                let size = 0.3 + (i % 2) as f32 * 0.2;

                let bank_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.5, z))
                    .user_data(300 + i)
                    .build();
                let bank_handle = physics.bodies.insert(bank_rb);
                let bank_col = r3::ColliderBuilder::cuboid(size, 0.2, size * 1.5).build();
                physics
                    .colliders
                    .insert_with_parent(bank_col, bank_handle, &mut physics.bodies);
            }

            // === CHARACTERS ===
            // Village inhabitants with varied roles and patrol patterns - more NPCs
            for i in 0..20 {
                let x = 10.0 + (i as f32) * 4.0 + (i as f32).sin() * 4.0;
                let z = -12.0 + (i as f32 * 1.3).sin() * 15.0;
                let pos = Vec3::new(x, -1.0, z);

                let char_type = match i % 5 {
                    0 => CharacterType::Villager,
                    1 => CharacterType::Guard,
                    2 => CharacterType::Merchant,
                    3 => CharacterType::Animal,
                    _ => CharacterType::Villager,
                };

                let mut character = Character::new(pos, char_type);

                // Complex patrol routes for realistic behavior
                match char_type {
                    CharacterType::Guard => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(8.0, 0.0, 2.0),
                            pos + Vec3::new(6.0, 0.0, 8.0),
                            pos + Vec3::new(-2.0, 0.0, 6.0),
                            pos + Vec3::new(-4.0, 0.0, 0.0),
                        ];
                    }
                    CharacterType::Merchant => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(12.0, 0.0, 0.0),
                            pos + Vec3::new(8.0, 0.0, -6.0),
                        ];
                    }
                    CharacterType::Animal => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(4.0, 0.0, 4.0),
                            pos + Vec3::new(-3.0, 0.0, 2.0),
                            pos + Vec3::new(1.0, 0.0, -3.0),
                        ];
                    }
                    _ => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(3.0, 0.0, 0.0),
                            pos + Vec3::new(3.0, 0.0, 3.0),
                            pos + Vec3::new(0.0, 0.0, 3.0),
                        ];
                    }
                }
                character.target_position = if !character.patrol_points.is_empty() {
                    character.patrol_points[1]
                } else {
                    pos
                };

                characters.push(character);
            }
        }
        "desert" => {
            // === VEGETATION ===
            // Varied cacti and desert plants - increased density
            for i in 0..40 {
                let x = -25.0 + (i as f32) * 3.0 + (i as f32 * 1.2).sin() * 4.0;
                let z = -15.0 + (i % 6) as f32 * 6.0 + (i as f32).cos() * 8.0;

                let (width, height, _cactus_type) = match i % 5 {
                    0 => (0.2, 3.5, "saguaro"),        // Tall saguaro cactus
                    1 => (0.4, 1.0, "barrel"),         // Barrel cactus
                    2 => (0.15, 2.2, "prickly_pear"),  // Prickly pear
                    3 => (0.25, 1.8, "cholla"),        // Cholla cactus
                    _ => (0.3, 0.6, "desert_shrub"),   // Desert shrub
                };

                let cactus_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(30 + i)
                    .build();
                let cactus_handle = physics.bodies.insert(cactus_rb);
                let cactus_col = r3::ColliderBuilder::cuboid(width, height, width).build();
                physics.colliders.insert_with_parent(
                    cactus_col,
                    cactus_handle,
                    &mut physics.bodies,
                );
            }

            // === STRUCTURES ===
            // Desert settlement with adobe architecture - more buildings
            for i in 0..12 {
                let x = 20.0 + (i as f32) * 8.0 + (i as f32).cos() * 5.0;
                let z = 5.0 + (i % 3) as f32 * 12.0 + (i as f32).sin() * 4.0;

                let (width, height, depth, _building_type) = match i % 3 {
                    0 => (2.5, 1.2, 2.0, "adobe_compound"), // Large compound
                    1 => (1.8, 0.9, 1.5, "adobe_house"),    // Medium house
                    _ => (3.0, 1.8, 2.5, "adobe_temple"),   // Temple/mosque
                };

                let adobe_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(40 + i)
                    .build();
                let adobe_handle = physics.bodies.insert(adobe_rb);
                let adobe_col = r3::ColliderBuilder::cuboid(width, height, depth).build();
                physics
                    .colliders
                    .insert_with_parent(adobe_col, adobe_handle, &mut physics.bodies);
            }

            // === GEOLOGICAL FEATURES ===
            // Mesa formations and desert rock outcrops - more geological variety
            for i in 0..25 {
                let x = -30.0 + (i as f32) * 5.0 + (i as f32 * 1.9).sin() * 10.0;
                let z = 25.0 + (i as f32 * 1.3).cos() * 12.0;
                let size = 1.2 + (i % 5) as f32 * 0.8;

                let (width, height, depth) = match i % 4 {
                    0 => (size, size * 2.0, size * 0.8), // Tall mesa
                    1 => (size * 1.5, size, size * 1.2), // Wide plateau
                    2 => (size * 0.6, size * 3.0, size * 0.6), // Spire
                    _ => (size, size * 0.8, size), // Regular rock
                };

                let formation_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(76 + i)
                    .build();
                let formation_handle = physics.bodies.insert(formation_rb);
                let formation_col = r3::ColliderBuilder::cuboid(width, height, depth).build();
                physics.colliders.insert_with_parent(
                    formation_col,
                    formation_handle,
                    &mut physics.bodies,
                );
            }

            // Sand dunes (represented as low, wide formations)
            for i in 0..8 {
                let x = 0.0 + (i as f32) * 15.0 + (i as f32 * 2.5).sin() * 10.0;
                let z = -25.0 + (i as f32 * 1.8).cos() * 15.0;
                let width = 4.0 + (i % 3) as f32 * 2.0;
                let height = 0.5 + (i % 2) as f32 * 0.3;

                let dune_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(400 + i)
                    .build();
                let dune_handle = physics.bodies.insert(dune_rb);
                let dune_col = r3::ColliderBuilder::cuboid(width, height, width * 0.6).build();
                physics
                    .colliders
                    .insert_with_parent(dune_col, dune_handle, &mut physics.bodies);
            }

            // === WATER FEATURES ===
            // Oasis with palm-like vegetation
            let oasis_x = 5.0;
            let oasis_z = 10.0;
            for i in 0..5 {
                let angle = (i as f32) * std::f32::consts::PI * 2.0 / 5.0;
                let radius = 3.0;
                let x = oasis_x + radius * angle.cos();
                let z = oasis_z + radius * angle.sin();

                let palm_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + 2.0, z))
                    .user_data(500 + i)
                    .build();
                let palm_handle = physics.bodies.insert(palm_rb);
                let palm_col = r3::ColliderBuilder::cuboid(0.2, 2.0, 0.2).build();
                physics
                    .colliders
                    .insert_with_parent(palm_col, palm_handle, &mut physics.bodies);
            }

            // === CHARACTERS ===
            // Desert nomads and traders
            for i in 0..8 {
                let x = 15.0 + (i as f32) * 12.0 + (i as f32).sin() * 5.0;
                let z = -5.0 + (i as f32 * 0.9).sin() * 8.0;
                let pos = Vec3::new(x, -1.0, z);

                let char_type = match i % 4 {
                    0 => CharacterType::Merchant,
                    1 => CharacterType::Guard,
                    2 => CharacterType::Animal, // Desert animals (camels, etc.)
                    _ => CharacterType::Villager, // Nomads
                };

                let mut character = Character::new(pos, char_type);

                // Longer patrol routes for desert environment
                match char_type {
                    CharacterType::Merchant => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(20.0, 0.0, 5.0),
                            pos + Vec3::new(15.0, 0.0, 15.0),
                            pos + Vec3::new(-5.0, 0.0, 10.0),
                        ];
                    }
                    CharacterType::Animal => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(8.0, 0.0, 8.0),
                            pos + Vec3::new(-5.0, 0.0, 12.0),
                            pos + Vec3::new(-8.0, 0.0, -3.0),
                        ];
                    }
                    _ => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(10.0, 0.0, 3.0),
                            pos + Vec3::new(6.0, 0.0, 8.0),
                            pos + Vec3::new(-3.0, 0.0, 5.0),
                        ];
                    }
                }
                character.target_position = if !character.patrol_points.is_empty() {
                    character.patrol_points[1]
                } else {
                    pos
                };

                characters.push(character);
            }
        }
        "forest" => {
            // === DENSE FOREST BIOME ===
            // Ancient forest with towering trees and rich undergrowth
            
            // === VEGETATION ===
            // Ancient towering trees - higher density for deep forest feeling
            for i in 0..95 {
                let x = -40.0 + (i as f32) * 1.1 + (i as f32 * 0.6).sin() * 3.0;
                let z = -30.0 + (i % 10) as f32 * 3.8 + (i as f32 * 0.8).cos() * 4.0;

                // Varied ancient tree types with dramatic height differences
                let (height, width, _tree_type) = match i % 6 {
                    0 => (4.5, 0.6, "ancient_oak"),     // Massive ancient oaks
                    1 => (3.8, 0.4, "giant_pine"),     // Tall pines
                    2 => (2.8, 0.3, "elder_birch"),    // Elder birch
                    3 => (5.2, 0.8, "world_tree"),     // Mythical world trees
                    4 => (3.2, 0.35, "cedar"),         // Tall cedars
                    _ => (2.2, 0.25, "maple"),          // Forest maples
                };

                let tree_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(10 + i)
                    .build();
                let tree_handle = physics.bodies.insert(tree_rb);
                let tree_col = r3::ColliderBuilder::cuboid(width, height, width).build();
                physics
                    .colliders
                    .insert_with_parent(tree_col, tree_handle, &mut physics.bodies);
            }

            // Dense undergrowth and ferns - forest floor vegetation
            for i in 0..60 {
                let x = -25.0 + (i as f32) * 2.0 + (i as f32 * 1.4).sin() * 6.0;
                let z = 8.0 + (i as f32 * 1.2).cos() * 15.0;
                let size = 0.15 + (i % 4) as f32 * 0.08;

                let undergrowth_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + size, z))
                    .user_data(150 + i)
                    .build();
                let undergrowth_handle = physics.bodies.insert(undergrowth_rb);
                let undergrowth_col = r3::ColliderBuilder::cuboid(size, size * 0.5, size).build();
                physics
                    .colliders
                    .insert_with_parent(undergrowth_col, undergrowth_handle, &mut physics.bodies);
            }

            // === STRUCTURES ===
            // Woodland dwellings and mystical sites
            for i in 0..8 {
                let x = 25.0 + (i as f32) * 8.0 + (i as f32).sin() * 6.0;
                let z = -5.0 + (i % 3) as f32 * 10.0 + (i as f32).cos() * 4.0;

                let (width, height, depth, _building_type) = match i % 4 {
                    0 => (2.0, 1.8, 1.6, "tree_house"),      // Elevated tree houses
                    1 => (1.2, 2.5, 1.2, "wizard_tower"),    // Tall mystical towers
                    2 => (2.5, 1.0, 2.5, "woodland_shrine"), // Ground-level shrines
                    _ => (1.6, 1.4, 1.4, "ranger_cabin"),    // Ranger cabins
                };

                let structure_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(200 + i)
                    .build();
                let structure_handle = physics.bodies.insert(structure_rb);
                let structure_col = r3::ColliderBuilder::cuboid(width, height, depth).build();
                physics
                    .colliders
                    .insert_with_parent(structure_col, structure_handle, &mut physics.bodies);
            }

            // === GEOLOGICAL FEATURES ===
            // Moss-covered boulders and ancient stone formations
            for i in 0..18 {
                let x = -35.0 + (i as f32) * 7.0 + (i as f32 * 2.2).sin() * 10.0;
                let z = 25.0 + (i as f32 * 1.8).cos() * 12.0;
                let size = 1.0 + (i % 3) as f32 * 0.6;

                let boulder_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + size * 0.8, z))
                    .user_data(250 + i)
                    .build();
                let boulder_handle = physics.bodies.insert(boulder_rb);
                let boulder_col = r3::ColliderBuilder::cuboid(size, size * 0.8, size * 0.9).build();
                physics
                    .colliders
                    .insert_with_parent(boulder_col, boulder_handle, &mut physics.bodies);
            }

            // Ancient stone circles (mystical sites)
            let circle_center_x = 0.0;
            let circle_center_z = 15.0;
            for i in 0..8 {
                let angle = (i as f32) * std::f32::consts::PI * 2.0 / 8.0;
                let radius = 8.0;
                let x = circle_center_x + radius * angle.cos();
                let z = circle_center_z + radius * angle.sin();

                let stone_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + 1.5, z))
                    .user_data(300 + i)
                    .build();
                let stone_handle = physics.bodies.insert(stone_rb);
                let stone_col = r3::ColliderBuilder::cuboid(0.5, 1.5, 0.3).build();
                physics
                    .colliders
                    .insert_with_parent(stone_col, stone_handle, &mut physics.bodies);
            }

            // === WATER FEATURES ===
            // Forest streams and pools
            for i in 0..3 {
                let x = -10.0 + (i as f32) * 15.0;
                let z = -12.0 + (i as f32) * 8.0;

                let pool_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + 0.2, z))
                    .user_data(350 + i)
                    .build();
                let pool_handle = physics.bodies.insert(pool_rb);
                let pool_col = r3::ColliderBuilder::cuboid(2.0, 0.2, 1.5).build();
                physics
                    .colliders
                    .insert_with_parent(pool_col, pool_handle, &mut physics.bodies);
            }

            // === CHARACTERS ===
            // Forest dwellers and mystical beings
            for i in 0..10 {
                let x = -20.0 + (i as f32) * 8.0 + (i as f32 * 1.1).sin() * 12.0;
                let z = -10.0 + (i as f32 * 0.9).cos() * 18.0;
                let pos = Vec3::new(x, -1.5, z);

                let char_type = match i % 5 {
                    0 => CharacterType::Guard,    // Forest rangers
                    1 => CharacterType::Merchant, // Herb gatherers
                    2 => CharacterType::Villager, // Forest dwellers  
                    3 => CharacterType::Guard,    // Druids (using guard type)
                    _ => CharacterType::Villager, // Woodland folk
                };

                let mut character = Character::new(pos, char_type);

                // Forest-specific patrol routes through the trees
                match i % 4 {
                    0 => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(6.0, 0.0, 2.0),
                            pos + Vec3::new(4.0, 0.0, 8.0),
                            pos + Vec3::new(-2.0, 0.0, 6.0),
                            pos + Vec3::new(-4.0, 0.0, 2.0),
                        ];
                    }
                    1 => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(-5.0, 0.0, 3.0),
                            pos + Vec3::new(-3.0, 0.0, -4.0),
                            pos + Vec3::new(2.0, 0.0, -2.0),
                        ];
                    }
                    2 => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(8.0, 0.0, -1.0),
                            pos + Vec3::new(5.0, 0.0, -6.0),
                            pos + Vec3::new(-1.0, 0.0, -4.0),
                        ];
                    }
                    _ => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(2.0, 0.0, 7.0),
                            pos + Vec3::new(-3.0, 0.0, 5.0),
                            pos + Vec3::new(-1.0, 0.0, 1.0),
                        ];
                    }
                }

                characters.push(character);
            }
        }
        _ => {
            // Enhanced default environment with mixed biome features
            for i in 0..15 {
                let x = -12.0 + (i as f32) * 2.5;
                let z = 3.0 + (i % 3) as f32 * 6.0 + (i as f32).sin() * 3.0;
                let height = 1.0 + (i % 4) as f32 * 0.8;

                let obj_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(50 + i)
                    .build();
                let obj_handle = physics.bodies.insert(obj_rb);
                let obj_col = r3::ColliderBuilder::cuboid(0.6, height, 0.6).build();
                physics
                    .colliders
                    .insert_with_parent(obj_col, obj_handle, &mut physics.bodies);
            }

            // Default characters with simple behavior
            for i in 0..6 {
                let x = (i as f32) * 6.0;
                let z = (i % 2) as f32 * 4.0;
                let pos = Vec3::new(x, -1.0, z);
                let mut character = Character::new(pos, CharacterType::Villager);
                character.patrol_points = vec![
                    pos,
                    pos + Vec3::new(4.0, 0.0, 0.0),
                    pos + Vec3::new(4.0, 0.0, 4.0),
                    pos + Vec3::new(0.0, 0.0, 4.0),
                ];
                character.target_position = character.patrol_points[1];
                characters.push(character);
            }
        }
    }

    characters
}

// ------------------------------- Main entry -------------------------------

fn main() -> Result<()> {
    // Use pollster to block on the async run
    pollster::block_on(run())
}

async fn run() -> Result<()> {
    // Generate default textures at startup if missing (seed -> vary looks)
    let seed = 0xA57; // change to taste / hook to key for regeneration
    texture_synth::ensure_textures("assets", seed, true)?;

    // Boilerplate: create event loop and window
    let event_loop = EventLoop::new()?;
    let window = std::sync::Arc::new(
        WindowBuilder::new()
            .with_title("AstraWeave Unified Showcase (Modified)")
            .build(&event_loop)?,
    );
    // Setup renderer, UI, physics
    let mut render = setup_renderer(window.clone()).await?;
    let mut physics = build_physics_world();

    // Initialize default environment and texture pack
    let mut characters = generate_environment_objects(&mut physics, "grassland");

    // Load the initial grassland texture pack
    if let Err(e) = reload_texture_pack(&mut render, "grassland") {
        println!(
            "Warning: Failed to load initial grassland texture pack: {}",
            e
        );
        println!("Continuing with default textures...");
        println!(
            "Note: You can still switch texture packs using keys 1 (grassland) and 2 (desert)"
        );
    } else {
        println!("Successfully loaded initial grassland texture pack");
        println!(
            "Controls: WASD+mouse=camera, P=pause physics, T=teleport sphere, E=apply impulse, C=toggle camera mode"
        );
        println!("Mouse wheel: zoom camera | Right-click + mouse: look around");
        println!("Texture packs: Press 1 for grassland, 2 for desert, 3 for forest");
    }

    let mut instances = build_show_instances();
    let mut ui = UiState::default();

    // Use proper camera system from astraweave-render with enhanced positioning for optimal biome showcase
    let mut camera = RenderCamera {
        position: Vec3::new(15.0, 12.0, 30.0), // Enhanced position to better showcase biome diversity
        yaw: -0.3,    // Better angle to view village, forest, and terrain features
        pitch: -0.4,  // Optimal pitch to see both terrain detail and sky
        fovy: 70f32.to_radians(), // Optimized field of view for biome immersion
        aspect: 1.0,
        znear: 0.01,
        zfar: 10000.0, // Extended far plane for maximum terrain visibility
    };
    let mut camera_controller = CameraController::new(8.0, 0.002);
    let mut last = Instant::now();
    let mut fps_acc = 0.0;
    let mut fps_cnt = 0u32;

    let elwt = event_loop;
    let _ = elwt.run(move |event, elwt_window_target| {
        elwt_window_target.set_control_flow(winit::event_loop::ControlFlow::Poll);
        match event {
            Event::WindowEvent {
                event: win_event, ..
            } => {
                match win_event {
                    WindowEvent::CloseRequested => {
                        elwt_window_target.exit();
                    }
                    WindowEvent::KeyboardInput {
                        event:
                            KeyEvent {
                                physical_key,
                                state,
                                ..
                            },
                        ..
                    } => {
                        let pressed = state == ElementState::Pressed;
                        match physical_key {
                            PhysicalKey::Code(code) => {
                                camera_controller.process_keyboard(code, pressed);
                                match code {
                                    KeyCode::Escape => {
                                        if pressed {
                                            elwt_window_target.exit();
                                        }
                                    }
                                    KeyCode::KeyP => {
                                        if pressed {
                                            ui.physics_paused = !ui.physics_paused;
                                        }
                                    }
                                    KeyCode::KeyT => {
                                        if pressed {
                                            // Teleport sphere a few meters in front of camera
                                            let forward = astraweave_render::camera::Camera::dir(
                                                camera.yaw,
                                                camera.pitch,
                                            );
                                            let target = camera.position
                                                + forward * 4.0
                                                + Vec3::new(0.0, -0.5, 0.0);
                                            teleport_sphere_to(&mut physics, target);
                                        }
                                    }
                                    KeyCode::KeyE => {
                                        if pressed {
                                            // Raycast forward and apply impulse to first hit dynamic body
                                            let forward = astraweave_render::camera::Camera::dir(
                                                camera.yaw,
                                                camera.pitch,
                                            );

                                            // Create a ray for the query
                                            let ray_origin = nalgebra::Point3::new(
                                                camera.position.x,
                                                camera.position.y,
                                                camera.position.z,
                                            );
                                            let ray_dir = nalgebra::Vector3::new(
                                                forward.x, forward.y, forward.z,
                                            );
                                            let ray = r3::Ray::new(ray_origin, ray_dir);

                                            // Update the query pipeline with just the colliders
                                            physics.query_pipeline.update(&physics.colliders);

                                            // Cast the ray
                                            if let Some((h, _toi)) =
                                                physics.query_pipeline.cast_ray(
                                                    &physics.bodies,
                                                    &physics.colliders,
                                                    &ray,
                                                    15.0,
                                                    true,
                                                    r3::QueryFilter::default(),
                                                )
                                            {
                                                if let Some(body) =
                                                    physics.bodies.get_mut(r3::RigidBodyHandle(h.0))
                                                {
                                                    if !body.is_fixed() {
                                                        let impulse = nalgebra::Vector3::new(
                                                            forward.x * 3.0,
                                                            1.0,
                                                            forward.z * 3.0,
                                                        );
                                                        body.apply_impulse(impulse, true);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    KeyCode::KeyC => {
                                        if pressed {
                                            camera_controller.toggle_mode(&mut camera);
                                            println!("Camera mode: {:?}", camera_controller.mode);
                                        }
                                    }
                                    KeyCode::Digit1 => {
                                        if pressed {
                                            let pack_name = "grassland";
                                            if let Err(e) =
                                                reload_texture_pack(&mut render, pack_name)
                                            {
                                                println!(
                                                    "Failed to switch to {} texture pack: {}",
                                                    pack_name, e
                                                );
                                            } else {
                                                ui.current_texture_pack = pack_name.to_string();
                                                ui.info_text = format!(
                                                    "Switched to {} environment",
                                                    pack_name
                                                );
                                                characters = generate_environment_objects(
                                                    &mut physics,
                                                    pack_name,
                                                );
                                            }
                                        }
                                    }
                                    KeyCode::Digit2 => {
                                        if pressed {
                                            let pack_name = "desert";
                                            println!("Attempting to switch to desert texture pack...");
                                            if let Err(e) =
                                                reload_texture_pack(&mut render, pack_name)
                                            {
                                                println!(
                                                    "Failed to switch to {} texture pack: {}",
                                                    pack_name, e
                                                );
                                            } else {
                                                ui.current_texture_pack = pack_name.to_string();
                                                ui.info_text = format!(
                                                    "Switched to {} environment",
                                                    pack_name
                                                );
                                                println!("Successfully switched to desert texture pack");
                                                characters = generate_environment_objects(
                                                    &mut physics,
                                                    pack_name,
                                                );
                                                println!("Regenerated {} desert environment objects", characters.len());
                                            }
                                        }
                                    }
                                    KeyCode::Digit3 => {
                                        if pressed {
                                            let pack_name = "forest";
                                            if let Err(e) =
                                                reload_texture_pack(&mut render, pack_name)
                                            {
                                                println!(
                                                    "Failed to switch to {} texture pack: {}",
                                                    pack_name, e
                                                );
                                            } else {
                                                println!(
                                                    "Switched to {} environment",
                                                    pack_name
                                                );
                                                characters = generate_environment_objects(
                                                    &mut physics,
                                                    pack_name,
                                                );
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            _ => {}
                        }
                    }
                    WindowEvent::MouseInput { state, button, .. } => {
                        camera_controller
                            .process_mouse_button(button, state == ElementState::Pressed);
                        if button == winit::event::MouseButton::Right {
                            let pressed = state == ElementState::Pressed;
                            // Grab or release cursor for reliable deltas
                            if pressed {
                                let _ = window.set_cursor_grab(CursorGrabMode::Locked);
                                window.set_cursor_visible(false);
                            } else {
                                let _ = window.set_cursor_grab(CursorGrabMode::None);
                                window.set_cursor_visible(true);
                            }
                        }
                    }
                    WindowEvent::MouseWheel {
                        delta: MouseScrollDelta::LineDelta(_, y),
                        ..
                    } => {
                        // Use camera controller for zoom instead of speed adjustment
                        camera_controller.process_scroll(&mut camera, y);
                    }
                    WindowEvent::Resized(size) => {
                        render.surface_cfg.width = size.width.max(1);
                        render.surface_cfg.height = size.height.max(1);
                        render
                            .surface
                            .configure(&render.device, &render.surface_cfg);
                        render.depth_view = create_depth(
                            &render.device,
                            render.surface_cfg.width,
                            render.surface_cfg.height,
                            render.msaa_samples,
                        );
                        // Recreate MSAA color target
                        render.msaa_color_view = if render.msaa_samples > 1 {
                            Some(create_msaa_color(
                                &render.device,
                                render.surface_cfg.format,
                                render.surface_cfg.width,
                                render.surface_cfg.height,
                                render.msaa_samples,
                            ))
                        } else { None };

                        // Update UI info with character count
                        ui.info_text = format!(
                            "Environment: {} ({} characters)",
                            ui.current_texture_pack,
                            characters.len()
                        );
                    }
                    WindowEvent::RedrawRequested => {
                        let now = Instant::now();
                        let dt = now - last;
                        last = now;

                        // smooth FPS
                        let fps = 1.0 / dt.as_secs_f32().max(1e-5);
                        fps_acc += fps;
                        fps_cnt += 1;
                        if fps_cnt >= 30 {
                            ui.fps_text = format!("{:.1} fps", fps_acc / fps_cnt as f32);
                            fps_acc = 0.0;
                            fps_cnt = 0;
                        }

                        // Update camera
                        camera.aspect = (render.surface_cfg.width as f32 * ui.resolution_scale)
                            .max(1.0)
                            / (render.surface_cfg.height as f32 * ui.resolution_scale).max(1.0);

                        // Update camera with controller
                        camera_controller.update_camera(&mut camera, dt.as_secs_f32());

                        // Update characters
                        for character in &mut characters {
                            character.update(dt.as_secs_f32());
                        }

                        // Physics
                        if !ui.physics_paused {
                            physics_step(&mut physics);
                        }

                        // Sync sim to render and batch instances by mesh type
                        sync_instances_from_physics(&physics, &characters, camera.position, &mut instances);
                        render.instance_count = instances.len() as u32;
                        
                        // Batch instances by mesh type for efficient rendering
                        let instance_batches = batch_instances_by_mesh_type(&instances);

                        // Camera uniform
                        let cam = GpuCamera {
                            view_proj: camera.vp().to_cols_array(),
                        };
                        render
                            .queue
                            .write_buffer(&render.camera_ub, 0, bytemuck::bytes_of(&cam));

                        // Prepare command encoder (reused for shadow and main passes)
                        let mut encoder = render.device.create_command_encoder(&wgpu::CommandEncoderDescriptor { label: Some("frame-encoder") });

                        // Update light matrices (directional light)
                        let light_dir = glam::Vec3::new(0.6, 1.0, 0.4).normalize();
                        let light_view = Mat4::look_at_rh(-light_dir * 150.0, Vec3::ZERO, Vec3::Y);
                        let ortho_extent = 220.0;
                        let light_proj = Mat4::orthographic_rh(
                            -ortho_extent, ortho_extent,
                            -ortho_extent, ortho_extent,
                            0.1, 400.0,
                        );
                        let light_vp = light_proj * light_view;
                        let lcam = GpuCamera { view_proj: light_vp.to_cols_array() };
                        render.queue.write_buffer(&render.light_ub, 0, bytemuck::bytes_of(&lcam));

                        // Shadow pass
                        {
                            let mut sp = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                                label: Some("shadow-pass"),
                                color_attachments: &[],
                                depth_stencil_attachment: Some(wgpu::RenderPassDepthStencilAttachment {
                                    view: &render.shadow_view,
                                    depth_ops: Some(wgpu::Operations { load: wgpu::LoadOp::Clear(1.0), store: wgpu::StoreOp::Store }),
                                    stencil_ops: None,
                                }),
                                timestamp_writes: None,
                                occlusion_query_set: None,
                            });
                            sp.set_pipeline(&render.shadow_pipeline);
                            sp.set_bind_group(0, &render.light_bg, &[]);
                            for batch in &instance_batches {
                                if batch.mesh_type == MeshType::Skybox { continue; }
                                if let Some(mesh) = render.meshes.get(&batch.mesh_type) {
                                    render.queue.write_buffer(&render.instance_vb, 0, bytemuck::cast_slice(&batch.instances));
                                    sp.set_vertex_buffer(0, mesh.vertex_buffer.slice(..));
                                    sp.set_vertex_buffer(1, render.instance_vb.slice(..));
                                    sp.set_index_buffer(mesh.index_buffer.slice(..), wgpu::IndexFormat::Uint32);
                                    if !batch.instances.is_empty() {
                                        sp.draw_indexed(0..mesh.index_count, 0, 0..batch.instances.len() as u32);
                                    }
                                }
                            }
                        }

                        // Render
                        let frame = match render.surface.get_current_texture() {
                            Ok(f) => f,
                            Err(_) => {
                                render
                                    .surface
                                    .configure(&render.device, &render.surface_cfg);
                                render.surface.get_current_texture().unwrap()
                            }
                        };
                        let view = frame
                            .texture
                            .create_view(&wgpu::TextureViewDescriptor::default());
                        {
                            let mut rp = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                                label: Some("main-pass"),
                                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                                    view: render.msaa_color_view.as_ref().unwrap_or(&view),
                                    resolve_target: if render.msaa_samples > 1 { Some(&view) } else { None },
                                    ops: wgpu::Operations {
                                        load: wgpu::LoadOp::Clear(wgpu::Color {
                                            r: 0.4,  // Sky color that matches procedural sky
                                            g: 0.6,  // to eliminate void appearance
                                            b: 0.9,  // if skybox has any gaps
                                            a: 1.0,
                                        }),
                                        store: wgpu::StoreOp::Store,
                                    },
                                })],
                                depth_stencil_attachment: Some(
                                    wgpu::RenderPassDepthStencilAttachment {
                                        view: &render.depth_view,
                                        depth_ops: Some(wgpu::Operations {
                                            load: wgpu::LoadOp::Clear(1.0),
                                            store: wgpu::StoreOp::Store,
                                        }),
                                        stencil_ops: None,
                                    },
                                ),
                                timestamp_writes: None,
                                occlusion_query_set: None,
                            });
                            rp.set_pipeline(&render.pipeline);
                            rp.set_bind_group(0, &render.camera_bg, &[]);
                            if let Some(ref texture_bg) = render.ground_bind_group { rp.set_bind_group(1, texture_bg, &[]); }
                            rp.set_bind_group(2, &render.shadow_bg, &[]);
                            rp.set_bind_group(3, &render.light_bg, &[]);
                            // Render each mesh type batch efficiently
                            // Render skybox first with special depth handling
                            for batch in &instance_batches {
                                if batch.mesh_type == MeshType::Skybox {
                                    if let Some(mesh) = render.meshes.get(&batch.mesh_type) {
                                        // Upload skybox instances to the instance buffer
                                        render.queue.write_buffer(
                                            &render.instance_vb,
                                            0,
                                            bytemuck::cast_slice(&batch.instances),
                                        );
                                        
                                        // Set up rendering for skybox - render at far plane
                                        rp.set_vertex_buffer(0, mesh.vertex_buffer.slice(..));
                                        rp.set_vertex_buffer(1, render.instance_vb.slice(..));
                                        rp.set_index_buffer(mesh.index_buffer.slice(..), wgpu::IndexFormat::Uint32);
                                        
                                        // Draw skybox
                                        if !batch.instances.is_empty() {
                                            rp.draw_indexed(
                                                0..mesh.index_count,
                                                0,
                                                0..batch.instances.len() as u32,
                                            );
                                        }
                                    }
                                }
                            }
                            
                            // Render all other mesh types after skybox
                            for batch in &instance_batches {
                                if batch.mesh_type != MeshType::Skybox {
                                    if let Some(mesh) = render.meshes.get(&batch.mesh_type) {
                                        // Upload this batch's instances to the instance buffer
                                        render.queue.write_buffer(
                                            &render.instance_vb,
                                            0,
                                            bytemuck::cast_slice(&batch.instances),
                                        );
                                        
                                        // Set up rendering for this mesh type
                                        rp.set_vertex_buffer(0, mesh.vertex_buffer.slice(..));
                                        rp.set_vertex_buffer(1, render.instance_vb.slice(..));
                                        rp.set_index_buffer(mesh.index_buffer.slice(..), wgpu::IndexFormat::Uint32);
                                        
                                        // Draw this batch
                                        if !batch.instances.is_empty() {
                                            rp.draw_indexed(
                                                0..mesh.index_count,
                                                0,
                                                0..batch.instances.len() as u32,
                                            );
                                        }
                                    }
                                }
                            }
                        }
                        render.queue.submit(Some(encoder.finish()));
                        frame.present();
                    }
                    _ => {}
                }
            }
            Event::AboutToWait => {
                window.request_redraw();
            }
            Event::DeviceEvent {
                event: DeviceEvent::MouseMotion { delta },
                ..
            } => {
                // Use proper mouse delta handling for camera controller
                let mouse_delta = Vec2::new(delta.0 as f32, delta.1 as f32);
                camera_controller.process_mouse_delta(&mut camera, mouse_delta);
            }
            _ => {}
        }
    });
    Ok(())
}

// ---------------- Helper functions for default textures ----------------

fn create_default_albedo_texture(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
) -> Result<LoadedTexture> {
    let white_texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("default-white"),
        size: wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Rgba8UnormSrgb,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });
    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &white_texture,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &[255, 255, 255, 255], // RGBA white
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4),
            rows_per_image: Some(1),
        },
        wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
    );
    let view = white_texture.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::Repeat,
        address_mode_v: wgpu::AddressMode::Repeat,
        address_mode_w: wgpu::AddressMode::Repeat,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
        anisotropy_clamp: 8,
        ..Default::default()
    });
    Ok(LoadedTexture {
        texture: white_texture,
        view,
        sampler,
    })
}

fn create_default_normal_texture(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
) -> Result<LoadedTexture> {
    let normal_texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("default-normal"),
        size: wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
    format: wgpu::TextureFormat::Rgba8Unorm,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });
    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &normal_texture,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &[128, 128, 255, 255], // Default normal pointing up (0, 0, 1) in normal map encoding
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4),
            rows_per_image: Some(1),
        },
        wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
    );
    let view = normal_texture.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::Repeat,
        address_mode_v: wgpu::AddressMode::Repeat,
        address_mode_w: wgpu::AddressMode::Repeat,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
    anisotropy_clamp: 8,
        ..Default::default()
    });
    Ok(LoadedTexture {
        texture: normal_texture,
        view,
        sampler,
    })
}

// Default MRA texture: R=AO=1.0 (no occlusion), G=Roughness=0.8, B=Metallic=0.0
fn create_default_mra_texture(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
) -> Result<LoadedTexture> {
    let mra_tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("default-mra"),
        size: wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
    format: wgpu::TextureFormat::Rgba8Unorm,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });
    // RGBA: AO, Roughness, Metallic, unused
    let ao = (1.0 * 255.0) as u8;
    let rough = (0.8 * 255.0) as u8;
    let metal = (0.0 * 255.0) as u8;
    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &mra_tex,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &[ao, rough, metal, 255],
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4),
            rows_per_image: Some(1),
        },
        wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
    );
    let view = mra_tex.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::Repeat,
        address_mode_v: wgpu::AddressMode::Repeat,
        address_mode_w: wgpu::AddressMode::Repeat,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
        anisotropy_clamp: 8,
        ..Default::default()
    });
    Ok(LoadedTexture { texture: mra_tex, view, sampler })
}

// Default emissive texture: black (no emission)
fn create_default_emissive_texture(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
) -> Result<LoadedTexture> {
    let e_tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("default-emissive"),
        size: wgpu::Extent3d { width: 1, height: 1, depth_or_array_layers: 1 },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
    format: wgpu::TextureFormat::Rgba8UnormSrgb,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });
    queue.write_texture(
        wgpu::ImageCopyTexture { texture: &e_tex, mip_level: 0, origin: wgpu::Origin3d::ZERO, aspect: wgpu::TextureAspect::All },
        &[0, 0, 0, 255],
        wgpu::ImageDataLayout { offset: 0, bytes_per_row: Some(4), rows_per_image: Some(1) },
        wgpu::Extent3d { width: 1, height: 1, depth_or_array_layers: 1 },
    );
    let view = e_tex.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::Repeat,
        address_mode_v: wgpu::AddressMode::Repeat,
        address_mode_w: wgpu::AddressMode::Repeat,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Linear,
        anisotropy_clamp: 8,
        ..Default::default()
    });
    Ok(LoadedTexture { texture: e_tex, view, sampler })
}

// Fallback: create a 1x1 texture matching the color of an existing texture's first texel
fn default_albedo_clone(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
    _src: &LoadedTexture,
) -> Result<LoadedTexture> {
    // We don't read from GPU; just make a neutral 1x1 white as a safe stand-in
    create_default_albedo_texture(device, queue)
}

// ---------------- renderer setup ----------------
// Structure to hold batched instance data for efficient rendering
struct InstanceBatch {
    instances: Vec<InstanceRaw>,
    mesh_type: MeshType,
}

fn batch_instances_by_mesh_type(instances: &[InstanceRaw]) -> Vec<InstanceBatch> {
    let mut batches = Vec::new();
    
    // Create separate batches for each mesh type including skybox
    for &mesh_type_val in &[MeshType::Skybox as u32, MeshType::Cube as u32, MeshType::Tree as u32, MeshType::House as u32, MeshType::Character as u32] {
        let mesh_type = match mesh_type_val {
            0 => MeshType::Cube,
            1 => MeshType::Tree,
            2 => MeshType::House,
            3 => MeshType::Character,
            4 => MeshType::Skybox,
            _ => MeshType::Cube,
        };
        
        let filtered_instances: Vec<InstanceRaw> = instances
            .iter()
            .filter(|instance| instance.mesh_type == mesh_type_val)
            .copied()
            .collect();
            
        if !filtered_instances.is_empty() {
            batches.push(InstanceBatch {
                instances: filtered_instances,
                mesh_type,
            });
        }
    }
    
    batches
}

// Generate terrain mesh with height variations matching the shader logic
fn generate_terrain_mesh(size: usize, scale: f32) -> (Vec<[f32; 3]>, Vec<u32>) {
    let mut vertices = Vec::new();
    let mut indices = Vec::new();
    
    // Generate vertices with height variation
    for z in 0..=size {
        for x in 0..=size {
            let world_x = (x as f32 - size as f32 * 0.5) * scale;
            let world_z = (z as f32 - size as f32 * 0.5) * scale;
            
            // Match the shader's biome and terrain height logic
            let world_pos = [world_x, world_z];
            let biome_type = get_biome_type_rust(world_pos);
            let terrain_height = get_biome_terrain_height_rust(world_pos, biome_type);
            
            vertices.push([world_x, -2.0 + terrain_height, world_z]);
        }
    }
    
    // Generate indices for triangles
    for z in 0..size {
        for x in 0..size {
            let i0 = (z * (size + 1) + x) as u32;
            let i1 = (z * (size + 1) + x + 1) as u32;
            let i2 = ((z + 1) * (size + 1) + x) as u32;
            let i3 = ((z + 1) * (size + 1) + x + 1) as u32;
            
            // Two triangles per quad
            indices.extend_from_slice(&[i0, i2, i1, i1, i2, i3]);
        }
    }
    
    (vertices, indices)
}

// Rust implementation of shader biome detection
fn get_biome_type_rust(world_pos: [f32; 2]) -> i32 {
    let biome_scale = 0.02;
    let biome_pos = [world_pos[0] * biome_scale, world_pos[1] * biome_scale];
    
    let primary_noise = (biome_pos[0] * 3.0).sin() * (biome_pos[1] * 2.0).cos();
    let secondary_noise = ((biome_pos[0] * 1.5) + 100.0).sin() * ((biome_pos[1] * 1.8) + 200.0).cos();
    let combined_noise = primary_noise * 0.7 + secondary_noise * 0.3;
    
    if combined_noise > 0.3 {
        1 // Desert
    } else if combined_noise < -0.2 {
        2 // Dense Forest
    } else {
        0 // Grassland
    }
}

// Rust implementation of shader terrain height generation
fn get_biome_terrain_height_rust(world_pos: [f32; 2], biome_type: i32) -> f32 {
    let base_scale = 0.005;
    let detail_scale = 0.02;
    let fine_scale = 0.15;
    let micro_scale = 0.8;
    
    let base_noise = (world_pos[0] * base_scale).sin() * (world_pos[1] * base_scale).cos();
    let detail_noise = ((world_pos[0] * detail_scale) + 1.0).sin() * ((world_pos[1] * detail_scale) + 1.5).cos();
    let fine_noise = ((world_pos[0] * fine_scale) + 2.0).sin() * ((world_pos[1] * fine_scale) + 2.5).cos();
    let micro_noise = ((world_pos[0] * micro_scale) + 3.0).sin() * ((world_pos[1] * micro_scale) + 3.5).cos();
    
    let combined_noise = base_noise * 0.5 + detail_noise * 0.25 + fine_noise * 0.15 + micro_noise * 0.1;
    
    match biome_type {
        0 => { // Grassland
            let grassland_height = combined_noise * 4.0;
            
            // River valleys
            let river_x = (world_pos[0] * 0.006).sin() * 0.8;
            let river_z = (world_pos[1] * 0.004).cos() * 0.6;
            let river_noise = ((world_pos[0] + river_z * 20.0) * 0.008).sin() * ((world_pos[1] + river_x * 15.0) * 0.01).cos();
            let valley_factor = 1.0 - river_noise.abs();
            let valley_depth = valley_factor * valley_factor * valley_factor * -3.0;
            
            // Rolling hills
            let hill_pattern = (world_pos[0] * 0.01).sin() * (world_pos[1] * 0.012).cos() * 2.0;
            
            grassland_height + valley_depth + hill_pattern
        },
        1 => { // Desert
            let desert_height = combined_noise * 5.0;
            
            // Sand dunes
            let dune_scale = 0.02;
            let dune_noise = (world_pos[0] * dune_scale).sin() + (world_pos[1] * dune_scale * 0.6).cos();
            let wind_direction = (world_pos[0] * 0.001).sin() * (world_pos[1] * 0.0008).cos();
            let dune_height = (dune_noise + wind_direction * 0.5) * 2.5;
            
            // Mesa formations
            let mesa_scale = 0.003;
            let mesa_noise = (world_pos[0] * mesa_scale).sin() * (world_pos[1] * mesa_scale).cos();
            let mesa_height = if mesa_noise > 0.2 { 8.0 } else { 0.0 };
            
            desert_height + dune_height + mesa_height
        },
        _ => { // Forest
            let forest_height = combined_noise * 3.5;
            
            // Rolling forest floor with clearings
            let clearing_scale = 0.008;
            let clearing_noise = (world_pos[0] * clearing_scale).sin() * (world_pos[1] * clearing_scale * 0.7).cos();
            let elevation_mod = if clearing_noise > 0.4 { -1.5 } else { 1.0 };
            
            forest_height + elevation_mod
        }
    }
}

fn create_mesh(device: &wgpu::Device, vertices: &[[f32; 3]], indices: &[u32]) -> Mesh {
    let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("mesh-vertices"),
        contents: bytemuck::cast_slice(vertices),
        usage: wgpu::BufferUsages::VERTEX,
    });
    
    let index_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("mesh-indices"),
        contents: bytemuck::cast_slice(indices),
        usage: wgpu::BufferUsages::INDEX,
    });
    
    Mesh {
        vertex_buffer,
        index_buffer,
        index_count: indices.len() as u32,
    }
}

fn to_u32_indices(src: &[u16]) -> Vec<u32> { src.iter().map(|&i| i as u32).collect() }

fn create_all_meshes(device: &wgpu::Device) -> std::collections::HashMap<MeshType, Mesh> {
    let mut meshes = std::collections::HashMap::new();
    
    // Generate terrain mesh instead of simple cube for ground
    let terrain_size = 256; // higher resolution grid
    let terrain_scale = 6.0; // tighter spacing to increase detail
    let (terrain_vertices, terrain_indices) = generate_terrain_mesh(terrain_size, terrain_scale);
    
    // Create terrain mesh as Cube type (since ground uses MeshType::Cube)
    meshes.insert(MeshType::Cube, create_mesh(device, &terrain_vertices, &terrain_indices));
    meshes.insert(MeshType::Tree, create_mesh(device, TREE_VERTICES, &to_u32_indices(TREE_INDICES)));
    meshes.insert(MeshType::House, create_mesh(device, HOUSE_VERTICES, &to_u32_indices(HOUSE_INDICES)));
    meshes.insert(MeshType::Character, create_mesh(device, CHARACTER_VERTICES, &to_u32_indices(CHARACTER_INDICES)));
    meshes.insert(MeshType::Skybox, create_mesh(device, SKY_FS_VERTICES, &to_u32_indices(SKY_FS_INDICES)));
    
    meshes
}

async fn setup_renderer(window: std::sync::Arc<winit::window::Window>) -> Result<RenderStuff> {
    let size = window.inner_size();
    println!(
        "Setting up wgpu renderer with window size: {}x{}",
        size.width, size.height
    );

    // Enable debug features for better error reporting
    let instance = wgpu::Instance::new(wgpu::InstanceDescriptor {
        backends: wgpu::Backends::all(),
        flags: wgpu::InstanceFlags::DEBUG | wgpu::InstanceFlags::VALIDATION,
        ..Default::default()
    });

    println!("Creating surface...");
    let surface = instance.create_surface(window.clone())?;

    println!("Requesting adapter...");
    let adapter = instance
        .request_adapter(&wgpu::RequestAdapterOptions {
            power_preference: wgpu::PowerPreference::HighPerformance,
            compatible_surface: Some(&surface),
            force_fallback_adapter: false,
        })
        .await
        .unwrap();

    println!("Adapter found: {:?}", adapter.get_info());

    println!("Requesting device...");
    let (device, queue) = adapter
        .request_device(
            &wgpu::DeviceDescriptor {
                label: Some("device"),
                required_features: wgpu::Features::empty(),
                required_limits: wgpu::Limits::default(),
            },
            None, // Enable validation for debug builds: Some(&std::path::Path::new("wgpu_trace"))
        )
        .await
        .unwrap();

    println!("Device created successfully");

    let msaa_samples = 4u32; // enable 4x MSAA
    let caps = surface.get_capabilities(&adapter);
    println!("Surface capabilities: {:?}", caps);

    let surface_format = caps
        .formats
        .iter()
        .copied()
        .find(|f| f.is_srgb())
        .unwrap_or(caps.formats[0]);

    println!("Selected surface format: {:?}", surface_format);
    let surface_cfg = wgpu::SurfaceConfiguration {
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
        format: surface_format,
        width: size.width.max(1),
        height: size.height.max(1),
        present_mode: caps.present_modes[0],
        alpha_mode: caps.alpha_modes[0],
        view_formats: vec![],
        desired_maximum_frame_latency: 2,
    };
    surface.configure(&device, &surface_cfg);
    let depth_view = create_depth(&device, surface_cfg.width, surface_cfg.height, msaa_samples);
    let msaa_color_view = if msaa_samples > 1 {
        Some(create_msaa_color(
            &device,
            surface_cfg.format,
            surface_cfg.width,
            surface_cfg.height,
            msaa_samples,
        ))
    } else {
        None
    };

    // Create all meshes
    let meshes = create_all_meshes(&device);

    // Create camera uniform buffer and bind group layout
    let camera_ub = device.create_buffer(&wgpu::BufferDescriptor {
        label: Some("camera-ub"),
        size: std::mem::size_of::<GpuCamera>() as u64,
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        mapped_at_creation: false,
    });
    let camera_bg_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("camera-layout"),
        entries: &[wgpu::BindGroupLayoutEntry {
            binding: 0,
            visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
            ty: wgpu::BindingType::Buffer {
                ty: wgpu::BufferBindingType::Uniform,
                has_dynamic_offset: false,
                min_binding_size: None,
            },
            count: None,
        }],
    });
    let camera_bg = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("camera-bg"),
        layout: &camera_bg_layout,
        entries: &[wgpu::BindGroupEntry {
            binding: 0,
            resource: camera_ub.as_entire_binding(),
        }],
    });

    // Light uniform and bind group (holds light view-projection)
    let light_ub = device.create_buffer(&wgpu::BufferDescriptor {
        label: Some("light-ub"),
        size: std::mem::size_of::<GpuCamera>() as u64,
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        mapped_at_creation: false,
    });
    let light_bg_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("light-layout"),
        entries: &[wgpu::BindGroupLayoutEntry {
            binding: 0,
            visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
            ty: wgpu::BindingType::Buffer {
                ty: wgpu::BufferBindingType::Uniform,
                has_dynamic_offset: false,
                min_binding_size: None,
            },
            count: None,
        }],
    });
    let light_bg = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("light-bg"),
        layout: &light_bg_layout,
        entries: &[wgpu::BindGroupEntry { binding: 0, resource: light_ub.as_entire_binding() }],
    });

    // Texture bind group layout (for PBR: albedo + normal + MRA + emissive)
    let texture_bind_group_layout =
        device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("pbr-textures"),
            entries: &[
                // binding 0: albedo texture
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        multisampled: false,
                        view_dimension: wgpu::TextureViewDimension::D2,
                        sample_type: wgpu::TextureSampleType::Float { filterable: true },
                    },
                    count: None,
                },
                // binding 1: albedo sampler
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                    count: None,
                },
                // binding 2: normal texture
                wgpu::BindGroupLayoutEntry {
                    binding: 2,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        multisampled: false,
                        view_dimension: wgpu::TextureViewDimension::D2,
                        sample_type: wgpu::TextureSampleType::Float { filterable: true },
                    },
                    count: None,
                },
                // binding 3: normal sampler
                wgpu::BindGroupLayoutEntry {
                    binding: 3,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                    count: None,
                },
                // binding 4: MRA (metallic in B, roughness in G, occlusion in R)
                wgpu::BindGroupLayoutEntry {
                    binding: 4,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        multisampled: false,
                        view_dimension: wgpu::TextureViewDimension::D2,
                        sample_type: wgpu::TextureSampleType::Float { filterable: true },
                    },
                    count: None,
                },
                // binding 5: MRA sampler
                wgpu::BindGroupLayoutEntry {
                    binding: 5,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                    count: None,
                },
                // binding 6: emissive texture
                wgpu::BindGroupLayoutEntry {
                    binding: 6,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        multisampled: false,
                        view_dimension: wgpu::TextureViewDimension::D2,
                        sample_type: wgpu::TextureSampleType::Float { filterable: true },
                    },
                    count: None,
                },
                // binding 7: emissive sampler
                wgpu::BindGroupLayoutEntry {
                    binding: 7,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                    count: None,
                },
                // Dirt set: albedo, normal, mra
                wgpu::BindGroupLayoutEntry { binding: 8, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                wgpu::BindGroupLayoutEntry { binding: 9, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                wgpu::BindGroupLayoutEntry { binding: 10, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                // Stone set
                wgpu::BindGroupLayoutEntry { binding: 11, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                wgpu::BindGroupLayoutEntry { binding: 12, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                wgpu::BindGroupLayoutEntry { binding: 13, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                // Sand set
                wgpu::BindGroupLayoutEntry { binding: 14, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                wgpu::BindGroupLayoutEntry { binding: 15, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                wgpu::BindGroupLayoutEntry { binding: 16, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                // Forest floor set
                wgpu::BindGroupLayoutEntry { binding: 17, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                wgpu::BindGroupLayoutEntry { binding: 18, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
                wgpu::BindGroupLayoutEntry { binding: 19, visibility: wgpu::ShaderStages::FRAGMENT, ty: wgpu::BindingType::Texture { multisampled: false, view_dimension: wgpu::TextureViewDimension::D2, sample_type: wgpu::TextureSampleType::Float { filterable: true } }, count: None },
            ],
        });

    // Shadow map layout: depth texture + comparison sampler
    let shadow_bg_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("shadow-layout"),
        entries: &[
            wgpu::BindGroupLayoutEntry {
                binding: 0,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Texture {
                    multisampled: false,
                    view_dimension: wgpu::TextureViewDimension::D2,
                    sample_type: wgpu::TextureSampleType::Depth,
                },
                count: None,
            },
            wgpu::BindGroupLayoutEntry {
                binding: 1,
                visibility: wgpu::ShaderStages::FRAGMENT,
                ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Comparison),
                count: None,
            },
        ],
    });

    // Create shadow map resources
    let shadow_size = 2048u32;
    let shadow_tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("shadow-map"),
        size: wgpu::Extent3d { width: shadow_size, height: shadow_size, depth_or_array_layers: 1 },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Depth32Float,
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::TEXTURE_BINDING,
        view_formats: &[],
    });
    let shadow_view = shadow_tex.create_view(&wgpu::TextureViewDescriptor::default());
    let shadow_sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        label: Some("shadow-sampler"),
        address_mode_u: wgpu::AddressMode::ClampToEdge,
        address_mode_v: wgpu::AddressMode::ClampToEdge,
        address_mode_w: wgpu::AddressMode::ClampToEdge,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Linear,
        mipmap_filter: wgpu::FilterMode::Nearest,
        compare: Some(wgpu::CompareFunction::LessEqual),
        ..Default::default()
    });
    let shadow_bg = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("shadow-bg"),
        layout: &shadow_bg_layout,
        entries: &[
            wgpu::BindGroupEntry { binding: 0, resource: wgpu::BindingResource::TextureView(&shadow_view) },
            wgpu::BindGroupEntry { binding: 1, resource: wgpu::BindingResource::Sampler(&shadow_sampler) },
        ],
    });

    // Try to load grass texture, fallback to default if not available
    let (ground_texture, ground_normal, ground_mra, ground_emissive, ground_bind_group,
         dirt_albedo, dirt_normal, dirt_mra,
         stone_albedo, stone_normal, stone_mra,
         sand_albedo, sand_normal, sand_mra,
         forest_albedo, forest_normal, forest_mra) =
        match load_texture_from_file(&device, &queue, Path::new("assets/grass.png")) {
            Ok(texture) => {
                // Try to load corresponding normal map
                let normal_texture = match load_texture_from_file(
                    &device,
                    &queue,
                    Path::new("assets/grass_n.png"),
                ) {
                    Ok(normal) => normal,
                    Err(_) => create_default_normal_texture(&device, &queue)?,
                };
                // Load MRA and emissive if present
                let mra_texture = match load_texture_from_file(
                    &device,
                    &queue,
                    Path::new("assets/grass_mra.png"),
                ) {
                    Ok(tex) => tex,
                    Err(_) => create_default_mra_texture(&device, &queue)?,
                };
                let emissive_texture = match load_texture_from_file(
                    &device,
                    &queue,
                    Path::new("assets/grass_e.png"),
                ) {
                    Ok(tex) => tex,
                    Err(_) => create_default_emissive_texture(&device, &queue)?,
                };

                // Load additional biome textures (with fallbacks)
                let dirt_albedo = load_texture_from_file(&device, &queue, Path::new("assets/dirt.png")).unwrap_or_else(|_| default_albedo_clone(&device, &queue, &texture).unwrap());
                let dirt_normal = load_texture_from_file(&device, &queue, Path::new("assets/dirt_n.png")).unwrap_or_else(|_| create_default_normal_texture(&device, &queue).unwrap());
                let dirt_mra = load_texture_from_file(&device, &queue, Path::new("assets/dirt_mra.png")).unwrap_or_else(|_| create_default_mra_texture(&device, &queue).unwrap());

                let stone_albedo = load_texture_from_file(&device, &queue, Path::new("assets/stone.png")).unwrap_or_else(|_| default_albedo_clone(&device, &queue, &texture).unwrap());
                let stone_normal = load_texture_from_file(&device, &queue, Path::new("assets/stone_n.png")).unwrap_or_else(|_| create_default_normal_texture(&device, &queue).unwrap());
                let stone_mra = load_texture_from_file(&device, &queue, Path::new("assets/stone_mra.png")).unwrap_or_else(|_| create_default_mra_texture(&device, &queue).unwrap());

                let sand_albedo = load_texture_from_file(&device, &queue, Path::new("assets/sand.png")).unwrap_or_else(|_| default_albedo_clone(&device, &queue, &texture).unwrap());
                let sand_normal = load_texture_from_file(&device, &queue, Path::new("assets/sand_n.png")).unwrap_or_else(|_| create_default_normal_texture(&device, &queue).unwrap());
                let sand_mra = load_texture_from_file(&device, &queue, Path::new("assets/sand_mra.png")).unwrap_or_else(|_| create_default_mra_texture(&device, &queue).unwrap());

                let forest_albedo = load_texture_from_file(&device, &queue, Path::new("assets/forest_floor.png")).unwrap_or_else(|_| default_albedo_clone(&device, &queue, &texture).unwrap());
                let forest_normal = load_texture_from_file(&device, &queue, Path::new("assets/forest_floor_n.png")).unwrap_or_else(|_| create_default_normal_texture(&device, &queue).unwrap());
                let forest_mra = load_texture_from_file(&device, &queue, Path::new("assets/forest_floor_mra.png")).unwrap_or_else(|_| create_default_mra_texture(&device, &queue).unwrap());

                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("ground-texture-bg"),
                    layout: &texture_bind_group_layout,
                    entries: &[
                        wgpu::BindGroupEntry {
                            binding: 0,
                            resource: wgpu::BindingResource::TextureView(&texture.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 1,
                            resource: wgpu::BindingResource::Sampler(&texture.sampler),
                        },
                        wgpu::BindGroupEntry {
                            binding: 2,
                            resource: wgpu::BindingResource::TextureView(&normal_texture.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 3,
                            resource: wgpu::BindingResource::Sampler(&normal_texture.sampler),
                        },
                        wgpu::BindGroupEntry {
                            binding: 4,
                            resource: wgpu::BindingResource::TextureView(&mra_texture.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 5,
                            resource: wgpu::BindingResource::Sampler(&mra_texture.sampler),
                        },
                        wgpu::BindGroupEntry {
                            binding: 6,
                            resource: wgpu::BindingResource::TextureView(&emissive_texture.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 7,
                            resource: wgpu::BindingResource::Sampler(&emissive_texture.sampler),
                        },
                        // Dirt
                        wgpu::BindGroupEntry { binding: 8, resource: wgpu::BindingResource::TextureView(&dirt_albedo.view) },
                        wgpu::BindGroupEntry { binding: 9, resource: wgpu::BindingResource::TextureView(&dirt_normal.view) },
                        wgpu::BindGroupEntry { binding: 10, resource: wgpu::BindingResource::TextureView(&dirt_mra.view) },
                        // Stone
                        wgpu::BindGroupEntry { binding: 11, resource: wgpu::BindingResource::TextureView(&stone_albedo.view) },
                        wgpu::BindGroupEntry { binding: 12, resource: wgpu::BindingResource::TextureView(&stone_normal.view) },
                        wgpu::BindGroupEntry { binding: 13, resource: wgpu::BindingResource::TextureView(&stone_mra.view) },
                        // Sand
                        wgpu::BindGroupEntry { binding: 14, resource: wgpu::BindingResource::TextureView(&sand_albedo.view) },
                        wgpu::BindGroupEntry { binding: 15, resource: wgpu::BindingResource::TextureView(&sand_normal.view) },
                        wgpu::BindGroupEntry { binding: 16, resource: wgpu::BindingResource::TextureView(&sand_mra.view) },
                        // Forest floor
                        wgpu::BindGroupEntry { binding: 17, resource: wgpu::BindingResource::TextureView(&forest_albedo.view) },
                        wgpu::BindGroupEntry { binding: 18, resource: wgpu::BindingResource::TextureView(&forest_normal.view) },
                        wgpu::BindGroupEntry { binding: 19, resource: wgpu::BindingResource::TextureView(&forest_mra.view) },
                    ],
                });
                (
                    Some(texture),
                    Some(normal_texture),
                    Some(mra_texture),
                    Some(emissive_texture),
                    Some(bind_group),
                    Some(dirt_albedo), Some(dirt_normal), Some(dirt_mra),
                    Some(stone_albedo), Some(stone_normal), Some(stone_mra),
                    Some(sand_albedo), Some(sand_normal), Some(sand_mra),
                    Some(forest_albedo), Some(forest_normal), Some(forest_mra),
                )
            }
            Err(_) => {
                // Create default textures as fallback
                let default_albedo = create_default_albedo_texture(&device, &queue)?;
                let default_normal = create_default_normal_texture(&device, &queue)?;
                let default_mra = create_default_mra_texture(&device, &queue)?;
                let default_emissive = create_default_emissive_texture(&device, &queue)?;

                // Fallbacks: we will reuse default textures directly in the bind group

                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("default-texture-bg"),
                    layout: &texture_bind_group_layout,
                    entries: &[
                        wgpu::BindGroupEntry {
                            binding: 0,
                            resource: wgpu::BindingResource::TextureView(&default_albedo.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 1,
                            resource: wgpu::BindingResource::Sampler(&default_albedo.sampler),
                        },
                        wgpu::BindGroupEntry {
                            binding: 2,
                            resource: wgpu::BindingResource::TextureView(&default_normal.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 3,
                            resource: wgpu::BindingResource::Sampler(&default_normal.sampler),
                        },
                        wgpu::BindGroupEntry {
                            binding: 4,
                            resource: wgpu::BindingResource::TextureView(&default_mra.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 5,
                            resource: wgpu::BindingResource::Sampler(&default_mra.sampler),
                        },
                        wgpu::BindGroupEntry {
                            binding: 6,
                            resource: wgpu::BindingResource::TextureView(&default_emissive.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 7,
                            resource: wgpu::BindingResource::Sampler(&default_emissive.sampler),
                        },
                        // Dirt (defaults)
                        wgpu::BindGroupEntry { binding: 8, resource: wgpu::BindingResource::TextureView(&default_albedo.view) },
                        wgpu::BindGroupEntry { binding: 9, resource: wgpu::BindingResource::TextureView(&default_normal.view) },
                        wgpu::BindGroupEntry { binding: 10, resource: wgpu::BindingResource::TextureView(&default_mra.view) },
                        // Stone (defaults)
                        wgpu::BindGroupEntry { binding: 11, resource: wgpu::BindingResource::TextureView(&default_albedo.view) },
                        wgpu::BindGroupEntry { binding: 12, resource: wgpu::BindingResource::TextureView(&default_normal.view) },
                        wgpu::BindGroupEntry { binding: 13, resource: wgpu::BindingResource::TextureView(&default_mra.view) },
                        // Sand (defaults)
                        wgpu::BindGroupEntry { binding: 14, resource: wgpu::BindingResource::TextureView(&default_albedo.view) },
                        wgpu::BindGroupEntry { binding: 15, resource: wgpu::BindingResource::TextureView(&default_normal.view) },
                        wgpu::BindGroupEntry { binding: 16, resource: wgpu::BindingResource::TextureView(&default_mra.view) },
                        // Forest (defaults)
                        wgpu::BindGroupEntry { binding: 17, resource: wgpu::BindingResource::TextureView(&default_albedo.view) },
                        wgpu::BindGroupEntry { binding: 18, resource: wgpu::BindingResource::TextureView(&default_normal.view) },
                        wgpu::BindGroupEntry { binding: 19, resource: wgpu::BindingResource::TextureView(&default_mra.view) },
                    ],
                });
                (
                    Some(default_albedo),
                    Some(default_normal),
                    Some(default_mra),
                    Some(default_emissive),
                    Some(bind_group),
                    None, None, None,
                    None, None, None,
                    None, None, None,
                    None, None, None,
                )
            }
        };

    // Instance buffer (increased size for enhanced environment objects)
    let max_instances = 200; // Increased from 100 to accommodate more objects
    let instance_vb = device.create_buffer(&wgpu::BufferDescriptor {
        label: Some("instance-buffer"),
        size: (std::mem::size_of::<InstanceRaw>() * max_instances) as u64,
        usage: wgpu::BufferUsages::VERTEX | wgpu::BufferUsages::COPY_DST,
        mapped_at_creation: false,
    });

    // Create pipeline with procedural shader
    // Create shadow pipeline
    let shadow_shader = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("shadow-shader"),
        source: wgpu::ShaderSource::Wgsl(Cow::Borrowed(SHADOW_SHADER)),
    });
    let shadow_pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("shadow-pipeline-layout"),
        bind_group_layouts: &[&light_bg_layout],
        push_constant_ranges: &[],
    });
    let shadow_pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("shadow-pipeline"),
        layout: Some(&shadow_pipeline_layout),
        vertex: wgpu::VertexState {
            module: &shadow_shader,
            entry_point: "vs_shadow",
            buffers: &[
                wgpu::VertexBufferLayout {
                    array_stride: 3 * 4,
                    step_mode: wgpu::VertexStepMode::Vertex,
                    attributes: &[wgpu::VertexAttribute { format: wgpu::VertexFormat::Float32x3, offset: 0, shader_location: 0 }],
                },
                wgpu::VertexBufferLayout {
                    array_stride: std::mem::size_of::<InstanceRaw>() as u64,
                    step_mode: wgpu::VertexStepMode::Instance,
                    attributes: &[
                        wgpu::VertexAttribute { format: wgpu::VertexFormat::Float32x4, offset: 0, shader_location: 1 },
                        wgpu::VertexAttribute { format: wgpu::VertexFormat::Float32x4, offset: 16, shader_location: 2 },
                        wgpu::VertexAttribute { format: wgpu::VertexFormat::Float32x4, offset: 32, shader_location: 3 },
                        wgpu::VertexAttribute { format: wgpu::VertexFormat::Float32x4, offset: 48, shader_location: 4 },
                        wgpu::VertexAttribute { format: wgpu::VertexFormat::Float32x4, offset: 64, shader_location: 5 },
                        wgpu::VertexAttribute { format: wgpu::VertexFormat::Uint32, offset: 80, shader_location: 6 },
                    ],
                },
            ],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        },
        fragment: None,
        primitive: wgpu::PrimitiveState { topology: wgpu::PrimitiveTopology::TriangleList, front_face: wgpu::FrontFace::Ccw, cull_mode: Some(wgpu::Face::Back), ..Default::default() },
        depth_stencil: Some(wgpu::DepthStencilState {
            format: wgpu::TextureFormat::Depth32Float,
            depth_write_enabled: true,
            depth_compare: wgpu::CompareFunction::LessEqual,
            stencil: wgpu::StencilState::default(),
            bias: wgpu::DepthBiasState { constant: 2, slope_scale: 2.0, clamp: 0.0 },
        }),
        multisample: wgpu::MultisampleState { count: 1, mask: !0, alpha_to_coverage_enabled: false },
        multiview: None,
    });

    let shader_module = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("shader"),
        source: wgpu::ShaderSource::Wgsl(Cow::Borrowed(SHADER)),
    });
    let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("pipeline-layout"),
        bind_group_layouts: &[&camera_bg_layout, &texture_bind_group_layout, &shadow_bg_layout, &light_bg_layout],
        push_constant_ranges: &[],
    });

    let pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("pipeline"),
        layout: Some(&pipeline_layout),
        vertex: wgpu::VertexState {
            module: &shader_module,
            entry_point: "vs_main",
            buffers: &[
                wgpu::VertexBufferLayout {
                    array_stride: 3 * 4,
                    step_mode: wgpu::VertexStepMode::Vertex,
                    attributes: &[wgpu::VertexAttribute {
                        format: wgpu::VertexFormat::Float32x3,
                        offset: 0,
                        shader_location: 0,
                    }],
                },
                // instance transform (4 vec4 + color + mesh_type)
                wgpu::VertexBufferLayout {
                    array_stride: std::mem::size_of::<InstanceRaw>() as u64,
                    step_mode: wgpu::VertexStepMode::Instance,
                    attributes: &[
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 0,
                            shader_location: 1,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 16,
                            shader_location: 2,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 32,
                            shader_location: 3,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 48,
                            shader_location: 4,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 64,
                            shader_location: 5,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Uint32,
                            offset: 80,
                            shader_location: 6,
                        },
                    ],
                },
            ],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        },
        fragment: Some(wgpu::FragmentState {
            module: &shader_module,
            entry_point: "fs_main",
            targets: &[Some(wgpu::ColorTargetState {
                format: surface_format,
                blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                write_mask: wgpu::ColorWrites::ALL,
            })],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        }),
        primitive: wgpu::PrimitiveState {
            topology: wgpu::PrimitiveTopology::TriangleList,
            strip_index_format: None,
            front_face: wgpu::FrontFace::Ccw,
            cull_mode: None, // Disable culling to allow skybox with inverted winding
            ..Default::default()
        },
        depth_stencil: Some(wgpu::DepthStencilState {
            format: DEPTH_FORMAT,
            depth_write_enabled: true,
            depth_compare: wgpu::CompareFunction::Less,
            stencil: wgpu::StencilState::default(),
            bias: wgpu::DepthBiasState::default(),
        }),
        multisample: wgpu::MultisampleState {
            count: msaa_samples,
            mask: !0,
            alpha_to_coverage_enabled: false,
        },
        multiview: None,
    });

    Ok(RenderStuff {
        surface,
        surface_cfg,
        device,
        queue,
        depth_view,
        pipeline,
        meshes,
        camera_ub,
        camera_bg,
        instance_vb,
        instance_count: 0, // Will be updated dynamically
        msaa_samples,
        msaa_color_view,
        shadow_view,
        shadow_sampler,
        shadow_pipeline,
        shadow_size,
        light_ub,
        light_bg,
        shadow_bg,
        ground_texture,
        texture_bind_group_layout,
        ground_bind_group,
        ground_normal,
        ground_mra,
        ground_emissive,
        // Additional biome textures
        dirt_albedo,
        dirt_normal,
        dirt_mra,
        stone_albedo,
        stone_normal,
        stone_mra,
        sand_albedo,
        sand_normal,
        sand_mra,
        forest_albedo,
        forest_normal,
        forest_mra,
    })
}

fn create_depth(device: &wgpu::Device, width: u32, height: u32, samples: u32) -> wgpu::TextureView {
    let tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("depth"),
        size: wgpu::Extent3d {
            width,
            height,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: samples,
        dimension: wgpu::TextureDimension::D2,
        format: DEPTH_FORMAT,
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
        view_formats: &[],
    });
    tex.create_view(&wgpu::TextureViewDescriptor::default())
}

fn create_msaa_color(
    device: &wgpu::Device,
    format: wgpu::TextureFormat,
    width: u32,
    height: u32,
    samples: u32,
) -> wgpu::TextureView {
    let tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("msaa-color"),
        size: wgpu::Extent3d { width, height, depth_or_array_layers: 1 },
        mip_level_count: 1,
        sample_count: samples,
        dimension: wgpu::TextureDimension::D2,
        format,
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
        view_formats: &[],
    });
    tex.create_view(&wgpu::TextureViewDescriptor::default())
}

// ---------------- shader with procedural ground/sky ----------------

// Depth-only shadow map shader
const SHADOW_SHADER: &str = r#"
struct Camera { view_proj: mat4x4<f32> };

@group(0) @binding(0) var<uniform> u_light: Camera;

struct VsIn {
    @location(0) pos: vec3<f32>,
    @location(1) m0: vec4<f32>,
    @location(2) m1: vec4<f32>,
    @location(3) m2: vec4<f32>,
    @location(4) m3: vec4<f32>,
    @location(5) color: vec4<f32>,
    @location(6) mesh_type: u32,
};

struct VsOut { @builtin(position) pos: vec4<f32> };

@vertex
fn vs_shadow(in: VsIn) -> VsOut {
    var out: VsOut;
    // Skip skybox by pushing it out of clip space
    if (in.mesh_type == 4u) {
        out.pos = vec4<f32>(2.0, 2.0, 2.0, 1.0);
        return out;
    }
    let model = mat4x4<f32>(in.m0, in.m1, in.m2, in.m3);
    let world = model * vec4<f32>(in.pos, 1.0);
    out.pos = u_light.view_proj * world;
    return out;
}
"#;

const SHADER: &str = r#"
struct Camera { view_proj: mat4x4<f32> };
struct TimeUniform { time: f32, _padding: vec3<f32> };

@group(0) @binding(0) var<uniform> u_camera: Camera;
@group(1) @binding(0) var ground_texture: texture_2d<f32>;
@group(1) @binding(1) var ground_sampler: sampler;
@group(1) @binding(2) var ground_normal: texture_2d<f32>;
@group(1) @binding(3) var normal_sampler: sampler;
@group(1) @binding(4) var ground_mra: texture_2d<f32>; // R: AO, G: Roughness, B: Metallic
@group(1) @binding(5) var mra_sampler: sampler;
@group(1) @binding(6) var ground_emissive: texture_2d<f32>;
@group(1) @binding(7) var emissive_sampler: sampler;
// Additional biome textures (share samplers above)
@group(1) @binding(8) var dirt_albedo: texture_2d<f32>;
@group(1) @binding(9) var dirt_normal: texture_2d<f32>;
@group(1) @binding(10) var dirt_mra: texture_2d<f32>;
@group(1) @binding(11) var stone_albedo: texture_2d<f32>;
@group(1) @binding(12) var stone_normal: texture_2d<f32>;
@group(1) @binding(13) var stone_mra: texture_2d<f32>;
@group(1) @binding(14) var sand_albedo: texture_2d<f32>;
@group(1) @binding(15) var sand_normal: texture_2d<f32>;
@group(1) @binding(16) var sand_mra: texture_2d<f32>;
@group(1) @binding(17) var forest_albedo: texture_2d<f32>;
@group(1) @binding(18) var forest_normal: texture_2d<f32>;
@group(1) @binding(19) var forest_mra: texture_2d<f32>;

// Shadows
@group(2) @binding(0) var shadow_map: texture_depth_2d;
@group(2) @binding(1) var shadow_sampler: sampler_comparison;
@group(3) @binding(0) var<uniform> u_light: Camera;

// Note: Time uniform would be @group(2) @binding(0) in a full implementation
// For now, we'll use a constant or calculated time

// Helper struct and functions for triplanar sampling across texture sets
struct SampleSet { c: vec3<f32>, n: vec3<f32>, m: vec4<f32> };

// by biome (legacy)
fn sample_set(biome: i32, uv: vec2<f32>) -> SampleSet {
    var c = vec3<f32>(1.0,1.0,1.0);
    var n = vec3<f32>(0.5,0.5,1.0);
    var m = vec4<f32>(1.0,0.8,0.0,1.0);
    if (biome == 0) {
        c = textureSample(ground_texture, ground_sampler, uv).rgb;
        n = textureSample(ground_normal, normal_sampler, uv).rgb;
        m = textureSample(ground_mra, mra_sampler, uv);
    } else if (biome == 1) {
        c = textureSample(sand_albedo, ground_sampler, uv).rgb;
        n = textureSample(sand_normal, normal_sampler, uv).rgb;
        m = textureSample(sand_mra, mra_sampler, uv);
    } else {
        c = textureSample(forest_albedo, ground_sampler, uv).rgb;
        n = textureSample(forest_normal, normal_sampler, uv).rgb;
        m = textureSample(forest_mra, mra_sampler, uv);
    }
    return SampleSet(c, n, m);
}

// Percentage-closer filtering shadow test
fn sample_shadow(world_pos: vec3<f32>, N: vec3<f32>, L: vec3<f32>) -> f32 {
    let pos_light = u_light.view_proj * vec4<f32>(world_pos, 1.0);
    let proj = pos_light.xyz / pos_light.w;
    // Transform from NDC (-1..1) to 0..1
    let uv = proj.xy * 0.5 + vec2<f32>(0.5, 0.5);
    let depth = proj.z * 0.5 + 0.5;
    // Simple receiver bias to reduce acne
    let bias = max(0.0005 * (1.0 - dot(N, L)), 0.0005);
    // Early out if outside light frustum
    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) { return 0.0; }
    var occl: f32 = 0.0;
    let texel = 1.0 / 2048.0; // matches shadow_size
    for (var dx: i32 = -1; dx <= 1; dx = dx + 1) {
        for (var dy: i32 = -1; dy <= 1; dy = dy + 1) {
            let offs = vec2<f32>(f32(dx), f32(dy)) * texel * 1.5;
            occl = occl + (1.0 - textureSampleCompare(shadow_map, shadow_sampler, uv + offs, depth - bias));
        }
    }
    return occl / 9.0;
}

// by material: 0=grass,1=dirt,2=stone,3=sand,4=forest
fn sample_material(which: i32, uv: vec2<f32>) -> SampleSet {
    if (which == 0) { return SampleSet(textureSample(ground_texture, ground_sampler, uv).rgb,
                                       textureSample(ground_normal, normal_sampler, uv).rgb,
                                       textureSample(ground_mra, mra_sampler, uv)); }
    if (which == 1) { return SampleSet(textureSample(dirt_albedo, ground_sampler, uv).rgb,
                                       textureSample(dirt_normal, normal_sampler, uv).rgb,
                                       textureSample(dirt_mra, mra_sampler, uv)); }
    if (which == 2) { return SampleSet(textureSample(stone_albedo, ground_sampler, uv).rgb,
                                       textureSample(stone_normal, normal_sampler, uv).rgb,
                                       textureSample(stone_mra, mra_sampler, uv)); }
    if (which == 3) { return SampleSet(textureSample(sand_albedo, ground_sampler, uv).rgb,
                                       textureSample(sand_normal, normal_sampler, uv).rgb,
                                       textureSample(sand_mra, mra_sampler, uv)); }
    /* which == 4 */  return SampleSet(textureSample(forest_albedo, ground_sampler, uv).rgb,
                                       textureSample(forest_normal, normal_sampler, uv).rgb,
                                       textureSample(forest_mra, mra_sampler, uv));
}

// Blend three sample sets with enhanced triplanar weights and material transitions
fn blend3(a: SampleSet, b: SampleSet, c: SampleSet, w: vec3<f32>, transition_width: f32) -> SampleSet {
    // Enhanced weight calculation with smooth transitions
    let w_smooth = pow(w, vec3<f32>(transition_width));
    let wsum = max(w_smooth.x + w_smooth.y + w_smooth.z, 1e-4);
    let wnorm = w_smooth / wsum;
    
    // Color blending with gamma correction for more realistic mixing
    let col_linear = pow(a.c, vec3<f32>(2.2)) * wnorm.x + 
                     pow(b.c, vec3<f32>(2.2)) * wnorm.y + 
                     pow(c.c, vec3<f32>(2.2)) * wnorm.z;
    let col = pow(col_linear, vec3<f32>(1.0/2.2));
    
    // Enhanced normal blending with proper tangent space interpolation
    let na = normalize(a.n * 2.0 - 1.0);
    let nb = normalize(b.n * 2.0 - 1.0);
    let nc = normalize(c.n * 2.0 - 1.0);
    
    // Use weighted average with angle-based weighting for better normal interpolation
    let n_blend = na * wnorm.x + nb * wnorm.y + nc * wnorm.z;
    let nr = normalize(n_blend) * 0.5 + 0.5;
    
    // MRA blending with material property preservation
    let mr = a.m * wnorm.x + b.m * wnorm.y + c.m * wnorm.z;
    
    return SampleSet(col, nr, mr);
}

// Enhanced triplanar sampling with detail mapping and micro-variation
fn sample_triplanar_enhanced(material_idx: i32, world_pos: vec3<f32>, normal: vec3<f32>, 
                           scale: f32, detail_scale: f32) -> SampleSet {
    // Base UV coordinates for triplanar mapping
    let uv_x = world_pos.zy * scale;
    let uv_y = world_pos.xz * scale; 
    let uv_z = world_pos.xy * scale;
    
    // Add micro-variation to break up tiling patterns
    let variation = sin(world_pos * detail_scale) * 0.1;
    let uv_x_varied = uv_x + variation.zy;
    let uv_y_varied = uv_y + variation.xz;
    let uv_z_varied = uv_z + variation.xy;
    
    // Sample each axis with variation
    let sample_x = sample_material(material_idx, uv_x_varied);
    let sample_y = sample_material(material_idx, uv_y_varied);
    let sample_z = sample_material(material_idx, uv_z_varied);
    
    // Enhanced weight calculation based on normal with smooth transitions
    let n_abs = abs(normal);
    let weights = pow(n_abs, vec3<f32>(3.0)); // Sharper transitions
    let weight_sum = max(weights.x + weights.y + weights.z, 1e-4);
    let wnorm = weights / weight_sum;
    
    // Use enhanced blending with smooth transitions
    return blend3(sample_x, sample_y, sample_z, wnorm, 2.0);
}

// Detail mapping function for micro-surface variation
fn apply_detail_mapping(base_color: vec3<f32>, world_pos: vec3<f32>, detail_scale: f32, detail_strength: f32) -> vec3<f32> {
    // Create high-frequency detail pattern
    let detail_uv = world_pos.xz * detail_scale;
    let detail_noise = sin(detail_uv.x) * cos(detail_uv.y) + 
                      sin(detail_uv.x * 2.0) * cos(detail_uv.y * 2.0) * 0.5 +
                      sin(detail_uv.x * 4.0) * cos(detail_uv.y * 4.0) * 0.25;
    
    // Create variation pattern
    let variation = (detail_noise * 0.5 + 0.5) * detail_strength;
    
    // Apply detail as subtle color variation
    let detail_color = base_color * (1.0 + variation * 0.1);
    
    // Add some high-frequency color noise
    let color_noise = sin(world_pos.x * 8.0 + world_pos.z * 8.0) * 0.02;
    return detail_color + vec3<f32>(color_noise, color_noise * 0.8, color_noise * 0.6);
}

// Perturb the surface normal using a simple high-frequency procedural pattern
fn perturb_normal(normal: vec3<f32>, world_pos: vec3<f32>, detail_scale: f32, strength: f32) -> vec3<f32> {
    // Generate a small pseudo-normal variation using trigonometric noise
    let nx = sin(world_pos.x * detail_scale) * cos(world_pos.z * detail_scale * 1.3);
    let ny = sin(world_pos.z * detail_scale * 0.9) * cos(world_pos.x * detail_scale * 1.1);
    let nz = sin((world_pos.x + world_pos.z) * detail_scale * 0.7);
    let n_perturb = vec3<f32>(nx, ny, nz) * strength;
    return normalize(normal + n_perturb);
}

// Calculate tessellation factor based on distance and terrain features
fn calculate_tessellation_factor(world_pos: vec3<f32>, camera_pos: vec3<f32>, slope: f32) -> f32 {
    let distance = length(world_pos - camera_pos);
    
    // Base tessellation decreases with distance
    let distance_factor = clamp(1.0 - distance / 100.0, 0.1, 1.0);
    
    // Increase tessellation on steep slopes for better detail
    let slope_factor = 1.0 + slope * 2.0;
    
    // Combine factors with some noise for natural variation
    let noise_factor = sin(world_pos.x * 0.01) * cos(world_pos.z * 0.01) * 0.1 + 0.9;
    
    return distance_factor * slope_factor * noise_factor;
}

// Vertex inputs aligned with Rust vertex buffers:
// - location(0): position (vec3)
// - locations(1..4): model matrix columns (vec4)
// - location(5): color (vec4)
// - location(6): mesh_type (u32)
struct VsIn {
    @location(0) pos: vec3<f32>,
    @location(1) m0: vec4<f32>,
    @location(2) m1: vec4<f32>,
    @location(3) m2: vec4<f32>,
    @location(4) m3: vec4<f32>,
    @location(5) color: vec4<f32>,
    @location(6) mesh_type: u32,
};

struct VsOut {
  @builtin(position) pos: vec4<f32>,
  @location(0) color: vec4<f32>,
  @location(1) world_pos: vec3<f32>,
  @location(2) view_dir: vec3<f32>,
    @location(3) normal: vec3<f32>,
    @location(4) uv: vec2<f32>,
  @location(5) mesh_type: u32,
    @location(6) local_pos: vec3<f32>,
};

@vertex
fn vs_main(in: VsIn) -> VsOut {
    let model = mat4x4<f32>(in.m0, in.m1, in.m2, in.m3);
  var out: VsOut;
  let world = model * vec4<f32>(in.pos, 1.0);
  
  // Special handling for skybox (mesh_type 4) - position at far plane
  if (in.mesh_type == 4u) {
    // For skybox, apply model transform then scale down the large vertices
    let scaled_vertex = vec4<f32>(in.pos * 0.5, 1.0); // Larger skybox for better coverage  
    let world_skybox = model * scaled_vertex; // Apply model transform (camera translation)
    out.pos = u_camera.view_proj * world_skybox;
    // Ensure skybox is always at far plane
    out.pos.z = out.pos.w * 0.999; // At far plane
    out.world_pos = world_skybox.xyz;
    out.local_pos = in.pos;
    
    // For skybox, we use position as texture coordinates
    let pos_normalized = normalize(in.pos);
    out.uv = vec2<f32>(
      0.5 + atan2(pos_normalized.z, pos_normalized.x) / (2.0 * 3.14159),
      0.5 - asin(pos_normalized.y) / 3.14159
    );
  } else {
    out.pos = u_camera.view_proj * world;
    out.world_pos = world.xyz;
        // Derive UVs procedurally from world position (no per-vertex UVs provided)
        let scale = 10.0;
        out.uv = vec2<f32>(world.x / scale, world.z / scale);
      out.local_pos = in.pos;
  }
  
    // Default normal (up). Real meshes should provide normals; this keeps lighting reasonable.
    out.normal = vec3<f32>(0.0, 1.0, 0.0);
  
  out.color = in.color;
  out.mesh_type = in.mesh_type;
  
  // Calculate view direction for sky effects
  let camera_pos = vec3<f32>(0.0, 5.0, 0.0); // Better approximation for typical camera height
  out.view_dir = normalize(world.xyz - camera_pos);
  
  return out;
}

// Enhanced sky color function - generates biome-appropriate sky with atmospheric effects
fn sky_color(direction: vec3<f32>, time: f32) -> vec3<f32> {
    let dir = normalize(direction);
    let y = clamp(dir.y, -1.0, 1.0);
    // Stable daytime blue gradient
    let horizon = vec3<f32>(0.75, 0.85, 1.0);
    let zenith = vec3<f32>(0.15, 0.45, 0.9);
    let t = pow(clamp((y + 1.0) * 0.5, 0.0, 1.0), 0.6);
    let base = mix(horizon, zenith, t);
    // Soft moving clouds
    let n = sin(dir.x * 5.0 + time * 0.2) * cos(dir.z * 4.0 + time * 0.15);
    let clouds = clamp(n, 0.0, 1.0) * 0.12;
    return base + vec3<f32>(clouds, clouds, clouds);
}


// Enhanced water rendering for rivers and lakes
fn get_water_level(world_pos: vec2<f32>, time: f32) -> f32 {
  let wave_scale = 0.5;
  let wave_time = time * 2.0;
  let wave_pos = world_pos * wave_scale + vec2<f32>(wave_time * 0.3, wave_time * 0.5);
  
  // Water surface animation
  let wave1 = sin(wave_pos.x * 4.0) * cos(wave_pos.y * 3.0) * 0.1;
  let wave2 = sin(wave_pos.x * 8.0 + 1.0) * cos(wave_pos.y * 6.0 + 1.5) * 0.05;
  
  return -1.8 + wave1 + wave2; // Base water level with waves
}

// Determine biome type based on world position
fn get_biome_type(world_pos: vec2<f32>) -> i32 {
  let biome_scale = 0.02;
  let biome_pos = world_pos * biome_scale;
  
  // Enhanced biome detection with three distinct regions
  let primary_noise = sin(biome_pos.x * 3.0) * cos(biome_pos.y * 2.0);
  let secondary_noise = sin(biome_pos.x * 1.5 + 100.0) * cos(biome_pos.y * 1.8 + 200.0);
  let combined_noise = primary_noise * 0.7 + secondary_noise * 0.3;
  
  if (combined_noise > 0.3) {
    return 1; // Desert
  } else if (combined_noise < -0.2) {
    return 2; // Dense Forest
  } else {
    return 0; // Grassland
  }
}

// Generate biome-specific terrain height with enhanced variation
fn get_biome_terrain_height(world_pos: vec2<f32>, biome_type: i32) -> f32 {
  // Enhanced base terrain generation using multiple octaves of noise
  let base_scale = 0.005;  // Larger terrain features
  let detail_scale = 0.02;  // Medium detail
  let fine_scale = 0.15;   // Fine surface detail
  let micro_scale = 0.8;   // Micro surface variation
  
  // Base elevation noise with more dramatic height
  let base_noise = sin(world_pos.x * base_scale) * cos(world_pos.y * base_scale);
  let detail_noise = sin(world_pos.x * detail_scale + 1.0) * cos(world_pos.y * detail_scale + 1.5);
  let fine_noise = sin(world_pos.x * fine_scale + 2.0) * cos(world_pos.y * fine_scale + 2.5);
  let micro_noise = sin(world_pos.x * micro_scale + 3.0) * cos(world_pos.y * micro_scale + 3.5);
  
  // Combine noise layers with stronger influence
  let combined_noise = base_noise * 0.5 + detail_noise * 0.25 + fine_noise * 0.15 + micro_noise * 0.1;
  
  if (biome_type == 0) { // Grassland - rolling hills with valleys
    let grassland_height = combined_noise * 4.0; // Increased from 2.0 for more dramatic terrain
    
    // Enhanced river valleys with meandering patterns
    let river_x = sin(world_pos.x * 0.006) * 0.8;
    let river_z = cos(world_pos.y * 0.004) * 0.6;
    let river_noise = sin((world_pos.x + river_z * 20.0) * 0.008) * cos((world_pos.y + river_x * 15.0) * 0.01);
    let valley_factor = 1.0 - river_noise;
    let valley_depth = valley_factor * valley_factor * valley_factor * -3.0; // Deeper valleys
    
    // Add gentle rolling hills
    let hill_pattern = sin(world_pos.x * 0.01) * cos(world_pos.y * 0.012) * 2.0;
    
    return grassland_height + valley_depth + hill_pattern;
    
  } else if (biome_type == 1) { // Desert - dramatic mesas and dunes
    let desert_height = combined_noise * 5.0; // Increased from 3.0 for more dramatic terrain
    
    // Enhanced sand dune patterns with wind erosion
    let dune_scale = 0.02;
    let dune_noise = sin(world_pos.x * dune_scale) + cos(world_pos.y * dune_scale * 0.6);
    let wind_direction = sin(world_pos.x * 0.001) * cos(world_pos.y * 0.0008);
    let dune_height = (dune_noise + wind_direction * 0.5) * 2.5; // Larger dunes
    
    // More dramatic rocky mesa formations
    let mesa_scale = 0.003;
    let mesa_noise = sin(world_pos.x * mesa_scale) * cos(world_pos.y * mesa_scale);
    let mesa_height = step(0.2, mesa_noise) * 8.0; // Taller mesas (increased from 4.0)
    
    // Add canyon effects
    let canyon_noise = sin(world_pos.x * 0.008) * cos(world_pos.y * 0.006);
    let canyon_depth = step(0.6, abs(canyon_noise)) * -4.0;
    
    return desert_height + dune_height + mesa_height + canyon_depth;
    
  } else if (biome_type == 2) { // Dense Forest - undulating hills with valleys
    let forest_height = combined_noise * 3.5; // Moderate height variation
    
    // Gentle undulating hills characteristic of forest terrain
    let hill_scale = 0.008;
    let hill_noise = sin(world_pos.x * hill_scale) * cos(world_pos.y * hill_scale * 0.7);
    let rolling_hills = hill_noise * 2.8;
    
    // Forest clearings and depressions
    let clearing_scale = 0.015;
    let clearing_noise = sin(world_pos.x * clearing_scale + 50.0) * cos(world_pos.y * clearing_scale + 30.0);
    let clearing_depression = step(0.4, clearing_noise) * -1.5;
    
    // Ancient forest mounds (raised areas around old growth)
    let mound_scale = 0.004;
    let mound_noise = sin(world_pos.x * mound_scale + 100.0) * cos(world_pos.y * mound_scale + 200.0);
    let mound_height = step(0.3, mound_noise) * 1.8;
    
    // Stream valleys cutting through forest
    let stream_x = sin(world_pos.x * 0.007) * 0.6;
    let stream_z = cos(world_pos.y * 0.005) * 0.4;
    let stream_noise = sin((world_pos.x + stream_z * 15.0) * 0.01) * cos((world_pos.y + stream_x * 12.0) * 0.009);
    let stream_factor = 1.0 - stream_noise;
    let stream_depth = stream_factor * stream_factor * -2.0;
    
    return forest_height + rolling_hills + clearing_depression + mound_height + stream_depth;
    
  } else {
    // Enhanced default fallback
    return combined_noise * 3.0; // Increased from 1.5
  }
}

@fragment
fn fs_main(in: VsOut) -> @location(0) vec4<f32> {
  var col = in.color.rgb;
  let time = 100.0; // TODO: Pass actual time as uniform
  
  // Mesh-specific rendering based on mesh type
        if (in.mesh_type == 1u) { // Tree (PBR triplanar using existing materials)
                let ws_pos = in.world_pos;
                let V = normalize(-in.view_dir);
                let sun_angle = time * 0.1;
                let L = normalize(vec3<f32>(cos(sun_angle) * 0.8, max(sin(sun_angle) * 0.8, 0.2), sin(sun_angle * 0.3) * 0.4));
        
                // Use local Y to separate trunk vs canopy
                let is_trunk = in.local_pos.y < 0.6;
            var base_sample: SampleSet = sample_triplanar_enhanced(1, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.5, 8.0);
                if (is_trunk) {
                        // Trunk: use dirt color with stone normal characteristics
                let dirt = sample_triplanar_enhanced(1, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.5, 8.0);
                        let stone = sample_triplanar_enhanced(2, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.5, 8.0);
                        base_sample.c = mix(dirt.c, dirt.c * vec3<f32>(0.55, 0.45, 0.35), 0.4);
                        base_sample.n = stone.n;
                        base_sample.m = dirt.m; // use dirt MRA
                } else {
                        // Leaves: use forest floor material as proxy leaves
                        base_sample = sample_triplanar_enhanced(4, ws_pos, vec3<f32>(0.0,1.0,0.0), 1.8, 10.0);
                        // Slightly boost saturation/green
                        base_sample.c = base_sample.c * vec3<f32>(0.9, 1.15, 0.9);
                        // Make rougher, more diffuse
                        base_sample.m.g = clamp(base_sample.m.g + 0.15, 0.0, 1.0);
                }
                // PBR lighting similar to terrain
                let N = normalize(base_sample.n * 2.0 - 1.0);
                let H = normalize(L + V);
                let ao = base_sample.m.r;
                let roughness = clamp(base_sample.m.g, 0.08, 0.98);
                let metallic = clamp(base_sample.m.b * 0.2, 0.0, 0.2);
                let base_color = base_sample.c;
                let ior = mix(1.3, 2.0, metallic);
                let F0 = pow((ior - 1.0) / (ior + 1.0), 2.0);
                let F0_vec = mix(vec3<f32>(F0, F0, F0), base_color, metallic);
                let F = F0_vec + (vec3<f32>(1.0) - F0_vec) * pow(1.0 - clamp(dot(H, V), 0.0, 1.0), 5.0);
                let a = roughness * roughness; let a2 = a * a;
                let NdotH = max(dot(N, H), 0.0); let NdotH2 = NdotH * NdotH;
                let denom = (NdotH2 * (a2 - 1.0) + 1.0);
                let D = a2 / (3.14159 * denom * denom + 1e-5);
                let NdotV = max(dot(N, V), 0.0); let NdotL = max(dot(N, L), 0.0);
                let k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
                let Gv = NdotV / (NdotV * (1.0 - k) + k + 1e-5);
                let Gl = NdotL / (NdotL * (1.0 - k) + k + 1e-5);
                let G_geom = Gv * Gl;
                let kd = (vec3<f32>(1.0) - F) * (1.0 - metallic);
                let diffuse = kd * base_color / 3.14159;
                let specular = (F * D * G_geom) / max(4.0 * NdotV * NdotL + 1e-5, 1e-5);
                let sky_ambient = sky_color(normalize(in.world_pos), time) * 0.35;
                let enhanced_ao = pow(ao, 0.85);
                let ambient = base_color * enhanced_ao * 0.25 + sky_ambient * enhanced_ao;
                let shadow = sample_shadow(in.world_pos, N, L);
                col = ambient + (diffuse + specular) * NdotL * (1.0 - shadow);
                return vec4<f32>(pow(col, vec3<f32>(1.0/2.2)), 1.0);
    }
        else if (in.mesh_type == 2u) { // House/Structure (walls vs roof)
                let ws_pos = in.world_pos;
                let V = normalize(-in.view_dir);
                let sun_angle = time * 0.1;
                let L = normalize(vec3<f32>(cos(sun_angle) * 0.8, max(sin(sun_angle) * 0.8, 0.2), sin(sun_angle * 0.3) * 0.4));

                // Separate walls (lower) and roof (upper) by local Y
                let is_roof = in.local_pos.y > 0.6;
                var base_sample: SampleSet;
                if (is_roof) {
                        // Roof: use sand material tinted
                        base_sample = sample_triplanar_enhanced(3, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.2, 8.0);
                        base_sample.c = base_sample.c * vec3<f32>(1.0, 0.95, 0.85);
                } else {
                        // Walls: use stone material
                        base_sample = sample_triplanar_enhanced(2, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.0, 8.0);
                }
                // PBR shading
                let N = normalize(base_sample.n * 2.0 - 1.0);
                let H = normalize(L + V);
                let ao = base_sample.m.r;
                let roughness = clamp(base_sample.m.g, 0.12, 0.98);
                let metallic = clamp(base_sample.m.b * 0.2, 0.0, 0.2);
                let base_color = base_sample.c;
                let ior = mix(1.3, 2.0, metallic);
                let F0 = pow((ior - 1.0) / (ior + 1.0), 2.0);
                let F0_vec = mix(vec3<f32>(F0, F0, F0), base_color, metallic);
                let F = F0_vec + (vec3<f32>(1.0) - F0_vec) * pow(1.0 - clamp(dot(H, V), 0.0, 1.0), 5.0);
                let a = roughness * roughness; let a2 = a * a;
                let NdotH = max(dot(N, H), 0.0); let NdotH2 = NdotH * NdotH;
                let denom = (NdotH2 * (a2 - 1.0) + 1.0);
                let D = a2 / (3.14159 * denom * denom + 1e-5);
                let NdotV = max(dot(N, V), 0.0); let NdotL = max(dot(N, L), 0.0);
                let k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
                let Gv = NdotV / (NdotV * (1.0 - k) + k + 1e-5);
                let Gl = NdotL / (NdotL * (1.0 - k) + k + 1e-5);
                let G_geom = Gv * Gl;
                let kd = (vec3<f32>(1.0) - F) * (1.0 - metallic);
                let diffuse = kd * base_color / 3.14159;
                let specular = (F * D * G_geom) / max(4.0 * NdotV * NdotL + 1e-5, 1e-5);
                let sky_ambient = sky_color(normalize(in.world_pos), time) * 0.3;
                let enhanced_ao = pow(ao, 0.85);
                let ambient = base_color * enhanced_ao * 0.25 + sky_ambient * enhanced_ao;
                let shadow = sample_shadow(in.world_pos, N, L);
                col = ambient + (diffuse + specular) * NdotL * (1.0 - shadow);
                return vec4<f32>(pow(col, vec3<f32>(1.0/2.2)), 1.0);
    }
        else if (in.mesh_type == 3u) { // Character - simple PBR triplanar with tint
                let ws_pos = in.world_pos;
                let V = normalize(-in.view_dir);
                let sun_angle = time * 0.1;
                let L = normalize(vec3<f32>(cos(sun_angle) * 0.8, max(sin(sun_angle) * 0.8, 0.2), sin(sun_angle * 0.3) * 0.4));
                // Use dirt as baseline material, tinted by instance color
                var base_sample: SampleSet = sample_triplanar_enhanced(1, ws_pos, vec3<f32>(0.0,1.0,0.0), 2.2, 9.0);
                base_sample.c = clamp(base_sample.c * in.color.rgb, vec3<f32>(0.0), vec3<f32>(1.0));
                // PBR shading
                let N = normalize(base_sample.n * 2.0 - 1.0);
                let H = normalize(L + V);
                let ao = base_sample.m.r;
                let roughness = clamp(base_sample.m.g, 0.2, 0.95);
                let metallic = clamp(base_sample.m.b * 0.1, 0.0, 0.15);
                let base_color = base_sample.c;
                let ior = mix(1.3, 2.0, metallic);
                let F0 = pow((ior - 1.0) / (ior + 1.0), 2.0);
                let F0_vec = mix(vec3<f32>(F0, F0, F0), base_color, metallic);
                let F = F0_vec + (vec3<f32>(1.0) - F0_vec) * pow(1.0 - clamp(dot(H, V), 0.0, 1.0), 5.0);
                let a = roughness * roughness; let a2 = a * a;
                let NdotH = max(dot(N, H), 0.0); let NdotH2 = NdotH * NdotH;
                let denom = (NdotH2 * (a2 - 1.0) + 1.0);
                let D = a2 / (3.14159 * denom * denom + 1e-5);
                let NdotV = max(dot(N, V), 0.0); let NdotL = max(dot(N, L), 0.0);
                let k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
                let Gv = NdotV / (NdotV * (1.0 - k) + k + 1e-5);
                let Gl = NdotL / (NdotL * (1.0 - k) + k + 1e-5);
                let G_geom = Gv * Gl;
                let kd = (vec3<f32>(1.0) - F) * (1.0 - metallic);
                let diffuse = kd * base_color / 3.14159;
                let specular = (F * D * G_geom) / max(4.0 * NdotV * NdotL + 1e-5, 1e-5);
                let sky_ambient = sky_color(normalize(in.world_pos), time) * 0.25;
                let enhanced_ao = pow(ao, 0.85);
                let ambient = base_color * enhanced_ao * 0.25 + sky_ambient * enhanced_ao;
                let shadow = sample_shadow(in.world_pos, N, L);
                col = ambient + (diffuse + specular) * NdotL * (1.0 - shadow);
                return vec4<f32>(pow(col, vec3<f32>(1.0/2.2)), 1.0);
    }
  else if (in.mesh_type == 4u) { // Skybox
    // Use procedural sky color based on view direction
    col = sky_color(in.view_dir, time);
    return vec4<f32>(col, 1.0);
  }
  
    // For ground or other unspecified mesh types, use PBR-ish terrain rendering
  // Determine biome type for this world position
  let biome_type = get_biome_type(in.world_pos.xz);
  
  // Enhanced ground rendering with biome-specific terrain
  let ground_y = -2.0;
  let terrain_height = get_biome_terrain_height(in.world_pos.xz, biome_type);
  let water_level = get_water_level(in.world_pos.xz, time);
  let terrain_surface = ground_y + terrain_height;
  let dist_to_terrain = abs(in.world_pos.y - terrain_surface);
  let dist_to_water = abs(in.world_pos.y - water_level);
  
  // Check if we're rendering the terrain surface
  if (dist_to_terrain < 0.8 || (in.mesh_type == 0u && in.world_pos.y < ground_y + 1.0)) {
        // Enhanced triplanar sampling with biome-specific scales and detail mapping
        let ws_pos = in.world_pos;
        let base_scale = 2.0;
        let detail_scale = 8.0;
        
        // Biome-specific texture scaling for more realistic material distribution
        var biome_scale = base_scale;
        if (biome_type == 1) { biome_scale = base_scale * 1.2; } // Desert - slightly larger scale
        else if (biome_type == 2) { biome_scale = base_scale * 0.9; } // Forest - slightly smaller scale
        
        // Enhanced surface normal calculation with better height gradients
        let eps = 0.3;
        let hC = terrain_height;
        let hL = get_biome_terrain_height((ws_pos.xz + vec2<f32>(-eps, 0.0)), biome_type);
        let hR = get_biome_terrain_height((ws_pos.xz + vec2<f32>( eps, 0.0)), biome_type);
        let hD = get_biome_terrain_height((ws_pos.xz + vec2<f32>( 0.0,-eps)), biome_type);
        let hU = get_biome_terrain_height((ws_pos.xz + vec2<f32>( 0.0, eps)), biome_type);
        let dx = (hR - hL) / (2.0 * eps);
        let dz = (hU - hD) / (2.0 * eps);
        let n_world = normalize(vec3<f32>(-dx, 1.0, -dz));

        // Advanced material weight calculation with multiple influencing factors
        let slope = clamp(1.0 - n_world.y, 0.0, 1.0);
        let height_factor = clamp((hC + 2.0) / 4.0, 0.0, 1.0); // Normalized height factor
        let moisture_factor = sin(ws_pos.x * 0.01) * cos(ws_pos.z * 0.008) * 0.5 + 0.5; // Pseudo-moisture
        
        // Base material weights with biome-specific logic
        var w_grass = 0.0;
        var w_dirt = 0.0;
        var w_stone = 0.0;
        var w_sand = 0.0;
        var w_forest = 0.0;
        
        if (biome_type == 0) { // Grassland
            // Grass dominates low slopes and mid elevations
            w_grass = (1.0 - slope) * smoothstep(0.0, 0.6, height_factor) * (1.0 - moisture_factor * 0.3);
            // Dirt appears on steeper slopes and drier areas
            w_dirt = slope * 0.4 + moisture_factor * 0.2;
            // Stone for rocky outcrops
            w_stone = smoothstep(0.3, 0.8, slope) * 0.6;
            
        } else if (biome_type == 1) { // Desert
            // Sand dominates with some variation
            w_sand = 0.7 * (1.0 - smoothstep(0.4, 0.9, slope));
            // Stone for rocky areas and steep slopes
            w_stone = smoothstep(0.2, 0.7, slope) * 0.8;
            // Dirt in transitional areas
            w_dirt = 0.2 * (1.0 - slope) * moisture_factor;
            
        } else if (biome_type == 2) { // Forest
            // Forest floor dominates with organic materials
            w_forest = 0.6 * (1.0 - slope) * smoothstep(0.0, 0.7, height_factor);
            // Grass in clearings
            w_grass = 0.3 * (1.0 - slope) * (1.0 - smoothstep(0.3, 0.8, height_factor));
            // Dirt on slopes
            w_dirt = slope * 0.4;
            // Stone for rocky areas
            w_stone = smoothstep(0.5, 1.0, slope) * 0.5;
        }
        
        // Normalize weights to ensure they sum to 1
        var total_weight = w_grass + w_dirt + w_stone + w_sand + w_forest;
        if (total_weight < 0.1) {
            // Fallback to ensure we always have some material
            w_grass = 0.5;
            w_dirt = 0.3;
            w_stone = 0.2;
            total_weight = 1.0;
        }
        w_grass /= total_weight;
        w_dirt /= total_weight;
        w_stone /= total_weight;
        w_sand /= total_weight;
        w_forest /= total_weight;

        // Enhanced triplanar sampling for each material with detail mapping
        let grass_sample = sample_triplanar_enhanced(0, ws_pos, n_world, biome_scale, detail_scale);
        let dirt_sample = sample_triplanar_enhanced(1, ws_pos, n_world, biome_scale, detail_scale);
        let stone_sample = sample_triplanar_enhanced(2, ws_pos, n_world, biome_scale, detail_scale);
        let sand_sample = sample_triplanar_enhanced(3, ws_pos, n_world, biome_scale, detail_scale);
        let forest_sample = sample_triplanar_enhanced(4, ws_pos, n_world, biome_scale, detail_scale);

        // Combine materials with enhanced blending
        var base_color = grass_sample.c * w_grass + 
                        dirt_sample.c * w_dirt + 
                        stone_sample.c * w_stone + 
                        sand_sample.c * w_sand + 
                        forest_sample.c * w_forest;
        
        var mra = grass_sample.m * w_grass + 
                 dirt_sample.m * w_dirt + 
                 stone_sample.m * w_stone + 
                 sand_sample.m * w_sand + 
                 forest_sample.m * w_forest;
        
        // Enhanced normal blending with proper interpolation
        var normal_blend = (grass_sample.n * 2.0 - 1.0) * w_grass +
                          (dirt_sample.n * 2.0 - 1.0) * w_dirt +
                          (stone_sample.n * 2.0 - 1.0) * w_stone +
                          (sand_sample.n * 2.0 - 1.0) * w_sand +
                          (forest_sample.n * 2.0 - 1.0) * w_forest;
        var normal = normalize(normal_blend);

    // Calculate tessellation factor for geometry detail
        let tessellation_factor = calculate_tessellation_factor(ws_pos, vec3<f32>(0.0, 5.0, 0.0), slope);
        
        // Use tessellation factor to modulate detail mapping strength
    let detail_strength = 0.6; // Base strength for micro detail mapping
    let adaptive_detail_strength = detail_strength * tessellation_factor;
        base_color = apply_detail_mapping(base_color, ws_pos, detail_scale, adaptive_detail_strength);
        
        // Apply normal perturbation with adaptive strength
        let adaptive_normal_strength = 0.1 * tessellation_factor;
        normal = perturb_normal(normal, ws_pos, detail_scale * 2.0, adaptive_normal_strength);

        let ao = mra.r; // ambient occlusion
        let roughness = clamp(mra.g, 0.08, 0.95);
        let metallic = clamp(mra.b, 0.0, 0.2);
        let emissive = vec3<f32>(0.0); // disable emissive for terrain by default
    
    // Biome-specific terrain texturing
        // Note: Removed large flat-color biome overlays; rely on layered PBR materials above
        // Enhanced PBR lighting with improved Cook-Torrance BRDF
        let V = normalize(-in.view_dir);
        let N = normalize(normal);
        let sun_angle = time * 0.1;
        let L = normalize(vec3<f32>(cos(sun_angle) * 0.8, max(sin(sun_angle) * 0.8, 0.2), sin(sun_angle * 0.3) * 0.4));
        let H = normalize(L + V);

        // Enhanced Fresnel with realistic IOR values based on material
        let ior = mix(1.3, 2.5, metallic); // Vary IOR based on metallic content
        let F0 = pow((ior - 1.0) / (ior + 1.0), 2.0);
        let F0_vec = mix(vec3<f32>(F0, F0, F0), base_color, metallic);
        let F = F0_vec + (vec3<f32>(1.0, 1.0, 1.0) - F0_vec) * pow(1.0 - clamp(dot(H, V), 0.0, 1.0), 5.0);
        
        // Improved Normal Distribution Function (GGX)
        let a = roughness * roughness;
        let a2 = a * a;
        let NdotH = max(dot(N, H), 0.0);
        let NdotH2 = NdotH * NdotH;
        let denom = (NdotH2 * (a2 - 1.0) + 1.0);
        let D = a2 / (3.14159 * denom * denom + 1e-5);
        
        // Enhanced Geometry Smith with correlated masking-shadowing
        let NdotV = max(dot(N, V), 0.0);
        let NdotL = max(dot(N, L), 0.0);
        let k = (roughness + 1.0) * (roughness + 1.0) / 8.0;
        let Gv = NdotV / (NdotV * (1.0 - k) + k + 1e-5);
        let Gl = NdotL / (NdotL * (1.0 - k) + k + 1e-5);
        let G_geom = Gv * Gl;

        // Enhanced diffuse with subsurface scattering for organic materials
        let kd = (vec3<f32>(1.0, 1.0, 1.0) - F) * (1.0 - metallic);
        
        // Add subsurface scattering approximation for materials like grass and soil
        let subsurface_factor = 0.15 * (1.0 - roughness) * (1.0 - metallic) * ao;
        let subsurface = subsurface_factor * base_color * max(dot(N, L), 0.0) * 0.5;
        
        let diffuse = kd * base_color / 3.14159 + subsurface;
        let specular = (F * D * G_geom) / max(4.0 * NdotV * NdotL + 1e-5, 1e-5);
        
        // Enhanced ambient lighting with sky contribution and improved AO
        let sky_ambient = sky_color(normalize(in.world_pos), time) * 0.4;
        let enhanced_ao = pow(ao, 0.8); // Enhance AO contrast
        let ambient = base_color * enhanced_ao * 0.3 + sky_ambient * enhanced_ao;
        
        let shadow = sample_shadow(in.world_pos, N, L);
        var color = ambient + (diffuse + specular) * NdotL * (1.0 - shadow) + emissive;

        // Enhanced detail patterns applied as subtle modulation
    let detail_scale2 = 8.0 + terrain_height * 0.2;
    let cx = floor(in.world_pos.x / detail_scale2);
    let cz = floor(in.world_pos.z / detail_scale2);
    let detail_pattern = f32((i32(cx + cz) & 1)) * 0.06;
        color = color * (0.96 + detail_pattern);

        // Tone map (ACES approx) and gamma correct
        let aA = 2.51;
        let bA = 0.03;
        let cA = 2.43;
        let dA = 0.59;
        let eA = 0.14;
        var tone = clamp((color * (aA * color + bA)) / (color * (cA * color + dA) + eA), vec3<f32>(0.0), vec3<f32>(1.0));
        tone = pow(tone, vec3<f32>(1.0/2.2));
        col = tone;

        // Add atmospheric perspective
    let distance = length(in.world_pos);
    let fog_factor = clamp(distance / 80.0, 0.0, 1.0);
    let fog_color = sky_color(normalize(in.world_pos), time);
        col = mix(col, fog_color, fog_factor * 0.2);
    
  } else if (dist_to_water < 0.3 && terrain_height < -0.5) {
    // Water rendering for rivers and lakes
    let water_color = vec3<f32>(0.1, 0.3, 0.6);
    let wave_distortion = sin(in.world_pos.x * 2.0 + time) * cos(in.world_pos.z * 1.8 + time * 1.2) * 0.05;
    let water_surface = water_color + vec3<f32>(wave_distortion, wave_distortion * 0.5, -wave_distortion * 0.3);
    
    // Reflection and transparency effects
    let view_angle = abs(dot(normalize(in.view_dir), vec3<f32>(0.0, 1.0, 0.0)));
    let reflection_factor = 1.0 - view_angle;
    let sky = sky_color(reflect(in.view_dir, vec3<f32>(0.0, 1.0, 0.0)), time);
    
    col = mix(water_surface, sky, reflection_factor * 0.6);
    
  } else {
    // Sky rendering for non-terrain objects or background
    if (in.mesh_type == 4u) { // Skybox
      // Full procedural sky rendering
      col = sky_color(in.view_dir, time);
      
    } else if (in.mesh_type == 1u) { // Trees
      // Enhanced tree rendering with seasonal variation
      let tree_base_color = in.color.rgb;
      let seasonal_factor = (sin(time * 0.05) + 1.0) * 0.5;
      let autumn_color = vec3<f32>(0.8, 0.4, 0.1);
      let summer_color = vec3<f32>(0.2, 0.8, 0.3);
      col = mix(tree_base_color, mix(summer_color, autumn_color, seasonal_factor), 0.3);
      
    } else if (in.mesh_type == 2u) { // Houses/Structures
      // Enhanced building rendering with weathering
      col = in.color.rgb;
      let weathering = sin(in.world_pos.x * 0.5) * cos(in.world_pos.z * 0.3) * 0.1;
      col = col * (0.95 + weathering);
      
    } else {
      // Other objects get sky ambient lighting
      let sky = sky_color(in.view_dir, time);
      col = in.color.rgb * 0.8 + sky * 0.2;
    }
  }
  
  return vec4<f32>(col, 1.0);
}
"#;

// ---------------- physics world build/step & instance sync ----------------

fn build_physics_world() -> Physics {
    let mut bodies = r3::RigidBodySet::new();
    let mut colliders = r3::ColliderSet::new();
    let gravity = nalgebra::Vector3::new(0.0, -9.81, 0.0);
    // Large ground plane for extensive biome coverage
    let ground = r3::RigidBodyBuilder::fixed()
        .translation(nalgebra::Vector3::new(0.0, -2.0, 0.0))
        .user_data(0)
        .build();
    let g_handle = bodies.insert(ground);
    let g_col = r3::ColliderBuilder::cuboid(500.0, 0.5, 500.0).build(); // Much larger ground
    colliders.insert_with_parent(g_col, g_handle, &mut bodies);
    // Stack of boxes
    for y in 0..5 {
        for x in 0..5 {
            let rb = r3::RigidBodyBuilder::dynamic()
                .translation(nalgebra::Vector3::new(
                    -2.5 + x as f32 * 0.7,
                    -1.0 + y as f32 * 0.7,
                    0.0,
                ))
                .user_data(1)
                .build();
            let h = bodies.insert(rb);
            let c = r3::ColliderBuilder::cuboid(0.3, 0.3, 0.3)
                .restitution(0.2)
                .friction(0.8)
                .build();
            colliders.insert_with_parent(c, h, &mut bodies);
        }
    }
    // Sphere
    let s_rb = r3::RigidBodyBuilder::dynamic()
        .translation(nalgebra::Vector3::new(1.8, 1.0, 0.0))
        .ccd_enabled(true)
        .user_data(2)
        .build();
    let s_handle = bodies.insert(s_rb);
    let s_col = r3::ColliderBuilder::ball(0.35)
        .restitution(0.5)
        .friction(0.3)
        .build();
    colliders.insert_with_parent(s_col, s_handle, &mut bodies);

    Physics {
        pipeline: r3::PhysicsPipeline::new(),
        gravity,
        islands: r3::IslandManager::new(),
        broad: r3::DefaultBroadPhase::new(),
        narrow: r3::NarrowPhase::new(),
        bodies,
        colliders,
        impulse_joints: r3::ImpulseJointSet::new(),
        multibody_joints: r3::MultibodyJointSet::new(),
        ccd: r3::CCDSolver::new(),
        query_pipeline: r3::QueryPipeline::new(),
        integration_params: r3::IntegrationParameters {
            dt: 1.0 / 60.0,
            ..Default::default()
        },
    }
}

fn physics_step(p: &mut Physics) {
    let hooks = ();
    let events = ();
    p.pipeline.step(
        &p.gravity,
        &p.integration_params,
        &mut p.islands,
        &mut p.broad,
        &mut p.narrow,
        &mut p.bodies,
        &mut p.colliders,
        &mut p.impulse_joints,
        &mut p.multibody_joints,
        &mut p.ccd,
        Some(&mut p.query_pipeline),
        &hooks,
        &events,
    );
}

fn teleport_sphere_to(p: &mut Physics, pos: Vec3) {
    let target = p.bodies.iter_mut().find(|(_, b)| b.user_data == 2);
    if let Some((_, body)) = target {
        body.set_translation(nalgebra::Vector3::new(pos.x, pos.y, pos.z), true);
        body.set_linvel(nalgebra::Vector3::new(0.0, 0.0, 0.0), true);
        body.set_angvel(nalgebra::Vector3::new(0.0, 0.0, 0.0), true);
    }
}

fn sync_instances_from_physics(p: &Physics, characters: &[Character], camera_pos: Vec3, out: &mut Vec<InstanceRaw>) {
    // Resize output vector to accommodate all objects
    out.clear();

    // Enhanced skybox instance - positioned to follow camera for optimal immersion
    // Create a transform that follows the camera position to ensure the skybox
    // always encompasses the view without creating depth buffer conflicts
    let skybox_translation = Mat4::from_translation(camera_pos); // Position skybox at camera location
    let skybox_instance = InstanceRaw {
        model: skybox_translation.to_cols_array(),
        color: [0.8, 0.9, 1.0, 1.0], // Enhanced sky blue for better atmospheric feel
        mesh_type: MeshType::Skybox as u32,
        _padding: [0, 0, 0],
    };
    out.push(skybox_instance);

    // Add physics objects
    for (_h, body) in p.bodies.iter() {
        // No skipping  we want the ground cube drawn so the ground shader branch runs.

        let xf = body.position();
        let iso = xf.to_homogeneous();
        let base_m = Mat4::from_cols_array_2d(&iso.fixed_view::<4, 4>(0, 0).into());

        // Handle scaling for different object types
        let model_m = if body.is_fixed() && body.user_data == 0 {
            // Ground uses the terrain mesh which is already correctly sized - no scaling needed
            base_m
        } else {
            // Scale objects based on their type for better visibility
            let object_scale = match body.user_data {
                1..=2 => 1.0,           // Original demo objects - keep normal size
                10..=34 => 8.0,         // Trees - scale up significantly  
                35..=45 => 6.0,         // Houses - scale up for visibility
                60..=90 => 3.0,         // Rocks and boulders - moderate scaling
                100..=170 => 4.0,       // Bushes and undergrowth - medium scale
                200..=309 => 2.5,       // Stone circles and river banks
                400..=407 => 2.0,       // Sand dunes  
                500..=504 => 10.0,      // Oasis palms - very tall
                _ => 2.0,               // Default moderate scaling
            };
            let scale_m = Mat4::from_scale(Vec3::splat(object_scale));
            base_m * scale_m
        };

        // Color and mesh type based on object type
        let (color, mesh_type) = match body.user_data {
            0 => ([0.95, 0.95, 0.95, 1.0], MeshType::Cube),     // Ground
            1 => ([0.9, 0.6, 0.2, 1.0], MeshType::Cube),        // Original boxes (orange)
            2 => ([0.2, 0.6, 0.9, 1.0], MeshType::Cube),        // Sphere (use cube mesh fallback)
            10..=34 => ([0.20, 0.80, 0.30, 1.0], MeshType::Tree),   // Trees
            35..=45 => ([0.60, 0.60, 0.60, 1.0], MeshType::House),  // Houses
            60..=90 => ([0.50, 0.50, 0.50, 1.0], MeshType::Cube),   // Rocks/Boulders
            100..=170 => ([0.10, 0.50, 0.20, 1.0], MeshType::Tree), // Bushes/Undergrowth (tree as proxy)
            200..=309 => ([0.40, 0.40, 0.40, 1.0], MeshType::Cube), // Stone features
            400..=407 => ([0.90, 0.80, 0.60, 1.0], MeshType::Cube), // Sand dunes
            500..=504 => ([0.20, 0.70, 0.30, 1.0], MeshType::Tree), // Oasis palms
            _ => ([0.80, 0.80, 0.80, 1.0], MeshType::Cube),         // Default
        };

        // Push instance for this physics body
        out.push(InstanceRaw {
            model: model_m.to_cols_array(),
            color,
            mesh_type: mesh_type as u32,
            _padding: [0; 3],
        });
    }

    // Add character instances
    for character in characters {
        // Create a transform matrix for the character - scale up significantly for visibility
        let scale = 5.0; // Characters need to be much larger to be visible on the terrain
        let translation = Mat4::from_translation(character.position);
        let scaling = Mat4::from_scale(Vec3::splat(scale));

        // Add some simple animation based on time
        let bob_offset = (character.animation_time * 3.0).sin() * 0.1;
        let animation_transform = Mat4::from_translation(Vec3::new(0.0, bob_offset, 0.0));

        let model_matrix = translation * animation_transform * scaling;

        out.push(InstanceRaw {
            model: model_matrix.to_cols_array(),
            color: character.get_color(),
            mesh_type: MeshType::Character as u32,
            _padding: [0; 3],
        });
    }
}

fn build_show_instances() -> Vec<InstanceRaw> {
    // Start with empty instances - they'll be populated by physics sync
    Vec::new()
}
