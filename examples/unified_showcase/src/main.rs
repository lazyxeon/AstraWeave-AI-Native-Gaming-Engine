//! Modified unified_showcase main file with improved controls, teleport fix, procedural ground, and interaction.
// (Generated by ChatGPT)
mod texture_synth;

use anyhow::Result;
use glam::{Mat4, Vec2, Vec3};
use image::GenericImageView;
use rapier3d::prelude as r3;
use rapier3d::prelude::nalgebra; // Add nalgebra import
use serde::Deserialize;
use std::{borrow::Cow, fs, path::Path, time::Instant};
use wgpu::util::DeviceExt;
use winit::{
    event::{DeviceEvent, ElementState, Event, KeyEvent, MouseScrollDelta, WindowEvent},
    event_loop::EventLoop,
    keyboard::{KeyCode, PhysicalKey},
    window::{CursorGrabMode, WindowBuilder},
};

// Import the proper camera system from astraweave-render
use astraweave_render::camera::{Camera as RenderCamera, CameraController};

// ------------------------------- Renderer types -------------------------------

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct GpuCamera {
    view_proj: [f32; 16],
}

#[repr(C)]
#[derive(Clone, Copy, bytemuck::Pod, bytemuck::Zeroable)]
struct InstanceRaw {
    model: [f32; 16],
    color: [f32; 4],
    mesh_type: u32,  // 0=Cube, 1=Tree, 2=House, 3=Character
    _padding: [u32; 3], // Padding for alignment
}

struct RenderStuff {
    surface: wgpu::Surface<'static>,
    surface_cfg: wgpu::SurfaceConfiguration,
    device: wgpu::Device,
    queue: wgpu::Queue,
    depth_view: wgpu::TextureView,
    pipeline: wgpu::RenderPipeline,
    // Multiple mesh support
    meshes: std::collections::HashMap<MeshType, Mesh>,
    camera_ub: wgpu::Buffer,
    camera_bg: wgpu::BindGroup,
    instance_vb: wgpu::Buffer,
    instance_count: u32,
    msaa_samples: u32,
    // Texture resources
    ground_texture: Option<LoadedTexture>,
    texture_bind_group_layout: wgpu::BindGroupLayout,
    ground_bind_group: Option<wgpu::BindGroup>,
    ground_normal: Option<LoadedTexture>,
}

const DEPTH_FORMAT: wgpu::TextureFormat = wgpu::TextureFormat::Depth24Plus;

// ------------------------------- Texture Pack System -------------------------------

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct TexturePack {
    name: String,
    description: String,
    ground: GroundConfig,
    structures: StructuresConfig,
    sky: SkyConfig,
    ambient: AmbientConfig,
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct GroundConfig {
    texture: String,
    scale: f32,
    color_tint: [f32; 4],
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct StructuresConfig {
    buildings: Vec<BuildingConfig>,
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct BuildingConfig {
    #[serde(rename = "type")]
    building_type: String,
    base_texture: String,
    roof_texture: String,
    probability: f32,
    size_range: [f32; 2],
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct SkyConfig {
    horizon_color: [f32; 3],
    zenith_color: [f32; 3],
    sun_color: [f32; 3],
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)] // Configuration struct - fields may be used in future iterations
struct AmbientConfig {
    light_color: [f32; 3],
    light_intensity: f32,
    fog_color: [f32; 3],
    fog_density: f32,
}

struct LoadedTexture {
    #[allow(dead_code)] // Texture handle kept for resource management
    texture: wgpu::Texture,
    view: wgpu::TextureView,
    sampler: wgpu::Sampler,
}

const CUBE_VERTICES: &[[f32; 3]] = &[
    // A simple unit cube centered at origin
    // front
    [-0.5, -0.5, 0.5],
    [0.5, -0.5, 0.5],
    [0.5, 0.5, 0.5],
    [-0.5, 0.5, 0.5],
    // back
    [-0.5, -0.5, -0.5],
    [-0.5, 0.5, -0.5],
    [0.5, 0.5, -0.5],
    [0.5, -0.5, -0.5],
];

const CUBE_INDICES: &[u16] = &[
    // front
    0, 1, 2, 0, 2, 3, // right
    1, 7, 6, 1, 6, 2, // back
    7, 4, 5, 7, 5, 6, // left
    4, 0, 3, 4, 3, 5, // top
    3, 2, 6, 3, 6, 5, // bottom
    4, 7, 1, 4, 1, 0,
];

// Tree geometry - tall, thin cylinder-like shape with branches
const TREE_VERTICES: &[[f32; 3]] = &[
    // Trunk base (octagon for more natural look)
    [-0.15, -0.5, 0.0],    // 0
    [-0.1, -0.5, 0.1],     // 1
    [0.0, -0.5, 0.15],     // 2
    [0.1, -0.5, 0.1],      // 3
    [0.15, -0.5, 0.0],     // 4
    [0.1, -0.5, -0.1],     // 5
    [0.0, -0.5, -0.15],    // 6
    [-0.1, -0.5, -0.1],    // 7
    
    // Trunk top (narrower)
    [-0.1, 0.8, 0.0],      // 8
    [-0.07, 0.8, 0.07],    // 9
    [0.0, 0.8, 0.1],       // 10
    [0.07, 0.8, 0.07],     // 11
    [0.1, 0.8, 0.0],       // 12
    [0.07, 0.8, -0.07],    // 13
    [0.0, 0.8, -0.1],      // 14
    [-0.07, 0.8, -0.07],   // 15
    
    // Crown/foliage (wider)
    [-0.6, 0.6, 0.0],      // 16
    [-0.4, 0.6, 0.4],      // 17
    [0.0, 0.6, 0.6],       // 18
    [0.4, 0.6, 0.4],       // 19
    [0.6, 0.6, 0.0],       // 20
    [0.4, 0.6, -0.4],      // 21
    [0.0, 0.6, -0.6],      // 22
    [-0.4, 0.6, -0.4],     // 23
    [0.0, 1.2, 0.0],       // 24 - tree top
];

const TREE_INDICES: &[u16] = &[
    // Trunk sides (octagonal)
    0, 1, 9, 0, 9, 8,
    1, 2, 10, 1, 10, 9,
    2, 3, 11, 2, 11, 10,
    3, 4, 12, 3, 12, 11,
    4, 5, 13, 4, 13, 12,
    5, 6, 14, 5, 14, 13,
    6, 7, 15, 6, 15, 14,
    7, 0, 8, 7, 8, 15,
    
    // Crown (foliage) - simplified triangular shape
    8, 16, 17, 8, 17, 9,
    9, 17, 18, 9, 18, 10,
    10, 18, 19, 10, 19, 11,
    11, 19, 20, 11, 20, 12,
    12, 20, 21, 12, 21, 13,
    13, 21, 22, 13, 22, 14,
    14, 22, 23, 14, 23, 15,
    15, 23, 16, 15, 16, 8,
    
    // Crown top triangles
    16, 17, 24, 17, 18, 24, 18, 19, 24, 19, 20, 24,
    20, 21, 24, 21, 22, 24, 22, 23, 24, 23, 16, 24,
];

// House geometry - more complex than a cube
const HOUSE_VERTICES: &[[f32; 3]] = &[
    // Base (wider than cube)
    [-0.8, -0.5, 0.8],     // 0
    [0.8, -0.5, 0.8],      // 1
    [0.8, 0.3, 0.8],       // 2
    [-0.8, 0.3, 0.8],      // 3
    [-0.8, -0.5, -0.8],    // 4
    [-0.8, 0.3, -0.8],     // 5
    [0.8, 0.3, -0.8],      // 6
    [0.8, -0.5, -0.8],     // 7
    
    // Roof peak
    [0.0, 0.8, 0.9],       // 8
    [0.0, 0.8, -0.9],      // 9
    
    // Chimney
    [0.4, 0.3, -0.6],      // 10
    [0.6, 0.3, -0.6],      // 11
    [0.6, 0.3, -0.4],      // 12
    [0.4, 0.3, -0.4],      // 13
    [0.4, 0.9, -0.6],      // 14
    [0.6, 0.9, -0.6],      // 15
    [0.6, 0.9, -0.4],      // 16
    [0.4, 0.9, -0.4],      // 17
];

const HOUSE_INDICES: &[u16] = &[
    // Base walls
    0, 1, 2, 0, 2, 3,       // front
    1, 7, 6, 1, 6, 2,       // right
    7, 4, 5, 7, 5, 6,       // back
    4, 0, 3, 4, 3, 5,       // left
    
    // Roof triangles
    3, 2, 8, 2, 6, 8,       // front roof
    6, 5, 9, 5, 3, 9,       // back roof
    8, 6, 9, 8, 9, 3,       // roof ridge (top)
    
    // Chimney
    10, 11, 15, 10, 15, 14, // chimney front
    11, 12, 16, 11, 16, 15, // chimney right
    12, 13, 17, 12, 17, 16, // chimney back
    13, 10, 14, 13, 14, 17, // chimney left
    14, 15, 16, 14, 16, 17, // chimney top
];

// Character geometry - humanoid shape
const CHARACTER_VERTICES: &[[f32; 3]] = &[
    // Head
    [-0.15, 0.8, 0.15],    // 0
    [0.15, 0.8, 0.15],     // 1
    [0.15, 1.0, 0.15],     // 2
    [-0.15, 1.0, 0.15],    // 3
    [-0.15, 0.8, -0.15],   // 4
    [-0.15, 1.0, -0.15],   // 5
    [0.15, 1.0, -0.15],    // 6
    [0.15, 0.8, -0.15],    // 7
    
    // Torso
    [-0.2, 0.2, 0.1],      // 8
    [0.2, 0.2, 0.1],       // 9
    [0.2, 0.8, 0.1],       // 10
    [-0.2, 0.8, 0.1],      // 11
    [-0.2, 0.2, -0.1],     // 12
    [-0.2, 0.8, -0.1],     // 13
    [0.2, 0.8, -0.1],      // 14
    [0.2, 0.2, -0.1],      // 15
    
    // Legs
    [-0.1, -0.5, 0.05],    // 16
    [0.0, -0.5, 0.05],     // 17
    [0.0, 0.2, 0.05],      // 18
    [-0.1, 0.2, 0.05],     // 19
    [-0.1, -0.5, -0.05],   // 20
    [-0.1, 0.2, -0.05],    // 21
    [0.0, 0.2, -0.05],     // 22
    [0.0, -0.5, -0.05],    // 23
    
    [0.0, -0.5, 0.05],     // 24
    [0.1, -0.5, 0.05],     // 25
    [0.1, 0.2, 0.05],      // 26
    [0.0, 0.2, 0.05],      // 27
    [0.0, -0.5, -0.05],    // 28
    [0.0, 0.2, -0.05],     // 29
    [0.1, 0.2, -0.05],     // 30
    [0.1, -0.5, -0.05],    // 31
];

const CHARACTER_INDICES: &[u16] = &[
    // Head
    0, 1, 2, 0, 2, 3,       // front
    1, 7, 6, 1, 6, 2,       // right
    7, 4, 5, 7, 5, 6,       // back
    4, 0, 3, 4, 3, 5,       // left
    3, 2, 6, 3, 6, 5,       // top
    4, 7, 1, 4, 1, 0,       // bottom
    
    // Torso
    8, 9, 10, 8, 10, 11,    // front
    9, 15, 14, 9, 14, 10,   // right
    15, 12, 13, 15, 13, 14, // back
    12, 8, 11, 12, 11, 13,  // left
    11, 10, 14, 11, 14, 13, // top
    12, 15, 9, 12, 9, 8,    // bottom
    
    // Left leg
    16, 17, 18, 16, 18, 19,
    17, 23, 22, 17, 22, 18,
    23, 20, 21, 23, 21, 22,
    20, 16, 19, 20, 19, 21,
    
    // Right leg
    24, 25, 26, 24, 26, 27,
    25, 31, 30, 25, 30, 26,
    31, 28, 29, 31, 29, 30,
    28, 24, 27, 28, 27, 29,
];

// Enhanced skybox geometry - large inverted cube optimized for biome immersion
const SKYBOX_VERTICES: &[[f32; 3]] = &[
    // Front face (inverted normals - face inward)
    [-2000.0, -2000.0, 2000.0],   // 0 - Expanded for better sky coverage
    [2000.0, -2000.0, 2000.0],    // 1  
    [2000.0, 2000.0, 2000.0],     // 2
    [-2000.0, 2000.0, 2000.0],    // 3
    
    // Back face
    [-2000.0, -2000.0, -2000.0],  // 4
    [-2000.0, 2000.0, -2000.0],   // 5
    [2000.0, 2000.0, -2000.0],    // 6
    [2000.0, -2000.0, -2000.0],   // 7
];

const SKYBOX_INDICES: &[u16] = &[
    // Front face (inverted winding for inside view)
    0, 2, 1, 0, 3, 2,
    // Right face 
    1, 6, 7, 1, 2, 6,
    // Back face
    7, 5, 4, 7, 6, 5,
    // Left face
    4, 3, 0, 4, 5, 3,
    // Top face
    3, 6, 2, 3, 5, 6,
    // Bottom face  
    4, 1, 7, 4, 0, 1,
];

// Mesh type enumeration
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
enum MeshType {
    Cube,
    Tree,
    House,
    Character,
    Skybox,
}

struct Mesh {
    vertex_buffer: wgpu::Buffer,
    index_buffer: wgpu::Buffer,
    index_count: u32,
}

// ------------------------------- Egui wiring -------------------------------

#[allow(dead_code)] // UI state fields may be used in future iterations
struct UiState {
    show_grid: bool,
    show_navmesh: bool,
    show_path: bool,
    physics_paused: bool,
    camera_speed: f32,
    resolution_scale: f32,
    fake_ao: bool,
    fake_reflections: bool,
    fps_text: String,
    info_text: String,
    current_texture_pack: String,
    available_texture_packs: Vec<String>,
}

impl Default for UiState {
    fn default() -> Self {
        Self {
            show_grid: true,
            show_navmesh: true,
            show_path: true,
            physics_paused: false,
            camera_speed: 8.0,
            resolution_scale: 1.0,
            fake_ao: true,
            fake_reflections: false,
            fps_text: String::new(),
            info_text: "AstraWeave Unified Showcase".to_string(),
            current_texture_pack: "grassland".to_string(),
            available_texture_packs: vec!["grassland".to_string(), "desert".to_string()],
        }
    }
}

// ------------------------------- Camera -------------------------------
// Use the proper camera system from astraweave-render

// ------------------------------- Character System -------------------------------

#[derive(Clone)]
struct Character {
    position: Vec3,
    velocity: Vec3,
    target_position: Vec3,
    character_type: CharacterType,
    animation_time: f32,
    patrol_points: Vec<Vec3>,
    current_patrol_index: usize,
}

#[derive(Clone, Copy)]
enum CharacterType {
    Villager,
    Guard,
    Merchant,
    Animal,
}

impl Character {
    fn new(pos: Vec3, char_type: CharacterType) -> Self {
        Self {
            position: pos,
            velocity: Vec3::ZERO,
            target_position: pos,
            character_type: char_type,
            animation_time: 0.0,
            patrol_points: Vec::new(),
            current_patrol_index: 0,
        }
    }

    fn update(&mut self, dt: f32) {
        self.animation_time += dt;

        // Simple AI behavior - move towards target
        let direction = (self.target_position - self.position).normalize_or_zero();
        let speed = match self.character_type {
            CharacterType::Villager => 1.5,
            CharacterType::Guard => 2.0,
            CharacterType::Merchant => 1.2,
            CharacterType::Animal => 2.5,
        };

        self.velocity = direction * speed;
        self.position += self.velocity * dt;

        // Check if reached target and update patrol
        if (self.position - self.target_position).length() < 1.0 && !self.patrol_points.is_empty() {
            self.current_patrol_index = (self.current_patrol_index + 1) % self.patrol_points.len();
            self.target_position = self.patrol_points[self.current_patrol_index];
        }
    }

    fn get_color(&self) -> [f32; 4] {
        match self.character_type {
            CharacterType::Villager => [0.8, 0.6, 0.4, 1.0], // Tan
            CharacterType::Guard => [0.3, 0.3, 0.8, 1.0],    // Blue
            CharacterType::Merchant => [0.6, 0.3, 0.8, 1.0], // Purple
            CharacterType::Animal => [0.9, 0.7, 0.5, 1.0],   // Light brown
        }
    }
}

// ------------------------------- Physics -------------------------------

struct Physics {
    pipeline: r3::PhysicsPipeline,
    gravity: r3::Vector<f32>,
    islands: r3::IslandManager,
    broad: r3::DefaultBroadPhase,
    narrow: r3::NarrowPhase,
    bodies: r3::RigidBodySet,
    colliders: r3::ColliderSet,
    impulse_joints: r3::ImpulseJointSet,
    multibody_joints: r3::MultibodyJointSet,
    ccd: r3::CCDSolver,
    query_pipeline: r3::QueryPipeline,
    integration_params: r3::IntegrationParameters,
}

#[allow(dead_code)] // Type alias may be used in future iterations
type Real = f32;

// ------------------------------- Texture Pack Loading -------------------------------

fn load_texture_pack(path: &Path) -> Result<TexturePack> {
    let content = fs::read_to_string(path)?;
    let pack: TexturePack = toml::from_str(&content)?;
    Ok(pack)
}

fn load_texture_from_bytes(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
    bytes: &[u8],
    label: &str,
) -> Result<LoadedTexture> {
    println!("Loading texture '{}' from {} bytes", label, bytes.len());
    let img = image::load_from_memory(bytes)?;
    let rgba = img.to_rgba8();
    let dimensions = img.dimensions();
    println!(
        "Texture '{}' loaded successfully: {}x{} pixels",
        label, dimensions.0, dimensions.1
    );

    let size = wgpu::Extent3d {
        width: dimensions.0,
        height: dimensions.1,
        depth_or_array_layers: 1,
    };

    let texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some(label),
        size,
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Rgba8UnormSrgb,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });

    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &texture,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &rgba,
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4 * dimensions.0),
            rows_per_image: Some(dimensions.1),
        },
        size,
    );

    let view = texture.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
        address_mode_u: wgpu::AddressMode::Repeat,
        address_mode_v: wgpu::AddressMode::Repeat,
        address_mode_w: wgpu::AddressMode::Repeat,
        mag_filter: wgpu::FilterMode::Linear,
        min_filter: wgpu::FilterMode::Nearest,
        mipmap_filter: wgpu::FilterMode::Nearest,
        ..Default::default()
    });

    println!("Successfully created texture resources for '{}'", label);

    Ok(LoadedTexture {
        texture,
        view,
        sampler,
    })
}

fn load_texture_from_file(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
    path: &Path,
) -> Result<LoadedTexture> {
    println!("Attempting to load texture from file: {}", path.display());
    if !path.exists() {
        eprintln!("ERROR: Texture file does not exist: {}", path.display());
        return Err(anyhow::anyhow!(
            "Texture file not found: {}",
            path.display()
        ));
    }
    let bytes = fs::read(path)?;
    println!(
        "Successfully read {} bytes from {}",
        bytes.len(),
        path.display()
    );
    load_texture_from_bytes(device, queue, &bytes, &path.to_string_lossy())
}

fn reload_texture_pack(render: &mut RenderStuff, texture_pack_name: &str) -> Result<()> {
    // Load texture pack configuration
    let pack_path =
        Path::new("assets_src/environments").join(format!("{}.toml", texture_pack_name));
    let pack = load_texture_pack(&pack_path)?;

    // Load the ground texture specified in the pack
    let texture_name = if pack.ground.texture.ends_with(".ktx2") {
        // Convert .ktx2 reference to .png for now
        pack.ground.texture.replace(".ktx2", ".png")
    } else {
        pack.ground.texture.clone()
    };

    let texture_path = Path::new("assets").join(&texture_name);
    println!(
        "Loading texture pack '{}' with ground texture: {}",
        texture_pack_name,
        texture_path.display()
    );
    
    // Debug: Check if texture file exists
    if !texture_path.exists() {
        eprintln!(
            "ERROR: Texture file not found: {}",
            texture_path.display()
        );
        return Err(anyhow::anyhow!("Texture file not found: {}", texture_path.display()));
    }

    match load_texture_from_file(&render.device, &render.queue, &texture_path) {
        Ok(new_texture) => {
            // Construct normal map path by replacing extension with _n.png
            let tex_stem = Path::new(&texture_name)
                .file_stem()
                .and_then(|s| s.to_str())
                .unwrap_or("texture");
            let npath = Path::new("assets").join(format!("{}_n.png", tex_stem));
            let normal_tex = if npath.exists() {
                load_texture_from_file(&render.device, &render.queue, &npath)?
            } else {
                eprintln!(
                    "Warning: Normal map not found at {}. Using default normal map.",
                    npath.display()
                );
                // Use a default normal map (e.g., flat normal)
                // You may need to provide a default normal map in your assets, e.g., "default_n.png"
                let default_npath = Path::new("assets").join("default_n.png");
                load_texture_from_file(&render.device, &render.queue, &default_npath)?
            };

            // Create bind group with both textures
            let combined_bg = render.device.create_bind_group(&wgpu::BindGroupDescriptor {
                label: Some(&format!("{}-albedo-normal", texture_pack_name)),
                layout: &render.texture_bind_group_layout,
                entries: &[
                    wgpu::BindGroupEntry {
                        binding: 0,
                        resource: wgpu::BindingResource::TextureView(&new_texture.view),
                    },
                    wgpu::BindGroupEntry {
                        binding: 1,
                        resource: wgpu::BindingResource::Sampler(&new_texture.sampler),
                    },
                    wgpu::BindGroupEntry {
                        binding: 2,
                        resource: wgpu::BindingResource::TextureView(&normal_tex.view),
                    },
                    wgpu::BindGroupEntry {
                        binding: 3,
                        resource: wgpu::BindingResource::Sampler(&normal_tex.sampler),
                    },
                ],
            });

            // Update render state
            render.ground_texture = Some(new_texture);
            render.ground_normal = Some(normal_tex);
            render.ground_bind_group = Some(combined_bg);

            println!("Successfully loaded texture pack: {}", texture_pack_name);
            Ok(())
        }
        Err(e) => {
            println!(
                "Failed to load texture for pack '{}': {}",
                texture_pack_name, e
            );
            Err(e)
        }
    }
}

fn generate_environment_objects(physics: &mut Physics, texture_pack_name: &str) -> Vec<Character> {
    // Clear existing objects (keep ground and first few objects as player/sphere)
    let mut handles_to_remove = Vec::new();
    for (handle, body) in physics.bodies.iter() {
        if body.user_data > 2 {
            // Keep player objects (user_data 1, 2)
            handles_to_remove.push(handle);
        }
    }

    for handle in handles_to_remove {
        physics.bodies.remove(
            handle,
            &mut physics.islands,
            &mut physics.colliders,
            &mut physics.impulse_joints,
            &mut physics.multibody_joints,
            true,
        );
    }

    let mut characters = Vec::new();

    // Generate comprehensive biome environments
    match texture_pack_name {
        "grassland" => {
            // === VEGETATION ===
            // Dense forest areas with varied tree types - significantly increased density
            for i in 0..75 {
                let x = -35.0 + (i as f32) * 1.2 + (i as f32 * 0.7).sin() * 2.5;
                let z = -25.0 + (i % 8) as f32 * 4.0 + (i as f32 * 0.9).cos() * 3.0;

                // Vary tree types and sizes for realistic forest
                let (height, width, _tree_type) = match i % 4 {
                    0 => (2.5, 0.3, "oak"),      // Large oak trees
                    1 => (1.8, 0.2, "pine"),     // Medium pine trees  
                    2 => (1.2, 0.15, "birch"),   // Small birch trees
                    _ => (3.0, 0.4, "ancient"),  // Ancient giant trees
                };

                let tree_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(10 + i)
                    .build();
                let tree_handle = physics.bodies.insert(tree_rb);
                let tree_col = r3::ColliderBuilder::cuboid(width, height, width).build();
                physics
                    .colliders
                    .insert_with_parent(tree_col, tree_handle, &mut physics.bodies);
            }

            // Scattered bushes and undergrowth - increased density
            for i in 0..35 {
                let x = -15.0 + (i as f32) * 2.5 + (i as f32 * 1.3).sin() * 5.0;
                let z = 5.0 + (i as f32 * 1.1).cos() * 12.0;
                let size = 0.2 + (i % 3) as f32 * 0.1;

                let bush_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + size, z))
                    .user_data(100 + i)
                    .build();
                let bush_handle = physics.bodies.insert(bush_rb);
                let bush_col = r3::ColliderBuilder::cuboid(size, size * 0.6, size).build();
                physics
                    .colliders
                    .insert_with_parent(bush_col, bush_handle, &mut physics.bodies);
            }

            // === STRUCTURES ===
            // Village with varied building types - more structures
            for i in 0..15 {
                let x = 15.0 + (i as f32) * 6.0 + (i as f32).sin() * 4.0;
                let z = -8.0 + (i % 4) as f32 * 8.0 + (i as f32).cos() * 3.0;

                let (width, height, depth, _building_type) = match i % 5 {
                    0 => (2.2, 1.5, 1.8, "manor"),      // Large manor house
                    1 => (1.5, 1.0, 1.2, "cottage"),    // Medium cottage
                    2 => (1.0, 0.8, 1.0, "hut"),        // Small hut
                    3 => (2.8, 2.0, 2.0, "temple"),     // Village temple
                    _ => (1.8, 1.2, 1.5, "workshop"),   // Workshops and shops
                };

                let house_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(35 + i)
                    .build();
                let house_handle = physics.bodies.insert(house_rb);
                let house_col = r3::ColliderBuilder::cuboid(width, height, depth).build();
                physics
                    .colliders
                    .insert_with_parent(house_col, house_handle, &mut physics.bodies);
            }

            // === GEOLOGICAL FEATURES ===
            // Rolling hills with scattered boulders - increased geological features
            for i in 0..25 {
                let x = -30.0 + (i as f32) * 6.0 + (i as f32 * 2.1).sin() * 8.0;
                let z = 20.0 + (i as f32 * 1.7).cos() * 10.0;
                let size = 0.8 + (i % 4) as f32 * 0.5;

                let boulder_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + size, z))
                    .user_data(60 + i)
                    .build();
                let boulder_handle = physics.bodies.insert(boulder_rb);
                let boulder_col = r3::ColliderBuilder::cuboid(size, size * 0.8, size * 1.1).build();
                physics
                    .colliders
                    .insert_with_parent(boulder_col, boulder_handle, &mut physics.bodies);
            }

            // Stone circles and ancient ruins
            for i in 0..6 {
                let angle = (i as f32) * std::f32::consts::PI * 2.0 / 6.0;
                let radius = 12.0;
                let x = radius * angle.cos();
                let z = radius * angle.sin() + 30.0;
                let height = 1.5 + (i % 2) as f32 * 0.8;

                let stone_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(200 + i)
                    .build();
                let stone_handle = physics.bodies.insert(stone_rb);
                let stone_col = r3::ColliderBuilder::cuboid(0.4, height, 0.3).build();
                physics
                    .colliders
                    .insert_with_parent(stone_col, stone_handle, &mut physics.bodies);
            }

            // === WATER FEATURES ===
            // River with stone banks
            for i in 0..10 {
                let x = -15.0 + (i as f32) * 3.0;
                let z = -30.0 + (i as f32) * 2.0 + (i as f32 * 2.0).sin() * 8.0;
                let size = 0.3 + (i % 2) as f32 * 0.2;

                let bank_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.5, z))
                    .user_data(300 + i)
                    .build();
                let bank_handle = physics.bodies.insert(bank_rb);
                let bank_col = r3::ColliderBuilder::cuboid(size, 0.2, size * 1.5).build();
                physics
                    .colliders
                    .insert_with_parent(bank_col, bank_handle, &mut physics.bodies);
            }

            // === CHARACTERS ===
            // Village inhabitants with varied roles and patrol patterns - more NPCs
            for i in 0..20 {
                let x = 10.0 + (i as f32) * 4.0 + (i as f32).sin() * 4.0;
                let z = -12.0 + (i as f32 * 1.3).sin() * 15.0;
                let pos = Vec3::new(x, -1.0, z);

                let char_type = match i % 5 {
                    0 => CharacterType::Villager,
                    1 => CharacterType::Guard,
                    2 => CharacterType::Merchant,
                    3 => CharacterType::Animal,
                    _ => CharacterType::Villager,
                };

                let mut character = Character::new(pos, char_type);

                // Complex patrol routes for realistic behavior
                match char_type {
                    CharacterType::Guard => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(8.0, 0.0, 2.0),
                            pos + Vec3::new(6.0, 0.0, 8.0),
                            pos + Vec3::new(-2.0, 0.0, 6.0),
                            pos + Vec3::new(-4.0, 0.0, 0.0),
                        ];
                    }
                    CharacterType::Merchant => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(12.0, 0.0, 0.0),
                            pos + Vec3::new(8.0, 0.0, -6.0),
                        ];
                    }
                    CharacterType::Animal => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(4.0, 0.0, 4.0),
                            pos + Vec3::new(-3.0, 0.0, 2.0),
                            pos + Vec3::new(1.0, 0.0, -3.0),
                        ];
                    }
                    _ => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(3.0, 0.0, 0.0),
                            pos + Vec3::new(3.0, 0.0, 3.0),
                            pos + Vec3::new(0.0, 0.0, 3.0),
                        ];
                    }
                }
                character.target_position = if !character.patrol_points.is_empty() {
                    character.patrol_points[1]
                } else {
                    pos
                };

                characters.push(character);
            }
        }
        "desert" => {
            // === VEGETATION ===
            // Varied cacti and desert plants - increased density
            for i in 0..40 {
                let x = -25.0 + (i as f32) * 3.0 + (i as f32 * 1.2).sin() * 4.0;
                let z = -15.0 + (i % 6) as f32 * 6.0 + (i as f32 * 0.8).cos() * 8.0;

                let (width, height, _cactus_type) = match i % 5 {
                    0 => (0.2, 3.5, "saguaro"),        // Tall saguaro cactus
                    1 => (0.4, 1.0, "barrel"),         // Barrel cactus
                    2 => (0.15, 2.2, "prickly_pear"),  // Prickly pear
                    3 => (0.25, 1.8, "cholla"),        // Cholla cactus
                    _ => (0.3, 0.6, "desert_shrub"),   // Desert shrub
                };

                let cactus_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(30 + i)
                    .build();
                let cactus_handle = physics.bodies.insert(cactus_rb);
                let cactus_col = r3::ColliderBuilder::cuboid(width, height, width).build();
                physics.colliders.insert_with_parent(
                    cactus_col,
                    cactus_handle,
                    &mut physics.bodies,
                );
            }

            // === STRUCTURES ===
            // Desert settlement with adobe architecture - more buildings
            for i in 0..12 {
                let x = 20.0 + (i as f32) * 8.0 + (i as f32).cos() * 5.0;
                let z = 5.0 + (i % 3) as f32 * 12.0 + (i as f32).sin() * 4.0;

                let (width, height, depth, _building_type) = match i % 3 {
                    0 => (2.5, 1.2, 2.0, "adobe_compound"), // Large compound
                    1 => (1.8, 0.9, 1.5, "adobe_house"),    // Medium house
                    _ => (3.0, 1.8, 2.5, "adobe_temple"),   // Temple/mosque
                };

                let adobe_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(40 + i)
                    .build();
                let adobe_handle = physics.bodies.insert(adobe_rb);
                let adobe_col = r3::ColliderBuilder::cuboid(width, height, depth).build();
                physics
                    .colliders
                    .insert_with_parent(adobe_col, adobe_handle, &mut physics.bodies);
            }

            // === GEOLOGICAL FEATURES ===
            // Mesa formations and desert rock outcrops - more geological variety
            for i in 0..25 {
                let x = -30.0 + (i as f32) * 5.0 + (i as f32 * 1.9).sin() * 10.0;
                let z = 25.0 + (i as f32 * 1.3).cos() * 12.0;
                let size = 1.2 + (i % 5) as f32 * 0.8;

                let (width, height, depth) = match i % 4 {
                    0 => (size, size * 2.0, size * 0.8), // Tall mesa
                    1 => (size * 1.5, size, size * 1.2), // Wide plateau
                    2 => (size * 0.6, size * 3.0, size * 0.6), // Spire
                    _ => (size, size * 0.8, size), // Regular rock
                };

                let formation_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(76 + i)
                    .build();
                let formation_handle = physics.bodies.insert(formation_rb);
                let formation_col = r3::ColliderBuilder::cuboid(width, height, depth).build();
                physics.colliders.insert_with_parent(
                    formation_col,
                    formation_handle,
                    &mut physics.bodies,
                );
            }

            // Sand dunes (represented as low, wide formations)
            for i in 0..8 {
                let x = 0.0 + (i as f32) * 15.0 + (i as f32 * 2.5).sin() * 10.0;
                let z = -25.0 + (i as f32 * 1.8).cos() * 15.0;
                let width = 4.0 + (i % 3) as f32 * 2.0;
                let height = 0.5 + (i % 2) as f32 * 0.3;

                let dune_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(400 + i)
                    .build();
                let dune_handle = physics.bodies.insert(dune_rb);
                let dune_col = r3::ColliderBuilder::cuboid(width, height, width * 0.6).build();
                physics
                    .colliders
                    .insert_with_parent(dune_col, dune_handle, &mut physics.bodies);
            }

            // === WATER FEATURES ===
            // Oasis with palm-like vegetation
            let oasis_x = 5.0;
            let oasis_z = 10.0;
            for i in 0..5 {
                let angle = (i as f32) * std::f32::consts::PI * 2.0 / 5.0;
                let radius = 3.0;
                let x = oasis_x + radius * angle.cos();
                let z = oasis_z + radius * angle.sin();

                let palm_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + 2.0, z))
                    .user_data(500 + i)
                    .build();
                let palm_handle = physics.bodies.insert(palm_rb);
                let palm_col = r3::ColliderBuilder::cuboid(0.2, 2.0, 0.2).build();
                physics
                    .colliders
                    .insert_with_parent(palm_col, palm_handle, &mut physics.bodies);
            }

            // === CHARACTERS ===
            // Desert nomads and traders
            for i in 0..8 {
                let x = 15.0 + (i as f32) * 12.0 + (i as f32).sin() * 5.0;
                let z = -5.0 + (i as f32 * 0.9).sin() * 8.0;
                let pos = Vec3::new(x, -1.0, z);

                let char_type = match i % 4 {
                    0 => CharacterType::Merchant,
                    1 => CharacterType::Guard,
                    2 => CharacterType::Animal, // Desert animals (camels, etc.)
                    _ => CharacterType::Villager, // Nomads
                };

                let mut character = Character::new(pos, char_type);

                // Longer patrol routes for desert environment
                match char_type {
                    CharacterType::Merchant => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(20.0, 0.0, 5.0),
                            pos + Vec3::new(15.0, 0.0, 15.0),
                            pos + Vec3::new(-5.0, 0.0, 10.0),
                        ];
                    }
                    CharacterType::Animal => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(8.0, 0.0, 8.0),
                            pos + Vec3::new(-5.0, 0.0, 12.0),
                            pos + Vec3::new(-8.0, 0.0, -3.0),
                        ];
                    }
                    _ => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(10.0, 0.0, 3.0),
                            pos + Vec3::new(6.0, 0.0, 8.0),
                            pos + Vec3::new(-3.0, 0.0, 5.0),
                        ];
                    }
                }
                character.target_position = if !character.patrol_points.is_empty() {
                    character.patrol_points[1]
                } else {
                    pos
                };

                characters.push(character);
            }
        }
        "forest" => {
            // === DENSE FOREST BIOME ===
            // Ancient forest with towering trees and rich undergrowth
            
            // === VEGETATION ===
            // Ancient towering trees - higher density for deep forest feeling
            for i in 0..95 {
                let x = -40.0 + (i as f32) * 1.1 + (i as f32 * 0.6).sin() * 3.0;
                let z = -30.0 + (i % 10) as f32 * 3.8 + (i as f32 * 0.8).cos() * 4.0;

                // Varied ancient tree types with dramatic height differences
                let (height, width, _tree_type) = match i % 6 {
                    0 => (4.5, 0.6, "ancient_oak"),     // Massive ancient oaks
                    1 => (3.8, 0.4, "giant_pine"),     // Tall pines
                    2 => (2.8, 0.3, "elder_birch"),    // Elder birch
                    3 => (5.2, 0.8, "world_tree"),     // Mythical world trees
                    4 => (3.2, 0.35, "cedar"),         // Tall cedars
                    _ => (2.2, 0.25, "maple"),          // Forest maples
                };

                let tree_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(10 + i)
                    .build();
                let tree_handle = physics.bodies.insert(tree_rb);
                let tree_col = r3::ColliderBuilder::cuboid(width, height, width).build();
                physics
                    .colliders
                    .insert_with_parent(tree_col, tree_handle, &mut physics.bodies);
            }

            // Dense undergrowth and ferns - forest floor vegetation
            for i in 0..60 {
                let x = -25.0 + (i as f32) * 2.0 + (i as f32 * 1.4).sin() * 6.0;
                let z = 8.0 + (i as f32 * 1.2).cos() * 15.0;
                let size = 0.15 + (i % 4) as f32 * 0.08;

                let undergrowth_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + size, z))
                    .user_data(150 + i)
                    .build();
                let undergrowth_handle = physics.bodies.insert(undergrowth_rb);
                let undergrowth_col = r3::ColliderBuilder::cuboid(size, size * 0.5, size).build();
                physics
                    .colliders
                    .insert_with_parent(undergrowth_col, undergrowth_handle, &mut physics.bodies);
            }

            // === STRUCTURES ===
            // Woodland dwellings and mystical sites
            for i in 0..8 {
                let x = 25.0 + (i as f32) * 8.0 + (i as f32).sin() * 6.0;
                let z = -5.0 + (i % 3) as f32 * 10.0 + (i as f32).cos() * 4.0;

                let (width, height, depth, _building_type) = match i % 4 {
                    0 => (2.0, 1.8, 1.6, "tree_house"),      // Elevated tree houses
                    1 => (1.2, 2.5, 1.2, "wizard_tower"),    // Tall mystical towers
                    2 => (2.5, 1.0, 2.5, "woodland_shrine"), // Ground-level shrines
                    _ => (1.6, 1.4, 1.4, "ranger_cabin"),    // Ranger cabins
                };

                let structure_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(200 + i)
                    .build();
                let structure_handle = physics.bodies.insert(structure_rb);
                let structure_col = r3::ColliderBuilder::cuboid(width, height, depth).build();
                physics
                    .colliders
                    .insert_with_parent(structure_col, structure_handle, &mut physics.bodies);
            }

            // === GEOLOGICAL FEATURES ===
            // Moss-covered boulders and ancient stone formations
            for i in 0..18 {
                let x = -35.0 + (i as f32) * 7.0 + (i as f32 * 2.2).sin() * 10.0;
                let z = 25.0 + (i as f32 * 1.8).cos() * 12.0;
                let size = 1.0 + (i % 3) as f32 * 0.6;

                let boulder_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + size * 0.8, z))
                    .user_data(250 + i)
                    .build();
                let boulder_handle = physics.bodies.insert(boulder_rb);
                let boulder_col = r3::ColliderBuilder::cuboid(size, size * 0.8, size * 0.9).build();
                physics
                    .colliders
                    .insert_with_parent(boulder_col, boulder_handle, &mut physics.bodies);
            }

            // Ancient stone circles (mystical sites)
            let circle_center_x = 0.0;
            let circle_center_z = 15.0;
            for i in 0..8 {
                let angle = (i as f32) * std::f32::consts::PI * 2.0 / 8.0;
                let radius = 8.0;
                let x = circle_center_x + radius * angle.cos();
                let z = circle_center_z + radius * angle.sin();

                let stone_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + 1.5, z))
                    .user_data(300 + i)
                    .build();
                let stone_handle = physics.bodies.insert(stone_rb);
                let stone_col = r3::ColliderBuilder::cuboid(0.5, 1.5, 0.3).build();
                physics
                    .colliders
                    .insert_with_parent(stone_col, stone_handle, &mut physics.bodies);
            }

            // === WATER FEATURES ===
            // Forest streams and pools
            for i in 0..3 {
                let x = -10.0 + (i as f32) * 15.0;
                let z = -12.0 + (i as f32) * 8.0;

                let pool_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + 0.2, z))
                    .user_data(350 + i)
                    .build();
                let pool_handle = physics.bodies.insert(pool_rb);
                let pool_col = r3::ColliderBuilder::cuboid(2.0, 0.2, 1.5).build();
                physics
                    .colliders
                    .insert_with_parent(pool_col, pool_handle, &mut physics.bodies);
            }

            // === CHARACTERS ===
            // Forest dwellers and mystical beings
            for i in 0..10 {
                let x = -20.0 + (i as f32) * 8.0 + (i as f32 * 1.1).sin() * 12.0;
                let z = -10.0 + (i as f32 * 0.9).cos() * 18.0;
                let pos = Vec3::new(x, -1.5, z);

                let char_type = match i % 5 {
                    0 => CharacterType::Guard,    // Forest rangers
                    1 => CharacterType::Merchant, // Herb gatherers
                    2 => CharacterType::Villager, // Forest dwellers  
                    3 => CharacterType::Guard,    // Druids (using guard type)
                    _ => CharacterType::Villager, // Woodland folk
                };

                let mut character = Character::new(pos, char_type);

                // Forest-specific patrol routes through the trees
                match i % 4 {
                    0 => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(6.0, 0.0, 2.0),
                            pos + Vec3::new(4.0, 0.0, 8.0),
                            pos + Vec3::new(-2.0, 0.0, 6.0),
                            pos + Vec3::new(-4.0, 0.0, 2.0),
                        ];
                    }
                    1 => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(-5.0, 0.0, 3.0),
                            pos + Vec3::new(-3.0, 0.0, -4.0),
                            pos + Vec3::new(2.0, 0.0, -2.0),
                        ];
                    }
                    2 => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(8.0, 0.0, -1.0),
                            pos + Vec3::new(5.0, 0.0, -6.0),
                            pos + Vec3::new(-1.0, 0.0, -4.0),
                        ];
                    }
                    _ => {
                        character.patrol_points = vec![
                            pos,
                            pos + Vec3::new(2.0, 0.0, 7.0),
                            pos + Vec3::new(-3.0, 0.0, 5.0),
                            pos + Vec3::new(-1.0, 0.0, 1.0),
                        ];
                    }
                }

                characters.push(character);
            }
        }
        _ => {
            // Enhanced default environment with mixed biome features
            for i in 0..15 {
                let x = -12.0 + (i as f32) * 2.5;
                let z = 3.0 + (i % 3) as f32 * 6.0 + (i as f32).sin() * 3.0;
                let height = 1.0 + (i % 4) as f32 * 0.8;

                let obj_rb = r3::RigidBodyBuilder::fixed()
                    .translation(nalgebra::Vector3::new(x, -2.0 + height, z))
                    .user_data(50 + i)
                    .build();
                let obj_handle = physics.bodies.insert(obj_rb);
                let obj_col = r3::ColliderBuilder::cuboid(0.6, height, 0.6).build();
                physics
                    .colliders
                    .insert_with_parent(obj_col, obj_handle, &mut physics.bodies);
            }

            // Default characters with simple behavior
            for i in 0..6 {
                let x = (i as f32) * 6.0;
                let z = (i % 2) as f32 * 4.0;
                let pos = Vec3::new(x, -1.0, z);
                let mut character = Character::new(pos, CharacterType::Villager);
                character.patrol_points = vec![
                    pos,
                    pos + Vec3::new(4.0, 0.0, 0.0),
                    pos + Vec3::new(4.0, 0.0, 4.0),
                    pos + Vec3::new(0.0, 0.0, 4.0),
                ];
                character.target_position = character.patrol_points[1];
                characters.push(character);
            }
        }
    }

    characters
}

// ------------------------------- Main entry -------------------------------

fn main() -> Result<()> {
    // Use pollster to block on the async run
    pollster::block_on(run())
}

async fn run() -> Result<()> {
    // Generate default textures at startup if missing (seed -> vary looks)
    let seed = 0xA57; // change to taste / hook to key for regeneration
    texture_synth::ensure_textures("assets", seed, false)?;

    // Boilerplate: create event loop and window
    let event_loop = EventLoop::new()?;
    let window = std::sync::Arc::new(
        WindowBuilder::new()
            .with_title("AstraWeave Unified Showcase (Modified)")
            .build(&event_loop)?,
    );
    // Setup renderer, UI, physics
    let mut render = setup_renderer(window.clone()).await?;
    let mut physics = build_physics_world();

    // Initialize default environment and texture pack
    let mut characters = generate_environment_objects(&mut physics, "grassland");

    // Load the initial grassland texture pack
    if let Err(e) = reload_texture_pack(&mut render, "grassland") {
        println!(
            "Warning: Failed to load initial grassland texture pack: {}",
            e
        );
        println!("Continuing with default textures...");
        println!(
            "Note: You can still switch texture packs using keys 1 (grassland) and 2 (desert)"
        );
    } else {
        println!("Successfully loaded initial grassland texture pack");
        println!(
            "Controls: WASD+mouse=camera, P=pause physics, T=teleport sphere, E=apply impulse, C=toggle camera mode"
        );
        println!("Mouse wheel: zoom camera | Right-click + mouse: look around");
        println!("Texture packs: Press 1 for grassland, 2 for desert, 3 for forest");
    }

    let mut instances = build_show_instances();
    let mut ui = UiState::default();

    // Use proper camera system from astraweave-render with enhanced positioning for optimal biome showcase
    let mut camera = RenderCamera {
        position: Vec3::new(15.0, 12.0, 30.0), // Enhanced position to better showcase biome diversity
        yaw: -0.3,    // Better angle to view village, forest, and terrain features
        pitch: -0.4,  // Optimal pitch to see both terrain detail and sky
        fovy: 70f32.to_radians(), // Optimized field of view for biome immersion
        aspect: 1.0,
        znear: 0.01,
        zfar: 10000.0, // Extended far plane for maximum terrain visibility
    };
    let mut camera_controller = CameraController::new(8.0, 0.002);
    let mut last = Instant::now();
    let mut fps_acc = 0.0;
    let mut fps_cnt = 0u32;

    let elwt = event_loop;
    let _ = elwt.run(move |event, elwt_window_target| {
        elwt_window_target.set_control_flow(winit::event_loop::ControlFlow::Poll);
        match event {
            Event::WindowEvent {
                event: win_event, ..
            } => {
                match win_event {
                    WindowEvent::CloseRequested => {
                        elwt_window_target.exit();
                    }
                    WindowEvent::KeyboardInput {
                        event:
                            KeyEvent {
                                physical_key,
                                state,
                                ..
                            },
                        ..
                    } => {
                        let pressed = state == ElementState::Pressed;
                        match physical_key {
                            PhysicalKey::Code(code) => {
                                camera_controller.process_keyboard(code, pressed);
                                match code {
                                    KeyCode::Escape => {
                                        if pressed {
                                            elwt_window_target.exit();
                                        }
                                    }
                                    KeyCode::KeyP => {
                                        if pressed {
                                            ui.physics_paused = !ui.physics_paused;
                                        }
                                    }
                                    KeyCode::KeyT => {
                                        if pressed {
                                            // Teleport sphere a few meters in front of camera
                                            let forward = astraweave_render::camera::Camera::dir(
                                                camera.yaw,
                                                camera.pitch,
                                            );
                                            let target = camera.position
                                                + forward * 4.0
                                                + Vec3::new(0.0, -0.5, 0.0);
                                            teleport_sphere_to(&mut physics, target);
                                        }
                                    }
                                    KeyCode::KeyE => {
                                        if pressed {
                                            // Raycast forward and apply impulse to first hit dynamic body
                                            let forward = astraweave_render::camera::Camera::dir(
                                                camera.yaw,
                                                camera.pitch,
                                            );

                                            // Create a ray for the query
                                            let ray_origin = nalgebra::Point3::new(
                                                camera.position.x,
                                                camera.position.y,
                                                camera.position.z,
                                            );
                                            let ray_dir = nalgebra::Vector3::new(
                                                forward.x, forward.y, forward.z,
                                            );
                                            let ray = r3::Ray::new(ray_origin, ray_dir);

                                            // Update the query pipeline with just the colliders
                                            physics.query_pipeline.update(&physics.colliders);

                                            // Cast the ray
                                            if let Some((h, _toi)) =
                                                physics.query_pipeline.cast_ray(
                                                    &physics.bodies,
                                                    &physics.colliders,
                                                    &ray,
                                                    15.0,
                                                    true,
                                                    r3::QueryFilter::default(),
                                                )
                                            {
                                                if let Some(body) =
                                                    physics.bodies.get_mut(r3::RigidBodyHandle(h.0))
                                                {
                                                    if !body.is_fixed() {
                                                        let impulse = nalgebra::Vector3::new(
                                                            forward.x * 3.0,
                                                            1.0,
                                                            forward.z * 3.0,
                                                        );
                                                        body.apply_impulse(impulse, true);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    KeyCode::KeyC => {
                                        if pressed {
                                            camera_controller.toggle_mode(&mut camera);
                                            println!("Camera mode: {:?}", camera_controller.mode);
                                        }
                                    }
                                    KeyCode::Digit1 => {
                                        if pressed {
                                            let pack_name = "grassland";
                                            if let Err(e) =
                                                reload_texture_pack(&mut render, pack_name)
                                            {
                                                println!(
                                                    "Failed to switch to {} texture pack: {}",
                                                    pack_name, e
                                                );
                                            } else {
                                                ui.current_texture_pack = pack_name.to_string();
                                                ui.info_text = format!(
                                                    "Switched to {} environment",
                                                    pack_name
                                                );
                                                characters = generate_environment_objects(
                                                    &mut physics,
                                                    pack_name,
                                                );
                                            }
                                        }
                                    }
                                    KeyCode::Digit2 => {
                                        if pressed {
                                            let pack_name = "desert";
                                            println!("Attempting to switch to desert texture pack...");
                                            if let Err(e) =
                                                reload_texture_pack(&mut render, pack_name)
                                            {
                                                println!(
                                                    "Failed to switch to {} texture pack: {}",
                                                    pack_name, e
                                                );
                                            } else {
                                                ui.current_texture_pack = pack_name.to_string();
                                                ui.info_text = format!(
                                                    "Switched to {} environment",
                                                    pack_name
                                                );
                                                println!("Successfully switched to desert texture pack");
                                                characters = generate_environment_objects(
                                                    &mut physics,
                                                    pack_name,
                                                );
                                                println!("Regenerated {} desert environment objects", characters.len());
                                            }
                                        }
                                    }
                                    KeyCode::Digit3 => {
                                        if pressed {
                                            let pack_name = "forest";
                                            if let Err(e) =
                                                reload_texture_pack(&mut render, pack_name)
                                            {
                                                println!(
                                                    "Failed to switch to {} texture pack: {}",
                                                    pack_name, e
                                                );
                                            } else {
                                                println!(
                                                    "Switched to {} environment",
                                                    pack_name
                                                );
                                                characters = generate_environment_objects(
                                                    &mut physics,
                                                    pack_name,
                                                );
                                            }
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            _ => {}
                        }
                    }
                    WindowEvent::MouseInput { state, button, .. } => {
                        camera_controller
                            .process_mouse_button(button, state == ElementState::Pressed);
                        if button == winit::event::MouseButton::Right {
                            let pressed = state == ElementState::Pressed;
                            // Grab or release cursor for reliable deltas
                            if pressed {
                                let _ = window.set_cursor_grab(CursorGrabMode::Locked);
                                window.set_cursor_visible(false);
                            } else {
                                let _ = window.set_cursor_grab(CursorGrabMode::None);
                                window.set_cursor_visible(true);
                            }
                        }
                    }
                    WindowEvent::MouseWheel {
                        delta: MouseScrollDelta::LineDelta(_, y),
                        ..
                    } => {
                        // Use camera controller for zoom instead of speed adjustment
                        camera_controller.process_scroll(&mut camera, y);
                    }
                    WindowEvent::Resized(size) => {
                        render.surface_cfg.width = size.width.max(1);
                        render.surface_cfg.height = size.height.max(1);
                        render
                            .surface
                            .configure(&render.device, &render.surface_cfg);
                        render.depth_view = create_depth(
                            &render.device,
                            render.surface_cfg.width,
                            render.surface_cfg.height,
                            render.msaa_samples,
                        );

                        // Update UI info with character count
                        ui.info_text = format!(
                            "Environment: {} ({} characters)",
                            ui.current_texture_pack,
                            characters.len()
                        );
                    }
                    WindowEvent::RedrawRequested => {
                        let now = Instant::now();
                        let dt = now - last;
                        last = now;

                        // smooth FPS
                        let fps = 1.0 / dt.as_secs_f32().max(1e-5);
                        fps_acc += fps;
                        fps_cnt += 1;
                        if fps_cnt >= 30 {
                            ui.fps_text = format!("{:.1} fps", fps_acc / fps_cnt as f32);
                            fps_acc = 0.0;
                            fps_cnt = 0;
                        }

                        // Update camera
                        camera.aspect = (render.surface_cfg.width as f32 * ui.resolution_scale)
                            .max(1.0)
                            / (render.surface_cfg.height as f32 * ui.resolution_scale).max(1.0);

                        // Update camera with controller
                        camera_controller.update_camera(&mut camera, dt.as_secs_f32());

                        // Update characters
                        for character in &mut characters {
                            character.update(dt.as_secs_f32());
                        }

                        // Physics
                        if !ui.physics_paused {
                            physics_step(&mut physics);
                        }

                        // Sync sim to render and batch instances by mesh type
                        sync_instances_from_physics(&physics, &characters, &mut instances);
                        render.instance_count = instances.len() as u32;
                        
                        // Batch instances by mesh type for efficient rendering
                        let instance_batches = batch_instances_by_mesh_type(&instances);

                        // Camera uniform
                        let cam = GpuCamera {
                            view_proj: camera.vp().to_cols_array(),
                        };
                        render
                            .queue
                            .write_buffer(&render.camera_ub, 0, bytemuck::bytes_of(&cam));

                        // Render
                        let frame = match render.surface.get_current_texture() {
                            Ok(f) => f,
                            Err(_) => {
                                render
                                    .surface
                                    .configure(&render.device, &render.surface_cfg);
                                render.surface.get_current_texture().unwrap()
                            }
                        };
                        let view = frame
                            .texture
                            .create_view(&wgpu::TextureViewDescriptor::default());
                        let mut encoder =
                            render
                                .device
                                .create_command_encoder(&wgpu::CommandEncoderDescriptor {
                                    label: Some("main-encoder"),
                                });
                        {
                            let mut rp = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                                label: Some("main-pass"),
                                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
                                    view: &view,
                                    resolve_target: None,
                                    ops: wgpu::Operations {
                                        load: wgpu::LoadOp::Clear(wgpu::Color {
                                            r: 0.4,  // Sky color that matches procedural sky
                                            g: 0.6,  // to eliminate void appearance
                                            b: 0.9,  // if skybox has any gaps
                                            a: 1.0,
                                        }),
                                        store: wgpu::StoreOp::Store,
                                    },
                                })],
                                depth_stencil_attachment: Some(
                                    wgpu::RenderPassDepthStencilAttachment {
                                        view: &render.depth_view,
                                        depth_ops: Some(wgpu::Operations {
                                            load: wgpu::LoadOp::Clear(1.0),
                                            store: wgpu::StoreOp::Store,
                                        }),
                                        stencil_ops: None,
                                    },
                                ),
                                timestamp_writes: None,
                                occlusion_query_set: None,
                            });
                            rp.set_pipeline(&render.pipeline);
                            rp.set_bind_group(0, &render.camera_bg, &[]);
                            if let Some(ref texture_bg) = render.ground_bind_group {
                                rp.set_bind_group(1, texture_bg, &[]);
                            }
                            // Render each mesh type batch efficiently
                            // Render skybox first with special depth handling
                            for batch in &instance_batches {
                                if batch.mesh_type == MeshType::Skybox {
                                    if let Some(mesh) = render.meshes.get(&batch.mesh_type) {
                                        // Upload skybox instances to the instance buffer
                                        render.queue.write_buffer(
                                            &render.instance_vb,
                                            0,
                                            bytemuck::cast_slice(&batch.instances),
                                        );
                                        
                                        // Set up rendering for skybox - render at far plane
                                        rp.set_vertex_buffer(0, mesh.vertex_buffer.slice(..));
                                        rp.set_vertex_buffer(1, render.instance_vb.slice(..));
                                        rp.set_index_buffer(
                                            mesh.index_buffer.slice(..),
                                            wgpu::IndexFormat::Uint16,
                                        );
                                        
                                        // Draw skybox
                                        if !batch.instances.is_empty() {
                                            rp.draw_indexed(
                                                0..mesh.index_count,
                                                0,
                                                0..batch.instances.len() as u32,
                                            );
                                        }
                                    }
                                }
                            }
                            
                            // Render all other mesh types after skybox
                            for batch in &instance_batches {
                                if batch.mesh_type != MeshType::Skybox {
                                    if let Some(mesh) = render.meshes.get(&batch.mesh_type) {
                                        // Upload this batch's instances to the instance buffer
                                        render.queue.write_buffer(
                                            &render.instance_vb,
                                            0,
                                            bytemuck::cast_slice(&batch.instances),
                                        );
                                        
                                        // Set up rendering for this mesh type
                                        rp.set_vertex_buffer(0, mesh.vertex_buffer.slice(..));
                                        rp.set_vertex_buffer(1, render.instance_vb.slice(..));
                                        rp.set_index_buffer(
                                            mesh.index_buffer.slice(..),
                                            wgpu::IndexFormat::Uint16,
                                        );
                                        
                                        // Draw this batch
                                        if !batch.instances.is_empty() {
                                            rp.draw_indexed(
                                                0..mesh.index_count,
                                                0,
                                                0..batch.instances.len() as u32,
                                            );
                                        }
                                    }
                                }
                            }
                        }
                        render.queue.submit(Some(encoder.finish()));
                        frame.present();
                    }
                    _ => {}
                }
            }
            Event::AboutToWait => {
                window.request_redraw();
            }
            Event::DeviceEvent {
                event: DeviceEvent::MouseMotion { delta },
                ..
            } => {
                // Use proper mouse delta handling for camera controller
                let mouse_delta = Vec2::new(delta.0 as f32, delta.1 as f32);
                camera_controller.process_mouse_delta(&mut camera, mouse_delta);
            }
            _ => {}
        }
    });
    Ok(())
}

// ---------------- Helper functions for default textures ----------------

fn create_default_albedo_texture(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
) -> Result<LoadedTexture> {
    let white_texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("default-white"),
        size: wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Rgba8UnormSrgb,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });
    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &white_texture,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &[255, 255, 255, 255], // RGBA white
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4),
            rows_per_image: Some(1),
        },
        wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
    );
    let view = white_texture.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor::default());
    Ok(LoadedTexture {
        texture: white_texture,
        view,
        sampler,
    })
}

fn create_default_normal_texture(
    device: &wgpu::Device,
    queue: &wgpu::Queue,
) -> Result<LoadedTexture> {
    let normal_texture = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("default-normal"),
        size: wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: 1,
        dimension: wgpu::TextureDimension::D2,
        format: wgpu::TextureFormat::Rgba8UnormSrgb,
        usage: wgpu::TextureUsages::TEXTURE_BINDING | wgpu::TextureUsages::COPY_DST,
        view_formats: &[],
    });
    queue.write_texture(
        wgpu::ImageCopyTexture {
            texture: &normal_texture,
            mip_level: 0,
            origin: wgpu::Origin3d::ZERO,
            aspect: wgpu::TextureAspect::All,
        },
        &[128, 128, 255, 255], // Default normal pointing up (0, 0, 1) in normal map encoding
        wgpu::ImageDataLayout {
            offset: 0,
            bytes_per_row: Some(4),
            rows_per_image: Some(1),
        },
        wgpu::Extent3d {
            width: 1,
            height: 1,
            depth_or_array_layers: 1,
        },
    );
    let view = normal_texture.create_view(&wgpu::TextureViewDescriptor::default());
    let sampler = device.create_sampler(&wgpu::SamplerDescriptor::default());
    Ok(LoadedTexture {
        texture: normal_texture,
        view,
        sampler,
    })
}

// ---------------- renderer setup ----------------
// Structure to hold batched instance data for efficient rendering
struct InstanceBatch {
    instances: Vec<InstanceRaw>,
    mesh_type: MeshType,
}

fn batch_instances_by_mesh_type(instances: &[InstanceRaw]) -> Vec<InstanceBatch> {
    let mut batches = Vec::new();
    
    // Create separate batches for each mesh type including skybox
    for &mesh_type_val in &[MeshType::Skybox as u32, MeshType::Cube as u32, MeshType::Tree as u32, MeshType::House as u32, MeshType::Character as u32] {
        let mesh_type = match mesh_type_val {
            0 => MeshType::Cube,
            1 => MeshType::Tree,
            2 => MeshType::House,
            3 => MeshType::Character,
            4 => MeshType::Skybox,
            _ => MeshType::Cube,
        };
        
        let filtered_instances: Vec<InstanceRaw> = instances
            .iter()
            .filter(|instance| instance.mesh_type == mesh_type_val)
            .copied()
            .collect();
            
        if !filtered_instances.is_empty() {
            batches.push(InstanceBatch {
                instances: filtered_instances,
                mesh_type,
            });
        }
    }
    
    batches
}

fn create_mesh(device: &wgpu::Device, vertices: &[[f32; 3]], indices: &[u16]) -> Mesh {
    let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("mesh-vertices"),
        contents: bytemuck::cast_slice(vertices),
        usage: wgpu::BufferUsages::VERTEX,
    });
    
    let index_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
        label: Some("mesh-indices"),
        contents: bytemuck::cast_slice(indices),
        usage: wgpu::BufferUsages::INDEX,
    });
    
    Mesh {
        vertex_buffer,
        index_buffer,
        index_count: indices.len() as u32,
    }
}

fn create_all_meshes(device: &wgpu::Device) -> std::collections::HashMap<MeshType, Mesh> {
    let mut meshes = std::collections::HashMap::new();
    
    meshes.insert(MeshType::Cube, create_mesh(device, CUBE_VERTICES, CUBE_INDICES));
    meshes.insert(MeshType::Tree, create_mesh(device, TREE_VERTICES, TREE_INDICES));
    meshes.insert(MeshType::House, create_mesh(device, HOUSE_VERTICES, HOUSE_INDICES));
    meshes.insert(MeshType::Character, create_mesh(device, CHARACTER_VERTICES, CHARACTER_INDICES));
    meshes.insert(MeshType::Skybox, create_mesh(device, SKYBOX_VERTICES, SKYBOX_INDICES));
    
    meshes
}

async fn setup_renderer(window: std::sync::Arc<winit::window::Window>) -> Result<RenderStuff> {
    let size = window.inner_size();
    println!(
        "Setting up wgpu renderer with window size: {}x{}",
        size.width, size.height
    );

    // Enable debug features for better error reporting
    let instance = wgpu::Instance::new(wgpu::InstanceDescriptor {
        backends: wgpu::Backends::all(),
        flags: wgpu::InstanceFlags::DEBUG | wgpu::InstanceFlags::VALIDATION,
        ..Default::default()
    });

    println!("Creating surface...");
    let surface = instance.create_surface(window.clone())?;

    println!("Requesting adapter...");
    let adapter = instance
        .request_adapter(&wgpu::RequestAdapterOptions {
            power_preference: wgpu::PowerPreference::HighPerformance,
            compatible_surface: Some(&surface),
            force_fallback_adapter: false,
        })
        .await
        .unwrap();

    println!("Adapter found: {:?}", adapter.get_info());

    println!("Requesting device...");
    let (device, queue) = adapter
        .request_device(
            &wgpu::DeviceDescriptor {
                label: Some("device"),
                required_features: wgpu::Features::empty(),
                required_limits: wgpu::Limits::default(),
            },
            None, // Enable validation for debug builds: Some(&std::path::Path::new("wgpu_trace"))
        )
        .await
        .unwrap();

    println!("Device created successfully");

    let msaa_samples = 1u32;
    let caps = surface.get_capabilities(&adapter);
    println!("Surface capabilities: {:?}", caps);

    let surface_format = caps
        .formats
        .iter()
        .copied()
        .find(|f| f.is_srgb())
        .unwrap_or(caps.formats[0]);

    println!("Selected surface format: {:?}", surface_format);
    let surface_cfg = wgpu::SurfaceConfiguration {
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
        format: surface_format,
        width: size.width.max(1),
        height: size.height.max(1),
        present_mode: caps.present_modes[0],
        alpha_mode: caps.alpha_modes[0],
        view_formats: vec![],
        desired_maximum_frame_latency: 2,
    };
    surface.configure(&device, &surface_cfg);
    let depth_view = create_depth(&device, surface_cfg.width, surface_cfg.height, msaa_samples);

    // Create all meshes
    let meshes = create_all_meshes(&device);

    // Create camera uniform buffer and bind group layout
    let camera_ub = device.create_buffer(&wgpu::BufferDescriptor {
        label: Some("camera-ub"),
        size: std::mem::size_of::<GpuCamera>() as u64,
        usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
        mapped_at_creation: false,
    });
    let camera_bg_layout = device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
        label: Some("camera-layout"),
        entries: &[wgpu::BindGroupLayoutEntry {
            binding: 0,
            visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
            ty: wgpu::BindingType::Buffer {
                ty: wgpu::BufferBindingType::Uniform,
                has_dynamic_offset: false,
                min_binding_size: None,
            },
            count: None,
        }],
    });
    let camera_bg = device.create_bind_group(&wgpu::BindGroupDescriptor {
        label: Some("camera-bg"),
        layout: &camera_bg_layout,
        entries: &[wgpu::BindGroupEntry {
            binding: 0,
            resource: camera_ub.as_entire_binding(),
        }],
    });

    // Texture bind group layout (for albedo + normal mapping)
    let texture_bind_group_layout =
        device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
            label: Some("albedo+normal"),
            entries: &[
                // binding 0: albedo texture
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        multisampled: false,
                        view_dimension: wgpu::TextureViewDimension::D2,
                        sample_type: wgpu::TextureSampleType::Float { filterable: true },
                    },
                    count: None,
                },
                // binding 1: albedo sampler
                wgpu::BindGroupLayoutEntry {
                    binding: 1,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                    count: None,
                },
                // binding 2: normal texture
                wgpu::BindGroupLayoutEntry {
                    binding: 2,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Texture {
                        multisampled: false,
                        view_dimension: wgpu::TextureViewDimension::D2,
                        sample_type: wgpu::TextureSampleType::Float { filterable: true },
                    },
                    count: None,
                },
                // binding 3: normal sampler
                wgpu::BindGroupLayoutEntry {
                    binding: 3,
                    visibility: wgpu::ShaderStages::FRAGMENT,
                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
                    count: None,
                },
            ],
        });

    // Try to load grass texture, fallback to default if not available
    let (ground_texture, ground_normal, ground_bind_group) =
        match load_texture_from_file(&device, &queue, Path::new("assets/grass.png")) {
            Ok(texture) => {
                // Try to load corresponding normal map
                let normal_texture = match load_texture_from_file(
                    &device,
                    &queue,
                    Path::new("assets/grass_n.png"),
                ) {
                    Ok(normal) => normal,
                    Err(_) => create_default_normal_texture(&device, &queue)?,
                };

                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("ground-texture-bg"),
                    layout: &texture_bind_group_layout,
                    entries: &[
                        wgpu::BindGroupEntry {
                            binding: 0,
                            resource: wgpu::BindingResource::TextureView(&texture.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 1,
                            resource: wgpu::BindingResource::Sampler(&texture.sampler),
                        },
                        wgpu::BindGroupEntry {
                            binding: 2,
                            resource: wgpu::BindingResource::TextureView(&normal_texture.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 3,
                            resource: wgpu::BindingResource::Sampler(&normal_texture.sampler),
                        },
                    ],
                });
                (Some(texture), Some(normal_texture), Some(bind_group))
            }
            Err(_) => {
                // Create default textures as fallback
                let default_albedo = create_default_albedo_texture(&device, &queue)?;
                let default_normal = create_default_normal_texture(&device, &queue)?;

                let bind_group = device.create_bind_group(&wgpu::BindGroupDescriptor {
                    label: Some("default-texture-bg"),
                    layout: &texture_bind_group_layout,
                    entries: &[
                        wgpu::BindGroupEntry {
                            binding: 0,
                            resource: wgpu::BindingResource::TextureView(&default_albedo.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 1,
                            resource: wgpu::BindingResource::Sampler(&default_albedo.sampler),
                        },
                        wgpu::BindGroupEntry {
                            binding: 2,
                            resource: wgpu::BindingResource::TextureView(&default_normal.view),
                        },
                        wgpu::BindGroupEntry {
                            binding: 3,
                            resource: wgpu::BindingResource::Sampler(&default_normal.sampler),
                        },
                    ],
                });
                (Some(default_albedo), Some(default_normal), Some(bind_group))
            }
        };

    // Instance buffer (increased size for enhanced environment objects)
    let max_instances = 200; // Increased from 100 to accommodate more objects
    let instance_vb = device.create_buffer(&wgpu::BufferDescriptor {
        label: Some("instance-buffer"),
        size: (std::mem::size_of::<InstanceRaw>() * max_instances) as u64,
        usage: wgpu::BufferUsages::VERTEX | wgpu::BufferUsages::COPY_DST,
        mapped_at_creation: false,
    });

    // Create pipeline with procedural shader
    let shader_module = device.create_shader_module(wgpu::ShaderModuleDescriptor {
        label: Some("shader"),
        source: wgpu::ShaderSource::Wgsl(Cow::Borrowed(SHADER)),
    });
    let pipeline_layout = device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
        label: Some("pipeline-layout"),
        bind_group_layouts: &[&camera_bg_layout, &texture_bind_group_layout],
        push_constant_ranges: &[],
    });

    let pipeline = device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
        label: Some("pipeline"),
        layout: Some(&pipeline_layout),
        vertex: wgpu::VertexState {
            module: &shader_module,
            entry_point: "vs_main",
            buffers: &[
                wgpu::VertexBufferLayout {
                    array_stride: 3 * 4,
                    step_mode: wgpu::VertexStepMode::Vertex,
                    attributes: &[wgpu::VertexAttribute {
                        format: wgpu::VertexFormat::Float32x3,
                        offset: 0,
                        shader_location: 0,
                    }],
                },
                // instance transform (4 vec4 + color + mesh_type)
                wgpu::VertexBufferLayout {
                    array_stride: std::mem::size_of::<InstanceRaw>() as u64,
                    step_mode: wgpu::VertexStepMode::Instance,
                    attributes: &[
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 0,
                            shader_location: 1,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 16,
                            shader_location: 2,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 32,
                            shader_location: 3,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 48,
                            shader_location: 4,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Float32x4,
                            offset: 64,
                            shader_location: 5,
                        },
                        wgpu::VertexAttribute {
                            format: wgpu::VertexFormat::Uint32,
                            offset: 80,
                            shader_location: 6,
                        },
                    ],
                },
            ],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        },
        fragment: Some(wgpu::FragmentState {
            module: &shader_module,
            entry_point: "fs_main",
            targets: &[Some(wgpu::ColorTargetState {
                format: surface_format,
                blend: Some(wgpu::BlendState::ALPHA_BLENDING),
                write_mask: wgpu::ColorWrites::ALL,
            })],
            compilation_options: wgpu::PipelineCompilationOptions::default(),
        }),
        primitive: wgpu::PrimitiveState {
            topology: wgpu::PrimitiveTopology::TriangleList,
            strip_index_format: None,
            front_face: wgpu::FrontFace::Ccw,
            cull_mode: Some(wgpu::Face::Back),
            ..Default::default()
        },
        depth_stencil: Some(wgpu::DepthStencilState {
            format: DEPTH_FORMAT,
            depth_write_enabled: true,
            depth_compare: wgpu::CompareFunction::Less,
            stencil: wgpu::StencilState::default(),
            bias: wgpu::DepthBiasState::default(),
        }),
        multisample: wgpu::MultisampleState {
            count: msaa_samples,
            mask: !0,
            alpha_to_coverage_enabled: false,
        },
        multiview: None,
    });

    Ok(RenderStuff {
        surface,
        surface_cfg,
        device,
        queue,
        depth_view,
        pipeline,
        meshes,
        camera_ub,
        camera_bg,
        instance_vb,
        instance_count: 0, // Will be updated dynamically
        msaa_samples,
        ground_texture,
        texture_bind_group_layout,
        ground_bind_group,
        ground_normal,
    })
}

fn create_depth(device: &wgpu::Device, width: u32, height: u32, samples: u32) -> wgpu::TextureView {
    let tex = device.create_texture(&wgpu::TextureDescriptor {
        label: Some("depth"),
        size: wgpu::Extent3d {
            width,
            height,
            depth_or_array_layers: 1,
        },
        mip_level_count: 1,
        sample_count: samples,
        dimension: wgpu::TextureDimension::D2,
        format: DEPTH_FORMAT,
        usage: wgpu::TextureUsages::RENDER_ATTACHMENT,
        view_formats: &[],
    });
    tex.create_view(&wgpu::TextureViewDescriptor::default())
}

// ---------------- shader with procedural ground/sky ----------------

const SHADER: &str = r#"
struct Camera { view_proj: mat4x4<f32> };
struct TimeUniform { time: f32, _padding: vec3<f32> };

@group(0) @binding(0) var<uniform> u_camera: Camera;
@group(1) @binding(0) var ground_texture: texture_2d<f32>;
@group(1) @binding(1) var ground_sampler: sampler;
@group(1) @binding(2) var ground_normal: texture_2d<f32>;
@group(1) @binding(3) var normal_sampler: sampler;

// Note: Time uniform would be @group(2) @binding(0) in a full implementation
// For now, we'll use a constant or calculated time

struct VsIn {
  @location(0) pos: vec3<f32>,
  @location(1) m0: vec4<f32>,
  @location(2) m1: vec4<f32>,
  @location(3) m2: vec4<f32>,
  @location(4) m3: vec4<f32>,
  @location(5) color: vec4<f32>,
  @location(6) mesh_type: u32,
};

struct VsOut {
  @builtin(position) pos: vec4<f32>,
  @location(0) color: vec4<f32>,
  @location(1) world_pos: vec3<f32>,
  @location(2) view_dir: vec3<f32>,
  @location(3) mesh_type: u32,
};

@vertex
fn vs_main(in: VsIn) -> VsOut {
  let model = mat4x4<f32>(in.m0, in.m1, in.m2, in.m3);
  var out: VsOut;
  let world = model * vec4<f32>(in.pos, 1.0);
  
  // Special handling for skybox (mesh_type 4) - position at far plane
  if (in.mesh_type == 4u) {
    // For skybox, create a view matrix without translation (rotation only)
    // and scale the skybox vertex position to create a large enough skybox
    let scaled_pos = vec4<f32>(in.pos * 0.1, 1.0); // Scale down from large vertices
    out.pos = u_camera.view_proj * scaled_pos;
    // Ensure skybox is always at far plane depth
    out.pos.z = out.pos.w * 0.999; // At far plane
    out.world_pos = scaled_pos.xyz;
  } else {
    out.pos = u_camera.view_proj * world;
    out.world_pos = world.xyz;
  }
  
  out.color = in.color;
  out.mesh_type = in.mesh_type;
  
  // Calculate view direction for sky effects
  let camera_pos = vec3<f32>(0.0, 2.0, 0.0); // Approximate camera position for sky
  out.view_dir = normalize(world.xyz - camera_pos);
  
  return out;
}

// Enhanced sky color function - generates biome-appropriate sky with atmospheric effects
fn sky_color(direction: vec3<f32>, time: f32) -> vec3<f32> {
  let dir = normalize(direction);
  let y = clamp(dir.y, -1.0, 1.0);
  
  // Enhanced time-based sun position for day/night cycle
  let sun_angle = time * 0.08; // Slightly slower day cycle
  let sun_dir = normalize(vec3<f32>(cos(sun_angle) * 0.9, sin(sun_angle) * 0.9, sin(sun_angle * 0.2) * 0.3));
  
  // Calculate sun influence with enhanced scattering
  let sun_dot = max(dot(dir, sun_dir), 0.0);
  let sun_influence = pow(sun_dot, 16.0); // Brighter sun disk
  let sun_halo = pow(sun_dot, 4.0) * 0.3; // Soft sun halo
  
  // Enhanced day factor based on sun height
  let day_factor = clamp(sun_dir.y + 0.3, 0.0, 1.0);
  
  // More vibrant sky gradient colors
  let horizon_day = vec3<f32>(0.9, 0.95, 1.0);    // Brighter blue horizon
  let zenith_day = vec3<f32>(0.2, 0.5, 0.95);     // Rich blue zenith
  let horizon_sunset = vec3<f32>(1.0, 0.7, 0.4);  // Warm sunset colors
  let zenith_sunset = vec3<f32>(0.8, 0.4, 0.6);   // Purple sunset zenith
  let horizon_night = vec3<f32>(0.05, 0.05, 0.2); // Deep blue night
  let zenith_night = vec3<f32>(0.02, 0.02, 0.15); // Dark night zenith
  
  // Calculate sunset factor for warm transitional colors
  let sunset_factor = clamp(1.0 - abs(sun_dir.y) * 3.0, 0.0, 1.0) * clamp(day_factor * 2.0, 0.0, 1.0);
  
  // Blend colors based on time of day and sunset
  let horizon_color = mix(
    mix(horizon_night, horizon_day, day_factor),
    horizon_sunset,
    sunset_factor
  );
  let zenith_color = mix(
    mix(zenith_night, zenith_day, day_factor),
    zenith_sunset,
    sunset_factor
  );
  
  // Enhanced vertical gradient with atmospheric curve
  let atmosphere_curve = pow(clamp((y + 1.0) * 0.5, 0.0, 1.0), 0.7);
  let sky_base = mix(horizon_color, zenith_color, atmosphere_curve);
  
  // Enhanced sun disk and atmospheric scattering
  let sun_color = mix(
    vec3<f32>(1.0, 0.95, 0.8),  // Day sun
    vec3<f32>(1.0, 0.6, 0.3),   // Sunset sun
    sunset_factor
  ) * day_factor;
  let sun_contribution = (sun_influence * 0.8 + sun_halo) * sun_color;
  
  // Enhanced atmospheric effects with distance-based haze
  let atmosphere_factor = pow(1.0 - abs(y), 1.5);
  let atmosphere_color = mix(
    vec3<f32>(0.6, 0.7, 0.9),   // Cool atmospheric color
    vec3<f32>(1.0, 0.8, 0.6),   // Warm atmospheric color
    sunset_factor
  );
  let atmosphere_contribution = atmosphere_factor * atmosphere_color * 0.15 * day_factor;
  
  // Add subtle cloud-like variation
  let cloud_noise = sin(dir.x * 8.0 + time * 0.5) * cos(dir.z * 6.0 + time * 0.3) * 0.1;
  let cloud_factor = max(cloud_noise, 0.0) * clamp(y + 0.2, 0.0, 1.0);
  let cloud_color = mix(vec3<f32>(0.9, 0.9, 0.95), vec3<f32>(1.0, 0.8, 0.7), sunset_factor);
  let cloud_contribution = cloud_factor * cloud_color * day_factor * 0.3;
  
  return sky_base + sun_contribution + atmosphere_contribution + cloud_contribution;
}


// Enhanced water rendering for rivers and lakes
fn get_water_level(world_pos: vec2<f32>, time: f32) -> f32 {
  let wave_scale = 0.5;
  let wave_time = time * 2.0;
  let wave_pos = world_pos * wave_scale + vec2<f32>(wave_time * 0.3, wave_time * 0.5);
  
  // Water surface animation
  let wave1 = sin(wave_pos.x * 4.0) * cos(wave_pos.y * 3.0) * 0.1;
  let wave2 = sin(wave_pos.x * 8.0 + 1.0) * cos(wave_pos.y * 6.0 + 1.5) * 0.05;
  
  return -1.8 + wave1 + wave2; // Base water level with waves
}

// Determine biome type based on world position
fn get_biome_type(world_pos: vec2<f32>) -> i32 {
  let biome_scale = 0.02;
  let biome_pos = world_pos * biome_scale;
  
  // Enhanced biome detection with three distinct regions
  let primary_noise = sin(biome_pos.x * 3.0) * cos(biome_pos.y * 2.0);
  let secondary_noise = sin(biome_pos.x * 1.5 + 100.0) * cos(biome_pos.y * 1.8 + 200.0);
  let combined_noise = primary_noise * 0.7 + secondary_noise * 0.3;
  
  if (combined_noise > 0.3) {
    return 1; // Desert
  } else if (combined_noise < -0.2) {
    return 2; // Dense Forest
  } else {
    return 0; // Grassland
  }
}

// Generate biome-specific terrain height with enhanced variation
fn get_biome_terrain_height(world_pos: vec2<f32>, biome_type: i32) -> f32 {
  // Enhanced base terrain generation using multiple octaves of noise
  let base_scale = 0.005;  // Larger terrain features
  let detail_scale = 0.02;  // Medium detail
  let fine_scale = 0.15;   // Fine surface detail
  let micro_scale = 0.8;   // Micro surface variation
  
  // Base elevation noise with more dramatic height
  let base_noise = sin(world_pos.x * base_scale) * cos(world_pos.y * base_scale);
  let detail_noise = sin(world_pos.x * detail_scale + 1.0) * cos(world_pos.y * detail_scale + 1.5);
  let fine_noise = sin(world_pos.x * fine_scale + 2.0) * cos(world_pos.y * fine_scale + 2.5);
  let micro_noise = sin(world_pos.x * micro_scale + 3.0) * cos(world_pos.y * micro_scale + 3.5);
  
  // Combine noise layers with stronger influence
  let combined_noise = base_noise * 0.5 + detail_noise * 0.25 + fine_noise * 0.15 + micro_noise * 0.1;
  
  if (biome_type == 0) { // Grassland - rolling hills with valleys
    let grassland_height = combined_noise * 4.0; // Increased from 2.0 for more dramatic terrain
    
    // Enhanced river valleys with meandering patterns
    let river_x = sin(world_pos.x * 0.006) * 0.8;
    let river_z = cos(world_pos.y * 0.004) * 0.6;
    let river_noise = sin((world_pos.x + river_z * 20.0) * 0.008) * cos((world_pos.y + river_x * 15.0) * 0.01);
    let valley_factor = 1.0 - abs(river_noise);
    let valley_depth = valley_factor * valley_factor * valley_factor * -3.0; // Deeper valleys
    
    // Add gentle rolling hills
    let hill_pattern = sin(world_pos.x * 0.01) * cos(world_pos.y * 0.012) * 2.0;
    
    return grassland_height + valley_depth + hill_pattern;
    
  } else if (biome_type == 1) { // Desert - dramatic mesas and dunes
    let desert_height = combined_noise * 5.0; // Increased from 3.0 for more dramatic terrain
    
    // Enhanced sand dune patterns with wind erosion
    let dune_scale = 0.02;
    let dune_noise = sin(world_pos.x * dune_scale) + cos(world_pos.y * dune_scale * 0.6);
    let wind_direction = sin(world_pos.x * 0.001) * cos(world_pos.y * 0.0008);
    let dune_height = (dune_noise + wind_direction * 0.5) * 2.5; // Larger dunes
    
    // More dramatic rocky mesa formations
    let mesa_scale = 0.003;
    let mesa_noise = sin(world_pos.x * mesa_scale) * cos(world_pos.y * mesa_scale);
    let mesa_height = step(0.2, mesa_noise) * 8.0; // Taller mesas (increased from 4.0)
    
    // Add canyon effects
    let canyon_noise = sin(world_pos.x * 0.008) * cos(world_pos.y * 0.006);
    let canyon_depth = step(0.6, abs(canyon_noise)) * -4.0;
    
    return desert_height + dune_height + mesa_height + canyon_depth;
    
  } else if (biome_type == 2) { // Dense Forest - undulating hills with valleys
    let forest_height = combined_noise * 3.5; // Moderate height variation
    
    // Gentle undulating hills characteristic of forest terrain
    let hill_scale = 0.008;
    let hill_noise = sin(world_pos.x * hill_scale) * cos(world_pos.y * hill_scale * 0.7);
    let rolling_hills = hill_noise * 2.8;
    
    // Forest clearings and depressions
    let clearing_scale = 0.015;
    let clearing_noise = sin(world_pos.x * clearing_scale + 50.0) * cos(world_pos.y * clearing_scale + 30.0);
    let clearing_depression = step(0.4, clearing_noise) * -1.5;
    
    // Ancient forest mounds (raised areas around old growth)
    let mound_scale = 0.004;
    let mound_noise = sin(world_pos.x * mound_scale + 100.0) * cos(world_pos.y * mound_scale + 200.0);
    let mound_height = step(0.3, mound_noise) * 1.8;
    
    // Stream valleys cutting through forest
    let stream_x = sin(world_pos.x * 0.007) * 0.6;
    let stream_z = cos(world_pos.y * 0.005) * 0.4;
    let stream_noise = sin((world_pos.x + stream_z * 15.0) * 0.01) * cos((world_pos.y + stream_x * 12.0) * 0.009);
    let stream_factor = 1.0 - abs(stream_noise);
    let stream_depth = stream_factor * stream_factor * -2.0;
    
    return forest_height + rolling_hills + clearing_depression + mound_height + stream_depth;
    
  } else {
    // Enhanced default fallback
    return combined_noise * 3.0; // Increased from 1.5
  }
}

@fragment
fn fs_main(in: VsOut) -> @location(0) vec4<f32> {
  var col = in.color.rgb;
  let time = 100.0; // TODO: Pass actual time as uniform
  
  // Determine biome type for this world position
  let biome_type = get_biome_type(in.world_pos.xz);
  
  // Enhanced ground rendering with biome-specific terrain
  let ground_y = -2.0;
  let terrain_height = get_biome_terrain_height(in.world_pos.xz, biome_type);
  let water_level = get_water_level(in.world_pos.xz, time);
  let terrain_surface = ground_y + terrain_height;
  let dist_to_terrain = abs(in.world_pos.y - terrain_surface);
  let dist_to_water = abs(in.world_pos.y - water_level);
  
  // Check if we're rendering the terrain surface
  if (dist_to_terrain < 0.8 || (in.mesh_type == 0u && in.world_pos.y < ground_y + 1.0)) {
    let scale = 3.0;
    let uv = vec2<f32>(in.world_pos.x / scale, in.world_pos.z / scale);
    var tex_color = textureSample(ground_texture, ground_sampler, uv).rgb;
    
    // Sample normal map for enhanced surface detail (moved before biome-specific texturing)
    let normal_sample = textureSample(ground_normal, normal_sampler, uv).rgb;
    let normal = normalize(normal_sample * 2.0 - 1.0);
    
    // Biome-specific terrain texturing
    if (biome_type == 0) { // Grassland
      // Mix grass with dirt based on terrain height and slope
      let height_factor = clamp((terrain_height + 2.0) / 6.0, 0.0, 1.0);
      let grass_color = vec3<f32>(0.3, 0.6, 0.2);
      let dirt_color = vec3<f32>(0.4, 0.3, 0.2);
      tex_color = mix(tex_color, mix(dirt_color, grass_color, height_factor), 0.7);
      
      // Add moss and vegetation on flat areas
      let slope_factor = 1.0 - abs(terrain_height) / 4.0;
      let moss_color = vec3<f32>(0.2, 0.5, 0.15);
      tex_color = mix(tex_color, moss_color, slope_factor * 0.3);
      
    } else if (biome_type == 1) { // Desert
      // Use sampled sand texture with height-based lightening and slope-based rock blending
      let h_factor = clamp(1.0 + terrain_height * 0.3, 0.0, 1.0);
      let sand_tex = tex_color.rgb * h_factor;
      
      // Optional tint: rock color on steep slopes (using normal map for better slope detection)
      let rock_color = vec3<f32>(0.5, 0.45, 0.4);
      let slope = clamp(1.0 - abs(normal.y), 0.0, 1.0);
      let blended = mix(sand_tex, rock_color, slope * 0.5);
      
      // Add mineral deposits and oasis effects using the blended texture
      let mineral_noise = sin(in.world_pos.x * 0.5) * cos(in.world_pos.z * 0.3);
      if (mineral_noise > 0.7) {
        let mineral_color = vec3<f32>(0.7, 0.6, 0.4);
        tex_color = mix(blended, mineral_color, 0.3);
      } else {
        tex_color = blended;
      }
    } else if (biome_type == 2) { // Dense Forest
      // Rich forest floor with deep organic layers
      let height_factor = clamp((terrain_height + 2.0) / 5.0, 0.0, 1.0);
      let forest_base = tex_color.rgb;
      
      // Dark rich soil base
      let soil_color = vec3<f32>(0.25, 0.2, 0.15);
      let leaf_litter = vec3<f32>(0.4, 0.3, 0.2);
      let moss_color = vec3<f32>(0.15, 0.4, 0.2);
      
      // Slope-based moss coverage (more moss on gentle slopes)
      let slope = clamp(1.0 - abs(normal.y), 0.0, 1.0);
      let moss_factor = (1.0 - slope) * 0.6;
      
      // Height-based composition
      let base_mix = mix(soil_color, leaf_litter, height_factor);
      tex_color = mix(forest_base, base_mix, 0.8);
      tex_color = mix(tex_color, moss_color, moss_factor);
      
      // Add depth variation with organic patches
      let organic_noise = sin(in.world_pos.x * 2.0) * cos(in.world_pos.z * 1.8);
      if (organic_noise > 0.4) {
        let organic_color = vec3<f32>(0.3, 0.25, 0.18);
        tex_color = mix(tex_color, organic_color, 0.4);
      }
      
      // Dappled light effect (filtering through canopy)
      let light_spots = sin(in.world_pos.x * 0.3) * cos(in.world_pos.z * 0.25);
      if (light_spots > 0.6) {
        tex_color = tex_color * 1.15; // Brighter in light spots
      } else if (light_spots < -0.3) {
        tex_color = tex_color * 0.85; // Darker in deep shade
      }
    }
    
    // Enhanced lighting with biome-specific adjustments
    let sun_angle = time * 0.1;
    let sun_dir = normalize(vec3<f32>(cos(sun_angle) * 0.8, sin(sun_angle) * 0.8, sin(sun_angle * 0.3) * 0.4));
    let ambient_dir = vec3<f32>(0.0, 1.0, 0.0);
    
    let sun_ndotl = max(dot(normal, sun_dir), 0.0);
    let ambient_ndotl = max(dot(normal, ambient_dir), 0.0);
    
    // Biome-specific lighting adjustments
    let day_factor = clamp(sun_dir.y + 0.2, 0.0, 1.0);
    var sun_color: vec3<f32>;
    var ambient_color: vec3<f32>;
    var base_ambient: vec3<f32>;
    
    if (biome_type == 0) { // Grassland - bright, clear lighting
      sun_color = mix(vec3<f32>(0.2, 0.2, 0.4), vec3<f32>(1.0, 0.95, 0.8), day_factor);
      ambient_color = mix(vec3<f32>(0.1, 0.1, 0.2), vec3<f32>(0.4, 0.5, 0.6), day_factor);
      base_ambient = mix(vec3<f32>(0.05, 0.05, 0.1), vec3<f32>(0.1, 0.1, 0.15), day_factor);
    } else if (biome_type == 1) { // Desert - warm, harsh lighting  
      sun_color = mix(vec3<f32>(0.3, 0.2, 0.3), vec3<f32>(1.0, 0.9, 0.7), day_factor);
      ambient_color = mix(vec3<f32>(0.15, 0.1, 0.15), vec3<f32>(0.5, 0.4, 0.5), day_factor);
      base_ambient = mix(vec3<f32>(0.08, 0.05, 0.08), vec3<f32>(0.12, 0.08, 0.1), day_factor);
    } else { // Forest - filtered, green-tinted lighting
      sun_color = mix(vec3<f32>(0.15, 0.2, 0.3), vec3<f32>(0.8, 0.9, 0.7), day_factor);
      ambient_color = mix(vec3<f32>(0.08, 0.12, 0.15), vec3<f32>(0.3, 0.4, 0.3), day_factor);
      base_ambient = mix(vec3<f32>(0.04, 0.06, 0.08), vec3<f32>(0.08, 0.1, 0.08), day_factor);
    }
    
    let sun_lighting = sun_ndotl * sun_color;
    let ambient_lighting = ambient_ndotl * ambient_color * 0.3;
    let lighting = sun_lighting + ambient_lighting + base_ambient;
    
    // Enhanced detail patterns
    let detail_scale = 8.0 + terrain_height * 0.2;
    let cx = floor(in.world_pos.x / detail_scale);
    let cz = floor(in.world_pos.z / detail_scale);
    let detail_pattern = f32((i32(cx + cz) & 1)) * 0.06;
    
    col = tex_color * lighting * (0.96 + detail_pattern);
    
    // Add atmospheric perspective
    let distance = length(in.world_pos);
    let fog_factor = clamp(distance / 80.0, 0.0, 1.0);
    let fog_color = sky_color(normalize(in.world_pos), time);
    col = mix(col, fog_color, fog_factor * 0.2);
    
  } else if (dist_to_water < 0.3 && terrain_height < -0.5) {
    // Water rendering for rivers and lakes
    let water_color = vec3<f32>(0.1, 0.3, 0.6);
    let wave_distortion = sin(in.world_pos.x * 2.0 + time) * cos(in.world_pos.z * 1.8 + time * 1.2) * 0.05;
    let water_surface = water_color + vec3<f32>(wave_distortion, wave_distortion * 0.5, -wave_distortion * 0.3);
    
    // Reflection and transparency effects
    let view_angle = abs(dot(normalize(in.view_dir), vec3<f32>(0.0, 1.0, 0.0)));
    let reflection_factor = 1.0 - view_angle;
    let sky = sky_color(reflect(in.view_dir, vec3<f32>(0.0, 1.0, 0.0)), time);
    
    col = mix(water_surface, sky, reflection_factor * 0.6);
    
  } else {
    // Sky rendering for non-terrain objects or background
    if (in.mesh_type == 4u) { // Skybox
      // Full procedural sky rendering
      col = sky_color(in.view_dir, time);
      
    } else if (in.mesh_type == 1u) { // Trees
      // Enhanced tree rendering with seasonal variation
      let tree_base_color = in.color.rgb;
      let seasonal_factor = (sin(time * 0.05) + 1.0) * 0.5;
      let autumn_color = vec3<f32>(0.8, 0.4, 0.1);
      let summer_color = vec3<f32>(0.2, 0.8, 0.3);
      col = mix(tree_base_color, mix(summer_color, autumn_color, seasonal_factor), 0.3);
      
    } else if (in.mesh_type == 2u) { // Houses/Structures
      // Enhanced building rendering with weathering
      col = in.color.rgb;
      let weathering = sin(in.world_pos.x * 0.5) * cos(in.world_pos.z * 0.3) * 0.1;
      col = col * (0.95 + weathering);
      
    } else {
      // Other objects get sky ambient lighting
      let sky = sky_color(in.view_dir, time);
      col = in.color.rgb * 0.8 + sky * 0.2;
    }
  }
  
  return vec4<f32>(col, 1.0);
}
"#;

// ---------------- physics world build/step & instance sync ----------------

fn build_physics_world() -> Physics {
    let mut bodies = r3::RigidBodySet::new();
    let mut colliders = r3::ColliderSet::new();
    let gravity = nalgebra::Vector3::new(0.0, -9.81, 0.0);
    // Large ground plane for extensive biome coverage
    let ground = r3::RigidBodyBuilder::fixed()
        .translation(nalgebra::Vector3::new(0.0, -2.0, 0.0))
        .user_data(0)
        .build();
    let g_handle = bodies.insert(ground);
    let g_col = r3::ColliderBuilder::cuboid(500.0, 0.5, 500.0).build(); // Much larger ground
    colliders.insert_with_parent(g_col, g_handle, &mut bodies);
    // Stack of boxes
    for y in 0..5 {
        for x in 0..5 {
            let rb = r3::RigidBodyBuilder::dynamic()
                .translation(nalgebra::Vector3::new(
                    -2.5 + x as f32 * 0.7,
                    -1.0 + y as f32 * 0.7,
                    0.0,
                ))
                .user_data(1)
                .build();
            let h = bodies.insert(rb);
            let c = r3::ColliderBuilder::cuboid(0.3, 0.3, 0.3)
                .restitution(0.2)
                .friction(0.8)
                .build();
            colliders.insert_with_parent(c, h, &mut bodies);
        }
    }
    // Sphere
    let s_rb = r3::RigidBodyBuilder::dynamic()
        .translation(nalgebra::Vector3::new(1.8, 1.0, 0.0))
        .ccd_enabled(true)
        .user_data(2)
        .build();
    let s_handle = bodies.insert(s_rb);
    let s_col = r3::ColliderBuilder::ball(0.35)
        .restitution(0.5)
        .friction(0.3)
        .build();
    colliders.insert_with_parent(s_col, s_handle, &mut bodies);

    Physics {
        pipeline: r3::PhysicsPipeline::new(),
        gravity,
        islands: r3::IslandManager::new(),
        broad: r3::DefaultBroadPhase::new(),
        narrow: r3::NarrowPhase::new(),
        bodies,
        colliders,
        impulse_joints: r3::ImpulseJointSet::new(),
        multibody_joints: r3::MultibodyJointSet::new(),
        ccd: r3::CCDSolver::new(),
        query_pipeline: r3::QueryPipeline::new(),
        integration_params: r3::IntegrationParameters {
            dt: 1.0 / 60.0,
            ..Default::default()
        },
    }
}

fn physics_step(p: &mut Physics) {
    let hooks = ();
    let events = ();
    p.pipeline.step(
        &p.gravity,
        &p.integration_params,
        &mut p.islands,
        &mut p.broad,
        &mut p.narrow,
        &mut p.bodies,
        &mut p.colliders,
        &mut p.impulse_joints,
        &mut p.multibody_joints,
        &mut p.ccd,
        Some(&mut p.query_pipeline),
        &hooks,
        &events,
    );
}

fn teleport_sphere_to(p: &mut Physics, pos: Vec3) {
    let target = p.bodies.iter_mut().find(|(_, b)| b.user_data == 2);
    if let Some((_, body)) = target {
        body.set_translation(nalgebra::Vector3::new(pos.x, pos.y, pos.z), true);
        body.set_linvel(nalgebra::Vector3::new(0.0, 0.0, 0.0), true);
        body.set_angvel(nalgebra::Vector3::new(0.0, 0.0, 0.0), true);
    }
}

fn sync_instances_from_physics(p: &Physics, characters: &[Character], out: &mut Vec<InstanceRaw>) {
    // Resize output vector to accommodate all objects
    out.clear();

    // Enhanced skybox instance - positioned to follow camera for optimal immersion
    // Create a transform that follows the camera position to ensure the skybox
    // always encompasses the view without creating depth buffer conflicts
    let skybox_translation = Mat4::from_translation(Vec3::new(0.0, 0.0, 0.0)); // Keep at origin for now
    let skybox_instance = InstanceRaw {
        model: skybox_translation.to_cols_array(),
        color: [0.8, 0.9, 1.0, 1.0], // Enhanced sky blue for better atmospheric feel
        mesh_type: MeshType::Skybox as u32,
        _padding: [0, 0, 0],
    };
    out.push(skybox_instance);

    // Add physics objects
    for (h, body) in p.bodies.iter() {
        // No skipping — we want the ground cube drawn so the ground shader branch runs.

        let xf = body.position();
        let iso = xf.to_homogeneous();
        let base_m = Mat4::from_cols_array_2d(&iso.fixed_view::<4, 4>(0, 0).into());

        // Default: no scale (unit cube)
        let mut model_m = base_m;

        // If this is the ground (user_data == 0 and fixed), scale the render
        // instance to match the collider half-extents (Rapier cuboid uses half-extents).
        if body.is_fixed() && body.user_data == 0 {
            // Find any collider attached to this body; prefer a Cuboid.
            if let Some((_, col)) = p.colliders.iter().find(|(_, c)| c.parent() == Some(h)) {
                if let Some(cuboid) = col.shape().as_cuboid() {
                    let he = cuboid.half_extents; // nalgebra::Vector
                    // Full extents = half_extents * 2
                    let sx = he.x * 2.0;
                    let sy = he.y * 2.0;
                    let sz = he.z * 2.0;
                    let scale_m = Mat4::from_scale(Vec3::new(sx, sy, sz));
                    model_m = base_m * scale_m;
                } else {
                    // Fallback: reasonable plane size if shape not Cuboid
                    let scale_m = Mat4::from_scale(Vec3::new(200.0, 1.0, 200.0));
                    model_m = base_m * scale_m;
                }
            } else {
                // Fallback if no collider found (shouldn't happen)
                let scale_m = Mat4::from_scale(Vec3::new(200.0, 1.0, 200.0));
                model_m = base_m * scale_m;
            }
        }

        // Color and mesh type based on object type
        let (color, mesh_type) = match body.user_data {
            0 => ([0.95, 0.95, 0.95, 1.0], MeshType::Cube),     // Ground
            1 => ([0.9, 0.6, 0.2, 1.0], MeshType::Cube),        // Original boxes (orange)
            2 => ([0.1, 0.8, 0.9, 1.0], MeshType::Cube),        // Sphere (cyan)
            
            // Trees and vegetation (10-34)
            10..=34 => ([0.2, 0.7, 0.3, 1.0], MeshType::Tree),  // Trees (green)
            
            // Buildings and structures (20-27, 40-45) - non-overlapping with trees
            35..=39 => ([0.7, 0.5, 0.3, 1.0], MeshType::House), // Grassland houses (brown)
            40..=45 => ([0.8, 0.7, 0.5, 1.0], MeshType::House), // Adobe houses (sandy)
            
            // Geological features
            60..=75 => ([0.5, 0.45, 0.4, 1.0], MeshType::Cube), // Grassland rocks (gray-brown)
            76..=90 => ([0.6, 0.45, 0.35, 1.0], MeshType::Cube), // Desert formations (reddish brown)
            
            // Bushes and undergrowth (100-114)
            100..=114 => ([0.3, 0.6, 0.2, 1.0], MeshType::Tree), // Bushes (darker green)
            
            // Special structures
            200..=205 => ([0.6, 0.6, 0.7, 1.0], MeshType::Cube), // Stone circles (gray)
            300..=309 => ([0.4, 0.4, 0.45, 1.0], MeshType::Cube), // River banks (dark gray)
            400..=407 => ([0.9, 0.8, 0.6, 1.0], MeshType::Cube), // Sand dunes (pale yellow)
            500..=504 => ([0.4, 0.8, 0.2, 1.0], MeshType::Tree), // Oasis palms (bright green)
            
            // Default objects
            50..=59 => ([0.6, 0.6, 0.6, 1.0], MeshType::Cube),  // Generic objects (gray)
            _ => ([0.5, 0.5, 0.5, 1.0], MeshType::Cube),         // Unknown (dark gray)
        };

        out.push(InstanceRaw {
            model: model_m.to_cols_array(),
            color,
            mesh_type: mesh_type as u32,
            _padding: [0; 3],
        });
    }

    // Add character instances
    for character in characters {
        // Create a transform matrix for the character
        let scale = 0.4; // Characters are smaller than buildings
        let translation = Mat4::from_translation(character.position);
        let scaling = Mat4::from_scale(Vec3::splat(scale));

        // Add some simple animation based on time
        let bob_offset = (character.animation_time * 3.0).sin() * 0.1;
        let animation_transform = Mat4::from_translation(Vec3::new(0.0, bob_offset, 0.0));

        let model_matrix = translation * animation_transform * scaling;

        out.push(InstanceRaw {
            model: model_matrix.to_cols_array(),
            color: character.get_color(),
            mesh_type: MeshType::Character as u32,
            _padding: [0; 3],
        });
    }
}

fn build_show_instances() -> Vec<InstanceRaw> {
    // Start with empty instances - they'll be populated by physics sync
    Vec::new()
}
