//! Weaving + PCG Demo - Dynamic Content Generation with Tension Detection
//!
//! Demonstrates: Seed â†’ Encounter Generation â†’ Pattern Detection â†’ Emergent Events
//!
//! Controls:
//! - Space: Generate new encounter
//! - N: Skip to next encounter  
//! - P: Show pattern analysis
//! - R: Reseed and restart
//! - Q: Quit
//!
//! Deterministic: Fixed seed ensures reproducible encounter sequences

use astraweave_core::{IVec2, Team, World};
use rand::{Rng, SeedableRng};

/// Encounter types generated by PCG
#[derive(Debug, Clone, PartialEq)]
enum EncounterType {
    Combat,
    Resource,
    Event,
    Rest,
}

/// Encounter instance
#[derive(Debug, Clone)]
struct Encounter {
    id: u32,
    encounter_type: EncounterType,
    difficulty: i32,
    position: IVec2,
    completed: bool,
}

/// Weaving signal types
#[derive(Debug, Clone, PartialEq)]
#[allow(dead_code)]
enum WeavingSignal {
    LowHealth,
    HighTension,
    ResourceScarcity,
    Momentum,
    None,
}

/// Intent types proposed by weaving system
#[derive(Debug, Clone, PartialEq)]
#[allow(dead_code)]
enum Intent {
    SpawnAid,      // Spawn healing resource
    SpawnIntel,    // Spawn map/encounter info
    ReduceTension, // Spawn rest area
    ScaleUp,       // Increase difficulty
    None,
}

/// Pattern detection results
#[derive(Debug, Clone, Default)]
struct PatternAnalysis {
    combat_streak: i32,
    avg_difficulty: f32,
    tension_score: f32,
    health_trend: String,
}

/// Demo state
#[allow(dead_code)]
struct DemoState {
    world: World,
    player_id: u32,
    encounters: Vec<Encounter>,
    current_encounter_idx: usize,
    signals: Vec<WeavingSignal>,
    pending_intents: Vec<Intent>,
    accepted_intents: Vec<Intent>,
    pattern: PatternAnalysis,
    encounter_count: u32,
    tick_count: u64,
    seed: u64,
    player_health: i32,
    tension: f32,
    paused: bool,
}

impl DemoState {
    fn new(seed: u64) -> Self {
        let mut world = World::new();
        let mut rng = rand::rngs::StdRng::seed_from_u64(seed);

        // Spawn player
        let player_id = world.spawn("Player", IVec2 { x: 10, y: 10 }, Team { id: 0 }, 100, 0);

        let mut demo = Self {
            world,
            player_id,
            encounters: Vec::new(),
            current_encounter_idx: 0,
            signals: Vec::new(),
            pending_intents: Vec::new(),
            accepted_intents: Vec::new(),
            pattern: PatternAnalysis::default(),
            encounter_count: 0,
            tick_count: 0,
            seed,
            player_health: 100,
            tension: 0.0,
            paused: false,
        };

        // Generate initial encounters
        demo.generate_encounters(&mut rng, 5);
        demo
    }

    #[allow(dead_code)]
    fn reset(&mut self) {
        *self = Self::new(self.seed);
    }

    #[allow(dead_code)]
    fn generate_encounters(&mut self, rng: &mut rand::rngs::StdRng, count: usize) {
        for _ in 0..count {
            let encounter_type = match rng.random_range(0..4) {
                0 => EncounterType::Combat,
                1 => EncounterType::Resource,
                2 => EncounterType::Event,
                _ => EncounterType::Rest,
            };

            let difficulty = match encounter_type {
                EncounterType::Combat => rng.random_range(1..10),
                EncounterType::Event => rng.random_range(1..5),
                _ => 0,
            };

            let x = rng.random_range(0..20);
            let y = rng.random_range(0..20);

            self.encounters.push(Encounter {
                id: self.encounter_count,
                encounter_type,
                difficulty,
                position: IVec2 { x, y },
                completed: false,
            });

            self.encounter_count += 1;
        }
    }

    fn update(&mut self) {
        if self.paused {
            return;
        }

        self.tick_count += 1;

        // Process current encounter
        if self.current_encounter_idx < self.encounters.len() {
            let encounter = &mut self.encounters[self.current_encounter_idx];

            if !encounter.completed {
                // Simulate encounter effects
                match encounter.encounter_type {
                    EncounterType::Combat => {
                        self.player_health -= encounter.difficulty;
                        self.tension += encounter.difficulty as f32 * 0.1;
                    }
                    EncounterType::Resource => {
                        self.player_health = (self.player_health + 10).min(100);
                    }
                    EncounterType::Event => {
                        self.tension += encounter.difficulty as f32 * 0.05;
                    }
                    EncounterType::Rest => {
                        self.tension = (self.tension - 0.5).max(0.0);
                        self.player_health = (self.player_health + 20).min(100);
                    }
                }

                encounter.completed = true;
            }
        }

        // Detect patterns and generate signals
        self.detect_patterns();
        self.generate_signals();

        // Propose intents based on signals
        self.propose_intents();

        // Adjudicate and accept intents
        self.adjudicate_intents();
    }

    fn detect_patterns(&mut self) {
        let completed: Vec<_> = self.encounters.iter().filter(|e| e.completed).collect();

        if completed.is_empty() {
            return;
        }

        // Combat streak
        let mut streak = 0;
        for enc in completed.iter().rev() {
            if enc.encounter_type == EncounterType::Combat {
                streak += 1;
            } else {
                break;
            }
        }
        self.pattern.combat_streak = streak;

        // Average difficulty
        let total_difficulty: i32 = completed.iter().map(|e| e.difficulty).sum();
        self.pattern.avg_difficulty = total_difficulty as f32 / completed.len() as f32;

        // Tension score
        self.pattern.tension_score = self.tension;

        // Health trend
        self.pattern.health_trend = if self.player_health < 30 {
            "Critical".to_string()
        } else if self.player_health < 60 {
            "Low".to_string()
        } else {
            "Healthy".to_string()
        };
    }

    fn generate_signals(&mut self) {
        self.signals.clear();

        // Low health signal
        if self.player_health < 40 {
            self.signals.push(WeavingSignal::LowHealth);
        }

        // High tension signal
        if self.tension > 5.0 {
            self.signals.push(WeavingSignal::HighTension);
        }

        // Combat momentum signal
        if self.pattern.combat_streak >= 3 {
            self.signals.push(WeavingSignal::Momentum);
        }

        if self.signals.is_empty() {
            self.signals.push(WeavingSignal::None);
        }
    }

    fn propose_intents(&mut self) {
        self.pending_intents.clear();

        for signal in &self.signals {
            match signal {
                WeavingSignal::LowHealth => {
                    self.pending_intents.push(Intent::SpawnAid);
                }
                WeavingSignal::HighTension => {
                    self.pending_intents.push(Intent::ReduceTension);
                }
                WeavingSignal::Momentum => {
                    self.pending_intents.push(Intent::SpawnIntel);
                }
                _ => {}
            }
        }

        // Default: scale up if no critical signals
        if self.pending_intents.is_empty() && self.player_health > 70 {
            self.pending_intents.push(Intent::ScaleUp);
        }
    }

    fn adjudicate_intents(&mut self) {
        // Simple adjudication: accept first intent if tension budget allows
        if !self.pending_intents.is_empty() {
            let intent = self.pending_intents[0].clone();

            // Check cooldown/budget (simplified)
            let can_accept = match intent {
                Intent::SpawnAid => self.tension < 8.0,
                Intent::ReduceTension => self.tension > 3.0,
                Intent::SpawnIntel => self.tension < 10.0,
                Intent::ScaleUp => self.tension < 7.0,
                Intent::None => false,
            };

            if can_accept {
                self.execute_intent(&intent);
                self.accepted_intents.push(intent);
            }
        }
    }

    fn execute_intent(&mut self, intent: &Intent) {
        let mut rng = rand::rngs::StdRng::seed_from_u64(self.seed + self.tick_count);

        match intent {
            Intent::SpawnAid => {
                // Spawn healing resource
                let x = rng.random_range(0..20);
                let y = rng.random_range(0..20);
                self.encounters.push(Encounter {
                    id: self.encounter_count,
                    encounter_type: EncounterType::Resource,
                    difficulty: 0,
                    position: IVec2 { x, y },
                    completed: false,
                });
                self.encounter_count += 1;
            }
            Intent::SpawnIntel => {
                // Spawn event encounter
                let x = rng.random_range(0..20);
                let y = rng.random_range(0..20);
                self.encounters.push(Encounter {
                    id: self.encounter_count,
                    encounter_type: EncounterType::Event,
                    difficulty: 2,
                    position: IVec2 { x, y },
                    completed: false,
                });
                self.encounter_count += 1;
            }
            Intent::ReduceTension => {
                // Spawn rest area
                let x = rng.random_range(0..20);
                let y = rng.random_range(0..20);
                self.encounters.push(Encounter {
                    id: self.encounter_count,
                    encounter_type: EncounterType::Rest,
                    difficulty: 0,
                    position: IVec2 { x, y },
                    completed: false,
                });
                self.encounter_count += 1;
            }
            Intent::ScaleUp => {
                // Spawn harder combat
                let x = rng.random_range(0..20);
                let y = rng.random_range(0..20);
                self.encounters.push(Encounter {
                    id: self.encounter_count,
                    encounter_type: EncounterType::Combat,
                    difficulty: (self.pattern.avg_difficulty + 2.0) as i32,
                    position: IVec2 { x, y },
                    completed: false,
                });
                self.encounter_count += 1;
            }
            Intent::None => {}
        }
    }

    fn next_encounter(&mut self) {
        if self.current_encounter_idx < self.encounters.len() - 1 {
            self.current_encounter_idx += 1;
        }
    }

    #[allow(dead_code)]
    fn generate_new_encounter(&mut self) {
        let mut rng = rand::rngs::StdRng::seed_from_u64(self.seed + self.tick_count);
        self.generate_encounters(&mut rng, 1);
    }

    fn render_hud(&self) {
        println!("\n=== WEAVING + PCG DEMO ===");
        println!("Seed: {}", self.seed);
        println!("Tick: {}", self.tick_count);
        println!("Status: {}", if self.paused { "PAUSED" } else { "RUNNING" });

        // Player state
        println!("\nğŸ“Š Player State:");
        println!(
            "  Health: {}/100 ({})",
            self.player_health, self.pattern.health_trend
        );
        println!("  Tension: {:.1}", self.tension);

        // Current encounter
        println!(
            "\nğŸ² Current Encounter: {}/{}",
            self.current_encounter_idx + 1,
            self.encounters.len()
        );
        if self.current_encounter_idx < self.encounters.len() {
            let enc = &self.encounters[self.current_encounter_idx];
            println!("  Type: {:?}", enc.encounter_type);
            println!("  Difficulty: {}", enc.difficulty);
            println!("  Position: ({}, {})", enc.position.x, enc.position.y);
            println!(
                "  Status: {}",
                if enc.completed {
                    "âœ“ Completed"
                } else {
                    "â³ Active"
                }
            );
        }

        // Pattern analysis
        println!("\nğŸ“ˆ Pattern Analysis:");
        println!("  Combat Streak: {}", self.pattern.combat_streak);
        println!("  Avg Difficulty: {:.1}", self.pattern.avg_difficulty);
        println!("  Tension Score: {:.1}", self.pattern.tension_score);

        // Weaving signals
        println!("\nâš¡ Weaving Signals:");
        for signal in &self.signals {
            println!("  - {:?}", signal);
        }

        // Intents
        println!("\nğŸ¯ Intents:");
        println!("  Proposed: {} intents", self.pending_intents.len());
        for intent in &self.pending_intents {
            println!("    - {:?}", intent);
        }
        println!(
            "  Accepted (this run): {} intents",
            self.accepted_intents.len()
        );

        // Encounter queue
        println!("\nğŸ“ Upcoming Encounters:");
        let upcoming: Vec<_> = self
            .encounters
            .iter()
            .skip(self.current_encounter_idx + 1)
            .take(3)
            .collect();
        for enc in upcoming {
            println!(
                "  [{:02}] {:?} (diff: {})",
                enc.id, enc.encounter_type, enc.difficulty
            );
        }

        println!(
            "\nControls: [Space] New Encounter | [N] Next | [P] Pattern | [R] Reseed | [Q] Quit"
        );
        println!("============================");
    }

    #[allow(dead_code)]
    fn show_pattern_detail(&self) {
        println!("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
        println!("â•‘   PATTERN ANALYSIS DETAIL     â•‘");
        println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");

        println!("\nğŸ” Encounter History:");
        for (i, enc) in self.encounters.iter().enumerate() {
            let status = if enc.completed { "âœ“" } else { "â—‹" };
            println!(
                "  {}{:02}: {:?} (diff: {}, pos: {:?})",
                status,
                i + 1,
                enc.encounter_type,
                enc.difficulty,
                enc.position
            );
        }

        println!("\nğŸ“Š Statistics:");
        let completed = self.encounters.iter().filter(|e| e.completed).count();
        let combat_count = self
            .encounters
            .iter()
            .filter(|e| e.completed && e.encounter_type == EncounterType::Combat)
            .count();
        println!("  Total Encounters: {}", self.encounters.len());
        println!("  Completed: {}", completed);
        println!("  Combat Encounters: {}", combat_count);
        println!("  Current Streak: {}", self.pattern.combat_streak);
        println!("  Average Difficulty: {:.2}", self.pattern.avg_difficulty);

        println!("\nâš¡ Signal Generation Rules:");
        println!("  LowHealth: health < 40");
        println!("  HighTension: tension > 5.0");
        println!("  Momentum: combat_streak >= 3");

        println!("\nğŸ¯ Intent Adjudication:");
        println!("  SpawnAid: accepted if tension < 8.0");
        println!("  ReduceTension: accepted if tension > 3.0");
        println!("  SpawnIntel: accepted if tension < 10.0");
        println!("  ScaleUp: accepted if tension < 7.0");

        println!("\nPress any key to continue...\n");
    }
}

fn main() -> anyhow::Result<()> {
    println!("Weaving + PCG Demo - Dynamic Content Generation");
    println!("Seed: 456 (deterministic)");
    println!("\nDemonstrating: Tension Detection â†’ Intent Proposal â†’ Adjudication â†’ Content Spawn");
    println!("\nInitializing...\n");

    let mut demo = DemoState::new(456);

    // Main loop (100 ticks or until all encounters complete)
    for _ in 0..100 {
        demo.render_hud();
        demo.update();

        // Check for completion
        if demo.current_encounter_idx >= demo.encounters.len() {
            println!("\nğŸ¯ ALL ENCOUNTERS COMPLETED!");
            break;
        }

        // Auto-advance to next encounter
        if demo.current_encounter_idx < demo.encounters.len()
            && demo.encounters[demo.current_encounter_idx].completed
        {
            demo.next_encounter();
        }

        std::thread::sleep(std::time::Duration::from_millis(1000));
    }

    println!(
        "\nâœ… Demo finished. Total encounters: {}",
        demo.encounter_count
    );
    Ok(())
}
