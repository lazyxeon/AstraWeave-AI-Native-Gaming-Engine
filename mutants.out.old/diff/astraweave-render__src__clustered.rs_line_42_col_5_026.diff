--- astraweave-render/src/clustered.rs
+++ replace bin_lights_cpu -> (Vec<u32>, Vec<u32>, Vec<u32>) with (vec![1], vec![1], vec![1])
@@ -34,124 +34,17 @@
 pub fn bin_lights_cpu(
     lights: &[CpuLight],
     dims: ClusterDims,
     screen: (u32, u32),
     near: f32,
     far: f32,
     fov_y: f32,
 ) -> (Vec<u32>, Vec<u32>, Vec<u32>) {
-    let (width, height) = screen;
-    let aspect = width.max(1) as f32 / height.max(1) as f32;
-    let fy = 1.0 / (0.5 * fov_y).tan();
-    let fx = fy / aspect;
-    let tile_w = (width as f32 / dims.x as f32).max(1.0);
-    let tile_h = (height as f32 / dims.y as f32).max(1.0);
-
-    let clusters = (dims.x * dims.y * dims.z) as usize;
-    let mut counts = vec![0u32; clusters];
-
-    // First pass: counts
-    for l in lights.iter() {
-        let z = l.pos.z.max(near + 1e-4);
-        if z - l.radius > far {
-            continue;
-        }
-        // Project center to NDC
-        let ndc_x = (l.pos.x / z) * fx;
-        let ndc_y = (l.pos.y / z) * fy;
-        // Convert to pixel space
-        let px = (ndc_x * 0.5 + 0.5) * width as f32;
-        let py = (ndc_y * 0.5 + 0.5) * height as f32;
-        // Screen-space radius in pixels (approx)
-        let rpx_x = (l.radius / z) * fx * (width as f32 * 0.5);
-        let rpx_y = (l.radius / z) * fy * (height as f32 * 0.5);
-        let min_px = (px - rpx_x).floor() as i32;
-        let max_px = (px + rpx_x).ceil() as i32;
-        let min_py = (py - rpx_y).floor() as i32;
-        let max_py = (py + rpx_y).ceil() as i32;
-        let ix0 = clamp_u32(min_px / tile_w as i32, 0, dims.x as i32 - 1);
-        let ix1 = clamp_u32(max_px / tile_w as i32, 0, dims.x as i32 - 1);
-        let iy0 = clamp_u32(min_py / tile_h as i32, 0, dims.y as i32 - 1);
-        let iy1 = clamp_u32(max_py / tile_h as i32, 0, dims.y as i32 - 1);
-        // Z slices
-        let zmin = (z - l.radius).max(near);
-        let zmax = (z + l.radius).min(far);
-        if zmin >= zmax {
-            continue;
-        }
-        let iz0 = (((zmin - near) / (far - near)) * dims.z as f32)
-            .floor()
-            .clamp(0.0, dims.z as f32 - 1.0) as u32;
-        let iz1 = (((zmax - near) / (far - near)) * dims.z as f32)
-            .floor()
-            .clamp(0.0, dims.z as f32 - 1.0) as u32;
-        for iz in iz0..=iz1 {
-            for iy in iy0..=iy1 {
-                for ix in ix0..=ix1 {
-                    let ci = cluster_index(ix, iy, iz, dims);
-                    counts[ci] += 1;
-                }
-            }
-        }
-    }
-
-    // Exclusive scan to offsets
-    let mut offsets = vec![0u32; clusters + 1];
-    for i in 0..clusters {
-        offsets[i + 1] = offsets[i] + counts[i];
-    }
-
-    // Second pass: fill indices using running write cursors
-    let total = offsets[clusters] as usize;
-    let mut indices = vec![0u32; total];
-    let mut cursors = vec![0u32; clusters];
-    for (li, l) in lights.iter().enumerate() {
-        let z = l.pos.z.max(near + 1e-4);
-        if z - l.radius > far {
-            continue;
-        }
-        let ndc_x = (l.pos.x / z) * fx;
-        let ndc_y = (l.pos.y / z) * fy;
-        let px = (ndc_x * 0.5 + 0.5) * width as f32;
-        let py = (ndc_y * 0.5 + 0.5) * height as f32;
-        let rpx_x = (l.radius / z) * fx * (width as f32 * 0.5);
-        let rpx_y = (l.radius / z) * fy * (height as f32 * 0.5);
-        let min_px = (px - rpx_x).floor() as i32;
-        let max_px = (px + rpx_x).ceil() as i32;
-        let min_py = (py - rpx_y).floor() as i32;
-        let max_py = (py + rpx_y).ceil() as i32;
-        let ix0 = clamp_u32(min_px / tile_w as i32, 0, dims.x as i32 - 1);
-        let ix1 = clamp_u32(max_px / tile_w as i32, 0, dims.x as i32 - 1);
-        let iy0 = clamp_u32(min_py / tile_h as i32, 0, dims.y as i32 - 1);
-        let iy1 = clamp_u32(max_py / tile_h as i32, 0, dims.y as i32 - 1);
-        let zmin = (z - l.radius).max(near);
-        let zmax = (z + l.radius).min(far);
-        if zmin >= zmax {
-            continue;
-        }
-        let iz0 = (((zmin - near) / (far - near)) * dims.z as f32)
-            .floor()
-            .clamp(0.0, dims.z as f32 - 1.0) as u32;
-        let iz1 = (((zmax - near) / (far - near)) * dims.z as f32)
-            .floor()
-            .clamp(0.0, dims.z as f32 - 1.0) as u32;
-        for iz in iz0..=iz1 {
-            for iy in iy0..=iy1 {
-                for ix in ix0..=ix1 {
-                    let ci = cluster_index(ix, iy, iz, dims);
-                    let off = offsets[ci] + cursors[ci];
-                    indices[off as usize] = li as u32;
-                    cursors[ci] += 1;
-                }
-            }
-        }
-    }
-
-    (counts, indices, offsets)
+    (vec![1], vec![1], vec![1]) /* ~ changed by cargo-mutants ~ */
 }
 
 pub const WGSL_CLUSTER_BIN: &str = r#"
 struct Light { pos_radius: vec4<f32> };
 struct Params { screen: vec4<u32>, clusters: vec4<u32>, val: vec4<f32> };
 @group(0) @binding(0) var<storage, read> lights: array<Light>;
 @group(0) @binding(1) var<uniform> params: Params;
 // Offsets: length = clusters+1 (exclusive scan). Counts: length = clusters. Indices: variable length
