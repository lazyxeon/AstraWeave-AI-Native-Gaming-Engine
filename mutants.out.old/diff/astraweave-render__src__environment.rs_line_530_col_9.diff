--- astraweave-render/src/environment.rs
+++ replace SkyRenderer::render -> Result<()> with Ok(())
@@ -522,168 +522,17 @@
         encoder: &mut wgpu::CommandEncoder,
         target_view: &wgpu::TextureView,
         depth_view: &wgpu::TextureView,
         view_proj: Mat4,
         queue: &wgpu::Queue,
         sky_texture: Option<&wgpu::TextureView>,
         equirect_texture: Option<&wgpu::TextureView>,
     ) -> Result<()> {
-        let pipeline = self
-            .skybox_pipeline
-            .as_ref()
-            .context("Sky pipeline not initialized")?;
-
-        // Update uniforms
-        let uniforms = self.create_sky_uniforms(view_proj);
-        let uniform_buffer = self
-            .uniform_buffer
-            .as_ref()
-            .context("Uniform buffer not initialized")?;
-
-        let data = bytemuck::bytes_of(&uniforms);
-        queue.write_buffer(uniform_buffer, 0, data);
-
-        let vertices = self
-            .skybox_vertices
-            .as_ref()
-            .context("Vertices not initialized")?;
-        let indices = self
-            .skybox_indices
-            .as_ref()
-            .context("Indices not initialized")?;
-
-        let mut render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
-            label: Some("Sky Render Pass"),
-            color_attachments: &[Some(wgpu::RenderPassColorAttachment {
-                view: target_view,
-                resolve_target: None,
-                ops: wgpu::Operations {
-                    load: wgpu::LoadOp::Clear(wgpu::Color {
-                        r: 1.0,
-                        g: 0.0,
-                        b: 1.0,
-                        a: 1.0,
-                    }), // Debug color to see if skybox fails
-                    store: wgpu::StoreOp::Store,
-                },
-            })],
-            depth_stencil_attachment: Some(wgpu::RenderPassDepthStencilAttachment {
-                view: depth_view,
-                depth_ops: Some(wgpu::Operations {
-                    load: wgpu::LoadOp::Clear(1.0),
-                    store: wgpu::StoreOp::Store,
-                }),
-                stencil_ops: None,
-            }),
-            timestamp_writes: None,
-            occlusion_query_set: None,
-        });
-
-        // Render procedural, textured (cube), or equirect skybox
-        let mut drawn = false;
-
-        // 1. Try Equirectangular (Preferred if available)
-        if let Some(eqr_tex) = equirect_texture {
-            if let (Some(eqr_pipeline), Some(eqr_bgl)) =
-                (&self.equirect_pipeline, &self.equirect_bgl)
-            {
-                let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
-                    label: Some("Skybox Eqr Sampler"),
-                    mag_filter: wgpu::FilterMode::Linear,
-                    min_filter: wgpu::FilterMode::Linear,
-                    mipmap_filter: wgpu::FilterMode::Linear,
-                    address_mode_u: wgpu::AddressMode::Repeat, // Wrap horizontally
-                    address_mode_v: wgpu::AddressMode::ClampToEdge, // Clamp poles
-                    ..Default::default()
-                });
-
-                let bg = device.create_bind_group(&wgpu::BindGroupDescriptor {
-                    label: Some("Sky Eqr BG"),
-                    layout: eqr_bgl,
-                    entries: &[
-                        wgpu::BindGroupEntry {
-                            binding: 0,
-                            resource: uniform_buffer.as_entire_binding(),
-                        },
-                        wgpu::BindGroupEntry {
-                            binding: 1,
-                            resource: wgpu::BindingResource::TextureView(eqr_tex),
-                        },
-                        wgpu::BindGroupEntry {
-                            binding: 2,
-                            resource: wgpu::BindingResource::Sampler(&sampler),
-                        },
-                    ],
-                });
-
-                render_pass.set_pipeline(eqr_pipeline);
-                render_pass.set_bind_group(0, &bg, &[]);
-                render_pass.set_vertex_buffer(0, vertices.slice(..));
-                render_pass.set_index_buffer(indices.slice(..), wgpu::IndexFormat::Uint16);
-                render_pass.draw_indexed(0..self.index_count, 0, 0..1);
-                drawn = true;
-            }
-        }
-
-        // 2. Try Textured Cube (Fallback)
-        if !drawn {
-            if let Some(tex) = sky_texture {
-                if let (Some(tex_pipeline), Some(tex_bgl)) =
-                    (&self.texture_pipeline, &self.texture_bgl)
-                {
-                    // Create sampler
-                    let sampler = device.create_sampler(&wgpu::SamplerDescriptor {
-                        label: Some("Skybox Sampler"),
-                        mag_filter: wgpu::FilterMode::Linear,
-                        min_filter: wgpu::FilterMode::Linear,
-                        mipmap_filter: wgpu::FilterMode::Linear,
-                        ..Default::default()
-                    });
-
-                    let bg = device.create_bind_group(&wgpu::BindGroupDescriptor {
-                        label: Some("Sky Texture BG"),
-                        layout: tex_bgl,
-                        entries: &[
-                            wgpu::BindGroupEntry {
-                                binding: 0,
-                                resource: uniform_buffer.as_entire_binding(),
-                            },
-                            wgpu::BindGroupEntry {
-                                binding: 1,
-                                resource: wgpu::BindingResource::TextureView(tex),
-                            },
-                            wgpu::BindGroupEntry {
-                                binding: 2,
-                                resource: wgpu::BindingResource::Sampler(&sampler),
-                            },
-                        ],
-                    });
-
-                    render_pass.set_pipeline(tex_pipeline);
-                    render_pass.set_bind_group(0, &bg, &[]);
-                    render_pass.set_vertex_buffer(0, vertices.slice(..));
-                    render_pass.set_index_buffer(indices.slice(..), wgpu::IndexFormat::Uint16);
-                    render_pass.draw_indexed(0..self.index_count, 0, 0..1);
-                    drawn = true;
-                }
-            }
-        }
-
-        // 3. Procedural (Fallback)
-        if !drawn {
-            render_pass.set_pipeline(pipeline);
-            let bind_group = self.bind_group.as_ref().unwrap();
-            render_pass.set_bind_group(0, bind_group, &[]);
-            render_pass.set_vertex_buffer(0, vertices.slice(..));
-            render_pass.set_index_buffer(indices.slice(..), wgpu::IndexFormat::Uint16);
-            render_pass.draw_indexed(0..self.index_count, 0, 0..1);
-        }
-
-        Ok(())
+        Ok(()) /* ~ changed by cargo-mutants ~ */
     }
 
     /// Get the current time of day system
     pub fn time_of_day(&self) -> &TimeOfDay {
         &self.time_of_day
     }
 
     /// Get mutable reference to time of day system
