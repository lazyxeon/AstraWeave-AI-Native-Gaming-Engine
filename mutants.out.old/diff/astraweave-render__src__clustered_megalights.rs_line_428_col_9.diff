--- astraweave-render/src/clustered_megalights.rs
+++ replace MegaLightsRenderer::dispatch -> Result<()> with Ok(())
@@ -420,90 +420,17 @@
     /// Dispatch GPU light culling (3-stage pipeline)
     ///
     /// Performance: <0.1ms @ 1000 lights on RTX 3060 (68Ã— faster than CPU)
     ///
     /// # Panics
     /// - If bind groups not initialized (call update_bind_groups first)
     /// - If light_count > max_lights
     pub fn dispatch(&self, encoder: &mut wgpu::CommandEncoder, light_count: u32) -> Result<()> {
-        anyhow::ensure!(
-            light_count as usize <= self.max_lights,
-            "Light count {} exceeds max_lights {}",
-            light_count,
-            self.max_lights
-        );
-
-        let count_bg = self
-            .count_bind_group
-            .as_ref()
-            .context("Count bind group not initialized")?;
-        let prefix_sum_bg = self
-            .prefix_sum_bind_group
-            .as_ref()
-            .context("Prefix sum bind group not initialized")?;
-        let write_indices_bg = self
-            .write_indices_bind_group
-            .as_ref()
-            .context("Write indices bind group not initialized")?;
-
-        let _total_clusters = self.cluster_dims.0 * self.cluster_dims.1 * self.cluster_dims.2;
-
-        // Stage 1: Count lights per cluster
-        {
-            let mut pass = encoder.begin_compute_pass(&wgpu::ComputePassDescriptor {
-                label: Some("MegaLights Count Pass"),
-                timestamp_writes: None,
-            });
-
-            pass.set_pipeline(&self.count_pipeline);
-            pass.set_bind_group(0, count_bg, &[]);
-
-            // Workgroup size = 64 (from shader @workgroup_size(64, 1, 1))
-            let workgroups_x = self.cluster_dims.0.div_ceil(64);
-            let workgroups_y = self.cluster_dims.1;
-            let workgroups_z = self.cluster_dims.2;
-
-            pass.dispatch_workgroups(workgroups_x, workgroups_y, workgroups_z);
-        }
-
-        // Stage 2: Prefix sum (exclusive scan)
-        {
-            let mut pass = encoder.begin_compute_pass(&wgpu::ComputePassDescriptor {
-                label: Some("MegaLights Prefix Sum Pass"),
-                timestamp_writes: None,
-            });
-
-            pass.set_pipeline(&self.prefix_sum_pipeline);
-            pass.set_bind_group(0, prefix_sum_bg, &[]);
-
-            // Serial scan on single thread (see prefix_sum.wgsl)
-            // For ~10k-50k clusters, a single thread is faster than multi-dispatch synchronization overhead
-            pass.dispatch_workgroups(1, 1, 1);
-        }
-
-        // Stage 3: Write light indices
-        {
-            let mut pass = encoder.begin_compute_pass(&wgpu::ComputePassDescriptor {
-                label: Some("MegaLights Write Indices Pass"),
-                timestamp_writes: None,
-            });
-
-            pass.set_pipeline(&self.write_indices_pipeline);
-            pass.set_bind_group(0, write_indices_bg, &[]);
-
-            // Same workgroup layout as count pass
-            let workgroups_x = self.cluster_dims.0.div_ceil(64);
-            let workgroups_y = self.cluster_dims.1;
-            let workgroups_z = self.cluster_dims.2;
-
-            pass.dispatch_workgroups(workgroups_x, workgroups_y, workgroups_z);
-        }
-
-        Ok(())
+        Ok(()) /* ~ changed by cargo-mutants ~ */
     }
 }
 
 #[cfg(test)]
 mod tests {
     use super::*;
 
     #[test]
