searchState.loadedDescShard("astraweave_render", 0, "Skeletal Animation System for AstraWeave\nComplete Clustered Forward Rendering Implementation\nGPU-driven frustum culling implementation for Phase 2 Task …\nCulling node for render graph integration (Phase 2 Task 3)\nEnvironmental rendering systems including sky, weather, …\nGlobal Illumination Module\nMinimal render graph scaffolding for Phase 2: establishes …\nImage-Based Lighting (IBL) manager and prefilter pipelines\nTerrain rendering integration for astraweave-render\nAnimation channel targeting a specific joint property\nAnimation clip with multiple channels\nAnimation playback state\nAnimation channel data (one property per channel)\nAnimation keyframe interpolation mode\nJoint in a skeleton hierarchy (imported from asset)\nJoint matrix for GPU upload (64 bytes, aligned)\nJoint palette for GPU skinning (uploaded as storage buffer)\nMaximum joints supported (for buffer sizing)\nSkeleton structure with joint hierarchy\nLocal transform (TRS)\nCompute world-space joint matrices from local transforms …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLinear interpolation between two transforms\nSample the animation at a given time and write joint …\nApply CPU skinning to a vertex with joint indices and …\nAdvance animation time by delta\nReset per-frame input accumulation flags; call once per …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs the right-mouse look active?\nIgnore tiny mouse deltas (raw input noise)\nExponential smoothing factor for mouse look [0..1], higher …\nCompute per-cluster light lists on CPU using simple …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWGSL shader code for clustered forward rendering\nConfiguration for clustered rendering\nClustered forward renderer\nCluster data for GPU\nGPU-compatible light structure Uses arrays instead of Vec4 …\nPadding\nGet the bind group\nGet the bind group layout\nBuild clusters and assign lights\nNumber of clusters in X dimension (screen width)\nNumber of clusters in Y dimension (screen height)\nNumber of clusters in Z dimension (depth)\nColor and intensity (w = intensity)\nGet configuration\nFar plane distance\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet light count\nNumber of lights in this cluster\nOffset into light index list\nMax bounds of cluster in view space\nMin bounds of cluster in view space\nNear plane distance\nCreate a new clustered forward renderer\nPosition in world space (w = radius)\nUpdate lights for the current frame\nBatch identifier for grouping instances by mesh+material\nCompute shader source for frustum culling\nGPU culling manager\nGPU buffers for culling\nA batch of instances sharing the same mesh and material\nIndirect draw command structure matching wgpu::DrawIndirect\nFrustum planes in world space for culling Planes are …\nPer-instance data for culling compute shader Represents an …\nGroup visible instances into batches by mesh/material (CPU …\nBuild indirect draw commands from visible instances and …\nCenter of the AABB in world space (vec3 in WGSL = 16 bytes …\nCPU fallback culling implementation Returns list of …\nCreate buffers and bind group for culling\nExecute culling compute pass Note: Caller must ensure …\nExecute culling with automatic buffer setup (clears count …\nHalf-extents (radius) from center (vec3 in WGSL = 16 bytes …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCompute AABB from world transform matrix and local bounds\nExtract frustum planes from view-projection matrix Uses …\nOriginal instance index in the instance buffer\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new indirect draw command for a mesh batch\nSix planes: left, right, bottom, top, near, far Each …\nCPU-based frustum culling (fallback path) Returns true if …\nRender graph node for GPU-driven frustum culling\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPrepare culling data before graph execution This must be …\nGet reference to culling resources (for accessing buffers)\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSky rendering configuration\nSky rendering system\nTime of day system that manages sun/moon position and …\nWeather particle system for rendering precipitation\nWeather system that manages weather transitions and effects\nTypes of weather that can occur\nCloud configuration\nGet current sky configuration\nCurrent time in game hours (0.0 - 24.0)\nGet the current weather type\nSky colors for different times of day\nLength of a full day-night cycle in real seconds\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet ambient light color\nGet suggested biome-appropriate weather for the given biome\nGet current fog density (0.0 to 1.0)\nGet light attenuation due to weather\nGet the light color based on time of day\nGet the primary light direction (sun during day, moon at …\nGet the moon position in the sky (opposite to sun)\nGet current rain intensity (0.0 to 1.0)\nGet current snow intensity (0.0 to 1.0)\nGet the sun position in the sky (-1 to 1 range)\nGet weather-based terrain color modifier\nGet current wind direction\nGet current wind strength\nInitialize GPU resources for sky rendering\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if it’s currently day time\nCheck if there’s fog\nCheck if it’s currently night time\nCheck if it’s currently raining\nCheck if it’s currently snowing\nCheck if it’s currently twilight (sunrise/sunset)\nCreate a new sky renderer\nCreate a new weather particle system\nCreate a new time system starting at the specified time\nCreate a new weather system starting with clear weather\nGet current rain particles for rendering\nRender the sky\nUpdate sky configuration\nSet target weather with transition duration\nGet current snow particles for rendering\nGet the target weather type\nGet the current time of day system\nGet mutable reference to time of day system\nHow fast time progresses (1.0 = real time, 60.0 = 1 minute …\nUpdate the time of day and sky state\nUpdate particle system\nUpdate the time based on real elapsed time\nUpdate the weather system\nHybrid GI configuration combining VXGI and DDGI\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUse DDGI for polygonal assets\nUse VXGI for voxel terrain\nVoxelization Pipeline - Converts Voxel Terrain Meshes to …\nVoxel Global Illumination (VXGI) using Voxel Cone Tracing\nVXGI configuration\nMaterial data for voxelization\nVertex data for voxelization\nConfiguration for voxelization\nMesh data for voxelization\nVoxelization compute pipeline\nBase color (RGB)\nGet bind group layout\nClear voxel texture to prepare for voxelization\nGet configuration\nEmissive radiance (RGB)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIntensity of direct lighting\nMetallic factor\nCreate a new voxelization pipeline\nNormal vector\nWorld-space position\nRoughness factor\nGet statistics\nNumber of triangles to voxelize\nUpdate configuration\nVoxel grid resolution (power of 2)\nVoxelize a mesh into the voxel texture\nWorld space size covered by voxel grid\nWGSL shader for cone tracing\nVoxel data for radiance field\nConfiguration for VXGI\nVXGI renderer\nGet bind group\nGet bind group layout\nCone aperture angle in radians\nNumber of cone samples per pixel\nGet configuration\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMark voxel grid as needing update\nMaximum cone tracing distance\nCreate a new VXGI renderer\nRGB radiance + opacity (stored as array instead of Vec4)\nUpdate voxel radiance field from terrain\nVoxel grid resolution (power of 2)\nWorld space size covered by voxel grid\n— Adapter nodes: integrate existing <code>Renderer</code> passes into …\nContext passed to graph nodes. This will carry wgpu …\nA very small, linear render graph. Edges are expressed as …\nTrait for a render graph node. Nodes should be …\nA node that defers to <code>Renderer::draw_into</code> to render the 3D …\nTyped GPU resources passed between graph nodes. Keep this …\nA simple typed resource handle registry for graph nodes to …\nCreate a transient texture resource (e.g., HDR target, …\nOptional GPU context for nodes that record commands\nExecute nodes in insertion order. Deterministic by …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOptional primary render target view provided by the driver …\nNamed transient resources produced/consumed by nodes\nGet a target view by key, falling back to <code>primary_view</code> …\nArbitrary user context for integration (e.g., &amp;mut …\nAttach GPU context for nodes that perform GPU work.\nDrive the provided <code>RenderGraph</code> within <code>Renderer::render_with</code>…\nLoad an equirectangular HDR and convert to a cubemap\nQuality presets for IBL resource sizes\nPublic handles to IBL resources (texture views suited for …\nRender a simple procedural sky into the cubemap\nSky sources supported by the manager\nEnsure environment and prefiltered outputs exist for the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHigh-level instance transform (CPU side)\nBatch of instances for the same mesh\nManages instancing for all meshes in the scene\nHelper for generating common instance patterns\nInstance transform data (sent to GPU)\nAdd instance for a specific mesh\nAdd multiple instances for a mesh at once\nGet number of unique meshes being instanced\nIterate over all batches\nGPU buffer for instance data\nCreate a circle pattern of instances\nClear all instances\nClear all instances (does not free GPU buffer immediately)\nReturns the vertex buffer layout descriptor for instance …\nGet draw call reduction percentage\nGet number of draw calls saved by instancing\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet batch for a specific mesh\nGet mutable batch for a specific mesh\nCreate a grid pattern of instances\nInstance transforms\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMesh identifier (e.g., mesh ID, asset path hash)\nModel matrix (4x4, column-major)\nGet total number of instances\nCreate or update GPU buffer with current instances\nUpdate all GPU buffers (call once per frame before …\nAdd random variation to positions\nAdd random rotation around Y axis\nAdd random variation to scales\nLevel of Detail configuration\nLOD generator using quadric error metrics\nMesh representation for LOD generation\nCalculate reduction percentage achieved\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate LOD levels for a mesh\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum allowed quadric error for simplification\nPreserve mesh boundaries during simplification\nTarget reduction percentages for each LOD level (e.g., […\nSimplify mesh to target vertex count using quadric error …\nFlag indicating the material has an albedo texture\nFlag indicating the material has a normal map\nFlag indicating the material has an ORM …\nFlag indicating triplanar projection should be used\nGPU representation of material properties for shader access\nPadding for alignment\nGet reference to albedo texture array (for hot-reload)\nReturns a concise single-line summary suitable for …\nCreate a bind group from the current material arrays\nGet current array layout (if loaded)\nGet current material stats (if loaded)\nMaterial factors: [metallic, roughness, ao, alpha]\nFlags bitfield (has_albedo, has_normal, has_orm, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate or get the cached bind group layout for materials …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGPU storage buffer containing MaterialGpu array\nMaterial metadata records (one per layer)\nGet reference to MRA texture array (for hot-reload)\nCreate a neutral/default material with the given layer …\nGet reference to normal texture array (for hot-reload)\nPacked texture indices: [albedo_idx, normal_idx, orm_idx, …\nTiling factors: [u_tile, v_tile, triplanar_scale, unused]\nValidate array layout for correctness\nValidate a MaterialPackDesc for correctness\nTOML representation for material authoring\nExtended material structure supporting advanced PBR …\nCreate a brushed metal material (anisotropic reflections)\nCreate a car paint material (metallic base + clearcoat)\nDisable a feature flag\nEnable a feature flag\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a glass material (transmission)\nCheck if a feature is enabled\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a skin material (subsurface scattering)\nConvert TOML definition to GPU representation\nCreate a velvet/fabric material (sheen)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBloom configuration parameters\nReturns the argument unchanged.\nBloom intensity multiplier\nCalls <code>U::from(self)</code>.\nNumber of downsample/upsample mip levels (1-8)\nLuminance threshold for bloom (values below are filtered …\nValidate parameters are within safe ranges\nUnit cube centered at origin, with face normals (no UVs).\nGround plane (square) on XZ at y=0, size 1 (we’ll scale …\nUV sphere centered at origin\nCreate a bind group layout deriving entries from a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a simple full-screen pipeline from a <code>MaterialPackage</code>…\nControls the split distribution between uniform (0) and …\nSets shadow filtering and bias values. radius is in texels …\nCompose a standalone fragment shader from a <code>MaterialPackage</code>…\nStep the sequencer and apply camera keys; returns emitted …\nTracks residency of assets in GPU memory for streaming. …\nCheck for hot-reload notifications and invalidate affected …\nEvict the least recently used asset.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet loaded assets.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLoad an asset into residency if not already loaded.\nMark asset as recently used.\nA simple terrain mesh for rendering\nTerrain rendering system that integrates with …\nVertex format for terrain rendering\nVegetation instance for rendering\nCreate GPU buffers for a terrain mesh\nCreate simple cube instances for vegetation (placeholder …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate a complete chunk with vegetation and resources\nSimple terrain preview generator for testing\nGet chunks in a radius around a center position\nGet a loaded mesh by chunk ID (must be loaded first)\nGenerate or get a terrain mesh for the given chunk\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new terrain renderer\nGet the world generator (for configuration access)\nGet mutable access to world generator\nRust-side terrain material with TOML support\nGPU representation of a single terrain layer Size: 64 …\nComplete terrain material pack definition\nExtended terrain material supporting up to 4 layers with …\nPadding to reach 64 bytes (48 bytes used, need 16 more)\nPadding to complete 64-byte common params block\nTexture paths\nBiome identifier (grassland, desert, forest, etc.)\nBlend sharpness: higher values = sharper transitions …\nBlend sharpness (0.0-1.0)\nCreate a desert terrain material (sand base + red sand + …\nCreate a forest terrain material (moss + dirt + rock + …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a grassland terrain material (grass base + dirt + …\nHeight blend enable (use height maps for smoother …\nHeight-based blending\nHeight blend range: [min_height, max_height] Used for …\nHeight range for automatic blending\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFour terrain layers (grass, rock, sand, snow, etc.)\nUp to 4 layers\nMaterial properties: [metallic, roughness]\nMaterial properties\nLayer name (e.g., “grass”, “rock”, “sand”)\nMaterial name\nNormal blend method: 0=Linear, 1=Reoriented Normal Mapping …\nNormal blending: “linear”, “rnm” (Reoriented …\nParse normal blend method string to GPU constant\nSplat map path (RGBA image defining layer weights)\nSplat map texture index (R=layer0, G=layer1, B=layer2, …\nGlobal UV scale for splat map sampling\nGlobal splat UV scale\nTexture indices: [albedo, normal, orm, height]\nConvert to GPU representation (requires texture index …\nTriplanar enable flag (0=off, 1=on)\nTriplanar settings\nTriplanar blend power (steepness threshold) Higher values …\nTriplanar power\nGlobal triplanar threshold (slope angle in degrees where …\nUV scale for this layer (allows different tiling per layer)\nUV tiling scale\nA loaded texture with its GPU resources\nCreate a 1x1 normal map texture pointing upward (0, 0, 1)\nCreate a 1x1 white texture as a default/fallback\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCompute cluster index for a screen-space pixel and linear …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCompressed vertex size\nCompressed vertex format optimized for GPU memory …\nHalf-float (f16) UV coordinate encoding\nMemory reduction percentage\nOctahedral normal encoding\nStandard vertex size (position + normal + uv)\nVertex compression utilities\nCalculate memory savings for a given vertex count\nCompress a standard vertex to compressed format\nCompress a batch of vertices\nDecode octahedral coordinates back to a normalized 3D …\nDecode a 16-bit half-float to 32-bit float\nDecode two half-floats to Vec2 (UV coordinates)\nDecompress a compressed vertex to standard format\nEncode a normalized 3D vector to 2D octahedral coordinates\nEncode a 32-bit float to 16-bit half-float\nEncode a Vec2 (UV coordinates) to two half-floats\nCompute encoding error (for quality assessment)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNormal encoded in octahedral format (2x i16, 4 bytes) …\nPosition (3x f32, 12 bytes) - kept full precision for …\nUV coordinates as half-floats (2x f16, 4 bytes) Reduces …")