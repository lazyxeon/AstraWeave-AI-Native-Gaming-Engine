diff --git a/tools/aw_editor/src/viewport/widget.rs b/tools/aw_editor/src/viewport/widget.rs
index 3ab93b8..7f6a828 100644
--- a/tools/aw_editor/src/viewport/widget.rs
+++ b/tools/aw_editor/src/viewport/widget.rs
@@ -14,164 +14,76 @@
 //! let viewport = ViewportWidget::new(cc)?;
 //!
 //! // In eframe::App::update()
-//! viewport.ui(ui, scene_state, undo_stack)?;
+//! viewport.ui(ui, &world, undo_stack, snapping_config)?;
 //! ```
 //!
-//! # Architecture
-//!
-//! ViewportWidget is the glue between egui (UI) and wgpu (3D rendering):
-//! - Allocates egui space for viewport
-//! - Handles mouse/keyboard input
-//! - Coordinates rendering (via ViewportRenderer)
-//! - Uses egui_wgpu::Callback for custom rendering
-//!
-//! # Performance
-//!
-//! Target: 16.67ms per frame (60 FPS)
-//! - Input handling: <0.1ms
-//! - Rendering: <10ms (see ViewportRenderer)
-//! - egui integration: <1ms
-//! - Total: <12ms (26% headroom)
-
-use anyhow::{Context, Result};
-use egui;
-use std::sync::{Arc, Mutex};
-use wgpu;
-
-use super::camera::OrbitCamera;
-use super::grid_renderer::GridRenderSettings;
-use super::renderer::ViewportRenderer;
-use super::toolbar::ViewportToolbar;
-use crate::gizmo::{GizmoMode, GizmoState};
-use crate::interaction::{self, GizmoCancelMetadata, GizmoOperationKind};
-use crate::scene_state::TransformableScene;
-use crate::telemetry::{self, EditorTelemetryEvent};
-use astraweave_core::{Entity, Team};
-
-/// Camera bookmark for F1-F12 quick recall
-#[derive(Clone, Debug)]
-struct CameraBookmark {
-    focal_point: glam::Vec3,
-    distance: f32,
-    yaw: f32,
-    pitch: f32,
-}
-
-/// 3D viewport widget for egui
-///
-/// Integrates wgpu 3D rendering into egui panel system.
-/// Manages camera, rendering, and input handling.
-pub struct ViewportWidget {
-    /// Viewport renderer (wgpu coordinator)
-    renderer: Arc<Mutex<ViewportRenderer>>,
+                                    if let Some(world_pos) =
+                                        self.project_pointer_to_ground(mouse_pos_abs, response.rect)
+                                    {
+                                        // Convert absolute screen position to viewport-relative (0,0 = top-left of viewport)
+                                        let mouse_pos = egui::Pos2 {
+                                            x: mouse_pos_abs.x - response.rect.min.x,
+                                            y: mouse_pos_abs.y - response.rect.min.y,
+                                        };
 
-    /// Orbit camera controller
-    camera: OrbitCamera,
+                                        // Check if Ctrl is held for grid snapping
+                                        let snap_enabled = ctx
+                                            .input(|i| i.modifiers.ctrl || i.modifiers.command);
 
-    /// Render texture (reused each frame)
-    render_texture: Option<Arc<wgpu::Texture>>,
+                                        // Apply grid snapping if enabled
+                                        let final_x = if snap_enabled {
+                                            self.snap_to_grid(world_pos.x)
+                                        } else {
+                                            world_pos.x
+                                        };
+                                        let final_z = if snap_enabled {
+                                            self.snap_to_grid(world_pos.z)
+                                        } else {
+                                            world_pos.z
+                                        };
 
-    /// Staging buffer for CPU readback (GPU ‚Üí CPU copy)
-    staging_buffer: Option<wgpu::Buffer>,
+                                        // Set entity position directly (no delta, just follow mouse)
+                                        let new_x = final_x.round() as i32;
+                                        let new_z = final_z.round() as i32;
 
-    /// egui texture handle for displaying rendered viewport
-    egui_texture: Option<egui::TextureHandle>,
+                                        if let Some(pose_mut) = world.pose_mut(selected_id) {
+                                            pose_mut.pos.x = new_x;
+                                            pose_mut.pos.y = new_z; // IVec2.y = world Z
+                                            interaction::refresh_transaction_state(
+                                                &mut self.gizmo_state,
+                                                world,
+                                            );
 
-    /// Last viewport size (for resize detection)
+                                            println!(
+                                                "üîß Translate (FREE{}): entity={}, mouse_abs=({:.1}, {:.1}), mouse_rel=({:.1}, {:.1}), world=({:.2}, {:.2}), new_pos=({}, {})",
+                                                if snap_enabled { " + SNAP" } else { "" },
+                                                selected_id, mouse_pos_abs.x, mouse_pos_abs.y,
+                                                mouse_pos.x, mouse_pos.y,
+                                                world_pos.x, world_pos.z, new_x, new_z
+                                            );
     /// ```
-    pub fn ui<S: TransformableScene>(
+    pub fn ui(
         &mut self,
         ui: &mut egui::Ui,
-        scene: &mut S,
+        world: &mut World,
         undo_stack: &mut crate::command::UndoStack, // Phase 2.1: Command integration
+        snapping: SnappingConfig,
     ) -> Result<()> {
+        self.snapping_config = snapping;
+        self.toolbar.snap_enabled = snapping.grid_enabled;
+        self.toolbar.snap_size = snapping.grid_size;
+        self.toolbar.angle_snap_enabled = snapping.angle_enabled;
+        self.toolbar.angle_snap_degrees = snapping.angle_increment;
+
         // Update frame time tracking
         let now = std::time::Instant::now();
         let frame_time = now.duration_since(self.last_frame_time).as_secs_f32();
@@ -214,6 +131,11 @@ impl ViewportWidget {
         let viewport_size = egui::vec2(available.x, available.y);
         let (rect, response) = ui.allocate_exact_size(viewport_size, egui::Sense::click_and_drag());
 
+        self.last_viewport_rect = Some(rect);
+        self.last_cursor_world = response
+            .hover_pos()
+            .and_then(|pos| self.project_pointer_to_ground(pos, rect));
+
         // Request focus on hover or click (enables camera controls)
         if response.hovered() || response.clicked() {
             println!(
@@ -237,7 +159,7 @@ impl ViewportWidget {
         }
 
         // Handle input (mouse/keyboard) - always process, but camera only moves if focused
-        self.handle_input(&response, ui.ctx(), scene, undo_stack)?;
+        self.handle_input(&response, ui.ctx(), world, undo_stack)?;
 
         // Request continuous repaint to update viewport every frame
         ui.ctx().request_repaint();
@@ -266,17 +188,12 @@ impl ViewportWidget {
             // Render in separate scope to drop MutexGuard early
             {
                 if let Ok(mut renderer) = self.renderer.lock() {
-                    let grid_settings = GridRenderSettings {
-                        enabled: self.toolbar.show_grid,
-                        spacing: self.grid_snap_size.max(0.1),
-                        major_line_multiple: 10.0,
-                    };
                     if let Err(e) = renderer.render(
                         &texture,
                         &self.camera,
-                        scene.world(),
+                        world,
                         Some(&self.gizmo_state),
-                        grid_settings,
+                        &self.snapping_config,
                     ) {
                         eprintln!("‚ùå Viewport render failed: {}", e);
                     }
@@ -369,13 +286,13 @@ impl ViewportWidget {
 
                     if snap_enabled {
                         let snap_text = match self.gizmo_state.mode {
-                            crate::gizmo::GizmoMode::Translate { .. } => {
-                                format!("üìê Grid Snap: {:.2}m", self.grid_snap_size)
+                            GizmoMode::Translate { .. } => {
+                                format!("üìê Grid Snap: {:.2}m", self.snapping_config.grid_size)
                             }
-                            crate::gizmo::GizmoMode::Rotate { .. } => {
+                            GizmoMode::Rotate { .. } => {
                                 format!(
                                     "üîÑ Angle Snap: {}¬∞",
-                                    self.angle_snap_increment.to_degrees() as i32
+                                    self.snapping_config.angle_increment as i32
                                 )
                             }
                             _ => String::new(),
@@ -413,11 +330,12 @@ impl ViewportWidget {
                 self.toolbar.stats.entity_count = 100; // Placeholder
                 self.toolbar.stats.triangle_count = 3600; // 100 cubes √ó 36 triangles
 
-                // Sync toolbar snap settings to viewport
-                self.grid_snap_size = self.toolbar.snap_size;
-                self.angle_snap_increment = self.toolbar.angle_snap_degrees.to_radians();
-
                 self.toolbar.ui(ui, rect);
+
+                self.snapping_config.grid_enabled = self.toolbar.snap_enabled;
+                self.snapping_config.grid_size = self.toolbar.snap_size;
+                self.snapping_config.angle_enabled = self.toolbar.angle_snap_enabled;
+                self.snapping_config.angle_increment = self.toolbar.angle_snap_degrees;
             } else {
                 // First frame - texture not ready yet
                 ui.painter()
@@ -454,15 +372,13 @@ impl ViewportWidget {
     /// - Scroll: Zoom camera
     /// - G/R/S: Gizmo mode (translate/rotate/scale)
     /// - Click: Select entity
-    fn handle_input<S: TransformableScene>(
+    fn handle_input(
         &mut self,
         response: &egui::Response,
         ctx: &egui::Context,
-        scene: &mut S,
+        world: &mut World,
         undo_stack: &mut crate::command::UndoStack, // Phase 2.1: Command integration
     ) -> Result<()> {
-        use crate::gizmo::GizmoMode;
-
         // Update gizmo state with current mouse position
         if let Some(pos) = response.hover_pos() {
             let mouse_pos = glam::Vec2::new(pos.x, pos.y);
@@ -472,35 +388,36 @@ impl ViewportWidget {
         // Gizmo transform application (if active and dragging)
         if self.gizmo_state.is_active() && response.dragged_by(egui::PointerButton::Primary) {
             if let Some(selected_id) = self.selected_entity() {
-                let mouse_delta = self.gizmo_state.mouse_delta();
-
-                match self.gizmo_state.mode {
-                    GizmoMode::Translate { constraint: _ } => {
-                        // Read CURRENT constraint (not captured at match time!)
-                        let constraint = match self.gizmo_state.mode {
-                            GizmoMode::Translate { constraint: c } => c,
-                            _ => crate::gizmo::AxisConstraint::None,
-                        };
+                // Get entity's current pose
+                if let Some(pose) = world.pose(selected_id) {
+                    let mouse_delta = self.gizmo_state.mouse_delta();
+
+                    match self.gizmo_state.mode {
+                        GizmoMode::Translate { constraint: _ } => {
+                            // Read CURRENT constraint (not captured at match time!)
+                            let constraint = match self.gizmo_state.mode {
+                                GizmoMode::Translate { constraint: c } => c,
+                                _ => AxisConstraint::None,
+                            };
 
-                        if constraint == crate::gizmo::AxisConstraint::None {
-                            // FREE MOVEMENT: Entity follows mouse pointer on ground plane
-                            if let Some(mouse_pos_abs) = response.hover_pos() {
-                                let viewport_size = response.rect.size();
-                                let mouse_pos = egui::Pos2 {
-                                    x: mouse_pos_abs.x - response.rect.min.x,
-                                    y: mouse_pos_abs.y - response.rect.min.y,
-                                };
-                                let ray = self.camera.ray_from_screen(mouse_pos, viewport_size);
-                                let plane_normal = glam::Vec3::Y;
-                                let plane_point = glam::Vec3::ZERO;
-                                let denom = ray.direction.dot(plane_normal);
-
-                                if denom.abs() > 0.0001 {
-                                    let t = (plane_point - ray.origin).dot(plane_normal) / denom;
-                                    if t >= 0.0 {
-                                        let world_pos = ray.origin + ray.direction * t;
-                                        let snap_enabled =
-                                            ctx.input(|i| i.modifiers.ctrl || i.modifiers.command);
+                            if constraint == AxisConstraint::None {
+                                // FREE MOVEMENT: Entity follows mouse pointer on ground plane
+                                // Get current mouse position in screen space
+                                if let Some(mouse_pos_abs) = response.hover_pos() {
+                                    if let Some(world_pos) = self
+                                        .project_pointer_to_ground(mouse_pos_abs, response.rect)
+                                    {
+                                        // Convert absolute screen position to viewport-relative (0,0 = top-left of viewport)
+                                        let mouse_pos = egui::Pos2 {
+                                            x: mouse_pos_abs.x - response.rect.min.x,
+                                            y: mouse_pos_abs.y - response.rect.min.y,
+                                        };
+
+                                        // Check if Ctrl is held for grid snapping
+                                        let snap_enabled = ctx
+                                            .input(|i| i.modifiers.ctrl || i.modifiers.command);
+
+                                        // Apply grid snapping if enabled
                                         let final_x = if snap_enabled {
                                             self.snap_to_grid(world_pos.x)
                                         } else {
@@ -511,149 +428,184 @@ impl ViewportWidget {
                                         } else {
                                             world_pos.z
                                         };
+
+                                        // Set entity position directly (no delta, just follow mouse)
                                         let new_x = final_x.round() as i32;
                                         let new_z = final_z.round() as i32;
 
-                                        if let Some(mut snapshot) = scene.snapshot_for(selected_id)
-                                        {
-                                            snapshot.position.x = final_x;
-                                            snapshot.position.z = final_z;
-                                            scene.apply_snapshot(selected_id, &snapshot);
-                                        }
+                                        if let Some(pose_mut) = world.pose_mut(selected_id) {
+                                            pose_mut.pos.x = new_x;
+                                            pose_mut.pos.y = new_z; // IVec2.y = world Z
+                                            interaction::refresh_transaction_state(
+                                                &mut self.gizmo_state,
+                                                world,
+                                            );
 
-                                        println!(
+                                            println!(
                                                 "üîß Translate (FREE{}): entity={}, mouse_abs=({:.1}, {:.1}), mouse_rel=({:.1}, {:.1}), world=({:.2}, {:.2}), new_pos=({}, {})",
                                                 if snap_enabled { " + SNAP" } else { "" },
                                                 selected_id, mouse_pos_abs.x, mouse_pos_abs.y,
                                                 mouse_pos.x, mouse_pos.y,
                                                 world_pos.x, world_pos.z, new_x, new_z
                                             );
+                                        }
+                                    }
+                                }
+                            } else {
+                                // CONSTRAINED MOVEMENT: Raycast to ground plane, then project onto constraint axis
+                                if let Some(mouse_pos_abs) = response.hover_pos() {
+                                    // Convert absolute screen position to viewport-relative
+                                    let mouse_pos = egui::Pos2 {
+                                        x: mouse_pos_abs.x - response.rect.min.x,
+                                        y: mouse_pos_abs.y - response.rect.min.y,
+                                    };
+
+                                    // Get start position from snapshot (for the locked axis)
+                                    let start_pos =
+                                        if let Some(snapshot) = &self.gizmo_state.start_transform {
+                                            (snapshot.position.x, snapshot.position.z)
+                                        } else {
+                                            (pose.pos.x as f32, pose.pos.y as f32)
+                                        };
+
+                                    if let Some(world_pos) = self
+                                        .project_pointer_to_ground(mouse_pos_abs, response.rect)
+                                    {
+                                        // Check if Ctrl is held for grid snapping
+                                        let snap_enabled = ctx
+                                            .input(|i| i.modifiers.ctrl || i.modifiers.command);
+
+                                        // Apply snapping to world position before constraints
+                                        let snapped_x = if snap_enabled {
+                                            self.snap_to_grid(world_pos.x)
+                                        } else {
+                                            world_pos.x
+                                        };
+                                        let snapped_z = if snap_enabled {
+                                            self.snap_to_grid(world_pos.z)
+                                        } else {
+                                            world_pos.z
+                                        };
+
+                                        // Project onto constraint axis (lock one component to start position)
+                                        let (new_x, new_z) = match constraint {
+                                            AxisConstraint::X => {
+                                                // X-axis only: follow mouse X, lock Z to start
+                                                (snapped_x.round() as i32, start_pos.1 as i32)
+                                            }
+                                            AxisConstraint::Z => {
+                                                // Z-axis only: lock X to start, follow mouse Z
+                                                (start_pos.0 as i32, snapped_z.round() as i32)
+                                            }
+                                            AxisConstraint::Y => {
+                                                // Y-axis constrained (ground plane - no movement)
+                                                (start_pos.0 as i32, start_pos.1 as i32)
+                                            }
+                                            _ => {
+                                                // Planar constraints: use both axes
+                                                (
+                                                    snapped_x.round() as i32,
+                                                    snapped_z.round() as i32,
+                                                )
+                                            }
+                                        };
+
+                                        if let Some(pose_mut) = world.pose_mut(selected_id) {
+                                            pose_mut.pos.x = new_x;
+                                            pose_mut.pos.y = new_z; // IVec2.y = world Z
+                                            interaction::refresh_transaction_state(
+                                                &mut self.gizmo_state,
+                                                world,
+                                            );
+
+                                            println!(
+                                                "üîß Translate (AXIS {:?}{}): entity={}, mouse_abs=({:.1}, {:.1}), mouse_rel=({:.1}, {:.1}), world=({:.2}, {:.2}), start=({:.2}, {:.2}), new_pos=({}, {})",
+                                                constraint,
+                                                if snap_enabled { " + SNAP" } else { "" },
+                                                selected_id, mouse_pos_abs.x, mouse_pos_abs.y,
+                                                mouse_pos.x, mouse_pos.y,
+                                                snapped_x, snapped_z, start_pos.0, start_pos.1,
+                                                new_x, new_z
+                                            );
+                                        }
                                     }
                                 }
                             }
-                        } else if let Some(mouse_pos_abs) = response.hover_pos() {
-                            // CONSTRAINED MOVEMENT: project onto axis/plane
-                            let viewport_size = response.rect.size();
-                            let mouse_pos = egui::Pos2 {
-                                x: mouse_pos_abs.x - response.rect.min.x,
-                                y: mouse_pos_abs.y - response.rect.min.y,
-                            };
+                        }
+                        GizmoMode::Rotate { constraint: _ } => {
+                            // IMPORTANT: We need to remember the start rotation when drag begins
+                            // For now, we'll store it in the TransformSnapshot rotation field
 
-                            let start_pos =
+                            // Try to get start rotation from snapshot (stored as Quat)
+                            let (start_x, start_y, start_z) =
                                 if let Some(snapshot) = &self.gizmo_state.start_transform {
-                                    (snapshot.position.x, snapshot.position.z)
-                                } else if let Some(pose) = scene.world().pose(selected_id) {
-                                    (pose.pos.x as f32, pose.pos.y as f32)
+                                    // Extract XYZ rotations from quaternion
+                                    snapshot.rotation.to_euler(glam::EulerRot::XYZ)
                                 } else {
-                                    (0.0, 0.0)
+                                    // Fallback: capture current as start
+                                    (pose.rotation_x, pose.rotation, pose.rotation_z)
                                 };
 
-                            let ray = self.camera.ray_from_screen(mouse_pos, viewport_size);
-                            let plane_normal = glam::Vec3::Y;
-                            let plane_point = glam::Vec3::ZERO;
-                            let denom = ray.direction.dot(plane_normal);
-
-                            if denom.abs() > 0.0001 {
-                                let t = (plane_point - ray.origin).dot(plane_normal) / denom;
-                                if t >= 0.0 {
-                                    let world_pos = ray.origin + ray.direction * t;
-                                    let snap_enabled =
-                                        ctx.input(|i| i.modifiers.ctrl || i.modifiers.command);
-                                    let snapped_x = if snap_enabled {
-                                        self.snap_to_grid(world_pos.x)
-                                    } else {
-                                        world_pos.x
-                                    };
-                                    let snapped_z = if snap_enabled {
-                                        self.snap_to_grid(world_pos.z)
-                                    } else {
-                                        world_pos.z
-                                    };
+                            // Calculate rotation angle from TOTAL mouse movement since drag started
+                            let rotation_sensitivity = 0.005; // 200px = 1 radian (57.3¬∞)
 
-                                    let (new_x, new_z) = match constraint {
-                                        crate::gizmo::AxisConstraint::X => {
-                                            (snapped_x.round() as i32, start_pos.1 as i32)
-                                        }
-                                        crate::gizmo::AxisConstraint::Z => {
-                                            (start_pos.0 as i32, snapped_z.round() as i32)
-                                        }
-                                        crate::gizmo::AxisConstraint::Y => {
-                                            (start_pos.0 as i32, start_pos.1 as i32)
-                                        }
-                                        _ => (snapped_x.round() as i32, snapped_z.round() as i32),
-                                    };
-
-                                    if let Some(mut snapshot) = scene.snapshot_for(selected_id) {
-                                        snapshot.position.x = new_x as f32;
-                                        snapshot.position.z = new_z as f32;
-                                        scene.apply_snapshot(selected_id, &snapshot);
-                                    }
+                            // CRITICAL FIX: Read CURRENT constraint (not captured at match time!)
+                            // This allows mid-drag constraint changes via X/Y/Z keys
+                            let constraint = match self.gizmo_state.mode {
+                                GizmoMode::Rotate { constraint: c } => c,
+                                _ => AxisConstraint::None,
+                            };
 
-                                    println!(
-                                            "üîß Translate (CONSTRAINED{}): entity={}, constraint={:?}, start=({:.1}, {:.1}), world=({:.2}, {:.2}), new=({}, {})",
-                                            if snap_enabled { " + SNAP" } else { "" },
-                                            selected_id, constraint, start_pos.0, start_pos.1,
-                                            world_pos.x, world_pos.z, new_x, new_z
-                                        );
+                            let (rotation_angle, target_axis) = match constraint {
+                                AxisConstraint::None => {
+                                    // No explicit constraint - default to Y-axis (yaw) but don't highlight
+                                    (mouse_delta.x * rotation_sensitivity, "Y")
                                 }
-                            }
-                        }
-                    }
-                    GizmoMode::Rotate { constraint: _ } => {
-                        // IMPORTANT: We need to remember the start rotation when drag begins
-                        let (start_x, start_y, start_z) =
-                            if let Some(snapshot) = &self.gizmo_state.start_transform {
-                                snapshot.rotation.to_euler(glam::EulerRot::XYZ)
-                            } else if let Some(pose) = scene.world().pose(selected_id) {
-                                (pose.rotation_x, pose.rotation, pose.rotation_z)
-                            } else {
-                                (0.0, 0.0, 0.0)
+                                AxisConstraint::Y => {
+                                    // Y-axis explicitly selected: horizontal mouse movement
+                                    (mouse_delta.x * rotation_sensitivity, "Y")
+                                }
+                                AxisConstraint::X => {
+                                    // X-axis (pitch): vertical mouse movement (inverted for intuitive control)
+                                    (-mouse_delta.y * rotation_sensitivity, "X")
+                                }
+                                AxisConstraint::Z => {
+                                    // Z-axis (roll): vertical mouse movement (same direction as X but different axis)
+                                    (mouse_delta.y * rotation_sensitivity, "Z")
+                                }
+                                _ => (0.0, "None"), // No rotation for planar constraints
                             };
 
-                        let rotation_sensitivity = 0.005; // 200px = 1 radian (57.3¬∞)
-                        let constraint = match self.gizmo_state.mode {
-                            GizmoMode::Rotate { constraint: c } => c,
-                            _ => crate::gizmo::AxisConstraint::None,
-                        };
+                            // Check if Ctrl is held for angle snapping
+                            let snap_enabled =
+                                ctx.input(|i| i.modifiers.ctrl || i.modifiers.command);
 
-                        let (rotation_angle, target_axis) = match constraint {
-                            crate::gizmo::AxisConstraint::None => {
-                                (mouse_delta.x * rotation_sensitivity, "Y")
-                            }
-                            crate::gizmo::AxisConstraint::Y => {
-                                (mouse_delta.x * rotation_sensitivity, "Y")
-                            }
-                            crate::gizmo::AxisConstraint::X => {
-                                (-mouse_delta.y * rotation_sensitivity, "X")
-                            }
-                            crate::gizmo::AxisConstraint::Z => {
-                                (mouse_delta.y * rotation_sensitivity, "Z")
-                            }
-                            _ => (0.0, "None"),
-                        };
+                            // Apply angle snapping if enabled (snap the delta, not the total)
+                            let final_angle = if snap_enabled {
+                                self.snap_angle(rotation_angle)
+                            } else {
+                                rotation_angle
+                            };
 
-                        let snap_enabled = ctx.input(|i| i.modifiers.ctrl || i.modifiers.command);
-                        let final_angle = if snap_enabled {
-                            self.snap_angle(rotation_angle)
-                        } else {
-                            rotation_angle
-                        };
+                            // Set rotation to START + TOTAL_ANGLE (not accumulate frame by frame!)
+                            let updated_angles = world.pose_mut(selected_id).map(|pose_mut| {
+                                match target_axis {
+                                    "X" => pose_mut.rotation_x = start_x + final_angle,
+                                    "Y" => pose_mut.rotation = start_y + final_angle,
+                                    "Z" => pose_mut.rotation_z = start_z + final_angle,
+                                    _ => {}
+                                }
+                                (pose_mut.rotation_x, pose_mut.rotation, pose_mut.rotation_z)
+                            });
 
-                        if let Some(mut snapshot) = scene.snapshot_for(selected_id) {
-                            let (mut rx, mut ry, mut rz) =
-                                snapshot.rotation.to_euler(glam::EulerRot::XYZ);
-                            match target_axis {
-                                "X" => rx = start_x + final_angle,
-                                "Y" => ry = start_y + final_angle,
-                                "Z" => rz = start_z + final_angle,
-                                _ => {}
-                            }
-                            snapshot.rotation =
-                                glam::Quat::from_euler(glam::EulerRot::XYZ, rx, ry, rz);
-                            scene.apply_snapshot(selected_id, &snapshot);
+                            if let Some(updated_angles) = updated_angles {
+                                interaction::refresh_transaction_state(
+                                    &mut self.gizmo_state,
+                                    world,
+                                );
 
-                            println!(
-                                    "üîß Rotate{}: entity={}, axis={}, start={:.1}¬∞, mouse_delta=({:.1}, {:.1}), angle={:.1}¬∞",
+                                println!(
+                                    "üîß Rotate{}: entity={}, axis={}, start={:.1}¬∞, mouse_delta=({:.1}, {:.1}), angle={:.1}¬∞, new={:.1}¬∞",
                                     if snap_enabled { " + SNAP" } else { "" },
                                     selected_id, target_axis,
                                     match target_axis {
@@ -662,20 +614,26 @@ impl ViewportWidget {
                                         "Z" => start_z.to_degrees(),
                                         _ => 0.0,
                                     },
-                                    mouse_delta.x,
-                                    mouse_delta.y,
-                                    final_angle.to_degrees()
+                                    mouse_delta.x, mouse_delta.y,
+                                    final_angle.to_degrees(),
+                                    match target_axis {
+                                        "X" => updated_angles.0.to_degrees(),
+                                        "Y" => updated_angles.1.to_degrees(),
+                                        "Z" => updated_angles.2.to_degrees(),
+                                        _ => 0.0,
+                                    }
                                 );
+                            }
                         }
+                        GizmoMode::Scale {
+                            constraint: _,
+                            uniform: _,
+                        } => {
+                            // SCALE MODE: Uses scroll wheel (handled above), not mouse drag
+                            // No-op here - scaling happens via scroll wheel in the zoom section
+                        }
+                        GizmoMode::Inactive => {}
                     }
-                    GizmoMode::Scale {
-                        constraint: _,
-                        uniform: _,
-                    } => {
-                        // SCALE MODE: Uses scroll wheel (handled above), not mouse drag
-                        // No-op here - scaling happens via scroll wheel in the zoom section
-                    }
-                    GizmoMode::Inactive => {}
                 }
             }
         }
@@ -723,16 +681,19 @@ impl ViewportWidget {
                     if matches!(self.gizmo_state.mode, GizmoMode::Scale { .. }) {
                         // SCALE MODE: Adjust entity scale with scroll wheel
                         if let Some(selected_id) = self.selected_entity() {
-                            if let Some(mut snapshot) = scene.snapshot_for(selected_id) {
+                            if let Some(pose_mut) = world.pose_mut(selected_id) {
+                                // Scale by 1% per scroll tick (very smooth, gradual scaling)
                                 let scale_delta = 1.0 + (scroll * 0.01);
-                                let mut uniform_scale = snapshot.scale.x * scale_delta;
-                                uniform_scale = uniform_scale.max(0.1).min(10.0);
-                                snapshot.scale = glam::Vec3::splat(uniform_scale);
-                                scene.apply_snapshot(selected_id, &snapshot);
+                                let new_scale = (pose_mut.scale * scale_delta).max(0.1).min(10.0);
+                                pose_mut.scale = new_scale;
+                                interaction::refresh_transaction_state(
+                                    &mut self.gizmo_state,
+                                    world,
+                                );
 
                                 println!(
                                     "üîß Scale (scroll): entity={}, delta={:.3}x, new_scale={:.3}x",
-                                    selected_id, scale_delta, uniform_scale
+                                    selected_id, scale_delta, new_scale
                                 );
                             }
                         }
@@ -755,18 +716,24 @@ impl ViewportWidget {
             self.gizmo_state.start_transform = None;
         }
 
-        // Capture start transform when beginning a new operation
+        // Capture start transform when beginning a new operation and emit tracing instrumentation
         if self.gizmo_state.is_active() && self.gizmo_state.start_transform.is_none() {
-            if interaction::ensure_world_snapshot(&mut self.gizmo_state, scene.world()).is_none() {
-                if let Some(selected_id) = self.selected_entity() {
-                    if let Some(snapshot) = scene.snapshot_for(selected_id) {
-                        println!(
-                            "üì∏ Captured scene-state start transform: {:?}",
-                            snapshot.position
-                        );
-                        self.gizmo_state.start_transform = Some(snapshot);
-                    }
-                }
+            let captured = interaction::ensure_world_snapshot(&mut self.gizmo_state, world);
+            if let (Some(snapshot), Some(entity)) = (captured, self.selected_entity()) {
+                let mode_text = self.gizmo_state.mode_text();
+                let constraint = self.gizmo_state.constraint_text();
+                let span = info_span!(
+                    "aw_editor.gizmo.start",
+                    entity = entity,
+                    mode = mode_text.as_str(),
+                    constraint = constraint.as_str()
+                );
+                let _guard = span.enter();
+                info!(
+                    pos_x = snapshot.position.x,
+                    pos_z = snapshot.position.z,
+                    "Captured gizmo start"
+                );
             }
         }
 
@@ -776,23 +743,11 @@ impl ViewportWidget {
 
             // Handle gizmo mode keys first
             if i.key_pressed(egui::Key::G) {
-                let prev = self.gizmo_state.mode;
                 self.gizmo_state.handle_key(KeyCode::KeyG);
-                if !matches!(prev, GizmoMode::Translate { .. })
-                    && matches!(self.gizmo_state.mode, GizmoMode::Translate { .. })
-                {
-                    self.emit_gizmo_start(GizmoOperationKind::Translate);
-                }
                 println!("üîß Gizmo mode: Translate (G)");
             }
             if i.key_pressed(egui::Key::R) {
-                let prev = self.gizmo_state.mode;
                 self.gizmo_state.handle_key(KeyCode::KeyR);
-                if !matches!(prev, GizmoMode::Rotate { .. })
-                    && matches!(self.gizmo_state.mode, GizmoMode::Rotate { .. })
-                {
-                    self.emit_gizmo_start(GizmoOperationKind::Rotate);
-                }
                 println!("üîß Gizmo mode: Rotate (R)");
             }
             if i.key_pressed(egui::Key::S) {
@@ -802,7 +757,6 @@ impl ViewportWidget {
                 if was_scaling {
                     println!("üîß Scale mode: OFF (camera control restored)");
                 } else {
-                    self.emit_gizmo_start(GizmoOperationKind::Scale);
                     println!("üîß Scale mode: ON (use scroll wheel to scale, S to exit)");
                 }
             }
@@ -835,29 +789,26 @@ impl ViewportWidget {
             if (i.modifiers.command || i.modifiers.ctrl) && i.key_pressed(egui::Key::Z) {
                 if i.modifiers.shift {
                     // Ctrl+Shift+Z: Redo
-                    if let Err(e) = undo_stack.redo(scene.world_mut()) {
+                    if let Err(e) = undo_stack.redo(world) {
                         eprintln!("‚ùå Redo failed: {}", e);
                     } else if let Some(desc) = undo_stack.redo_description() {
                         println!("‚è≠Ô∏è  Redo: {}", desc);
-                        scene.sync_all();
                     }
                 } else {
                     // Ctrl+Z: Undo
-                    if let Err(e) = undo_stack.undo(scene.world_mut()) {
+                    if let Err(e) = undo_stack.undo(world) {
                         eprintln!("‚ùå Undo failed: {}", e);
                     } else if let Some(desc) = undo_stack.undo_description() {
                         println!("‚èÆÔ∏è  Undo: {}", desc);
-                        scene.sync_all();
                     }
                 }
             }
             if (i.modifiers.command || i.modifiers.ctrl) && i.key_pressed(egui::Key::Y) {
                 // Ctrl+Y: Redo (alternative to Ctrl+Shift+Z)
-                if let Err(e) = undo_stack.redo(scene.world_mut()) {
+                if let Err(e) = undo_stack.redo(world) {
                     eprintln!("‚ùå Redo failed: {}", e);
                 } else if let Some(desc) = undo_stack.redo_description() {
                     println!("‚è≠Ô∏è  Redo: {}", desc);
-                    scene.sync_all();
                 }
             }
 
@@ -865,25 +816,25 @@ impl ViewportWidget {
             if (i.modifiers.command || i.modifiers.ctrl) && i.key_pressed(egui::Key::C) {
                 // Ctrl+C: Copy selected entities
                 if !self.selected_entities.is_empty() {
-                    self.copy_selection(scene);
+                    self.copy_selection(world);
                     println!("üìã Copied {} entities", self.selected_entities.len());
                 }
             }
             if (i.modifiers.command || i.modifiers.ctrl) && i.key_pressed(egui::Key::V) {
                 // Ctrl+V: Paste entities
-                self.paste_selection(scene, undo_stack);
+                self.paste_selection(world, undo_stack);
             }
             if (i.modifiers.command || i.modifiers.ctrl) && i.key_pressed(egui::Key::D) {
                 // Ctrl+D: Duplicate selected entities
                 if !self.selected_entities.is_empty() {
-                    self.duplicate_selection(scene, undo_stack);
+                    self.duplicate_selection(world, undo_stack);
                     println!("üìë Duplicated {} entities", self.selected_entities.len());
                 }
             }
             if i.key_pressed(egui::Key::Delete) {
                 // Delete: Remove selected entities
                 if !self.selected_entities.is_empty() {
-                    self.delete_selection(scene, undo_stack);
+                    self.delete_selection(world, undo_stack);
                     println!("üóëÔ∏è  Deleted {} entities", self.selected_entities.len());
                 }
             }
@@ -896,7 +847,7 @@ impl ViewportWidget {
 
                 if i.modifiers.command || i.modifiers.ctrl {
                     // Ctrl+A: Select all entities
-                    self.select_all(scene);
+                    self.select_all(world);
                     println!(
                         "üéØ Selected all entities ({} total)",
                         self.selected_entities.len()
@@ -908,7 +859,7 @@ impl ViewportWidget {
             if i.key_pressed(egui::Key::F) {
                 if let Some(selected_id) = self.selected_entity() {
                     // Frame World entity (match rendering position)
-                    if let Some(pose) = scene.world().pose(selected_id) {
+                    if let Some(pose) = world.pose(selected_id) {
                         let x = pose.pos.x as f32;
                         let z = pose.pos.y as f32;
                         let position = glam::Vec3::new(x, 1.0, z); // Y=1.0 (raised position)
@@ -923,7 +874,7 @@ impl ViewportWidget {
                         );
                     } else {
                         println!(
-                            "‚ö†Ô∏è  Frame selected: Entity {} not found in scene",
+                            "‚ö†Ô∏è  Frame selected: Entity {} not found in World",
                             selected_id
                         );
                     }
@@ -935,26 +886,26 @@ impl ViewportWidget {
             // Grid size controls: [ = decrease, ] = increase
             if i.key_pressed(egui::Key::OpenBracket) {
                 // Cycle down: 2.0 ‚Üí 1.0 ‚Üí 0.5 ‚Üí 0.25 ‚Üí 2.0
-                self.grid_snap_size = match self.grid_snap_size {
+                self.snapping_config.grid_size = match self.snapping_config.grid_size {
                     x if (x - 2.0).abs() < 0.01 => 1.0,
                     x if (x - 1.0).abs() < 0.01 => 0.5,
                     x if (x - 0.5).abs() < 0.01 => 0.25,
                     _ => 2.0,
                 };
-                println!("üìê Grid snap size: {:.2}m", self.grid_snap_size);
-                self.emit_grid_settings_event();
+                self.toolbar.snap_size = self.snapping_config.grid_size;
+                println!("üìê Grid snap size: {:.2}m", self.snapping_config.grid_size);
             }
 
             if i.key_pressed(egui::Key::CloseBracket) {
                 // Cycle up: 0.25 ‚Üí 0.5 ‚Üí 1.0 ‚Üí 2.0 ‚Üí 0.25
-                self.grid_snap_size = match self.grid_snap_size {
+                self.snapping_config.grid_size = match self.snapping_config.grid_size {
                     x if (x - 0.25).abs() < 0.01 => 0.5,
                     x if (x - 0.5).abs() < 0.01 => 1.0,
                     x if (x - 1.0).abs() < 0.01 => 2.0,
                     _ => 0.25,
                 };
-                println!("üìê Grid snap size: {:.2}m", self.grid_snap_size);
-                self.emit_grid_settings_event();
+                self.toolbar.snap_size = self.snapping_config.grid_size;
+                println!("üìê Grid snap size: {:.2}m", self.snapping_config.grid_size);
             }
 
             // Camera bookmarks: F1-F12 (restore), Shift+F1-F12 (save)
@@ -1004,29 +955,53 @@ impl ViewportWidget {
 
         // Handle gizmo confirm/cancel
         if self.gizmo_state.confirmed {
-            if let Some(metadata) = interaction::commit_active_gizmo(
-                &mut self.gizmo_state,
-                scene.world_mut(),
-                undo_stack,
-            ) {
-                scene.sync_entity(metadata.entity);
-                telemetry::record(EditorTelemetryEvent::from(metadata));
+            if let Some(metadata) =
+                interaction::commit_active_gizmo(&mut self.gizmo_state, world, undo_stack)
+            {
+                let span = info_span!(
+                    "aw_editor.gizmo.commit",
+                    entity = metadata.entity,
+                    operation = ?metadata.operation
+                );
+                let _guard = span.enter();
+                match metadata.measurement {
+                    GizmoMeasurement::Translate { from, to } => {
+                        info!(
+                            from_x = from.x,
+                            from_y = from.y,
+                            to_x = to.x,
+                            to_y = to.y,
+                            "Gizmo move committed"
+                        );
+                    }
+                    GizmoMeasurement::Rotate { from, to } => {
+                        info!(
+                            from_x = from.0,
+                            from_y = from.1,
+                            from_z = from.2,
+                            to_x = to.0,
+                            to_y = to.1,
+                            to_z = to.2,
+                            "Gizmo rotation committed"
+                        );
+                    }
+                    GizmoMeasurement::Scale { from, to } => {
+                        info!(from_value = from, to_value = to, "Gizmo scale committed");
+                    }
+                }
             }
             self.gizmo_state.confirmed = false;
         }
 
         if self.gizmo_state.cancelled {
-            if let Some(GizmoCancelMetadata {
-                entity,
-                operation,
-                snapshot,
-            }) = interaction::cancel_active_gizmo(&mut self.gizmo_state, scene.world_mut())
-            {
-                scene.apply_snapshot(entity, &snapshot);
-                telemetry::record(EditorTelemetryEvent::GizmoCancelled {
-                    entity: entity as u32,
-                    operation,
-                });
+            if let Some(metadata) = interaction::cancel_active_gizmo(&mut self.gizmo_state, world) {
+                let span = info_span!(
+                    "aw_editor.gizmo.cancel",
+                    entity = metadata.entity,
+                    operation = ?metadata.operation
+                );
+                let _guard = span.enter();
+                info!("Gizmo transform cancelled");
             }
             self.gizmo_state.cancelled = false;
         }
@@ -1091,7 +1066,7 @@ impl ViewportWidget {
                 for entity_id in 1..100 {
                     let entity: Entity = entity_id;
 
-                    if let Some(pose) = scene.world().pose(entity) {
+                    if let Some(pose) = world.pose(entity) {
                         // Match entity_renderer position calculation
                         let x = pose.pos.x as f32;
                         let z = pose.pos.y as f32;
@@ -1443,7 +1418,6 @@ impl ViewportWidget {
     /// Set the selected entities (replaces current selection)
     pub fn set_selected_entities(&mut self, entities: Vec<Entity>) {
         self.selected_entities = entities;
-        self.emit_selection_event();
     }
 
     /// Set a single selected entity (clears other selections)
@@ -1452,21 +1426,18 @@ impl ViewportWidget {
         if let Some(e) = entity {
             self.selected_entities.push(e);
         }
-        self.emit_selection_event();
     }
 
     /// Add an entity to the selection (for multi-select)
     pub fn add_to_selection(&mut self, entity: Entity) {
         if !self.selected_entities.contains(&entity) {
             self.selected_entities.push(entity);
-            self.emit_selection_event();
         }
     }
 
     /// Remove an entity from the selection
     pub fn remove_from_selection(&mut self, entity: Entity) {
         self.selected_entities.retain(|&e| e != entity);
-        self.emit_selection_event();
     }
 
     /// Get reference to the viewport toolbar
@@ -1480,41 +1451,12 @@ impl ViewportWidget {
             self.remove_from_selection(entity);
         } else {
             self.add_to_selection(entity);
-            // add_to_selection already emits event
-            return;
         }
-        self.emit_selection_event();
     }
 
     /// Clear all selections
     pub fn clear_selection(&mut self) {
         self.selected_entities.clear();
-        self.emit_selection_event();
-    }
-
-    fn emit_selection_event(&self) {
-        telemetry::record(EditorTelemetryEvent::SelectionChanged {
-            primary: self.selected_entity().map(|id| id as u32),
-            count: self.selected_entities.len(),
-        });
-    }
-
-    fn emit_grid_settings_event(&self) {
-        telemetry::record(EditorTelemetryEvent::GridSettingsChanged {
-            grid_enabled: self.toolbar.snap_enabled,
-            snap_size: self.grid_snap_size,
-            angle_enabled: self.toolbar.angle_snap_enabled,
-            angle_increment: self.toolbar.angle_snap_degrees,
-        });
-    }
-
-    fn emit_gizmo_start(&self, operation: GizmoOperationKind) {
-        if let Some(entity) = self.selected_entity() {
-            telemetry::record(EditorTelemetryEvent::GizmoStarted {
-                entity: entity as u32,
-                operation,
-            });
-        }
     }
 
     /// Check if an entity is selected
@@ -1523,7 +1465,7 @@ impl ViewportWidget {
     }
 
     /// Copy selected entities to clipboard
-    fn copy_selection<S: TransformableScene>(&mut self, _scene: &S) {
+    fn copy_selection(&mut self, _world: &World) {
         // TODO: Implement clipboard storage
         // For now, we'll store copied entities in a Vec<EntitySnapshot>
         // This will be expanded in Phase 2.2 with full serialization
@@ -1534,20 +1476,16 @@ impl ViewportWidget {
     }
 
     /// Paste entities from clipboard
-    fn paste_selection<S: TransformableScene>(
-        &mut self,
-        _scene: &mut S,
-        _undo_stack: &mut crate::command::UndoStack,
-    ) {
+    fn paste_selection(&mut self, _world: &mut World, _undo_stack: &mut crate::command::UndoStack) {
         // TODO: Implement paste from clipboard
         // Create new entities with offset position
         println!("üìã Paste: clipboard not yet implemented");
     }
 
     /// Duplicate selected entities (creates copies at offset position)
-    fn duplicate_selection<S: TransformableScene>(
+    fn duplicate_selection(
         &mut self,
-        scene: &mut S,
+        world: &mut World,
         _undo_stack: &mut crate::command::UndoStack,
     ) {
         if self.selected_entities.is_empty() {
@@ -1567,23 +1505,18 @@ impl ViewportWidget {
         for &entity_id in &self.selected_entities {
             println!("  üîç Processing entity {}", entity_id);
 
-            if let Some(pose) = scene.world().pose(entity_id) {
+            if let Some(pose) = world.pose(entity_id) {
                 // Create new entity at offset position (2 units right)
                 let new_pos = astraweave_core::IVec2 {
                     x: pose.pos.x + 2,
                     y: pose.pos.y,
                 };
 
-                // Get original entity's properties and clone what we need so we can
-                // safely mutably borrow later when spawning the duplicate.
-                let health = scene.world().health(entity_id);
-                let team = scene.world().team(entity_id);
-                let ammo = scene.world().ammo(entity_id);
-                let name = scene
-                    .world()
-                    .name(entity_id)
-                    .map(|s| s.to_string())
-                    .unwrap_or_else(|| format!("Entity_{}", entity_id));
+                // Get original entity's properties
+                let health = world.health(entity_id);
+                let team = world.team(entity_id);
+                let ammo = world.ammo(entity_id);
+                let name = world.name(entity_id).unwrap_or("Entity");
 
                 println!(
                     "    üìã Entity {} properties: name={}, team={:?}, health={:?}, ammo={:?}",
@@ -1591,7 +1524,7 @@ impl ViewportWidget {
                 );
 
                 // Create new entity using spawn
-                let new_id = scene.world_mut().spawn(
+                let new_id = world.spawn(
                     &format!("{}_copy", name),
                     new_pos,
                     team.unwrap_or(Team { id: 0 }),
@@ -1600,15 +1533,13 @@ impl ViewportWidget {
                 );
 
                 // Copy transform properties
-                if let Some(new_pose) = scene.world_mut().pose_mut(new_id) {
+                if let Some(new_pose) = world.pose_mut(new_id) {
                     new_pose.rotation = pose.rotation;
                     new_pose.rotation_x = pose.rotation_x;
                     new_pose.rotation_z = pose.rotation_z;
                     new_pose.scale = pose.scale;
                 }
 
-                scene.sync_entity(new_id);
-
                 new_entities.push(new_id);
                 println!(
                     "    ‚úÖ Duplicated entity {} ‚Üí {} at {:?}",
@@ -1626,7 +1557,6 @@ impl ViewportWidget {
                 "üéØ duplicate_selection: Complete. New selection: {:?}",
                 self.selected_entities
             );
-            self.emit_selection_event();
         } else {
             println!("‚ö†Ô∏è  duplicate_selection: No entities were duplicated!");
         }
@@ -1635,9 +1565,9 @@ impl ViewportWidget {
     }
 
     /// Delete selected entities
-    fn delete_selection<S: TransformableScene>(
+    fn delete_selection(
         &mut self,
-        _scene: &mut S,
+        _world: &mut World,
         _undo_stack: &mut crate::command::UndoStack,
     ) {
         if self.selected_entities.is_empty() {
@@ -1664,7 +1594,7 @@ impl ViewportWidget {
     }
 
     /// Select all entities in the world
-    fn select_all<S: TransformableScene>(&mut self, scene: &S) {
+    fn select_all(&mut self, world: &World) {
         self.selected_entities.clear();
 
         println!("üîç select_all: Starting scan for entities...");
@@ -1672,7 +1602,7 @@ impl ViewportWidget {
         // Iterate through all entities (World doesn't expose entity list, so we try a range)
         // This is a workaround - ideally World would have an entities() iterator
         for entity_id in 0..1000 {
-            if scene.world().pose(entity_id).is_some() {
+            if world.pose(entity_id).is_some() {
                 self.selected_entities.push(entity_id);
                 println!("  ‚úÖ Found entity {}", entity_id);
             }
@@ -1683,14 +1613,57 @@ impl ViewportWidget {
             self.selected_entities.len(),
             self.selected_entities
         );
+    }
+
+    /// Project an absolute screen position to the ground plane (Y=0) in world space
+    pub fn world_pos_from_pointer(&self, pointer_pos: egui::Pos2) -> Option<glam::Vec3> {
+        let rect = self.last_viewport_rect?;
+        if !rect.contains(pointer_pos) {
+            return None;
+        }
+        self.project_pointer_to_ground(pointer_pos, rect)
+    }
+
+    /// Last cursor world position cached during hover (if available)
+    pub fn cached_cursor_world(&self) -> Option<glam::Vec3> {
+        self.last_cursor_world
+    }
+
+    fn project_pointer_to_ground(
+        &self,
+        pointer_pos: egui::Pos2,
+        viewport_rect: egui::Rect,
+    ) -> Option<glam::Vec3> {
+        let viewport_size = viewport_rect.size();
+        if viewport_size.x <= 0.0 || viewport_size.y <= 0.0 {
+            return None;
+        }
+
+        // Convert to viewport-relative coordinates before casting a ray
+        let relative_pos = egui::Pos2 {
+            x: pointer_pos.x - viewport_rect.min.x,
+            y: pointer_pos.y - viewport_rect.min.y,
+        };
+
+        let ray = self.camera.ray_from_screen(relative_pos, viewport_size);
+        let plane_normal = glam::Vec3::Y;
+        let denom = ray.direction.dot(plane_normal);
+        if denom.abs() <= 0.0001 {
+            return None;
+        }
+
+        let t = (glam::Vec3::ZERO - ray.origin).dot(plane_normal) / denom;
+        if t < 0.0 {
+            return None;
+        }
 
-        self.emit_selection_event();
+        Some(ray.origin + ray.direction * t)
     }
 
     /// Snap a float value to the grid
     fn snap_to_grid(&self, value: f32) -> f32 {
-        if self.grid_snap_size > 0.0 {
-            (value / self.grid_snap_size).round() * self.grid_snap_size
+        if self.snapping_config.grid_enabled && self.snapping_config.grid_size > 0.0 {
+            (value / self.snapping_config.grid_size).round() * self.snapping_config.grid_size
         } else {
             value
         }
@@ -1698,8 +1671,9 @@ impl ViewportWidget {
 
     /// Snap an angle to the nearest increment
     fn snap_angle(&self, angle: f32) -> f32 {
-        if self.angle_snap_increment > 0.0 {
-            (angle / self.angle_snap_increment).round() * self.angle_snap_increment
+        if self.snapping_config.angle_enabled && self.snapping_config.angle_increment > 0.0 {
+            let increment = self.snapping_config.angle_increment.to_radians();
+            (angle / increment).round() * increment
         } else {
             angle
         }
