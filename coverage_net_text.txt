C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-behavior\src\goap_cache.rs:
    1|       |//! GOAP Plan Cache with LRU eviction
    2|       |//!
    3|       |//! Week 3 Action 9: Reduces complex planning from 31.7ms → <1ms with 90% cache hit rate.
    4|       |//! Uses scenario fingerprinting and state bucketing for high cache efficiency.
    5|       |
    6|       |#[cfg(feature = "profiling")]
    7|       |use astraweave_profiling::span;
    8|       |
    9|       |use crate::goap::{GoapAction, GoapGoal, WorldState};
   10|       |use std::collections::hash_map::DefaultHasher;
   11|       |use std::collections::{HashMap, VecDeque};
   12|       |use std::hash::{Hash, Hasher};
   13|       |
   14|       |/// Cache key for GOAP plans based on scenario fingerprint
   15|       |#[derive(Debug, Clone, PartialEq, Eq, Hash)]
   16|       |pub struct PlanCacheKey {
   17|       |    /// Hash of current world state (bucketed for similar states)
   18|       |    state_hash: u64,
   19|       |    /// Hash of goal desired state
   20|       |    goal_hash: u64,
   21|       |    /// Number of available actions (quick check for action set changes)
   22|       |    action_count: usize,
   23|       |}
   24|       |
   25|       |impl PlanCacheKey {
   26|       |    /// Create cache key with state bucketing for similar scenarios
   27|       |    ///
   28|       |    /// State bucketing groups similar states together to increase cache hits.
   29|       |    /// For example, "health = 95" and "health = 97" may use same cached plan.
   30|       |    pub fn new(
   31|       |        current_state: &WorldState,
   32|       |        goal: &GoapGoal,
   33|       |        available_actions: &[GoapAction],
   34|       |    ) -> Self {
   35|       |        Self {
   36|       |            state_hash: Self::hash_world_state_bucketed(current_state),
   37|       |            goal_hash: Self::hash_world_state(&goal.desired_state),
   38|       |            action_count: available_actions.len(),
   39|       |        }
   40|       |    }
   41|       |
   42|       |    /// Hash world state with exact facts (for goal hashing)
   43|       |    fn hash_world_state(state: &WorldState) -> u64 {
   44|       |        let mut hasher = DefaultHasher::new();
   45|       |        // Iterate in deterministic order (BTreeMap is sorted)
   46|       |        for (key, &value) in &state.facts {
   47|       |            key.hash(&mut hasher);
   48|       |            value.hash(&mut hasher);
   49|       |        }
   50|       |        hasher.finish()
   51|       |    }
   52|       |
   53|       |    /// Hash world state with bucketing for similar states
   54|       |    ///
   55|       |    /// Strategy: Hash both keys and values to ensure correctness.
   56|       |    /// Previously, this only hashed keys ("bucketing"), which led to invalid plans
   57|       |    /// being returned for states with the same variables but different values.
   58|       |    /// Now we enforce exact state matching for cache hits.
   59|       |    fn hash_world_state_bucketed(state: &WorldState) -> u64 {
   60|       |        let mut hasher = DefaultHasher::new();
   61|       |        // Hash both keys and values for exact matching
   62|       |        for (key, value) in &state.facts {
   63|       |            key.hash(&mut hasher);
   64|       |            value.hash(&mut hasher);
   65|       |        }
   66|       |        hasher.finish()
   67|       |    }
   68|       |
   69|       |    /// Create cache key with validation fingerprint
   70|       |    ///
   71|       |    /// Includes action set hash to invalidate cache if actions change.
   72|       |    /// This prevents stale plans when action definitions are modified.
   73|       |    pub fn with_action_validation(
   74|       |        current_state: &WorldState,
   75|       |        goal: &GoapGoal,
   76|       |        available_actions: &[GoapAction],
   77|       |    ) -> (Self, u64) {
   78|       |        let key = Self::new(current_state, goal, available_actions);
   79|       |        let action_hash = Self::hash_action_set(available_actions);
   80|       |        (key, action_hash)
   81|       |    }
   82|       |
   83|       |    /// Hash action set for validation (detects action changes)
   84|       |    fn hash_action_set(actions: &[GoapAction]) -> u64 {
   85|       |        let mut hasher = DefaultHasher::new();
   86|       |        for action in actions {
   87|       |            action.name.hash(&mut hasher);
   88|       |            // Hash cost as u32 for determinism (f32 has precision issues)
   89|       |            (action.cost as u32).hash(&mut hasher);
   90|       |        }
   91|       |        hasher.finish()
   92|       |    }
   93|       |}
   94|       |
   95|       |/// Cached plan entry with metadata
   96|       |#[derive(Debug, Clone)]
   97|       |struct CachedPlan {
   98|       |    /// Cached action sequence (empty vec = "no plan possible")
   99|       |    actions: Vec<GoapAction>,
  100|       |    /// Action set hash when plan was created (for validation)
  101|       |    action_hash: u64,
  102|       |    /// Number of times this plan was used (for stats)
  103|       |    hit_count: usize,
  104|       |}
  105|       |
  106|       |/// LRU cache for GOAP plans
  107|       |pub struct PlanCache {
  108|       |    /// Maximum number of cached plans
  109|       |    max_size: usize,
  110|       |    /// Cache storage (key -> plan)
  111|       |    cache: HashMap<PlanCacheKey, CachedPlan>,
  112|       |    /// LRU queue (keys in access order, oldest first)
  113|       |    lru_queue: VecDeque<PlanCacheKey>,
  114|       |    /// Statistics
  115|       |    stats: CacheStats,
  116|       |}
  117|       |
  118|       |/// Cache performance statistics
  119|       |#[derive(Debug, Clone, Default)]
  120|       |pub struct CacheStats {
  121|       |    pub hits: usize,
  122|       |    pub misses: usize,
  123|       |    pub evictions: usize,
  124|       |    pub invalidations: usize,
  125|       |}
  126|       |
  127|       |impl CacheStats {
  128|       |    /// Calculate cache hit rate (0.0 to 1.0)
  129|       |    pub fn hit_rate(&self) -> f64 {
  130|       |        let total = self.hits + self.misses;
  131|       |        if total == 0 {
  132|       |            0.0
  133|       |        } else {
  134|       |            self.hits as f64 / total as f64
  135|       |        }
  136|       |    }
  137|       |
  138|       |    /// Total cache accesses
  139|       |    pub fn total_accesses(&self) -> usize {
  140|       |        self.hits + self.misses
  141|       |    }
  142|       |}
  143|       |
  144|       |impl PlanCache {
  145|       |    /// Create new plan cache with given capacity
  146|       |    pub fn new(max_size: usize) -> Self {
  147|       |        Self {
  148|       |            max_size,
  149|       |            cache: HashMap::with_capacity(max_size),
  150|       |            lru_queue: VecDeque::with_capacity(max_size),
  151|       |            stats: CacheStats::default(),
  152|       |        }
  153|       |    }
  154|       |
  155|       |    /// Get cached plan if available and valid
  156|       |    ///
  157|       |    /// Returns Some(plan) if cache hit, None if miss or invalidated.
  158|       |    /// Automatically validates action set hash and evicts stale entries.
  159|       |    pub fn get(
  160|       |        &mut self,
  161|       |        current_state: &WorldState,
  162|       |        goal: &GoapGoal,
  163|       |        available_actions: &[GoapAction],
  164|       |    ) -> Option<Vec<GoapAction>> {
  165|       |        #[cfg(feature = "profiling")]
  166|       |        span!("AI::PlanCache::get");
  167|       |
  168|       |        let (key, action_hash) =
  169|       |            PlanCacheKey::with_action_validation(current_state, goal, available_actions);
  170|       |
  171|       |        if let Some(cached) = self.cache.get_mut(&key) {
  172|       |            // Validate action set hasn't changed
  173|       |            if cached.action_hash != action_hash {
  174|       |                // Action set changed - invalidate cache entry
  175|       |                self.cache.remove(&key);
  176|      0|                self.lru_queue.retain(|k| k != &key);
  177|       |                self.stats.invalidations += 1;
  178|       |                self.stats.misses += 1;
  179|       |                return None;
  180|       |            }
  181|       |
  182|       |            // Cache hit!
  183|       |            self.stats.hits += 1;
  184|       |            cached.hit_count += 1;
  185|       |
  186|       |            // Update LRU (move to back)
  187|      0|            self.lru_queue.retain(|k| k != &key);
  188|       |            self.lru_queue.push_back(key);
  189|       |
  190|       |            Some(cached.actions.clone())
  191|       |        } else {
  192|       |            // Cache miss
  193|       |            self.stats.misses += 1;
  194|       |            None
  195|       |        }
  196|       |    }
  197|       |
  198|       |    /// Store plan in cache with LRU eviction
  199|       |    pub fn put(
  200|       |        &mut self,
  201|       |        current_state: &WorldState,
  202|       |        goal: &GoapGoal,
  203|       |        available_actions: &[GoapAction],
  204|       |        plan: Vec<GoapAction>,
  205|       |    ) {
  206|       |        let (key, action_hash) =
  207|       |            PlanCacheKey::with_action_validation(current_state, goal, available_actions);
  208|       |
  209|       |        // Evict oldest entry if at capacity
  210|       |        if self.cache.len() >= self.max_size && !self.cache.contains_key(&key) {
  211|       |            if let Some(oldest_key) = self.lru_queue.pop_front() {
  212|       |                self.cache.remove(&oldest_key);
  213|       |                self.stats.evictions += 1;
  214|       |            }
  215|       |        }
  216|       |
  217|       |        // Store plan
  218|       |        let cached_plan = CachedPlan {
  219|       |            actions: plan,
  220|       |            action_hash,
  221|       |            hit_count: 0,
  222|       |        };
  223|       |
  224|       |        // Update LRU queue
  225|      0|        self.lru_queue.retain(|k| k != &key); // Remove if exists
  226|       |        self.lru_queue.push_back(key.clone());
  227|       |
  228|       |        self.cache.insert(key, cached_plan);
  229|       |    }
  230|       |
  231|       |    /// Clear all cached plans
  232|       |    pub fn clear(&mut self) {
  233|       |        self.cache.clear();
  234|       |        self.lru_queue.clear();
  235|       |        self.stats = CacheStats::default();
  236|       |    }
  237|       |
  238|       |    /// Get cache statistics
  239|       |    pub fn stats(&self) -> &CacheStats {
  240|       |        &self.stats
  241|       |    }
  242|       |
  243|       |    /// Get current cache size
  244|       |    pub fn len(&self) -> usize {
  245|       |        self.cache.len()
  246|       |    }
  247|       |
  248|       |    /// Check if cache is empty
  249|       |    pub fn is_empty(&self) -> bool {
  250|       |        self.cache.is_empty()
  251|       |    }
  252|       |
  253|       |    /// Get cache capacity
  254|       |    pub fn capacity(&self) -> usize {
  255|       |        self.max_size
  256|       |    }
  257|       |}
  258|       |
  259|       |impl Default for PlanCache {
  260|       |    fn default() -> Self {
  261|       |        Self::new(1000) // Default: 1000 cached plans
  262|       |    }
  263|       |}
  264|       |
  265|       |/// Caching GOAP planner that wraps base planner with LRU cache
  266|       |pub struct CachedGoapPlanner {
  267|       |    /// Base planner for cache misses
  268|       |    base_planner: crate::goap::GoapPlanner,
  269|       |    /// Plan cache
  270|       |    cache: PlanCache,
  271|       |}
  272|       |
  273|       |impl CachedGoapPlanner {
  274|       |    /// Create new cached planner with given cache size
  275|       |    pub fn new(cache_size: usize) -> Self {
  276|       |        Self {
  277|       |            base_planner: crate::goap::GoapPlanner::new(),
  278|       |            cache: PlanCache::new(cache_size),
  279|       |        }
  280|       |    }
  281|       |
  282|       |    /// Create with custom base planner
  283|       |    pub fn with_planner(planner: crate::goap::GoapPlanner, cache_size: usize) -> Self {
  284|       |        Self {
  285|       |            base_planner: planner,
  286|       |            cache: PlanCache::new(cache_size),
  287|       |        }
  288|       |    }
  289|       |
  290|       |    /// Plan with caching (tries cache first, falls back to planning)
  291|       |    pub fn plan(
  292|       |        &mut self,
  293|       |        current_state: &WorldState,
  294|       |        goal: &GoapGoal,
  295|       |        available_actions: &[GoapAction],
  296|       |    ) -> Option<Vec<GoapAction>> {
  297|       |        // Try cache first
  298|       |        if let Some(cached_plan) = self.cache.get(current_state, goal, available_actions) {
  299|       |            return Some(cached_plan);
  300|       |        }
  301|       |
  302|       |        // Cache miss - run planner
  303|       |        let plan = self
  304|       |            .base_planner
  305|       |            .plan(current_state, goal, available_actions)?;
  306|       |
  307|       |        // Store in cache for future use
  308|       |        self.cache
  309|       |            .put(current_state, goal, available_actions, plan.clone());
  310|       |
  311|       |        Some(plan)
  312|       |    }
  313|       |
  314|       |    /// Get cache statistics
  315|       |    pub fn cache_stats(&self) -> &CacheStats {
  316|       |        self.cache.stats()
  317|       |    }
  318|       |
  319|       |    /// Clear cache
  320|       |    pub fn clear_cache(&mut self) {
  321|       |        self.cache.clear();
  322|       |    }
  323|       |
  324|       |    /// Get base planner (for direct access)
  325|       |    pub fn base_planner(&self) -> &crate::goap::GoapPlanner {
  326|       |        &self.base_planner
  327|       |    }
  328|       |
  329|       |    /// Get mutable base planner
  330|       |    pub fn base_planner_mut(&mut self) -> &mut crate::goap::GoapPlanner {
  331|       |        &mut self.base_planner
  332|       |    }
  333|       |}
  334|       |
  335|       |impl Default for CachedGoapPlanner {
  336|       |    fn default() -> Self {
  337|       |        Self::new(1000)
  338|       |    }
  339|       |}
  340|       |
  341|       |#[cfg(test)]
  342|       |mod tests {
  343|       |    use super::*;
  344|       |
  345|       |    fn create_test_state() -> WorldState {
  346|       |        WorldState::from_facts(&[
  347|       |            ("has_weapon", true),
  348|       |            ("has_ammo", false),
  349|       |            ("enemy_visible", true),
  350|       |        ])
  351|       |    }
  352|       |
  353|       |    fn create_test_goal() -> GoapGoal {
  354|       |        GoapGoal::new(
  355|       |            "attack_enemy",
  356|       |            WorldState::from_facts(&[("enemy_dead", true)]),
  357|       |        )
  358|       |    }
  359|       |
  360|       |    fn create_test_actions() -> Vec<GoapAction> {
  361|       |        vec![
  362|       |            GoapAction::new("find_ammo")
  363|       |                .with_precondition("has_weapon", true)
  364|       |                .with_effect("has_ammo", true),
  365|       |            GoapAction::new("attack")
  366|       |                .with_precondition("has_weapon", true)
  367|       |                .with_precondition("has_ammo", true)
  368|       |                .with_precondition("enemy_visible", true)
  369|       |                .with_effect("enemy_dead", true),
  370|       |        ]
  371|       |    }
  372|       |
  373|       |    #[test]
  374|       |    fn test_cache_key_creation() {
  375|       |        let state = create_test_state();
  376|       |        let goal = create_test_goal();
  377|       |        let actions = create_test_actions();
  378|       |
  379|       |        let key1 = PlanCacheKey::new(&state, &goal, &actions);
  380|       |        let key2 = PlanCacheKey::new(&state, &goal, &actions);
  381|       |
  382|       |        assert_eq!(key1, key2, "Same inputs should produce same cache key");
  383|       |    }
  384|       |
  385|       |    #[test]
  386|       |    fn test_cache_hit() {
  387|       |        let mut cache = PlanCache::new(10);
  388|       |        let state = create_test_state();
  389|       |        let goal = create_test_goal();
  390|       |        let actions = create_test_actions();
  391|       |
  392|       |        // Store plan
  393|       |        let plan = vec![actions[0].clone(), actions[1].clone()];
  394|       |        cache.put(&state, &goal, &actions, plan.clone());
  395|       |
  396|       |        // Retrieve plan
  397|       |        let cached = cache.get(&state, &goal, &actions);
  398|       |        assert!(cached.is_some(), "Cache should hit for stored plan");
  399|       |        assert_eq!(
  400|       |            cached.unwrap().len(),
  401|       |            2,
  402|       |            "Cached plan should have 2 actions"
  403|       |        );
  404|       |
  405|       |        // Check stats
  406|       |        assert_eq!(cache.stats().hits, 1);
  407|       |        assert_eq!(cache.stats().misses, 0);
  408|       |    }
  409|       |
  410|       |    #[test]
  411|       |    fn test_cache_miss() {
  412|       |        let mut cache = PlanCache::new(10);
  413|       |        let state = create_test_state();
  414|       |        let goal = create_test_goal();
  415|       |        let actions = create_test_actions();
  416|       |
  417|       |        // Try to get non-existent plan
  418|       |        let cached = cache.get(&state, &goal, &actions);
  419|       |        assert!(cached.is_none(), "Cache should miss for non-existent plan");
  420|       |
  421|       |        // Check stats
  422|       |        assert_eq!(cache.stats().hits, 0);
  423|       |        assert_eq!(cache.stats().misses, 1);
  424|       |    }
  425|       |
  426|       |    #[test]
  427|       |    fn test_lru_eviction() {
  428|       |        let mut cache = PlanCache::new(2); // Small cache for testing
  429|       |        let state1 = WorldState::from_facts(&[("a", true)]);
  430|       |        let state2 = WorldState::from_facts(&[("b", true)]);
  431|       |        let state3 = WorldState::from_facts(&[("c", true)]);
  432|       |        let goal = create_test_goal();
  433|       |        let actions = create_test_actions();
  434|       |
  435|       |        // Fill cache
  436|       |        cache.put(&state1, &goal, &actions, vec![]);
  437|       |        cache.put(&state2, &goal, &actions, vec![]);
  438|       |
  439|       |        assert_eq!(cache.len(), 2, "Cache should have 2 entries");
  440|       |
  441|       |        // Add third entry (should evict oldest)
  442|       |        cache.put(&state3, &goal, &actions, vec![]);
  443|       |
  444|       |        assert_eq!(cache.len(), 2, "Cache should still have 2 entries");
  445|       |        assert_eq!(cache.stats().evictions, 1, "Should have 1 eviction");
  446|       |
  447|       |        // state1 should be evicted (oldest)
  448|       |        let cached1 = cache.get(&state1, &goal, &actions);
  449|       |        assert!(cached1.is_none(), "Oldest entry should be evicted");
  450|       |    }
  451|       |
  452|       |    #[test]
  453|       |    fn test_action_invalidation() {
  454|       |        let mut cache = PlanCache::new(10);
  455|       |        let state = create_test_state();
  456|       |        let goal = create_test_goal();
  457|       |        let actions1 = create_test_actions();
  458|       |
  459|       |        // Store plan
  460|       |        cache.put(&state, &goal, &actions1, vec![actions1[0].clone()]);
  461|       |
  462|       |        // Modify action set (different cost)
  463|       |        let mut actions2 = create_test_actions();
  464|       |        actions2[0].cost = 5.0;
  465|       |
  466|       |        // Try to get with modified actions (should invalidate)
  467|       |        let cached = cache.get(&state, &goal, &actions2);
  468|       |        assert!(
  469|       |            cached.is_none(),
  470|       |            "Cache should invalidate when actions change"
  471|       |        );
  472|       |        assert_eq!(cache.stats().invalidations, 1, "Should have 1 invalidation");
  473|       |    }
  474|       |
  475|       |    #[test]
  476|       |    fn test_cached_planner_integration() {
  477|       |        let mut planner = CachedGoapPlanner::new(10);
  478|       |        let state = create_test_state();
  479|       |        let goal = create_test_goal();
  480|       |        let actions = create_test_actions();
  481|       |
  482|       |        // First call (cache miss, will plan)
  483|       |        let plan1 = planner.plan(&state, &goal, &actions);
  484|       |        assert!(plan1.is_some(), "Planner should find plan");
  485|       |        assert_eq!(planner.cache_stats().misses, 1);
  486|       |        assert_eq!(planner.cache_stats().hits, 0);
  487|       |
  488|       |        // Second call (cache hit)
  489|       |        let plan2 = planner.plan(&state, &goal, &actions);
  490|       |        assert!(plan2.is_some(), "Cached planner should return plan");
  491|       |        assert_eq!(planner.cache_stats().hits, 1);
  492|       |        assert_eq!(planner.cache_stats().misses, 1);
  493|       |
  494|       |        // Plans should be identical
  495|       |        assert_eq!(plan1.unwrap().len(), plan2.unwrap().len());
  496|       |    }
  497|       |
  498|       |    #[test]
  499|       |    fn test_cache_hit_rate() {
  500|       |        let stats = CacheStats {
  501|       |            hits: 90,
  502|       |            misses: 10,
  503|       |            evictions: 0,
  504|       |            invalidations: 0,
  505|       |        };
  506|       |
  507|       |        assert_eq!(stats.hit_rate(), 0.9, "Hit rate should be 90%");
  508|       |        assert_eq!(stats.total_accesses(), 100);
  509|       |    }
  510|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-core\src\capture_replay.rs:
    1|       |// ECS/AI/Physics State Capture & Replay (Phase 0 minimal)
    2|       |// JSON snapshot of World and tick for smoke tests and determinism checks.
    3|       |
    4|       |use crate::{sim::step, World};
    5|       |use anyhow::{Context, Result};
    6|       |
    7|       |#[derive(serde::Serialize, serde::Deserialize)]
    8|       |struct Snapshot {
    9|       |    tick: u64,
   10|       |    world: WorldSerde,
   11|       |}
   12|       |
   13|       |// We can't serialize World directly due to HashMaps with non-serializable keys;
   14|       |// provide a stable serde wrapper. For Phase 0, we capture only fields we need
   15|       |// to rehydrate a minimal world state deterministically.
   16|       |#[derive(serde::Serialize, serde::Deserialize, Default)]
   17|       |struct WorldSerde {
   18|       |    t: f32,
   19|       |    next_id: u32,
   20|       |    obstacles: Vec<(i32, i32)>,
   21|       |}
   22|       |
   23|       |impl From<&World> for WorldSerde {
   24|      0|    fn from(w: &World) -> Self {
   25|      0|        let mut obstacles: Vec<(i32, i32)> = w.obstacles.iter().copied().collect();
   26|      0|        obstacles.sort_unstable();
   27|      0|        WorldSerde {
   28|      0|            t: w.t,
   29|      0|            next_id: w.next_id,
   30|      0|            obstacles,
   31|      0|        }
   32|      0|    }
   33|       |}
   34|       |
   35|       |impl World {
   36|      0|    fn from_serde(ws: &WorldSerde) -> Self {
   37|      0|        let mut w = World::new();
   38|      0|        w.t = ws.t;
   39|      0|        w.next_id = ws.next_id;
   40|      0|        w.obstacles = ws.obstacles.iter().copied().collect();
   41|      0|        w
   42|      0|    }
   43|       |}
   44|       |
   45|      0|pub fn capture_state(tick: u64, path: &str, world: &World) -> Result<()> {
   46|      0|    let snap = Snapshot {
   47|      0|        tick,
   48|      0|        world: WorldSerde::from(world),
   49|      0|    };
   50|      0|    let data = serde_json::to_vec_pretty(&snap).context("serializing snapshot")?;
   51|      0|    std::fs::write(path, data).context(format!("writing snapshot to {}", path))?;
   52|      0|    Ok(())
   53|      0|}
   54|       |
   55|      0|pub fn replay_state(path: &str, steps: u32, cfg: &crate::SimConfig) -> anyhow::Result<World> {
   56|      0|    let data = std::fs::read(path).context(format!("failed to read snapshot file: {}", path))?;
   57|      0|    let snap: Snapshot =
   58|      0|        serde_json::from_slice(&data).context("failed to deserialize snapshot JSON")?;
   59|      0|    let mut w = World::from_serde(&snap.world);
   60|      0|    for _ in 0..steps {
   61|      0|        step(&mut w, cfg);
   62|      0|    }
   63|      0|    Ok(w)
   64|      0|}
   65|       |
   66|       |#[cfg(test)]
   67|       |mod tests {
   68|       |    use super::*;
   69|       |    use crate::{IVec2, SimConfig, Team};
   70|       |    use std::fs;
   71|       |
   72|       |    #[test]
   73|       |    fn test_world_serde_default() {
   74|       |        let ws = WorldSerde::default();
   75|       |        assert_eq!(ws.t, 0.0);
   76|       |        assert_eq!(ws.next_id, 0);
   77|       |        assert!(ws.obstacles.is_empty());
   78|       |    }
   79|       |
   80|       |    #[test]
   81|       |    fn test_world_serde_from_world_empty() {
   82|       |        let w = World::new();
   83|       |        let ws = WorldSerde::from(&w);
   84|       |
   85|       |        assert_eq!(ws.t, 0.0);
   86|       |        assert_eq!(ws.next_id, 1);
   87|       |        assert!(ws.obstacles.is_empty());
   88|       |    }
   89|       |
   90|       |    #[test]
   91|       |    fn test_world_serde_from_world_with_obstacles() {
   92|       |        let mut w = World::new();
   93|       |        w.obstacles.insert((5, 10));
   94|       |        w.obstacles.insert((0, 0));
   95|       |        w.obstacles.insert((15, 20));
   96|       |        w.t = 1.5;
   97|       |        w.next_id = 42;
   98|       |
   99|       |        let ws = WorldSerde::from(&w);
  100|       |
  101|       |        assert_eq!(ws.t, 1.5);
  102|       |        assert_eq!(ws.next_id, 42);
  103|       |        assert_eq!(ws.obstacles.len(), 3);
  104|       |        // Obstacles should be sorted
  105|       |        assert!(ws.obstacles.contains(&(0, 0)));
  106|       |        assert!(ws.obstacles.contains(&(5, 10)));
  107|       |        assert!(ws.obstacles.contains(&(15, 20)));
  108|       |    }
  109|       |
  110|       |    #[test]
  111|       |    fn test_world_serde_obstacles_sorted() {
  112|       |        let mut w = World::new();
  113|       |        w.obstacles.insert((10, 10));
  114|       |        w.obstacles.insert((5, 5));
  115|       |        w.obstacles.insert((15, 15));
  116|       |
  117|       |        let ws = WorldSerde::from(&w);
  118|       |
  119|       |        // Check that obstacles are sorted (stable serialization)
  120|       |        let mut prev = ws.obstacles[0];
  121|       |        for &obs in ws.obstacles.iter().skip(1) {
  122|       |            assert!(obs >= prev, "Obstacles should be sorted");
  123|       |            prev = obs;
  124|       |        }
  125|       |    }
  126|       |
  127|       |    #[test]
  128|       |    fn test_world_from_serde_empty() {
  129|       |        let ws = WorldSerde::default();
  130|       |        let w = World::from_serde(&ws);
  131|       |
  132|       |        assert_eq!(w.t, 0.0);
  133|       |        assert_eq!(w.next_id, 0);
  134|       |        assert!(w.obstacles.is_empty());
  135|       |    }
  136|       |
  137|       |    #[test]
  138|       |    fn test_world_from_serde_with_data() {
  139|       |        let ws = WorldSerde {
  140|       |            t: 2.5,
  141|       |            next_id: 100,
  142|       |            obstacles: vec![(0, 0), (5, 5), (10, 10)],
  143|       |        };
  144|       |
  145|       |        let w = World::from_serde(&ws);
  146|       |
  147|       |        assert_eq!(w.t, 2.5);
  148|       |        assert_eq!(w.next_id, 100);
  149|       |        assert_eq!(w.obstacles.len(), 3);
  150|       |        assert!(w.obstacles.contains(&(0, 0)));
  151|       |        assert!(w.obstacles.contains(&(5, 5)));
  152|       |        assert!(w.obstacles.contains(&(10, 10)));
  153|       |    }
  154|       |
  155|       |    #[test]
  156|       |    fn test_world_serde_roundtrip() {
  157|       |        let mut w1 = World::new();
  158|       |        w1.t = 3.14;
  159|       |        w1.next_id = 999;
  160|       |        w1.obstacles.insert((1, 2));
  161|       |        w1.obstacles.insert((3, 4));
  162|       |
  163|       |        let ws = WorldSerde::from(&w1);
  164|       |        let w2 = World::from_serde(&ws);
  165|       |
  166|       |        assert_eq!(w2.t, w1.t);
  167|       |        assert_eq!(w2.next_id, w1.next_id);
  168|       |        assert_eq!(w2.obstacles, w1.obstacles);
  169|       |    }
  170|       |
  171|       |    #[test]
  172|       |    fn test_snapshot_serialization() {
  173|       |        let snap = Snapshot {
  174|       |            tick: 42,
  175|       |            world: WorldSerde {
  176|       |                t: 1.5,
  177|       |                next_id: 10,
  178|       |                obstacles: vec![(0, 0), (5, 5)],
  179|       |            },
  180|       |        };
  181|       |
  182|       |        let json = serde_json::to_vec_pretty(&snap).unwrap();
  183|       |        let deserialized: Snapshot = serde_json::from_slice(&json).unwrap();
  184|       |
  185|       |        assert_eq!(deserialized.tick, 42);
  186|       |        assert_eq!(deserialized.world.t, 1.5);
  187|       |        assert_eq!(deserialized.world.next_id, 10);
  188|       |        assert_eq!(deserialized.world.obstacles.len(), 2);
  189|       |    }
  190|       |
  191|       |    #[test]
  192|       |    fn test_capture_state_creates_file() {
  193|       |        let temp_path = "test_capture_state.json";
  194|       |        let mut w = World::new();
  195|       |        w.t = 5.0;
  196|       |        w.next_id = 50;
  197|       |        w.obstacles.insert((10, 20));
  198|       |
  199|       |        let result = capture_state(100, temp_path, &w);
  200|       |        assert!(result.is_ok(), "capture_state should succeed");
  201|       |
  202|       |        // Verify file was created
  203|       |        assert!(fs::metadata(temp_path).is_ok(), "File should exist");
  204|       |
  205|       |        // Cleanup
  206|       |        let _ = fs::remove_file(temp_path);
  207|       |    }
  208|       |
  209|       |    #[test]
  210|       |    fn test_capture_state_file_content() {
  211|       |        let temp_path = "test_capture_content.json";
  212|       |        let mut w = World::new();
  213|       |        w.t = 7.5;
  214|       |        w.next_id = 75;
  215|       |        w.obstacles.insert((1, 2));
  216|       |
  217|       |        capture_state(200, temp_path, &w).unwrap();
  218|       |
  219|       |        // Read and verify content
  220|       |        let data = fs::read(temp_path).unwrap();
  221|       |        let snap: Snapshot = serde_json::from_slice(&data).unwrap();
  222|       |
  223|       |        assert_eq!(snap.tick, 200);
  224|       |        assert_eq!(snap.world.t, 7.5);
  225|       |        assert_eq!(snap.world.next_id, 75);
  226|       |        assert_eq!(snap.world.obstacles.len(), 1);
  227|       |
  228|       |        // Cleanup
  229|       |        let _ = fs::remove_file(temp_path);
  230|       |    }
  231|       |
  232|       |    #[test]
  233|       |    fn test_capture_state_overwrites_existing() {
  234|       |        let temp_path = "test_capture_overwrite.json";
  235|       |
  236|       |        // First capture
  237|       |        let mut w1 = World::new();
  238|       |        w1.t = 1.0;
  239|       |        capture_state(1, temp_path, &w1).unwrap();
  240|       |
  241|       |        // Second capture (should overwrite)
  242|       |        let mut w2 = World::new();
  243|       |        w2.t = 2.0;
  244|       |        capture_state(2, temp_path, &w2).unwrap();
  245|       |
  246|       |        // Verify only second capture exists
  247|       |        let data = fs::read(temp_path).unwrap();
  248|       |        let snap: Snapshot = serde_json::from_slice(&data).unwrap();
  249|       |        assert_eq!(snap.tick, 2);
  250|       |        assert_eq!(snap.world.t, 2.0);
  251|       |
  252|       |        // Cleanup
  253|       |        let _ = fs::remove_file(temp_path);
  254|       |    }
  255|       |
  256|       |    #[test]
  257|       |    fn test_replay_state_loads_file() {
  258|       |        let temp_path = "test_replay_load.json";
  259|       |        let mut w = World::new();
  260|       |        w.t = 3.0;
  261|       |        w.next_id = 30;
  262|       |        w.obstacles.insert((5, 5));
  263|       |
  264|       |        capture_state(50, temp_path, &w).unwrap();
  265|       |
  266|       |        let cfg = SimConfig { dt: 0.1 };
  267|       |        let result = replay_state(temp_path, 0, &cfg);
  268|       |
  269|       |        assert!(result.is_ok(), "replay_state should succeed");
  270|       |        let loaded = result.unwrap();
  271|       |        assert_eq!(loaded.t, 3.0);
  272|       |        assert_eq!(loaded.next_id, 30);
  273|       |        assert!(loaded.obstacles.contains(&(5, 5)));
  274|       |
  275|       |        // Cleanup
  276|       |        let _ = fs::remove_file(temp_path);
  277|       |    }
  278|       |
  279|       |    #[test]
  280|       |    fn test_replay_state_with_steps() {
  281|       |        let temp_path = "test_replay_steps.json";
  282|       |        let mut w = World::new();
  283|       |        w.t = 0.0;
  284|       |        w.obstacles.insert((0, 0));
  285|       |
  286|       |        capture_state(0, temp_path, &w).unwrap();
  287|       |
  288|       |        let cfg = SimConfig { dt: 0.5 };
  289|       |        let replayed = replay_state(temp_path, 5, &cfg).unwrap();
  290|       |
  291|       |        // After 5 steps with dt=0.5, time should be 2.5
  292|       |        assert!((replayed.t - 2.5).abs() < 1e-6);
  293|       |
  294|       |        // Cleanup
  295|       |        let _ = fs::remove_file(temp_path);
  296|       |    }
  297|       |
  298|       |    #[test]
  299|       |    fn test_replay_state_zero_steps() {
  300|       |        let temp_path = "test_replay_zero.json";
  301|       |        let mut w = World::new();
  302|       |        w.t = 10.0;
  303|       |
  304|       |        capture_state(0, temp_path, &w).unwrap();
  305|       |
  306|       |        let cfg = SimConfig { dt: 0.1 };
  307|       |        let replayed = replay_state(temp_path, 0, &cfg).unwrap();
  308|       |
  309|       |        // Time should remain unchanged with 0 steps
  310|       |        assert_eq!(replayed.t, 10.0);
  311|       |
  312|       |        // Cleanup
  313|       |        let _ = fs::remove_file(temp_path);
  314|       |    }
  315|       |
  316|       |    #[test]
  317|       |    fn test_replay_state_nonexistent_file() {
  318|       |        let cfg = SimConfig { dt: 0.1 };
  319|       |        let result = replay_state("nonexistent_file_12345.json", 0, &cfg);
  320|       |
  321|       |        assert!(result.is_err(), "Should fail on nonexistent file");
  322|       |    }
  323|       |
  324|       |    #[test]
  325|       |    fn test_replay_state_invalid_json() {
  326|       |        let temp_path = "test_replay_invalid.json";
  327|       |        fs::write(temp_path, b"{ invalid json ").unwrap();
  328|       |
  329|       |        let cfg = SimConfig { dt: 0.1 };
  330|       |        let result = replay_state(temp_path, 0, &cfg);
  331|       |
  332|       |        assert!(result.is_err(), "Should fail on invalid JSON");
  333|       |
  334|       |        // Cleanup
  335|       |        let _ = fs::remove_file(temp_path);
  336|       |    }
  337|       |
  338|       |    #[test]
  339|       |    fn test_replay_state_wrong_structure() {
  340|       |        let temp_path = "test_replay_wrong.json";
  341|       |        fs::write(temp_path, br#"{"tick": 1}"#).unwrap();
  342|       |
  343|       |        let cfg = SimConfig { dt: 0.1 };
  344|       |        let result = replay_state(temp_path, 0, &cfg);
  345|       |
  346|       |        assert!(result.is_err(), "Should fail on wrong JSON structure");
  347|       |
  348|       |        // Cleanup
  349|       |        let _ = fs::remove_file(temp_path);
  350|       |    }
  351|       |
  352|       |    #[test]
  353|       |    fn test_capture_replay_roundtrip_with_entities() {
  354|       |        let temp_path = "test_roundtrip_entities.json";
  355|       |
  356|       |        // Create world with entities
  357|       |        let mut w1 = World::new();
  358|       |        w1.spawn("player", IVec2 { x: 0, y: 0 }, Team { id: 0 }, 100, 30);
  359|       |        w1.spawn("enemy", IVec2 { x: 10, y: 10 }, Team { id: 2 }, 50, 15);
  360|       |        w1.obstacles.insert((5, 5));
  361|       |        w1.obstacles.insert((15, 15));
  362|       |        let original_time = w1.t;
  363|       |        let original_next_id = w1.next_id;
  364|       |
  365|       |        // Capture
  366|       |        capture_state(42, temp_path, &w1).unwrap();
  367|       |
  368|       |        // Replay with steps
  369|       |        let cfg = SimConfig { dt: 0.2 };
  370|       |        let w2 = replay_state(temp_path, 10, &cfg).unwrap();
  371|       |
  372|       |        // Verify time advanced
  373|       |        assert!((w2.t - (original_time + 2.0)).abs() < 1e-6); // 10 steps * 0.2 dt
  374|       |
  375|       |        // Verify next_id preserved (entities not re-spawned)
  376|       |        assert_eq!(w2.next_id, original_next_id);
  377|       |
  378|       |        // Verify obstacles preserved
  379|       |        assert_eq!(w2.obstacles.len(), 2);
  380|       |        assert!(w2.obstacles.contains(&(5, 5)));
  381|       |        assert!(w2.obstacles.contains(&(15, 15)));
  382|       |
  383|       |        // Cleanup
  384|       |        let _ = fs::remove_file(temp_path);
  385|       |    }
  386|       |
  387|       |    #[test]
  388|       |    fn test_determinism_verification() {
  389|       |        let temp_path = "test_determinism.json";
  390|       |
  391|       |        // Create initial state
  392|       |        let mut w = World::new();
  393|       |        w.spawn("agent", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 80, 20);
  394|       |        w.obstacles.insert((3, 3));
  395|       |
  396|       |        capture_state(0, temp_path, &w).unwrap();
  397|       |
  398|       |        // Replay twice with same config
  399|       |        let cfg = SimConfig { dt: 0.1 };
  400|       |        let w1 = replay_state(temp_path, 50, &cfg).unwrap();
  401|       |        let w2 = replay_state(temp_path, 50, &cfg).unwrap();
  402|       |
  403|       |        // Results should be identical (determinism)
  404|       |        assert_eq!(w1.t, w2.t);
  405|       |        assert_eq!(w1.next_id, w2.next_id);
  406|       |        assert_eq!(w1.obstacles, w2.obstacles);
  407|       |
  408|       |        // Cleanup
  409|       |        let _ = fs::remove_file(temp_path);
  410|       |    }
  411|       |
  412|       |    #[test]
  413|       |    fn test_capture_state_with_empty_world() {
  414|       |        let temp_path = "test_empty_world.json";
  415|       |        let w = World::new();
  416|       |
  417|       |        let result = capture_state(0, temp_path, &w);
  418|       |        assert!(result.is_ok());
  419|       |
  420|       |        // Verify we can replay it
  421|       |        let cfg = SimConfig { dt: 0.1 };
  422|       |        let replayed = replay_state(temp_path, 0, &cfg).unwrap();
  423|       |        assert_eq!(replayed.t, 0.0);
  424|       |
  425|       |        // Cleanup
  426|       |        let _ = fs::remove_file(temp_path);
  427|       |    }
  428|       |
  429|       |    #[test]
  430|       |    fn test_capture_state_with_many_obstacles() {
  431|       |        let temp_path = "test_many_obstacles.json";
  432|       |        let mut w = World::new();
  433|       |
  434|       |        // Add 100 obstacles
  435|       |        for i in 0..100 {
  436|       |            w.obstacles.insert((i, i * 2));
  437|       |        }
  438|       |
  439|       |        capture_state(999, temp_path, &w).unwrap();
  440|       |
  441|       |        let cfg = SimConfig { dt: 0.1 };
  442|       |        let replayed = replay_state(temp_path, 0, &cfg).unwrap();
  443|       |
  444|       |        assert_eq!(replayed.obstacles.len(), 100);
  445|       |        assert!(replayed.obstacles.contains(&(50, 100)));
  446|       |
  447|       |        // Cleanup
  448|       |        let _ = fs::remove_file(temp_path);
  449|       |    }
  450|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-core\src\ecs_adapter.rs:
    1|       |//! ECS adapter: integrate a minimal ECS app/schedule while bridging existing World.
    2|       |use astraweave_ecs as ecs;
    3|       |
    4|       |use crate::ecs_bridge::EntityBridge;
    5|       |use crate::ecs_events::{Events, MovedEvent};
    6|       |use crate::{CAmmo, CCooldowns, CDesiredPos, CHealth, CPos, CTeam, IVec2, World};
    7|       |
    8|       |#[derive(Clone, Copy)]
    9|       |struct Dt(pub f32);
   10|       |
   11|       |fn sim_cooldowns(world_compat: &mut World, dt: f32) {
   12|       |    world_compat.tick(dt);
   13|       |}
   14|       |
   15|       |fn sys_sim(world: &mut ecs::World) {
   16|       |    let dt = world.get_resource::<Dt>().map(|d| d.0).unwrap_or(0.016);
   17|       |    if let Some(w) = world.get_resource_mut::<World>() {
   18|       |        sim_cooldowns(w, dt);
   19|       |    }
   20|       |    // Phase 1: mirror basic cooldown decay into ECS components if present
   21|       |    world.each_mut::<CCooldowns>(|_, cds| {
   22|       |        for v in cds.map.values_mut() {
   23|       |            *v = (*v - dt).max(0.0);
   24|       |        }
   25|       |    });
   26|       |}
   27|       |
   28|       |fn sys_move(world: &mut ecs::World) {
   29|       |    // Move entities one step toward desired pos (cardinal-only 4-neighborhood) per tick
   30|       |    // Deterministic order by BTreeMap underlying storage
   31|       |    // Note: no collision here—Phase 1 minimal behavior
   32|       |    // Read positions and desired goals, mutate positions
   33|       |    // We purposely run after sim (cooldowns)
   34|       |    use std::collections::BTreeMap;
   35|       |    let goals: BTreeMap<ecs::Entity, CDesiredPos> = {
   36|       |        let mut m = BTreeMap::new();
   37|       |        let q = ecs::Query::<CDesiredPos>::new(&*world);
   38|       |        for (e, g) in q {
   39|       |            m.insert(e, *g);
   40|       |        }
   41|       |        m
   42|       |    };
   43|       |    let mut moved: Vec<(ecs::Entity, IVec2, IVec2)> = vec![];
   44|       |    world.each_mut::<CPos>(|e, p| {
   45|       |        if let Some(goal) = goals.get(&e) {
   46|       |            let dx = (goal.pos.x - p.pos.x).signum();
   47|       |            let mut dy = (goal.pos.y - p.pos.y).signum();
   48|       |            // Cardinal-only behavior: prefer moving along X this tick; if we move in X,
   49|       |            // do not also move in Y (prevents diagonal movement).
   50|       |            if dx != 0 {
   51|       |                dy = 0;
   52|       |            }
   53|       |            if dx != 0 || dy != 0 {
   54|       |                let from = IVec2 {
   55|       |                    x: p.pos.x,
   56|       |                    y: p.pos.y,
   57|       |                };
   58|       |                if dx != 0 {
   59|       |                    p.pos.x += dx;
   60|       |                } else if dy != 0 {
   61|       |                    p.pos.y += dy;
   62|       |                }
   63|       |                moved.push((
   64|       |                    e,
   65|       |                    from,
   66|       |                    IVec2 {
   67|       |                        x: p.pos.x,
   68|       |                        y: p.pos.y,
   69|       |                    },
   70|       |                ));
   71|       |            }
   72|       |        }
   73|       |    });
   74|       |    if let Some(ev) = world.get_resource_mut::<Events<MovedEvent>>() {
   75|       |        let mut w = ev.writer();
   76|       |        for (e, from, to) in moved {
   77|       |            w.send(MovedEvent {
   78|       |                entity: e,
   79|       |                from,
   80|       |                to,
   81|       |            });
   82|       |        }
   83|       |    }
   84|       |}
   85|       |
   86|       |fn sys_refresh_los(world: &mut ecs::World) {
   87|       |    // Example LOS cache refresh placeholder: for now, no persistent cache type.
   88|       |    // In Phase 1 we show how to call helpers; a later step would store a cache component/resource.
   89|       |    // Using obstacles from legacy world if present
   90|       |    if let Some(w) = world.get_resource::<World>() {
   91|       |        let _ = &w.obstacles; // no-op to show access; real cache omitted for minimal footprint
   92|       |    }
   93|       |}
   94|       |
   95|       |fn sys_bridge_sync(world: &mut ecs::World) {
   96|       |    // Ensure any mapped ECS entities carry a CLegacyId component and
   97|       |    // remove CLegacyId from entities not present in the bridge.
   98|       |    use std::collections::BTreeSet;
   99|       |
  100|       |    // Collect all ecs entities referenced by the bridge
  101|       |    let mut referenced = BTreeSet::new();
  102|       |    if let Some(bridge) = world.get_resource::<EntityBridge>() {
  103|       |        for ecs_e in bridge.ecs_entities() {
  104|       |            referenced.insert(ecs_e);
  105|       |        }
  106|       |    }
  107|       |
  108|       |    // Add CLegacyId to referenced entities if missing
  109|       |    for &e in referenced.iter() {
  110|       |        if world.get::<crate::CLegacyId>(e).is_none() {
  111|       |            if let Some(bridge) = world.get_resource::<EntityBridge>() {
  112|       |                if let Some(legacy) = bridge.get_by_ecs(&e) {
  113|       |                    world.insert(e, crate::CLegacyId { id: legacy });
  114|       |                }
  115|       |            }
  116|       |        }
  117|       |    }
  118|       |
  119|       |    // Note: Phase 1 `astraweave_ecs::World` does not provide a component removal
  120|       |    // API. Removing CLegacyId entries would require extending the ECS. For now
  121|       |    // we only ensure referenced entities have the CLegacyId component. Stale
  122|       |    // CLegacyId components (if any) will remain until a future ECS API adds
  123|       |    // removal support.
  124|       |}
  125|       |
  126|       |fn sys_sync_to_legacy(world: &mut ecs::World) {
  127|       |    // Sync ECS state back to legacy World resource
  128|       |    // This allows legacy systems (like build_snapshot) to see ECS updates
  129|       |    let mut updates = Vec::new();
  130|       |
  131|       |    // Iterate all entities with CLegacyId
  132|       |    let q = ecs::Query::<crate::CLegacyId>::new(&*world);
  133|       |    for (e, legacy_id) in q {
  134|       |        let pos = world.get::<CPos>(e).map(|p| p.pos);
  135|       |        let hp = world.get::<CHealth>(e).map(|h| h.hp);
  136|       |        let ammo = world.get::<CAmmo>(e).map(|a| a.rounds);
  137|       |
  138|       |        updates.push((legacy_id.id, pos, hp, ammo));
  139|       |    }
  140|       |
  141|       |    if let Some(w) = world.get_resource_mut::<World>() {
  142|       |        for (id, pos, hp, ammo) in updates {
  143|       |            if let Some(p) = pos {
  144|       |                if let Some(pose) = w.pose_mut(id) {
  145|       |                    pose.pos = p;
  146|       |                }
  147|       |            }
  148|       |            if let Some(h) = hp {
  149|       |                if let Some(health) = w.health_mut(id) {
  150|       |                    health.hp = h;
  151|       |                }
  152|       |            }
  153|       |            if let Some(a) = ammo {
  154|       |                if let Some(am) = w.ammo_mut(id) {
  155|       |                    am.rounds = a;
  156|       |                }
  157|       |            }
  158|       |        }
  159|       |    }
  160|       |}
  161|       |
  162|       |// EntityBridge is defined in `crate::ecs_bridge` for cross-crate access.
  163|       |
  164|       |/// Build a minimal ECS app with stages and a single simulation system that
  165|       |/// bridges into the legacy `World` struct for Phase 1.
  166|       |pub fn build_app(legacy_world: World, dt: f32) -> ecs::App {
  167|       |    let mut app = ecs::App::new();
  168|       |    // Insert base resources first
  169|       |    app.world.insert_resource(Dt(dt));
  170|       |    app.world.insert_resource(Events::<MovedEvent>::default());
  171|       |    app.world.insert_resource(EntityBridge::default());
  172|       |
  173|       |    // Auto-populate ECS entities and the entity bridge from the provided legacy World
  174|       |    // using the owned `legacy_world` to avoid borrowing app.world while also mutating it.
  175|       |    for legacy in legacy_world.entities() {
  176|       |        let e = app.world.spawn();
  177|       |        // Mirror pose if present
  178|       |        if let Some(p) = legacy_world.pose(legacy) {
  179|       |            app.world.insert(
  180|       |                e,
  181|       |                CPos {
  182|       |                    pos: IVec2 {
  183|       |                        x: p.pos.x,
  184|       |                        y: p.pos.y,
  185|       |                    },
  186|       |                },
  187|       |            );
  188|       |        }
  189|       |        if let Some(h) = legacy_world.health(legacy) {
  190|       |            app.world.insert(e, CHealth { hp: h.hp });
  191|       |        }
  192|       |        if let Some(t) = legacy_world.team(legacy) {
  193|       |            app.world.insert(e, CTeam { id: t.id });
  194|       |        }
  195|       |        if let Some(a) = legacy_world.ammo(legacy) {
  196|       |            app.world.insert(e, CAmmo { rounds: a.rounds });
  197|       |        }
  198|       |        if let Some(cds) = legacy_world.cooldowns(legacy) {
  199|       |            // convert HashMap<String,f32> -> BTreeMap<CooldownKey,f32> for CCooldowns
  200|       |            let map: crate::cooldowns::Map = cds
  201|       |                .map
  202|       |                .iter()
  203|      0|                .map(|(k, v)| (crate::cooldowns::CooldownKey::from(k.as_str()), *v))
  204|       |                .collect();
  205|       |            app.world.insert(e, CCooldowns { map });
  206|       |        }
  207|       |        // populate bridge
  208|       |        if let Some(bridge) = app.world.get_resource_mut::<EntityBridge>() {
  209|       |            bridge.insert_pair(legacy, e);
  210|       |        }
  211|       |    }
  212|       |
  213|       |    // Now insert the legacy world as a resource so systems can access it.
  214|       |    app.world.insert_resource::<World>(legacy_world);
  215|       |    app.add_system("simulation", sys_sim as ecs::SystemFn);
  216|       |    app.add_system("simulation", sys_move as ecs::SystemFn);
  217|       |    // Bridge sync runs after simulation so mappings are reflected into components
  218|       |    app.add_system("sync", sys_bridge_sync as ecs::SystemFn);
  219|       |    // Sync back to legacy world so legacy systems see updates
  220|       |    app.add_system("sync", sys_sync_to_legacy as ecs::SystemFn);
  221|       |    // AI planning system is registered from astraweave-ai crate to avoid a dependency cycle.
  222|       |    app.add_system("perception", sys_refresh_los as ecs::SystemFn);
  223|       |    app
  224|       |}
  225|       |
  226|       |#[cfg(test)]
  227|       |mod tests {
  228|       |    use super::*;
  229|       |    use crate::IVec2;
  230|       |    #[test]
  231|       |    fn ecs_drives_legacy_world_tick() {
  232|       |        let mut w = World::new();
  233|       |        let _e = w.spawn("ally", IVec2 { x: 0, y: 0 }, crate::Team { id: 1 }, 100, 5);
  234|       |        let app = build_app(w, 0.010).run_fixed(5);
  235|       |        let w2 = app.world.get_resource::<World>().unwrap();
  236|       |        assert!((w2.t - 0.050).abs() < 1e-6);
  237|       |    }
  238|       |
  239|       |    #[test]
  240|       |    fn ecs_components_update_cooldowns() {
  241|       |        let w = World::new();
  242|       |        let mut app = build_app(w, 0.020);
  243|       |        // Insert an entity with cooldowns component
  244|       |        let e = app.world.spawn();
  245|       |        app.world.insert(
  246|       |            e,
  247|       |            CCooldowns {
  248|       |                map: std::collections::BTreeMap::from([(
  249|       |                    crate::cooldowns::CooldownKey::from("throw:smoke"),
  250|       |                    0.05,
  251|       |                )]),
  252|       |            },
  253|       |        );
  254|       |        // Run 2 ticks => cd should reduce to ~0.01
  255|       |        app = app.run_fixed(2);
  256|       |        let mut val = 0.0;
  257|       |        app.world.each_mut::<CCooldowns>(|_, cds| {
  258|       |            val = *cds
  259|       |                .map
  260|       |                .get(&crate::cooldowns::CooldownKey::from("throw:smoke"))
  261|       |                .unwrap();
  262|       |        });
  263|       |        assert!(val <= 0.02 && val >= 0.009);
  264|       |    }
  265|       |
  266|       |    #[test]
  267|       |    fn simple_movement_toward_goal() {
  268|       |        let w = World::new();
  269|       |        let mut app = build_app(w, 0.016);
  270|       |        let e = app.world.spawn();
  271|       |        // For Phase 1 tests we demonstrate populating the entity bridge when
  272|       |        // creating ECS entities that correspond to legacy world entities.
  273|       |        if let Some(bridge) = app.world.get_resource_mut::<EntityBridge>() {
  274|       |            // Use a synthetic legacy id 1 for test purposes
  275|       |            bridge.insert_pair(1, e);
  276|       |        }
  277|       |        app.world.insert(
  278|       |            e,
  279|       |            CPos {
  280|       |                pos: IVec2 { x: 0, y: 0 },
  281|       |            },
  282|       |        );
  283|       |        app.world.insert(
  284|       |            e,
  285|       |            CDesiredPos {
  286|       |                pos: IVec2 { x: 2, y: 0 },
  287|       |            },
  288|       |        );
  289|       |        app = app.run_fixed(3);
  290|       |        let p = app.world.get::<CPos>(e).unwrap();
  291|       |        assert_eq!((p.pos.x, p.pos.y), (2, 0));
  292|       |    }
  293|       |
  294|       |    #[test]
  295|       |    fn movement_emits_events() {
  296|       |        let w = World::new();
  297|       |        let mut app = build_app(w, 0.016);
  298|       |        let e = app.world.spawn();
  299|       |        if let Some(bridge) = app.world.get_resource_mut::<EntityBridge>() {
  300|       |            bridge.insert_pair(1, e);
  301|       |        }
  302|       |        app.world.insert(
  303|       |            e,
  304|       |            CPos {
  305|       |                pos: IVec2 { x: 0, y: 0 },
  306|       |            },
  307|       |        );
  308|       |        app.world.insert(
  309|       |            e,
  310|       |            CDesiredPos {
  311|       |                pos: IVec2 { x: 1, y: 0 },
  312|       |            },
  313|       |        );
  314|       |        app = app.run_fixed(1);
  315|       |        let evs = app.world.get_resource_mut::<Events<MovedEvent>>().unwrap();
  316|       |        let mut rdr = evs.reader();
  317|       |        let collected: Vec<_> = rdr.drain().collect();
  318|       |        assert_eq!(collected.len(), 1);
  319|       |        assert_eq!(collected[0].entity, e);
  320|       |        assert_eq!(collected[0].from, IVec2 { x: 0, y: 0 });
  321|       |        assert_eq!(collected[0].to, IVec2 { x: 1, y: 0 });
  322|       |    }
  323|       |
  324|       |    #[test]
  325|       |    fn parity_ecs_vs_legacy_movement_and_cooldowns() {
  326|       |        // Create identical legacy and ECS worlds, run for 10 ticks, compare final state
  327|       |        let mut legacy_world = World::new();
  328|       |        let legacy_entity =
  329|       |            legacy_world.spawn("test", IVec2 { x: 0, y: 0 }, crate::Team { id: 1 }, 100, 10);
  330|       |        // Set desired position by directly modifying pose (legacy doesn't have desired pos concept)
  331|       |        if let Some(pose) = legacy_world.pose_mut(legacy_entity) {
  332|       |            pose.pos = IVec2 { x: 5, y: 3 }; // Move to target position
  333|       |        }
  334|       |        // Set cooldown
  335|       |        if let Some(cds) = legacy_world.cooldowns_mut(legacy_entity) {
  336|       |            cds.map.insert("test_cd".to_string(), 1.0);
  337|       |        }
  338|       |
  339|       |        // Create ECS world with same initial state
  340|       |        let ecs_world = World::new();
  341|       |        let mut ecs_app = build_app(ecs_world, 0.016);
  342|       |        // Create ECS entity and set up bridge
  343|       |        let ecs_entity = ecs_app.world.spawn();
  344|       |        if let Some(bridge) = ecs_app.world.get_resource_mut::<EntityBridge>() {
  345|       |            bridge.insert_pair(legacy_entity, ecs_entity);
  346|       |        }
  347|       |        // Set initial position in ECS
  348|       |        ecs_app.world.insert(
  349|       |            ecs_entity,
  350|       |            CPos {
  351|       |                pos: IVec2 { x: 0, y: 0 },
  352|       |            },
  353|       |        );
  354|       |        // Set desired position in ECS
  355|       |        ecs_app.world.insert(
  356|       |            ecs_entity,
  357|       |            CDesiredPos {
  358|       |                pos: IVec2 { x: 5, y: 3 },
  359|       |            },
  360|       |        );
  361|       |        // Set cooldown in ECS
  362|       |        ecs_app.world.insert(
  363|       |            ecs_entity,
  364|       |            CCooldowns {
  365|       |                map: std::collections::BTreeMap::from([(
  366|       |                    crate::cooldowns::CooldownKey::from("test_cd"),
  367|       |                    1.0,
  368|       |                )]),
  369|       |            },
  370|       |        );
  371|       |        // Set health in ECS
  372|       |        ecs_app.world.insert(ecs_entity, CHealth { hp: 100 });
  373|       |
  374|       |        // Run 10 ticks
  375|       |        for _ in 0..10 {
  376|       |            legacy_world.tick(0.016);
  377|       |            // For legacy, manually move toward desired position (simplified movement)
  378|       |            if let Some(pose) = legacy_world.pose_mut(legacy_entity) {
  379|       |                let current = pose.pos;
  380|       |                let target = IVec2 { x: 5, y: 3 };
  381|       |                let dx = (target.x - current.x).signum();
  382|       |                let dy = (target.y - current.y).signum();
  383|       |                pose.pos.x += dx;
  384|       |                pose.pos.y += dy;
  385|       |            }
  386|       |        }
  387|       |        ecs_app = ecs_app.run_fixed(10);
  388|       |
  389|       |        // Compare positions
  390|       |        let legacy_pos = legacy_world.pos_of(legacy_entity).unwrap();
  391|       |        let ecs_pos = ecs_app.world.get::<CPos>(ecs_entity).unwrap().pos;
  392|       |        assert_eq!(legacy_pos, ecs_pos, "Positions should match after 10 ticks");
  393|       |
  394|       |        // Compare cooldowns
  395|       |        let legacy_cd = legacy_world
  396|       |            .cooldowns(legacy_entity)
  397|       |            .unwrap()
  398|       |            .map
  399|       |            .get("test_cd")
  400|       |            .copied()
  401|       |            .unwrap_or(0.0);
  402|       |        let ecs_cd = ecs_app
  403|       |            .world
  404|       |            .get::<CCooldowns>(ecs_entity)
  405|       |            .unwrap()
  406|       |            .map
  407|       |            .get(&crate::cooldowns::CooldownKey::from("test_cd"))
  408|       |            .copied()
  409|       |            .unwrap_or(0.0);
  410|       |        assert!(
  411|       |            (legacy_cd - ecs_cd).abs() < 1e-6,
  412|       |            "Cooldowns should match: legacy={:.3}, ecs={:.3}",
  413|       |            legacy_cd,
  414|       |            ecs_cd
  415|       |        );
  416|       |
  417|       |        // Compare health (should be unchanged)
  418|       |        let legacy_hp = legacy_world.health(legacy_entity).unwrap().hp;
  419|       |        let ecs_hp = ecs_app.world.get::<CHealth>(ecs_entity).unwrap().hp;
  420|       |        assert_eq!(legacy_hp, ecs_hp, "Health should match");
  421|       |    }
  422|       |
  423|       |    #[test]
  424|       |    fn sys_bridge_sync_adds_legacy_id() {
  425|       |        // COVERAGE TARGET: Lines 95-116 (sys_bridge_sync function)
  426|       |        let w = World::new();
  427|       |        let mut app = build_app(w, 0.016);
  428|       |
  429|       |        let e = app.world.spawn();
  430|       |        // Add entity to bridge (simulating legacy↔ECS binding)
  431|       |        if let Some(bridge) = app.world.get_resource_mut::<EntityBridge>() {
  432|       |            bridge.insert_pair(42, e); // Legacy ID 42 → ECS entity
  433|       |        }
  434|       |
  435|       |        // Call sys_bridge_sync directly (normally called by tick)
  436|       |        sys_bridge_sync(&mut app.world);
  437|       |
  438|       |        // Verify CLegacyId component was added (lines 110-116)
  439|       |        let legacy_id = app.world.get::<crate::CLegacyId>(e);
  440|       |        assert!(
  441|       |            legacy_id.is_some(),
  442|       |            "CLegacyId should be added by sys_bridge_sync"
  443|       |        );
  444|       |        assert_eq!(
  445|       |            legacy_id.unwrap().id,
  446|       |            42,
  447|       |            "Legacy ID should match bridge mapping"
  448|       |        );
  449|       |    }
  450|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-core\src\ecs_components.rs:
    1|       |//! ECS component types mirroring legacy World data (Phase 1 incremental migration)
    2|       |use crate::IVec2;
    3|       |use serde::{Deserialize, Serialize};
    4|       |
    5|       |#[derive(Clone, Copy, Debug, Default, Serialize, Deserialize)]
    6|       |pub struct CPos {
    7|       |    pub pos: IVec2,
    8|       |}
    9|       |
   10|       |#[derive(Clone, Copy, Debug, Default, Serialize, Deserialize)]
   11|       |pub struct CHealth {
   12|       |    pub hp: i32,
   13|       |}
   14|       |
   15|       |#[derive(Clone, Copy, Debug, Default, Serialize, Deserialize)]
   16|       |pub struct CTeam {
   17|       |    pub id: u8,
   18|       |}
   19|       |
   20|       |#[derive(Clone, Copy, Debug, Default, Serialize, Deserialize)]
   21|       |pub struct CAmmo {
   22|       |    pub rounds: i32,
   23|       |}
   24|       |
   25|       |pub mod cooldowns {
   26|       |    use serde::{Deserialize, Serialize};
   27|       |    use std::collections::BTreeMap;
   28|       |
   29|       |    /// Efficient key for cooldown kinds. Known variants can be matched statically;
   30|       |    /// unknown/custom keys fall back to `Custom(String)`.
   31|       |    #[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord, Hash)]
   32|       |    pub enum CooldownKey {
   33|       |        ThrowSmoke,
   34|       |        Custom(String),
   35|       |    }
   36|       |
   37|       |    impl From<&str> for CooldownKey {
   38|      0|        fn from(s: &str) -> Self {
   39|      0|            match s {
   40|      0|                "throw:smoke" => CooldownKey::ThrowSmoke,
   41|      0|                _ => CooldownKey::Custom(s.to_string()),
   42|       |            }
   43|      0|        }
   44|       |    }
   45|       |
   46|       |    impl From<String> for CooldownKey {
   47|      0|        fn from(s: String) -> Self {
   48|      0|            CooldownKey::from(s.as_str())
   49|      0|        }
   50|       |    }
   51|       |
   52|       |    impl std::fmt::Display for CooldownKey {
   53|      0|        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   54|      0|            match self {
   55|      0|                CooldownKey::ThrowSmoke => write!(f, "throw:smoke"),
   56|      0|                CooldownKey::Custom(s) => write!(f, "{}", s),
   57|       |            }
   58|      0|        }
   59|       |    }
   60|       |
   61|       |    pub type Map = BTreeMap<CooldownKey, f32>;
   62|       |}
   63|       |
   64|       |use cooldowns::Map as CooldownMap;
   65|       |
   66|       |#[derive(Clone, Debug, Default, Serialize, Deserialize)]
   67|       |pub struct CCooldowns {
   68|       |    pub map: CooldownMap,
   69|       |}
   70|       |
   71|       |#[derive(Clone, Copy, Debug, Default, Serialize, Deserialize)]
   72|       |pub struct CDesiredPos {
   73|       |    pub pos: IVec2,
   74|       |}
   75|       |
   76|       |#[derive(Clone, Debug, Default, Serialize, Deserialize)]
   77|       |pub struct CAiAgent;
   78|       |
   79|       |#[derive(Clone, Debug, Default, Serialize, Deserialize)]
   80|       |/// Component storing the legacy World entity id for round-trip mapping.
   81|       |pub struct CLegacyId {
   82|       |    pub id: crate::Entity,
   83|       |}
   84|       |
   85|       |// Temporary placeholder types to avoid circular dependency
   86|       |// These will be replaced when the memory system is integrated properly
   87|       |
   88|       |#[derive(Clone, Debug, Default, Serialize, Deserialize)]
   89|       |pub struct CompanionProfile {
   90|       |    pub name: String,
   91|       |    pub personality_traits: Vec<String>,
   92|       |    pub background: String,
   93|       |}
   94|       |
   95|       |#[derive(Clone, Debug, Default, Serialize, Deserialize)]
   96|       |pub struct Fact {
   97|       |    pub id: String,
   98|       |    pub content: String,
   99|       |    pub confidence: f32,
  100|       |    pub timestamp: f64,
  101|       |}
  102|       |
  103|       |#[derive(Clone, Debug, Default, Serialize, Deserialize)]
  104|       |pub struct Episode {
  105|       |    pub id: String,
  106|       |    pub description: String,
  107|       |    pub timestamp: f64,
  108|       |    pub importance: f32,
  109|       |}
  110|       |
  111|       |#[derive(Clone, Debug, Default, Serialize, Deserialize)]
  112|       |pub struct CPersona {
  113|       |    pub profile: CompanionProfile,
  114|       |}
  115|       |
  116|       |#[derive(Clone, Debug, Default, Serialize, Deserialize)]
  117|       |pub struct CMemory {
  118|       |    pub facts: Vec<Fact>,
  119|       |    pub episodes: Vec<Episode>,
  120|       |}
  121|       |
  122|       |#[cfg(test)]
  123|       |mod tests {
  124|       |    use super::cooldowns::CooldownKey;
  125|       |    use super::*;
  126|       |
  127|       |    #[test]
  128|       |    fn test_cpos_default() {
  129|       |        let cpos = CPos::default();
  130|       |        assert_eq!(cpos.pos.x, 0);
  131|       |        assert_eq!(cpos.pos.y, 0);
  132|       |    }
  133|       |
  134|       |    #[test]
  135|       |    fn test_chealth_default() {
  136|       |        let health = CHealth::default();
  137|       |        assert_eq!(health.hp, 0);
  138|       |    }
  139|       |
  140|       |    #[test]
  141|       |    fn test_cteam_default() {
  142|       |        let team = CTeam::default();
  143|       |        assert_eq!(team.id, 0);
  144|       |    }
  145|       |
  146|       |    #[test]
  147|       |    fn test_cammo_default() {
  148|       |        let ammo = CAmmo::default();
  149|       |        assert_eq!(ammo.rounds, 0);
  150|       |    }
  151|       |
  152|       |    #[test]
  153|       |    fn test_cooldown_key_from_str_known() {
  154|       |        let key = CooldownKey::from("throw:smoke");
  155|       |        assert_eq!(key, CooldownKey::ThrowSmoke);
  156|       |    }
  157|       |
  158|       |    #[test]
  159|       |    fn test_cooldown_key_from_str_custom() {
  160|       |        let key = CooldownKey::from("custom_ability");
  161|       |        assert_eq!(key, CooldownKey::Custom("custom_ability".into()));
  162|       |    }
  163|       |
  164|       |    #[test]
  165|       |    fn test_cooldown_key_from_string() {
  166|       |        let key = CooldownKey::from("throw:smoke".to_string());
  167|       |        assert_eq!(key, CooldownKey::ThrowSmoke);
  168|       |
  169|       |        let key2 = CooldownKey::from("other".to_string());
  170|       |        assert_eq!(key2, CooldownKey::Custom("other".into()));
  171|       |    }
  172|       |
  173|       |    #[test]
  174|       |    fn test_cooldown_key_display() {
  175|       |        let key1 = CooldownKey::ThrowSmoke;
  176|       |        assert_eq!(format!("{}", key1), "throw:smoke");
  177|       |
  178|       |        let key2 = CooldownKey::Custom("fireball".into());
  179|       |        assert_eq!(format!("{}", key2), "fireball");
  180|       |    }
  181|       |
  182|       |    #[test]
  183|       |    fn test_ccooldowns_default() {
  184|       |        let cds = CCooldowns::default();
  185|       |        assert!(cds.map.is_empty());
  186|       |    }
  187|       |
  188|       |    #[test]
  189|       |    fn test_cdesired_pos_default() {
  190|       |        let pos = CDesiredPos::default();
  191|       |        assert_eq!(pos.pos.x, 0);
  192|       |        assert_eq!(pos.pos.y, 0);
  193|       |    }
  194|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-core\src\perception.rs:
    1|       |use crate::schema::Poi;
    2|       |use crate::{CompanionState, EnemyState, Entity, IVec2, PlayerState, World, WorldSnapshot};
    3|       |use std::collections::BTreeMap;
    4|       |
    5|       |pub struct PerceptionConfig {
    6|       |    pub los_max: i32,
    7|       |}
    8|       |
    9|       |pub fn build_snapshot(
   10|       |    w: &World,
   11|       |    t_player: Entity,
   12|       |    t_companion: Entity,
   13|       |    enemies: &[Entity],
   14|       |    objective: Option<String>,
   15|       |    cfg: &PerceptionConfig,
   16|       |) -> WorldSnapshot {
   17|       |    let ppos = w
   18|       |        .pos_of(t_player)
   19|       |        .expect("Player entity should have Position component");
   20|       |    let cpos = w
   21|       |        .pos_of(t_companion)
   22|       |        .expect("Companion entity should have Position component");
   23|       |    let player = PlayerState {
   24|       |        hp: w
   25|       |            .health(t_player)
   26|       |            .expect("Player entity should have Health component")
   27|       |            .hp,
   28|       |        pos: ppos,
   29|       |        stance: "crouch".into(),
   30|       |        orders: vec!["hold_east".into()],
   31|       |    };
   32|       |    let me = CompanionState {
   33|       |        ammo: w
   34|       |            .ammo(t_companion)
   35|       |            .expect("Companion entity should have Ammo component")
   36|       |            .rounds,
   37|       |        cooldowns: w
   38|       |            .cooldowns(t_companion)
   39|       |            .expect("Companion entity should have Cooldowns component")
   40|       |            .map
   41|       |            .clone()
   42|       |            .into_iter()
   43|       |            .collect::<BTreeMap<_, _>>(),
   44|       |        morale: 0.8,
   45|       |        pos: cpos,
   46|       |    };
   47|       |    let enemies = enemies
   48|       |        .iter()
   49|      0|        .filter_map(|&e| {
   50|      0|            let pos = w.pos_of(e)?;
   51|      0|            let hp = w.health(e)?.hp;
   52|       |            // LOS consider simple radius; real LOS in validator
   53|      0|            let cover = if (pos.x - ppos.x).abs() + (pos.y - ppos.y).abs() > cfg.los_max {
   54|      0|                "unknown"
   55|       |            } else {
   56|      0|                "low"
   57|       |            };
   58|      0|            Some(EnemyState {
   59|      0|                id: e,
   60|      0|                pos,
   61|      0|                hp,
   62|      0|                cover: cover.into(),
   63|      0|                last_seen: w.t,
   64|      0|            })
   65|      0|        })
   66|       |        .collect::<Vec<_>>();
   67|       |
   68|       |    WorldSnapshot {
   69|       |        t: w.t,
   70|       |        player,
   71|       |        me,
   72|       |        enemies,
   73|       |        pois: vec![Poi {
   74|       |            k: "breach_door".into(),
   75|       |            pos: IVec2 { x: 15, y: 8 },
   76|       |        }],
   77|      0|        obstacles: w.obstacles.iter().map(|&(x, y)| IVec2 { x, y }).collect(),
   78|       |        objective,
   79|       |    }
   80|       |}
   81|       |
   82|       |#[cfg(test)]
   83|       |mod tests {
   84|       |    use super::*;
   85|       |    use crate::{Team, World};
   86|       |
   87|       |    fn iv2(x: i32, y: i32) -> IVec2 {
   88|       |        IVec2 { x, y }
   89|       |    }
   90|       |
   91|       |    // ===== PerceptionConfig Tests =====
   92|       |    #[test]
   93|       |    fn test_perception_config_creation() {
   94|       |        let cfg = PerceptionConfig { los_max: 10 };
   95|       |        assert_eq!(cfg.los_max, 10);
   96|       |    }
   97|       |
   98|       |    #[test]
   99|       |    fn test_perception_config_large_los() {
  100|       |        let cfg = PerceptionConfig { los_max: 100 };
  101|       |        assert_eq!(cfg.los_max, 100);
  102|       |    }
  103|       |
  104|       |    #[test]
  105|       |    fn test_perception_config_zero_los() {
  106|       |        let cfg = PerceptionConfig { los_max: 0 };
  107|       |        assert_eq!(cfg.los_max, 0);
  108|       |    }
  109|       |
  110|       |    // ===== build_snapshot Tests =====
  111|       |    #[test]
  112|       |    fn test_build_snapshot_basic() {
  113|       |        let mut w = World::new();
  114|       |        w.t = 5.0;
  115|       |
  116|       |        let player = w.spawn("player", iv2(0, 0), Team { id: 1 }, 100, 0);
  117|       |        let companion = w.spawn("companion", iv2(1, 1), Team { id: 1 }, 100, 10);
  118|       |        let enemy = w.spawn("enemy", iv2(5, 5), Team { id: 2 }, 50, 0);
  119|       |
  120|       |        let cfg = PerceptionConfig { los_max: 20 };
  121|       |        let snap = build_snapshot(&w, player, companion, &[enemy], None, &cfg);
  122|       |
  123|       |        assert_eq!(snap.t, 5.0);
  124|       |        assert_eq!(snap.player.hp, 100);
  125|       |        assert_eq!(snap.player.pos, iv2(0, 0));
  126|       |        assert_eq!(snap.me.pos, iv2(1, 1));
  127|       |        assert_eq!(snap.me.ammo, 10);
  128|       |        assert_eq!(snap.enemies.len(), 1);
  129|       |        assert_eq!(snap.enemies[0].hp, 50);
  130|       |        assert_eq!(snap.enemies[0].pos, iv2(5, 5));
  131|       |    }
  132|       |
  133|       |    #[test]
  134|       |    fn test_build_snapshot_time_tracking() {
  135|       |        let mut w = World::new();
  136|       |        w.t = 15.5;
  137|       |
  138|       |        let player = w.spawn("player", iv2(0, 0), Team { id: 1 }, 100, 0);
  139|       |        let companion = w.spawn("companion", iv2(1, 1), Team { id: 1 }, 80, 5);
  140|       |
  141|       |        let cfg = PerceptionConfig { los_max: 10 };
  142|       |        let snap = build_snapshot(&w, player, companion, &[], None, &cfg);
  143|       |
  144|       |        assert_eq!(snap.t, 15.5);
  145|       |    }
  146|       |
  147|       |    #[test]
  148|       |    fn test_build_snapshot_multiple_enemies() {
  149|       |        let mut w = World::new();
  150|       |        w.t = 0.0;
  151|       |
  152|       |        let player = w.spawn("player", iv2(0, 0), Team { id: 1 }, 100, 0);
  153|       |        let companion = w.spawn("companion", iv2(1, 1), Team { id: 1 }, 100, 10);
  154|       |        let enemy1 = w.spawn("enemy1", iv2(5, 5), Team { id: 2 }, 50, 0);
  155|       |        let enemy2 = w.spawn("enemy2", iv2(6, 6), Team { id: 2 }, 60, 0);
  156|       |        let enemy3 = w.spawn("enemy3", iv2(7, 7), Team { id: 2 }, 70, 0);
  157|       |
  158|       |        let cfg = PerceptionConfig { los_max: 20 };
  159|       |        let snap = build_snapshot(&w, player, companion, &[enemy1, enemy2, enemy3], None, &cfg);
  160|       |
  161|       |        assert_eq!(snap.enemies.len(), 3);
  162|       |        assert_eq!(snap.enemies[0].hp, 50);
  163|       |        assert_eq!(snap.enemies[1].hp, 60);
  164|       |        assert_eq!(snap.enemies[2].hp, 70);
  165|       |    }
  166|       |
  167|       |    #[test]
  168|       |    fn test_build_snapshot_no_enemies() {
  169|       |        let mut w = World::new();
  170|       |        w.t = 0.0;
  171|       |
  172|       |        let player = w.spawn("player", iv2(0, 0), Team { id: 1 }, 100, 0);
  173|       |        let companion = w.spawn("companion", iv2(1, 1), Team { id: 1 }, 100, 10);
  174|       |
  175|       |        let cfg = PerceptionConfig { los_max: 20 };
  176|       |        let snap = build_snapshot(&w, player, companion, &[], None, &cfg);
  177|       |
  178|       |        assert_eq!(snap.enemies.len(), 0);
  179|       |    }
  180|       |
  181|       |    #[test]
  182|       |    fn test_build_snapshot_player_state() {
  183|       |        let mut w = World::new();
  184|       |        w.t = 0.0;
  185|       |
  186|       |        let player = w.spawn("player", iv2(10, 20), Team { id: 1 }, 75, 0);
  187|       |        let companion = w.spawn("companion", iv2(1, 1), Team { id: 1 }, 100, 10);
  188|       |
  189|       |        let cfg = PerceptionConfig { los_max: 20 };
  190|       |        let snap = build_snapshot(&w, player, companion, &[], None, &cfg);
  191|       |
  192|       |        assert_eq!(snap.player.hp, 75);
  193|       |        assert_eq!(snap.player.pos, iv2(10, 20));
  194|       |        assert_eq!(snap.player.stance, "crouch");
  195|       |        assert_eq!(snap.player.orders.len(), 1);
  196|       |        assert_eq!(snap.player.orders[0], "hold_east");
  197|       |    }
  198|       |
  199|       |    #[test]
  200|       |    fn test_build_snapshot_companion_state() {
  201|       |        let mut w = World::new();
  202|       |        w.t = 0.0;
  203|       |
  204|       |        let player = w.spawn("player", iv2(0, 0), Team { id: 1 }, 100, 0);
  205|       |        let companion = w.spawn("companion", iv2(15, 25), Team { id: 1 }, 90, 7);
  206|       |
  207|       |        let cfg = PerceptionConfig { los_max: 20 };
  208|       |        let snap = build_snapshot(&w, player, companion, &[], None, &cfg);
  209|       |
  210|       |        assert_eq!(snap.me.pos, iv2(15, 25));
  211|       |        assert_eq!(snap.me.ammo, 7);
  212|       |        assert_eq!(snap.me.morale, 0.8);
  213|       |    }
  214|       |
  215|       |    #[test]
  216|       |    fn test_build_snapshot_cooldowns() {
  217|       |        let mut w = World::new();
  218|       |        w.t = 0.0;
  219|       |
  220|       |        let player = w.spawn("player", iv2(0, 0), Team { id: 1 }, 100, 0);
  221|       |        let companion = w.spawn("companion", iv2(1, 1), Team { id: 1 }, 100, 10);
  222|       |
  223|       |        // Get cooldowns component and modify
  224|       |        if let Some(cds) = w.cooldowns_mut(companion) {
  225|       |            cds.map.insert("throw".to_string(), 5.0);
  226|       |            cds.map.insert("heal".to_string(), 2.5);
  227|       |        }
  228|       |
  229|       |        let cfg = PerceptionConfig { los_max: 20 };
  230|       |        let snap = build_snapshot(&w, player, companion, &[], None, &cfg);
  231|       |
  232|       |        assert_eq!(snap.me.cooldowns.len(), 2);
  233|       |        assert_eq!(snap.me.cooldowns.get("throw"), Some(&5.0));
  234|       |        assert_eq!(snap.me.cooldowns.get("heal"), Some(&2.5));
  235|       |    }
  236|       |
  237|       |    #[test]
  238|       |    fn test_build_snapshot_with_objective() {
  239|       |        let mut w = World::new();
  240|       |        w.t = 0.0;
  241|       |
  242|       |        let player = w.spawn("player", iv2(0, 0), Team { id: 1 }, 100, 0);
  243|       |        let companion = w.spawn("companion", iv2(1, 1), Team { id: 1 }, 100, 10);
  244|       |
  245|       |        let cfg = PerceptionConfig { los_max: 20 };
  246|       |        let snap = build_snapshot(
  247|       |            &w,
  248|       |            player,
  249|       |            companion,
  250|       |            &[],
  251|       |            Some("Secure the breach point".to_string()),
  252|       |            &cfg,
  253|       |        );
  254|       |
  255|       |        assert!(snap.objective.is_some());
  256|       |        assert_eq!(snap.objective.unwrap(), "Secure the breach point");
  257|       |    }
  258|       |
  259|       |    #[test]
  260|       |    fn test_build_snapshot_no_objective() {
  261|       |        let mut w = World::new();
  262|       |        w.t = 0.0;
  263|       |
  264|       |        let player = w.spawn("player", iv2(0, 0), Team { id: 1 }, 100, 0);
  265|       |        let companion = w.spawn("companion", iv2(1, 1), Team { id: 1 }, 100, 10);
  266|       |
  267|       |        let cfg = PerceptionConfig { los_max: 20 };
  268|       |        let snap = build_snapshot(&w, player, companion, &[], None, &cfg);
  269|       |
  270|       |        assert!(snap.objective.is_none());
  271|       |    }
  272|       |
  273|       |    #[test]
  274|       |    fn test_build_snapshot_pois_generated() {
  275|       |        let mut w = World::new();
  276|       |        w.t = 0.0;
  277|       |
  278|       |        let player = w.spawn("player", iv2(0, 0), Team { id: 1 }, 100, 0);
  279|       |        let companion = w.spawn("companion", iv2(1, 1), Team { id: 1 }, 100, 10);
  280|       |
  281|       |        let cfg = PerceptionConfig { los_max: 20 };
  282|       |        let snap = build_snapshot(&w, player, companion, &[], None, &cfg);
  283|       |
  284|       |        assert_eq!(snap.pois.len(), 1);
  285|       |        assert_eq!(snap.pois[0].k, "breach_door");
  286|       |        assert_eq!(snap.pois[0].pos, iv2(15, 8));
  287|       |    }
  288|       |
  289|       |    #[test]
  290|       |    fn test_build_snapshot_obstacles() {
  291|       |        let mut w = World::new();
  292|       |        w.t = 0.0;
  293|       |        w.obstacles.insert((5, 5));
  294|       |        w.obstacles.insert((6, 6));
  295|       |        w.obstacles.insert((7, 7));
  296|       |
  297|       |        let player = w.spawn("player", iv2(0, 0), Team { id: 1 }, 100, 0);
  298|       |        let companion = w.spawn("companion", iv2(1, 1), Team { id: 1 }, 100, 10);
  299|       |
  300|       |        let cfg = PerceptionConfig { los_max: 20 };
  301|       |        let snap = build_snapshot(&w, player, companion, &[], None, &cfg);
  302|       |
  303|       |        assert_eq!(snap.obstacles.len(), 3);
  304|       |        assert!(snap.obstacles.contains(&iv2(5, 5)));
  305|       |        assert!(snap.obstacles.contains(&iv2(6, 6)));
  306|       |        assert!(snap.obstacles.contains(&iv2(7, 7)));
  307|       |    }
  308|       |
  309|       |    #[test]
  310|       |    fn test_build_snapshot_enemy_los_close() {
  311|       |        let mut w = World::new();
  312|       |        w.t = 0.0;
  313|       |
  314|       |        let player = w.spawn("player", iv2(0, 0), Team { id: 1 }, 100, 0);
  315|       |        let companion = w.spawn("companion", iv2(1, 1), Team { id: 1 }, 100, 10);
  316|       |        let enemy = w.spawn("enemy", iv2(2, 2), Team { id: 2 }, 50, 0);
  317|       |
  318|       |        let cfg = PerceptionConfig { los_max: 10 };
  319|       |        let snap = build_snapshot(&w, player, companion, &[enemy], None, &cfg);
  320|       |
  321|       |        assert_eq!(snap.enemies.len(), 1);
  322|       |        // Enemy within los_max should have cover "low"
  323|       |        assert_eq!(snap.enemies[0].cover, "low");
  324|       |    }
  325|       |
  326|       |    #[test]
  327|       |    fn test_build_snapshot_enemy_los_far() {
  328|       |        let mut w = World::new();
  329|       |        w.t = 0.0;
  330|       |
  331|       |        let player = w.spawn("player", iv2(0, 0), Team { id: 1 }, 100, 0);
  332|       |        let companion = w.spawn("companion", iv2(1, 1), Team { id: 1 }, 100, 10);
  333|       |        let enemy = w.spawn("enemy", iv2(50, 50), Team { id: 2 }, 50, 0);
  334|       |
  335|       |        let cfg = PerceptionConfig { los_max: 10 };
  336|       |        let snap = build_snapshot(&w, player, companion, &[enemy], None, &cfg);
  337|       |
  338|       |        assert_eq!(snap.enemies.len(), 1);
  339|       |        // Enemy beyond los_max should have cover "unknown"
  340|       |        assert_eq!(snap.enemies[0].cover, "unknown");
  341|       |    }
  342|       |
  343|       |    #[test]
  344|       |    fn test_build_snapshot_enemy_last_seen() {
  345|       |        let mut w = World::new();
  346|       |        w.t = 12.5;
  347|       |
  348|       |        let player = w.spawn("player", iv2(0, 0), Team { id: 1 }, 100, 0);
  349|       |        let companion = w.spawn("companion", iv2(1, 1), Team { id: 1 }, 100, 10);
  350|       |        let enemy = w.spawn("enemy", iv2(5, 5), Team { id: 2 }, 50, 0);
  351|       |
  352|       |        let cfg = PerceptionConfig { los_max: 20 };
  353|       |        let snap = build_snapshot(&w, player, companion, &[enemy], None, &cfg);
  354|       |
  355|       |        assert_eq!(snap.enemies.len(), 1);
  356|       |        assert_eq!(snap.enemies[0].last_seen, 12.5);
  357|       |    }
  358|       |
  359|       |    #[test]
  360|       |    fn test_build_snapshot_enemy_id_tracking() {
  361|       |        let mut w = World::new();
  362|       |        w.t = 0.0;
  363|       |
  364|       |        let player = w.spawn("player", iv2(0, 0), Team { id: 1 }, 100, 0);
  365|       |        let companion = w.spawn("companion", iv2(1, 1), Team { id: 1 }, 100, 10);
  366|       |        let enemy1 = w.spawn("enemy1", iv2(5, 5), Team { id: 2 }, 50, 0);
  367|       |        let enemy2 = w.spawn("enemy2", iv2(6, 6), Team { id: 2 }, 60, 0);
  368|       |
  369|       |        let cfg = PerceptionConfig { los_max: 20 };
  370|       |        let snap = build_snapshot(&w, player, companion, &[enemy1, enemy2], None, &cfg);
  371|       |
  372|       |        assert_eq!(snap.enemies.len(), 2);
  373|       |        assert_eq!(snap.enemies[0].id, enemy1);
  374|       |        assert_eq!(snap.enemies[1].id, enemy2);
  375|       |    }
  376|       |
  377|       |    #[test]
  378|       |    fn test_build_snapshot_comprehensive() {
  379|       |        let mut w = World::new();
  380|       |        w.t = 10.0;
  381|       |        w.obstacles.insert((3, 3));
  382|       |        w.obstacles.insert((4, 4));
  383|       |
  384|       |        let player = w.spawn("player", iv2(0, 0), Team { id: 1 }, 85, 0);
  385|       |        let companion = w.spawn("companion", iv2(2, 2), Team { id: 1 }, 95, 8);
  386|       |        let enemy1 = w.spawn("enemy1", iv2(5, 5), Team { id: 2 }, 40, 0);
  387|       |        let enemy2 = w.spawn("enemy2", iv2(100, 100), Team { id: 2 }, 30, 0);
  388|       |
  389|       |        if let Some(cds) = w.cooldowns_mut(companion) {
  390|       |            cds.map.insert("grenade".to_string(), 3.0);
  391|       |        }
  392|       |
  393|       |        let cfg = PerceptionConfig { los_max: 15 };
  394|       |        let snap = build_snapshot(
  395|       |            &w,
  396|       |            player,
  397|       |            companion,
  398|       |            &[enemy1, enemy2],
  399|       |            Some("Defend position".to_string()),
  400|       |            &cfg,
  401|       |        );
  402|       |
  403|       |        // Verify all components
  404|       |        assert_eq!(snap.t, 10.0);
  405|       |        assert_eq!(snap.player.hp, 85);
  406|       |        assert_eq!(snap.me.ammo, 8);
  407|       |        assert_eq!(snap.me.cooldowns.len(), 1);
  408|       |        assert_eq!(snap.enemies.len(), 2);
  409|       |        assert_eq!(snap.enemies[0].cover, "low"); // Within LOS
  410|       |        assert_eq!(snap.enemies[1].cover, "unknown"); // Beyond LOS
  411|       |        assert_eq!(snap.obstacles.len(), 2);
  412|       |        assert_eq!(snap.pois.len(), 1);
  413|       |        assert_eq!(snap.objective, Some("Defend position".to_string()));
  414|       |    }
  415|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-core\src\schema.rs:
    1|       |// Default implementations for test scaffolding
    2|       |impl Default for PlayerState {
    3|      0|    fn default() -> Self {
    4|      0|        PlayerState {
    5|      0|            hp: 100,
    6|      0|            pos: IVec2 { x: 0, y: 0 },
    7|      0|            stance: "stand".to_string(),
    8|      0|            orders: vec![],
    9|      0|        }
   10|      0|    }
   11|       |}
   12|       |
   13|       |impl Default for CompanionState {
   14|      0|    fn default() -> Self {
   15|      0|        CompanionState {
   16|      0|            ammo: 10,
   17|      0|            cooldowns: BTreeMap::new(),
   18|      0|            morale: 1.0,
   19|      0|            pos: IVec2 { x: 0, y: 0 },
   20|      0|        }
   21|      0|    }
   22|       |}
   23|       |
   24|       |impl Default for EnemyState {
   25|      0|    fn default() -> Self {
   26|      0|        EnemyState {
   27|      0|            id: 0,
   28|      0|            pos: IVec2 { x: 0, y: 0 },
   29|      0|            hp: 100,
   30|      0|            cover: "none".to_string(),
   31|      0|            last_seen: 0.0,
   32|      0|        }
   33|      0|    }
   34|       |}
   35|       |
   36|       |impl Default for Poi {
   37|      0|    fn default() -> Self {
   38|      0|        Poi {
   39|      0|            k: "poi".to_string(),
   40|      0|            pos: IVec2 { x: 0, y: 0 },
   41|      0|        }
   42|      0|    }
   43|       |}
   44|       |
   45|       |impl Default for WorldSnapshot {
   46|      0|    fn default() -> Self {
   47|      0|        WorldSnapshot {
   48|      0|            t: 0.0,
   49|      0|            player: PlayerState::default(),
   50|      0|            me: CompanionState::default(),
   51|      0|            enemies: vec![],
   52|      0|            pois: vec![],
   53|      0|            obstacles: vec![],
   54|      0|            objective: None,
   55|      0|        }
   56|      0|    }
   57|       |}
   58|       |use serde::{Deserialize, Serialize};
   59|       |use std::collections::BTreeMap;
   60|       |
   61|       |pub type Entity = u32;
   62|       |
   63|       |#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq, Default)]
   64|       |pub struct IVec2 {
   65|       |    pub x: i32,
   66|       |    pub y: i32,
   67|       |}
   68|       |
   69|       |impl IVec2 {
   70|       |    /// Convenience constructor matching glam-style APIs.
   71|      0|    pub const fn new(x: i32, y: i32) -> Self {
   72|      0|        Self { x, y }
   73|      0|    }
   74|       |}
   75|       |
   76|       |#[derive(Clone, Debug, Serialize, Deserialize)]
   77|       |pub struct WorldSnapshot {
   78|       |    pub t: f32,
   79|       |    pub player: PlayerState,
   80|       |    pub me: CompanionState,
   81|       |    pub enemies: Vec<EnemyState>,
   82|       |    pub pois: Vec<Poi>,
   83|       |    pub obstacles: Vec<IVec2>,
   84|       |    pub objective: Option<String>,
   85|       |}
   86|       |
   87|       |#[derive(Clone, Debug, Serialize, Deserialize)]
   88|       |pub struct PlayerState {
   89|       |    pub hp: i32,
   90|       |    pub pos: IVec2,
   91|       |    pub stance: String,
   92|       |    pub orders: Vec<String>,
   93|       |}
   94|       |
   95|       |#[derive(Clone, Debug, Serialize, Deserialize)]
   96|       |pub struct CompanionState {
   97|       |    pub ammo: i32,
   98|       |    pub cooldowns: BTreeMap<String, f32>,
   99|       |    pub morale: f32,
  100|       |    pub pos: IVec2,
  101|       |}
  102|       |
  103|       |#[derive(Clone, Debug, Serialize, Deserialize)]
  104|       |pub struct EnemyState {
  105|       |    pub id: Entity,
  106|       |    pub pos: IVec2,
  107|       |    pub hp: i32,
  108|       |    pub cover: String,
  109|       |    pub last_seen: f32,
  110|       |}
  111|       |
  112|       |#[derive(Clone, Debug, Serialize, Deserialize)]
  113|       |pub struct Poi {
  114|       |    pub k: String,
  115|       |    pub pos: IVec2,
  116|       |}
  117|       |
  118|       |#[derive(Clone, Debug, Serialize, Deserialize)]
  119|       |pub struct PhysicsContext {
  120|       |    pub blocking_objects: Vec<BlockingObject>,
  121|       |    pub interactable_objects: Vec<InteractableObject>,
  122|       |}
  123|       |
  124|       |#[derive(Clone, Debug, Serialize, Deserialize)]
  125|       |pub struct BlockingObject {
  126|       |    pub id: Entity,
  127|       |    pub pos: IVec2,
  128|       |    pub object_type: String,
  129|       |    pub is_locked: bool,
  130|       |}
  131|       |
  132|       |#[derive(Clone, Debug, Serialize, Deserialize)]
  133|       |pub struct InteractableObject {
  134|       |    pub id: Entity,
  135|       |    pub pos: IVec2,
  136|       |    pub object_type: String,
  137|       |    pub requires_item: Option<String>,
  138|       |}
  139|       |
  140|       |#[derive(Clone, Debug, Serialize, Deserialize, Default)]
  141|       |pub struct PlanIntent {
  142|       |    pub plan_id: String,
  143|       |    pub steps: Vec<ActionStep>,
  144|       |}
  145|       |
  146|       |// ============================================================================
  147|       |// MOVEMENT SPEED & DIRECTION ENUMS
  148|       |// ============================================================================
  149|       |
  150|       |#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq)]
  151|       |#[serde(rename_all = "lowercase")]
  152|       |pub enum MovementSpeed {
  153|       |    Walk,
  154|       |    Run,
  155|       |    Sprint,
  156|       |}
  157|       |
  158|       |#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq)]
  159|       |#[serde(rename_all = "lowercase")]
  160|       |pub enum StrafeDirection {
  161|       |    Left,
  162|       |    Right,
  163|       |}
  164|       |
  165|       |#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq)]
  166|       |#[serde(rename_all = "lowercase")]
  167|       |pub enum AttackType {
  168|       |    Light,
  169|       |    Heavy,
  170|       |}
  171|       |
  172|       |// ============================================================================
  173|       |// TERRAIN GENERATION DSL - AI-Orchestrated Dynamic Terrain (Phase 10)
  174|       |// ============================================================================
  175|       |
  176|       |/// Terrain feature types for LLM-driven generation
  177|       |#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
  178|       |#[serde(tag = "type")]
  179|       |pub enum TerrainFeatureType {
  180|       |    /// Underground cave system with specified depth
  181|       |    Cave { depth: u32 },
  182|       |    /// Impact crater with specified radius
  183|       |    Crater { radius: u32 },
  184|       |    /// Vertical cliff face with specified height
  185|       |    Cliff { height: u32 },
  186|       |    /// Body of water with specified depth
  187|       |    Lake { depth: u32 },
  188|       |    /// Dense vegetation area with specified density (0.0-1.0)
  189|       |    Forest { density: f32 },
  190|       |    /// Ancient ruins with specified complexity level (1-5)
  191|       |    Ruins { complexity: u32 },
  192|       |    /// Custom feature type with arbitrary parameters
  193|       |    Custom {
  194|       |        feature_id: String,
  195|       |        params: std::collections::HashMap<String, f32>,
  196|       |    },
  197|       |}
  198|       |
  199|       |impl Default for TerrainFeatureType {
  200|      0|    fn default() -> Self {
  201|      0|        TerrainFeatureType::Crater { radius: 10 }
  202|      0|    }
  203|       |}
  204|       |
  205|       |/// Cardinal direction for spatial references
  206|       |#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq)]
  207|       |#[serde(rename_all = "lowercase")]
  208|       |pub enum CardinalDirection {
  209|       |    North,
  210|       |    South,
  211|       |    East,
  212|       |    West,
  213|       |    NorthEast,
  214|       |    NorthWest,
  215|       |    SouthEast,
  216|       |    SouthWest,
  217|       |}
  218|       |
  219|       |impl CardinalDirection {
  220|       |    /// Convert to a unit vector (x, z) on the horizontal plane
  221|      0|    pub fn to_unit_vector(self) -> (f32, f32) {
  222|      0|        match self {
  223|      0|            CardinalDirection::North => (0.0, -1.0),
  224|      0|            CardinalDirection::South => (0.0, 1.0),
  225|      0|            CardinalDirection::East => (1.0, 0.0),
  226|      0|            CardinalDirection::West => (-1.0, 0.0),
  227|      0|            CardinalDirection::NorthEast => (0.707, -0.707),
  228|      0|            CardinalDirection::NorthWest => (-0.707, -0.707),
  229|      0|            CardinalDirection::SouthEast => (0.707, 0.707),
  230|      0|            CardinalDirection::SouthWest => (-0.707, 0.707),
  231|       |        }
  232|      0|    }
  233|       |}
  234|       |
  235|       |/// Distance categories to prevent LLM spatial hallucination
  236|       |#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq)]
  237|       |#[serde(rename_all = "lowercase")]
  238|       |pub enum DistanceCategory {
  239|       |    /// 10-50 units from reference point
  240|       |    Near,
  241|       |    /// 50-150 units from reference point
  242|       |    Medium,
  243|       |    /// 150-500 units from reference point
  244|       |    Far,
  245|       |}
  246|       |
  247|       |impl DistanceCategory {
  248|       |    /// Get the actual distance range (min, max) in world units
  249|      0|    pub fn to_range(self) -> (f32, f32) {
  250|      0|        match self {
  251|      0|            DistanceCategory::Near => (10.0, 50.0),
  252|      0|            DistanceCategory::Medium => (50.0, 150.0),
  253|      0|            DistanceCategory::Far => (150.0, 500.0),
  254|       |        }
  255|      0|    }
  256|       |
  257|       |    /// Get the midpoint distance for this category
  258|      0|    pub fn midpoint(self) -> f32 {
  259|      0|        let (min, max) = self.to_range();
  260|      0|        (min + max) / 2.0
  261|      0|    }
  262|       |}
  263|       |
  264|       |/// Relative location for LLM-friendly spatial references
  265|       |#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
  266|       |#[serde(tag = "method")]
  267|       |pub enum RelativeLocation {
  268|       |    /// Place at the point the camera/player is looking at
  269|       |    LineOfSight {
  270|       |        /// Maximum raycast distance
  271|       |        look_distance: f32,
  272|       |    },
  273|       |    /// Place in a direction from the current position
  274|       |    DirectionFrom {
  275|       |        /// Cardinal direction
  276|       |        cardinal: CardinalDirection,
  277|       |        /// Distance category
  278|       |        distance: DistanceCategory,
  279|       |    },
  280|       |    /// Explicit world coordinates (fallback)
  281|       |    Coordinates { x: f32, y: f32, z: f32 },
  282|       |}
  283|       |
  284|       |impl Default for RelativeLocation {
  285|      0|    fn default() -> Self {
  286|      0|        RelativeLocation::LineOfSight {
  287|      0|            look_distance: 50.0,
  288|      0|        }
  289|      0|    }
  290|       |}
  291|       |
  292|       |/// Persistence mode for terrain modifications
  293|       |#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq, Default)]
  294|       |#[serde(rename_all = "lowercase")]
  295|       |pub enum PersistenceMode {
  296|       |    /// Terrain changes are lost when the session ends
  297|       |    #[default]
  298|       |    SessionOnly,
  299|       |    /// Terrain changes are saved to disk and persist across sessions
  300|       |    Persistent,
  301|       |}
  302|       |
  303|       |/// LLM terrain generation request (DSL for Hermes 2 Pro)
  304|       |///
  305|       |/// This struct represents a complete terrain modification request that can be
  306|       |/// generated by an LLM and validated by the TerrainSolver before execution.
  307|       |#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
  308|       |pub struct TerrainGenerationRequest {
  309|       |    /// Unique identifier for this request (UUID v4)
  310|       |    pub request_id: String,
  311|       |    /// Type of terrain feature to generate
  312|       |    pub feature_type: TerrainFeatureType,
  313|       |    /// Where to place the feature relative to the player/camera
  314|       |    pub relative_location: RelativeLocation,
  315|       |    /// Intensity of the modification (0.0 = subtle, 1.0 = dramatic)
  316|       |    pub intensity: f32,
  317|       |    /// Narrative justification for the terrain change (max 100 chars)
  318|       |    pub narrative_reason: String,
  319|       |    /// Whether this change should persist across sessions
  320|       |    pub persistence_mode: PersistenceMode,
  321|       |    /// Biome constraints - if non-empty, feature can only spawn in these biomes
  322|       |    pub biome_constraints: Vec<String>,
  323|       |    /// Optional seed for deterministic generation and replay validation
  324|       |    pub seed: Option<u64>,
  325|       |}
  326|       |
  327|       |impl Default for TerrainGenerationRequest {
  328|      0|    fn default() -> Self {
  329|      0|        TerrainGenerationRequest {
  330|      0|            request_id: String::new(),
  331|      0|            feature_type: TerrainFeatureType::default(),
  332|      0|            relative_location: RelativeLocation::default(),
  333|      0|            intensity: 0.5,
  334|      0|            narrative_reason: String::new(),
  335|      0|            persistence_mode: PersistenceMode::default(),
  336|      0|            biome_constraints: Vec::new(),
  337|      0|            seed: None,
  338|      0|        }
  339|      0|    }
  340|       |}
  341|       |
  342|       |impl TerrainGenerationRequest {
  343|       |    /// Validate the request before processing
  344|      0|    pub fn validate(&self) -> Result<(), String> {
  345|       |        // Validate intensity bounds
  346|      0|        if self.intensity < 0.0 || self.intensity > 1.0 {
  347|      0|            return Err("Intensity must be between 0.0 and 1.0".to_string());
  348|      0|        }
  349|       |
  350|       |        // Validate narrative reason length
  351|      0|        if self.narrative_reason.len() > 100 {
  352|      0|            return Err("Narrative reason exceeds 100 characters".to_string());
  353|      0|        }
  354|       |
  355|       |        // Validate request_id is not empty
  356|      0|        if self.request_id.is_empty() {
  357|      0|            return Err("Request ID cannot be empty".to_string());
  358|      0|        }
  359|       |
  360|      0|        Ok(())
  361|      0|    }
  362|       |}
  363|       |
  364|       |// ============================================================================
  365|       |// ACTION STEP ENUM - 38 Tools Across 7 Categories (includes ModifyTerrain)
  366|       |// ============================================================================
  367|       |
  368|       |#[derive(Clone, Debug, Serialize, Deserialize)]
  369|       |#[serde(tag = "act")]
  370|       |pub enum ActionStep {
  371|       |    // ═══════════════════════════════════════
  372|       |    // MOVEMENT (6 tools)
  373|       |    // ═══════════════════════════════════════
  374|       |    /// Move to a specific position
  375|       |    MoveTo {
  376|       |        x: i32,
  377|       |        y: i32,
  378|       |        #[serde(default)]
  379|       |        speed: Option<MovementSpeed>,
  380|       |    },
  381|       |
  382|       |    /// Move toward target entity while maintaining distance
  383|       |    Approach {
  384|       |        target_id: Entity,
  385|       |        /// Desired distance (e.g., melee=2, ranged=15)
  386|       |        distance: f32,
  387|       |    },
  388|       |
  389|       |    /// Move away from target entity
  390|       |    Retreat {
  391|       |        target_id: Entity,
  392|       |        /// Safe distance to reach
  393|       |        distance: f32,
  394|       |    },
  395|       |
  396|       |    /// Take cover behind nearest obstacle
  397|       |    TakeCover {
  398|       |        /// Optional: specific cover position
  399|       |        position: Option<IVec2>,
  400|       |    },
  401|       |
  402|       |    /// Strafe around target (circle)
  403|       |    Strafe {
  404|       |        target_id: Entity,
  405|       |        direction: StrafeDirection,
  406|       |    },
  407|       |
  408|       |    /// Patrol between waypoints
  409|       |    Patrol { waypoints: Vec<IVec2> },
  410|       |
  411|       |    // ═══════════════════════════════════════
  412|       |    // OFFENSIVE (8 tools)
  413|       |    // ═══════════════════════════════════════
  414|       |    /// Basic attack targeting entity
  415|       |    Attack { target_id: Entity },
  416|       |
  417|       |    /// Aimed shot with higher accuracy
  418|       |    AimedShot { target_id: Entity },
  419|       |
  420|       |    /// Quick attack with lower damage
  421|       |    QuickAttack { target_id: Entity },
  422|       |
  423|       |    /// Heavy attack with higher damage
  424|       |    HeavyAttack { target_id: Entity },
  425|       |
  426|       |    /// Area-of-effect attack
  427|       |    AoEAttack { x: i32, y: i32, radius: f32 },
  428|       |
  429|       |    /// Throw explosive (grenade, etc.)
  430|       |    ThrowExplosive { x: i32, y: i32 },
  431|       |
  432|       |    /// Suppressive covering fire
  433|       |    CoverFire { target_id: Entity, duration: f32 },
  434|       |
  435|       |    /// Charge at target
  436|       |    Charge { target_id: Entity },
  437|       |
  438|       |    // ═══════════════════════════════════════
  439|       |    // DEFENSIVE (6 tools)
  440|       |    // ═══════════════════════════════════════
  441|       |    /// Block incoming attack
  442|       |    Block,
  443|       |
  444|       |    /// Dodge attack
  445|       |    Dodge { direction: Option<StrafeDirection> },
  446|       |
  447|       |    /// Parry incoming attack
  448|       |    Parry,
  449|       |
  450|       |    /// Throw smoke grenade
  451|       |    ThrowSmoke { x: i32, y: i32 },
  452|       |
  453|       |    /// Heal self or ally
  454|       |    Heal { target_id: Option<Entity> },
  455|       |
  456|       |    /// Use defensive ability
  457|       |    UseDefensiveAbility { ability_name: String },
  458|       |
  459|       |    // ═══════════════════════════════════════
  460|       |    // EQUIPMENT (5 tools)
  461|       |    // ═══════════════════════════════════════
  462|       |    /// Equip weapon
  463|       |    EquipWeapon { weapon_name: String },
  464|       |
  465|       |    /// Switch to different weapon
  466|       |    SwitchWeapon { slot: u32 },
  467|       |
  468|       |    /// Reload current weapon
  469|       |    Reload,
  470|       |
  471|       |    /// Use item from inventory
  472|       |    UseItem { item_name: String },
  473|       |
  474|       |    /// Drop item
  475|       |    DropItem { item_name: String },
  476|       |
  477|       |    // ═══════════════════════════════════════
  478|       |    // TACTICAL (7 tools)
  479|       |    // ═══════════════════════════════════════
  480|       |    /// Call for reinforcements
  481|       |    CallReinforcements { count: u32 },
  482|       |
  483|       |    /// Mark target for allies
  484|       |    MarkTarget { target_id: Entity },
  485|       |
  486|       |    /// Request covering fire
  487|       |    RequestCover { duration: f32 },
  488|       |
  489|       |    /// Coordinate attack with allies
  490|       |    CoordinateAttack { target_id: Entity },
  491|       |
  492|       |    /// Set up ambush
  493|       |    SetAmbush { position: IVec2 },
  494|       |
  495|       |    /// Distract enemy
  496|       |    Distract { target_id: Entity },
  497|       |
  498|       |    /// Regroup with allies
  499|       |    Regroup { rally_point: IVec2 },
  500|       |
  501|       |    // ═══════════════════════════════════════
  502|       |    // UTILITY (5 tools)
  503|       |    // ═══════════════════════════════════════
  504|       |    /// Scan area for threats
  505|       |    Scan { radius: f32 },
  506|       |
  507|       |    /// Wait for duration
  508|       |    Wait { duration: f32 },
  509|       |
  510|       |    /// Interact with object
  511|       |    Interact { target_id: Entity },
  512|       |
  513|       |    /// Use special ability
  514|       |    UseAbility { ability_name: String },
  515|       |
  516|       |    /// Taunt enemy
  517|       |    Taunt { target_id: Entity },
  518|       |
  519|       |    // ═══════════════════════════════════════
  520|       |    // LEGACY (kept for backward compatibility)
  521|       |    // ═══════════════════════════════════════
  522|       |    /// Generic throw (now use ThrowSmoke or ThrowExplosive)
  523|       |    Throw { item: String, x: i32, y: i32 },
  524|       |
  525|       |    /// Revive ally
  526|       |    Revive { ally_id: Entity },
  527|       |
  528|       |    // ═══════════════════════════════════════
  529|       |    // TERRAIN (1 tool) - AI-Orchestrated Dynamic Terrain
  530|       |    // ═══════════════════════════════════════
  531|       |    /// Modify terrain at a location (LLM-driven, validated by TerrainSolver)
  532|       |    ModifyTerrain {
  533|       |        /// Unique request identifier
  534|       |        request_id: String,
  535|       |        /// Full terrain generation request payload
  536|       |        payload: TerrainGenerationRequest,
  537|       |    },
  538|       |}
  539|       |
  540|       |#[derive(Clone, Debug, Serialize, Deserialize)]
  541|       |pub struct ToolSpec {
  542|       |    pub name: String,
  543|       |    pub args: BTreeMap<String, String>, // k: name, v: type ("i32","f32","enum[...]")
  544|       |}
  545|       |
  546|       |#[derive(Clone, Debug, Serialize, Deserialize)]
  547|       |pub struct ToolRegistry {
  548|       |    pub tools: Vec<ToolSpec>,
  549|       |    pub constraints: Constraints,
  550|       |}
  551|       |
  552|       |#[derive(Clone, Debug, Serialize, Deserialize)]
  553|       |pub struct Constraints {
  554|       |    pub enforce_cooldowns: bool,
  555|       |    pub enforce_los: bool,
  556|       |    pub enforce_stamina: bool,
  557|       |}
  558|       |
  559|       |#[derive(thiserror::Error, Debug)]
  560|       |pub enum EngineError {
  561|       |    #[error("invalid action: {0}")]
  562|       |    InvalidAction(String),
  563|       |    #[error("cooldown blocked: {0}")]
  564|       |    Cooldown(String),
  565|       |    #[error("line of sight blocked")]
  566|       |    LosBlocked,
  567|       |    #[error("path not found")]
  568|       |    NoPath,
  569|       |    #[error("resource missing: {0}")]
  570|       |    Resource(String),
  571|       |}
  572|       |
  573|       |#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
  574|       |pub struct Rect {
  575|       |    pub x0: i32,
  576|       |    pub y0: i32,
  577|       |    pub x1: i32,
  578|       |    pub y1: i32,
  579|       |}
  580|       |
  581|       |#[derive(Clone, Debug, Serialize, Deserialize)]
  582|       |#[serde(tag = "op")]
  583|       |pub enum DirectorOp {
  584|       |    Fortify {
  585|       |        rect: Rect,
  586|       |    }, // add obstacles
  587|       |    SpawnWave {
  588|       |        archetype: String,
  589|       |        count: u32,
  590|       |        origin: IVec2,
  591|       |    },
  592|       |    Collapse {
  593|       |        a: IVec2,
  594|       |        b: IVec2,
  595|       |    }, // line of obstacles ("bridge down")
  596|       |}
  597|       |
  598|       |#[derive(Clone, Debug, Serialize, Deserialize)]
  599|       |pub struct DirectorBudget {
  600|       |    pub traps: i32,
  601|       |    pub terrain_edits: i32,
  602|       |    pub spawns: i32,
  603|       |}
  604|       |
  605|       |#[derive(Clone, Debug, Serialize, Deserialize)]
  606|       |pub struct DirectorPlan {
  607|       |    pub ops: Vec<DirectorOp>,
  608|       |}
  609|       |
  610|       |#[cfg(test)]
  611|       |mod tests {
  612|       |    use super::*;
  613|       |
  614|       |    #[test]
  615|       |    fn test_ivec2_default() {
  616|       |        let v = IVec2::default();
  617|       |        assert_eq!(v.x, 0);
  618|       |        assert_eq!(v.y, 0);
  619|       |    }
  620|       |
  621|       |    #[test]
  622|       |    fn test_ivec2_equality() {
  623|       |        let v1 = IVec2 { x: 5, y: 10 };
  624|       |        let v2 = IVec2 { x: 5, y: 10 };
  625|       |        let v3 = IVec2 { x: 3, y: 10 };
  626|       |        assert_eq!(v1, v2);
  627|       |        assert_ne!(v1, v3);
  628|       |    }
  629|       |
  630|       |    #[test]
  631|       |    fn test_player_state_default() {
  632|       |        let player = PlayerState::default();
  633|       |        assert_eq!(player.hp, 100);
  634|       |        assert_eq!(player.pos, IVec2 { x: 0, y: 0 });
  635|       |        assert_eq!(player.stance, "stand");
  636|       |        assert!(player.orders.is_empty());
  637|       |    }
  638|       |
  639|       |    #[test]
  640|       |    fn test_companion_state_default() {
  641|       |        let companion = CompanionState::default();
  642|       |        assert_eq!(companion.ammo, 10);
  643|       |        assert_eq!(companion.morale, 1.0);
  644|       |        assert_eq!(companion.pos, IVec2 { x: 0, y: 0 });
  645|       |        assert!(companion.cooldowns.is_empty());
  646|       |    }
  647|       |
  648|       |    #[test]
  649|       |    fn test_enemy_state_default() {
  650|       |        let enemy = EnemyState::default();
  651|       |        assert_eq!(enemy.id, 0);
  652|       |        assert_eq!(enemy.hp, 100);
  653|       |        assert_eq!(enemy.cover, "none");
  654|       |        assert_eq!(enemy.last_seen, 0.0);
  655|       |    }
  656|       |
  657|       |    #[test]
  658|       |    fn test_poi_default() {
  659|       |        let poi = Poi::default();
  660|       |        assert_eq!(poi.k, "poi");
  661|       |        assert_eq!(poi.pos, IVec2 { x: 0, y: 0 });
  662|       |    }
  663|       |
  664|       |    #[test]
  665|       |    fn test_world_snapshot_default() {
  666|       |        let snapshot = WorldSnapshot::default();
  667|       |        assert_eq!(snapshot.t, 0.0);
  668|       |        assert!(snapshot.enemies.is_empty());
  669|       |        assert!(snapshot.pois.is_empty());
  670|       |        assert!(snapshot.obstacles.is_empty());
  671|       |        assert!(snapshot.objective.is_none());
  672|       |        assert!(snapshot.objective.is_none());
  673|       |    }
  674|       |
  675|       |    #[test]
  676|       |    fn test_plan_intent_default() {
  677|       |        let intent = PlanIntent::default();
  678|       |        assert!(intent.plan_id.is_empty());
  679|       |        assert!(intent.steps.is_empty());
  680|       |    }
  681|       |
  682|       |    #[test]
  683|       |    fn test_movement_speed_serde() {
  684|       |        let walk = MovementSpeed::Walk;
  685|       |        let json = serde_json::to_string(&walk).unwrap();
  686|       |        assert_eq!(json, "\"walk\"");
  687|       |
  688|       |        let deserialized: MovementSpeed = serde_json::from_str(&json).unwrap();
  689|       |        assert_eq!(deserialized, MovementSpeed::Walk);
  690|       |    }
  691|       |
  692|       |    #[test]
  693|       |    fn test_strafe_direction_serde() {
  694|       |        let left = StrafeDirection::Left;
  695|       |        let json = serde_json::to_string(&left).unwrap();
  696|       |        assert_eq!(json, "\"left\"");
  697|       |
  698|       |        let deserialized: StrafeDirection = serde_json::from_str(&json).unwrap();
  699|       |        assert_eq!(deserialized, StrafeDirection::Left);
  700|       |    }
  701|       |
  702|       |    #[test]
  703|       |    fn test_attack_type_serde() {
  704|       |        let heavy = AttackType::Heavy;
  705|       |        let json = serde_json::to_string(&heavy).unwrap();
  706|       |        assert_eq!(json, "\"heavy\"");
  707|       |    }
  708|       |
  709|       |    #[test]
  710|       |    fn test_action_step_move_to() {
  711|       |        let action = ActionStep::MoveTo {
  712|       |            x: 10,
  713|       |            y: 20,
  714|       |            speed: Some(MovementSpeed::Run),
  715|       |        };
  716|       |        let json = serde_json::to_string(&action).unwrap();
  717|       |        assert!(json.contains("\"act\":\"MoveTo\""));
  718|       |        assert!(json.contains("\"x\":10"));
  719|       |        assert!(json.contains("\"y\":20"));
  720|       |    }
  721|       |
  722|       |    #[test]
  723|       |    fn test_action_step_attack() {
  724|       |        let action = ActionStep::Attack { target_id: 42 };
  725|       |        let json = serde_json::to_string(&action).unwrap();
  726|       |        assert!(json.contains("\"act\":\"Attack\""));
  727|       |        assert!(json.contains("\"target_id\":42"));
  728|       |    }
  729|       |
  730|       |    #[test]
  731|       |    fn test_action_step_take_cover() {
  732|       |        let action = ActionStep::TakeCover { position: None };
  733|       |        let json = serde_json::to_string(&action).unwrap();
  734|       |        assert!(json.contains("\"act\":\"TakeCover\""));
  735|       |    }
  736|       |
  737|       |    #[test]
  738|       |    fn test_action_step_reload() {
  739|       |        let action = ActionStep::Reload;
  740|       |        let json = serde_json::to_string(&action).unwrap();
  741|       |        assert!(json.contains("\"act\":\"Reload\""));
  742|       |    }
  743|       |
  744|       |    #[test]
  745|       |    fn test_rect_structure() {
  746|       |        let rect = Rect {
  747|       |            x0: 0,
  748|       |            y0: 0,
  749|       |            x1: 10,
  750|       |            y1: 10,
  751|       |        };
  752|       |        assert_eq!(rect.x0, 0);
  753|       |        assert_eq!(rect.x1, 10);
  754|       |    }
  755|       |
  756|       |    #[test]
  757|       |    fn test_director_op_spawn_wave() {
  758|       |        let op = DirectorOp::SpawnWave {
  759|       |            archetype: "zombie".to_string(),
  760|       |            count: 5,
  761|       |            origin: IVec2 { x: 100, y: 200 },
  762|       |        };
  763|       |        let json = serde_json::to_string(&op).unwrap();
  764|       |        assert!(json.contains("\"op\":\"SpawnWave\""));
  765|       |        assert!(json.contains("\"count\":5"));
  766|       |    }
  767|       |
  768|       |    #[test]
  769|       |    fn test_director_budget() {
  770|       |        let budget = DirectorBudget {
  771|       |            traps: 3,
  772|       |            terrain_edits: 5,
  773|       |            spawns: 10,
  774|       |        };
  775|       |        assert_eq!(budget.traps, 3);
  776|       |        assert_eq!(budget.spawns, 10);
  777|       |    }
  778|       |
  779|       |    #[test]
  780|       |    fn test_tool_registry() {
  781|       |        let registry = ToolRegistry {
  782|       |            tools: vec![],
  783|       |            constraints: Constraints {
  784|       |                enforce_cooldowns: true,
  785|       |                enforce_los: false,
  786|       |                enforce_stamina: true,
  787|       |            },
  788|       |        };
  789|       |        assert!(registry.constraints.enforce_cooldowns);
  790|       |        assert!(!registry.constraints.enforce_los);
  791|       |    }
  792|       |
  793|       |    #[test]
  794|       |    fn test_engine_error_display() {
  795|       |        let err = EngineError::InvalidAction("test".to_string());
  796|       |        assert_eq!(err.to_string(), "invalid action: test");
  797|       |
  798|       |        let err2 = EngineError::LosBlocked;
  799|       |        assert_eq!(err2.to_string(), "line of sight blocked");
  800|       |    }
  801|       |
  802|       |    #[test]
  803|       |    fn test_world_snapshot_with_data() {
  804|       |        let snapshot = WorldSnapshot {
  805|       |            t: 10.5,
  806|       |            player: PlayerState::default(),
  807|       |            me: CompanionState::default(),
  808|       |            enemies: vec![EnemyState::default()],
  809|       |            pois: vec![Poi::default()],
  810|       |            obstacles: vec![IVec2 { x: 5, y: 5 }],
  811|       |            objective: Some("Survive".to_string()),
  812|       |        };
  813|       |        assert_eq!(snapshot.t, 10.5);
  814|       |        assert_eq!(snapshot.enemies.len(), 1);
  815|       |        assert_eq!(snapshot.pois.len(), 1);
  816|       |        assert_eq!(snapshot.obstacles.len(), 1);
  817|       |        assert_eq!(snapshot.objective, Some("Survive".to_string()));
  818|       |    }
  819|       |
  820|       |    #[test]
  821|       |    fn test_action_step_deserialization() {
  822|       |        let json = r#"{"act":"MoveTo","x":5,"y":10,"speed":"run"}"#;
  823|       |        let action: ActionStep = serde_json::from_str(json).unwrap();
  824|       |
  825|       |        match action {
  826|       |            ActionStep::MoveTo { x, y, speed } => {
  827|       |                assert_eq!(x, 5);
  828|       |                assert_eq!(y, 10);
  829|       |                assert_eq!(speed, Some(MovementSpeed::Run));
  830|       |            }
  831|       |            _ => panic!("Expected MoveTo action"),
  832|       |        }
  833|       |    }
  834|       |
  835|       |    #[test]
  836|       |    fn test_companion_state_cooldowns() {
  837|       |        let mut companion = CompanionState::default();
  838|       |        companion.cooldowns.insert("attack".to_string(), 2.5);
  839|       |        companion.cooldowns.insert("reload".to_string(), 1.0);
  840|       |
  841|       |        assert_eq!(companion.cooldowns.get("attack"), Some(&2.5));
  842|       |        assert_eq!(companion.cooldowns.len(), 2);
  843|       |    }
  844|       |
  845|       |    #[test]
  846|       |    fn test_plan_intent_with_steps() {
  847|       |        let intent = PlanIntent {
  848|       |            plan_id: "plan_123".to_string(),
  849|       |            steps: vec![
  850|       |                ActionStep::MoveTo {
  851|       |                    x: 10,
  852|       |                    y: 20,
  853|       |                    speed: None,
  854|       |                },
  855|       |                ActionStep::Attack { target_id: 5 },
  856|       |                ActionStep::Reload,
  857|       |            ],
  858|       |        };
  859|       |        assert_eq!(intent.plan_id, "plan_123");
  860|       |        assert_eq!(intent.steps.len(), 3);
  861|       |    }
  862|       |
  863|       |    #[test]
  864|       |    fn test_all_action_steps_compile() {
  865|       |        // Ensure all ActionStep variants compile
  866|       |        let _ = ActionStep::MoveTo {
  867|       |            x: 0,
  868|       |            y: 0,
  869|       |            speed: None,
  870|       |        };
  871|       |        let _ = ActionStep::Approach {
  872|       |            target_id: 1,
  873|       |            distance: 5.0,
  874|       |        };
  875|       |        let _ = ActionStep::Retreat {
  876|       |            target_id: 1,
  877|       |            distance: 10.0,
  878|       |        };
  879|       |        let _ = ActionStep::TakeCover { position: None };
  880|       |        let _ = ActionStep::Strafe {
  881|       |            target_id: 1,
  882|       |            direction: StrafeDirection::Left,
  883|       |        };
  884|       |        let _ = ActionStep::Patrol { waypoints: vec![] };
  885|       |        let _ = ActionStep::Attack { target_id: 1 };
  886|       |        let _ = ActionStep::AimedShot { target_id: 1 };
  887|       |        let _ = ActionStep::QuickAttack { target_id: 1 };
  888|       |        let _ = ActionStep::HeavyAttack { target_id: 1 };
  889|       |        let _ = ActionStep::AoEAttack {
  890|       |            x: 0,
  891|       |            y: 0,
  892|       |            radius: 5.0,
  893|       |        };
  894|       |        let _ = ActionStep::ThrowExplosive { x: 0, y: 0 };
  895|       |        let _ = ActionStep::CoverFire {
  896|       |            target_id: 1,
  897|       |            duration: 3.0,
  898|       |        };
  899|       |        let _ = ActionStep::Charge { target_id: 1 };
  900|       |        let _ = ActionStep::Block;
  901|       |        let _ = ActionStep::Dodge { direction: None };
  902|       |        let _ = ActionStep::Parry;
  903|       |        let _ = ActionStep::ThrowSmoke { x: 0, y: 0 };
  904|       |        let _ = ActionStep::Heal { target_id: None };
  905|       |        let _ = ActionStep::UseDefensiveAbility {
  906|       |            ability_name: "shield".to_string(),
  907|       |        };
  908|       |        let _ = ActionStep::EquipWeapon {
  909|       |            weapon_name: "sword".to_string(),
  910|       |        };
  911|       |        let _ = ActionStep::SwitchWeapon { slot: 1 };
  912|       |        let _ = ActionStep::Reload;
  913|       |        let _ = ActionStep::UseItem {
  914|       |            item_name: "potion".to_string(),
  915|       |        };
  916|       |        let _ = ActionStep::DropItem {
  917|       |            item_name: "trash".to_string(),
  918|       |        };
  919|       |        let _ = ActionStep::CallReinforcements { count: 3 };
  920|       |        let _ = ActionStep::MarkTarget { target_id: 1 };
  921|       |        let _ = ActionStep::RequestCover { duration: 5.0 };
  922|       |        let _ = ActionStep::CoordinateAttack { target_id: 1 };
  923|       |        let _ = ActionStep::SetAmbush {
  924|       |            position: IVec2 { x: 0, y: 0 },
  925|       |        };
  926|       |        let _ = ActionStep::Distract { target_id: 1 };
  927|       |        let _ = ActionStep::Regroup {
  928|       |            rally_point: IVec2 { x: 0, y: 0 },
  929|       |        };
  930|       |        let _ = ActionStep::Scan { radius: 10.0 };
  931|       |        let _ = ActionStep::Wait { duration: 2.0 };
  932|       |        let _ = ActionStep::Interact { target_id: 1 };
  933|       |        let _ = ActionStep::UseAbility {
  934|       |            ability_name: "fireball".to_string(),
  935|       |        };
  936|       |        let _ = ActionStep::Taunt { target_id: 1 };
  937|       |        let _ = ActionStep::Throw {
  938|       |            item: "grenade".to_string(),
  939|       |            x: 0,
  940|       |            y: 0,
  941|       |        };
  942|       |        let _ = ActionStep::Revive { ally_id: 1 };
  943|       |        // New terrain action
  944|       |        let _ = ActionStep::ModifyTerrain {
  945|       |            request_id: "test-req-1".to_string(),
  946|       |            payload: TerrainGenerationRequest::default(),
  947|       |        };
  948|       |    }
  949|       |
  950|       |    // =========================================================================
  951|       |    // TERRAIN DSL TESTS
  952|       |    // =========================================================================
  953|       |
  954|       |    #[test]
  955|       |    fn test_terrain_feature_type_default() {
  956|       |        let feature = TerrainFeatureType::default();
  957|       |        if let TerrainFeatureType::Crater { radius } = feature {
  958|       |            assert_eq!(radius, 10);
  959|       |        } else {
  960|       |            panic!("Default should be Crater");
  961|       |        }
  962|       |    }
  963|       |
  964|       |    #[test]
  965|       |    fn test_terrain_feature_type_serde() {
  966|       |        let cave = TerrainFeatureType::Cave { depth: 50 };
  967|       |        let json = serde_json::to_string(&cave).unwrap();
  968|       |        assert!(json.contains("\"type\":\"Cave\""));
  969|       |        assert!(json.contains("\"depth\":50"));
  970|       |
  971|       |        let forest = TerrainFeatureType::Forest { density: 0.8 };
  972|       |        let json = serde_json::to_string(&forest).unwrap();
  973|       |        assert!(json.contains("\"type\":\"Forest\""));
  974|       |    }
  975|       |
  976|       |    #[test]
  977|       |    fn test_cardinal_direction_to_unit_vector() {
  978|       |        let (x, z) = CardinalDirection::North.to_unit_vector();
  979|       |        assert!((x - 0.0).abs() < 0.001);
  980|       |        assert!((z - (-1.0)).abs() < 0.001);
  981|       |
  982|       |        let (x, z) = CardinalDirection::East.to_unit_vector();
  983|       |        assert!((x - 1.0).abs() < 0.001);
  984|       |        assert!((z - 0.0).abs() < 0.001);
  985|       |
  986|       |        let (x, z) = CardinalDirection::NorthEast.to_unit_vector();
  987|       |        assert!((x - 0.707).abs() < 0.001);
  988|       |        assert!((z - (-0.707)).abs() < 0.001);
  989|       |    }
  990|       |
  991|       |    #[test]
  992|       |    fn test_distance_category_to_range() {
  993|       |        let (min, max) = DistanceCategory::Near.to_range();
  994|       |        assert_eq!(min, 10.0);
  995|       |        assert_eq!(max, 50.0);
  996|       |
  997|       |        let (min, max) = DistanceCategory::Medium.to_range();
  998|       |        assert_eq!(min, 50.0);
  999|       |        assert_eq!(max, 150.0);
 1000|       |
 1001|       |        let (min, max) = DistanceCategory::Far.to_range();
 1002|       |        assert_eq!(min, 150.0);
 1003|       |        assert_eq!(max, 500.0);
 1004|       |    }
 1005|       |
 1006|       |    #[test]
 1007|       |    fn test_distance_category_midpoint() {
 1008|       |        assert_eq!(DistanceCategory::Near.midpoint(), 30.0);
 1009|       |        assert_eq!(DistanceCategory::Medium.midpoint(), 100.0);
 1010|       |        assert_eq!(DistanceCategory::Far.midpoint(), 325.0);
 1011|       |    }
 1012|       |
 1013|       |    #[test]
 1014|       |    fn test_relative_location_serde() {
 1015|       |        let los = RelativeLocation::LineOfSight {
 1016|       |            look_distance: 100.0,
 1017|       |        };
 1018|       |        let json = serde_json::to_string(&los).unwrap();
 1019|       |        assert!(json.contains("\"method\":\"LineOfSight\""));
 1020|       |        assert!(json.contains("\"look_distance\":100"));
 1021|       |
 1022|       |        let dir = RelativeLocation::DirectionFrom {
 1023|       |            cardinal: CardinalDirection::North,
 1024|       |            distance: DistanceCategory::Medium,
 1025|       |        };
 1026|       |        let json = serde_json::to_string(&dir).unwrap();
 1027|       |        assert!(json.contains("\"method\":\"DirectionFrom\""));
 1028|       |        assert!(json.contains("\"cardinal\":\"north\""));
 1029|       |        assert!(json.contains("\"distance\":\"medium\""));
 1030|       |    }
 1031|       |
 1032|       |    #[test]
 1033|       |    fn test_persistence_mode_default() {
 1034|       |        let mode = PersistenceMode::default();
 1035|       |        assert_eq!(mode, PersistenceMode::SessionOnly);
 1036|       |    }
 1037|       |
 1038|       |    #[test]
 1039|       |    fn test_terrain_generation_request_default() {
 1040|       |        let req = TerrainGenerationRequest::default();
 1041|       |        assert!(req.request_id.is_empty());
 1042|       |        assert_eq!(req.intensity, 0.5);
 1043|       |        assert!(req.biome_constraints.is_empty());
 1044|       |        assert_eq!(req.persistence_mode, PersistenceMode::SessionOnly);
 1045|       |    }
 1046|       |
 1047|       |    #[test]
 1048|       |    fn test_terrain_generation_request_validate_success() {
 1049|       |        let req = TerrainGenerationRequest {
 1050|       |            request_id: "test-123".to_string(),
 1051|       |            feature_type: TerrainFeatureType::Crater { radius: 20 },
 1052|       |            relative_location: RelativeLocation::LineOfSight {
 1053|       |                look_distance: 50.0,
 1054|       |            },
 1055|       |            intensity: 0.7,
 1056|       |            narrative_reason: "Creating a crater for quest objective".to_string(),
 1057|       |            persistence_mode: PersistenceMode::Persistent,
 1058|       |            biome_constraints: vec!["grassland".to_string()],
 1059|       |            seed: Some(12345),
 1060|       |        };
 1061|       |        assert!(req.validate().is_ok());
 1062|       |    }
 1063|       |
 1064|       |    #[test]
 1065|       |    fn test_terrain_generation_request_validate_intensity_too_high() {
 1066|       |        let req = TerrainGenerationRequest {
 1067|       |            request_id: "test-123".to_string(),
 1068|       |            intensity: 1.5, // Invalid
 1069|       |            ..TerrainGenerationRequest::default()
 1070|       |        };
 1071|       |        let result = req.validate();
 1072|       |        assert!(result.is_err());
 1073|       |        assert!(result.unwrap_err().contains("Intensity"));
 1074|       |    }
 1075|       |
 1076|       |    #[test]
 1077|       |    fn test_terrain_generation_request_validate_intensity_negative() {
 1078|       |        let req = TerrainGenerationRequest {
 1079|       |            request_id: "test-123".to_string(),
 1080|       |            intensity: -0.1, // Invalid
 1081|       |            ..TerrainGenerationRequest::default()
 1082|       |        };
 1083|       |        assert!(req.validate().is_err());
 1084|       |    }
 1085|       |
 1086|       |    #[test]
 1087|       |    fn test_terrain_generation_request_validate_narrative_too_long() {
 1088|       |        let req = TerrainGenerationRequest {
 1089|       |            request_id: "test-123".to_string(),
 1090|       |            narrative_reason: "x".repeat(101), // Too long
 1091|       |            ..TerrainGenerationRequest::default()
 1092|       |        };
 1093|       |        let result = req.validate();
 1094|       |        assert!(result.is_err());
 1095|       |        assert!(result.unwrap_err().contains("100 characters"));
 1096|       |    }
 1097|       |
 1098|       |    #[test]
 1099|       |    fn test_terrain_generation_request_validate_empty_request_id() {
 1100|       |        let req = TerrainGenerationRequest::default(); // Empty request_id
 1101|       |        let result = req.validate();
 1102|       |        assert!(result.is_err());
 1103|       |        assert!(result.unwrap_err().contains("Request ID"));
 1104|       |    }
 1105|       |
 1106|       |    #[test]
 1107|       |    fn test_action_step_modify_terrain_serde() {
 1108|       |        let action = ActionStep::ModifyTerrain {
 1109|       |            request_id: "terrain-001".to_string(),
 1110|       |            payload: TerrainGenerationRequest {
 1111|       |                request_id: "terrain-001".to_string(),
 1112|       |                feature_type: TerrainFeatureType::Cave { depth: 30 },
 1113|       |                relative_location: RelativeLocation::DirectionFrom {
 1114|       |                    cardinal: CardinalDirection::North,
 1115|       |                    distance: DistanceCategory::Near,
 1116|       |                },
 1117|       |                intensity: 0.6,
 1118|       |                narrative_reason: "Secret cave for quest".to_string(),
 1119|       |                persistence_mode: PersistenceMode::Persistent,
 1120|       |                biome_constraints: vec!["mountain".to_string(), "forest".to_string()],
 1121|       |                seed: Some(42),
 1122|       |            },
 1123|       |        };
 1124|       |        let json = serde_json::to_string(&action).unwrap();
 1125|       |        assert!(json.contains("\"act\":\"ModifyTerrain\""));
 1126|       |        assert!(json.contains("\"request_id\":\"terrain-001\""));
 1127|       |        assert!(json.contains("\"type\":\"Cave\""));
 1128|       |        assert!(json.contains("\"depth\":30"));
 1129|       |    }
 1130|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-core\src\sim.rs:
    1|       |use crate::World;
    2|       |
    3|       |pub struct SimConfig {
    4|       |    pub dt: f32,
    5|       |}
    6|       |
    7|      0|pub fn step(w: &mut World, cfg: &SimConfig) {
    8|      0|    w.tick(cfg.dt);
    9|      0|}
   10|       |
   11|       |#[cfg(test)]
   12|       |mod tests {
   13|       |    use super::*;
   14|       |
   15|       |    #[test]
   16|       |    fn test_sim_config_creation() {
   17|       |        let cfg = SimConfig { dt: 0.016 };
   18|       |        assert_eq!(cfg.dt, 0.016);
   19|       |    }
   20|       |
   21|       |    #[test]
   22|       |    fn test_sim_config_different_dt() {
   23|       |        let cfg1 = SimConfig { dt: 0.016 };
   24|       |        let cfg2 = SimConfig { dt: 0.033 };
   25|       |        assert_eq!(cfg1.dt, 0.016);
   26|       |        assert_eq!(cfg2.dt, 0.033);
   27|       |    }
   28|       |
   29|       |    #[test]
   30|       |    fn test_step_doesnt_crash() {
   31|       |        let mut world = World::new();
   32|       |        let cfg = SimConfig { dt: 0.016 };
   33|       |        step(&mut world, &cfg); // Should not crash
   34|       |    }
   35|       |
   36|       |    #[test]
   37|       |    fn test_step_multiple_times() {
   38|       |        let mut world = World::new();
   39|       |        let cfg = SimConfig { dt: 0.016 };
   40|       |        // Run 10 ticks without crashing
   41|       |        for _ in 0..10 {
   42|       |            step(&mut world, &cfg);
   43|       |        }
   44|       |    }
   45|       |
   46|       |    #[test]
   47|       |    fn test_step_with_different_dt_values() {
   48|       |        let mut world = World::new();
   49|       |
   50|       |        step(&mut world, &SimConfig { dt: 0.016 });
   51|       |        step(&mut world, &SimConfig { dt: 0.033 });
   52|       |        step(&mut world, &SimConfig { dt: 0.008 });
   53|       |        // Should not crash with varying dt
   54|       |    }
   55|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-core\src\tool_vocabulary.rs:
    1|       |//! Tool Vocabulary - Complete metadata for all 37 action tools
    2|       |//!
    3|       |//! This module provides comprehensive metadata for LLM prompt engineering,
    4|       |//! including descriptions, parameters, preconditions, and effects.
    5|       |
    6|       |use serde::{Deserialize, Serialize};
    7|       |
    8|       |/// Tool parameter definition
    9|       |#[derive(Clone, Debug, Serialize, Deserialize)]
   10|       |pub struct ToolParameter {
   11|       |    pub name: String,
   12|       |    pub param_type: String, // "i32", "f32", "Entity", "IVec2", etc.
   13|       |    pub required: bool,
   14|       |    pub description: String,
   15|       |}
   16|       |
   17|       |/// Complete tool metadata for LLM prompting
   18|       |#[derive(Clone, Debug, Serialize, Deserialize)]
   19|       |pub struct ToolMetadata {
   20|       |    pub name: String,
   21|       |    pub category: String,
   22|       |    pub description: String,
   23|       |    pub parameters: Vec<ToolParameter>,
   24|       |    pub preconditions: Vec<String>,
   25|       |    pub effects: Vec<String>,
   26|       |    pub cooldown: Option<f32>,
   27|       |    pub cost: Option<String>, // "ammo", "stamina", etc.
   28|       |}
   29|       |
   30|       |/// Get all tool metadata for LLM prompt engineering
   31|       |pub fn get_all_tools() -> Vec<ToolMetadata> {
   32|       |    vec![
   33|       |        // ═══════════════════════════════════════
   34|       |        // MOVEMENT (6 tools)
   35|       |        // ═══════════════════════════════════════
   36|       |        ToolMetadata {
   37|       |            name: "move_to".into(),
   38|       |            category: "Movement".into(),
   39|       |            description: "Move to a specific position on the map".into(),
   40|       |            parameters: vec![
   41|       |                ToolParameter {
   42|       |                    name: "x".into(),
   43|       |                    param_type: "i32".into(),
   44|       |                    required: true,
   45|       |                    description: "Target X coordinate".into(),
   46|       |                },
   47|       |                ToolParameter {
   48|       |                    name: "y".into(),
   49|       |                    param_type: "i32".into(),
   50|       |                    required: true,
   51|       |                    description: "Target Y coordinate".into(),
   52|       |                },
   53|       |                ToolParameter {
   54|       |                    name: "speed".into(),
   55|       |                    param_type: "MovementSpeed".into(),
   56|       |                    required: false,
   57|       |                    description: "Movement speed (Walk, Run, Sprint)".into(),
   58|       |                },
   59|       |            ],
   60|       |            preconditions: vec!["Path must be clear to target".into()],
   61|       |            effects: vec!["Agent position changes to (x, y)".into()],
   62|       |            cooldown: None,
   63|       |            cost: Some("stamina (if sprinting)".into()),
   64|       |        },
   65|       |        ToolMetadata {
   66|       |            name: "approach".into(),
   67|       |            category: "Movement".into(),
   68|       |            description: "Move toward target entity while maintaining specified distance".into(),
   69|       |            parameters: vec![
   70|       |                ToolParameter {
   71|       |                    name: "target_id".into(),
   72|       |                    param_type: "Entity".into(),
   73|       |                    required: true,
   74|       |                    description: "Entity to approach".into(),
   75|       |                },
   76|       |                ToolParameter {
   77|       |                    name: "distance".into(),
   78|       |                    param_type: "f32".into(),
   79|       |                    required: true,
   80|       |                    description: "Desired distance (e.g., 2 for melee, 15 for ranged)".into(),
   81|       |                },
   82|       |            ],
   83|       |            preconditions: vec!["Target entity must exist".into()],
   84|       |            effects: vec!["Agent moves closer to target".into()],
   85|       |            cooldown: None,
   86|       |            cost: None,
   87|       |        },
   88|       |        ToolMetadata {
   89|       |            name: "retreat".into(),
   90|       |            category: "Movement".into(),
   91|       |            description: "Move away from target entity to safe distance".into(),
   92|       |            parameters: vec![
   93|       |                ToolParameter {
   94|       |                    name: "target_id".into(),
   95|       |                    param_type: "Entity".into(),
   96|       |                    required: true,
   97|       |                    description: "Entity to retreat from".into(),
   98|       |                },
   99|       |                ToolParameter {
  100|       |                    name: "distance".into(),
  101|       |                    param_type: "f32".into(),
  102|       |                    required: true,
  103|       |                    description: "Safe distance to reach".into(),
  104|       |                },
  105|       |            ],
  106|       |            preconditions: vec!["Target entity must exist".into()],
  107|       |            effects: vec!["Agent moves away from target".into()],
  108|       |            cooldown: None,
  109|       |            cost: None,
  110|       |        },
  111|       |        ToolMetadata {
  112|       |            name: "take_cover".into(),
  113|       |            category: "Movement".into(),
  114|       |            description: "Take cover behind nearest obstacle or specified position".into(),
  115|       |            parameters: vec![ToolParameter {
  116|       |                name: "position".into(),
  117|       |                param_type: "IVec2?".into(),
  118|       |                required: false,
  119|       |                description: "Optional: specific cover position".into(),
  120|       |            }],
  121|       |            preconditions: vec!["Cover must be available".into()],
  122|       |            effects: vec!["Agent moves to cover, gains defensive bonus".into()],
  123|       |            cooldown: None,
  124|       |            cost: None,
  125|       |        },
  126|       |        ToolMetadata {
  127|       |            name: "strafe".into(),
  128|       |            category: "Movement".into(),
  129|       |            description: "Circle around target entity while maintaining line of sight".into(),
  130|       |            parameters: vec![
  131|       |                ToolParameter {
  132|       |                    name: "target_id".into(),
  133|       |                    param_type: "Entity".into(),
  134|       |                    required: true,
  135|       |                    description: "Entity to strafe around".into(),
  136|       |                },
  137|       |                ToolParameter {
  138|       |                    name: "direction".into(),
  139|       |                    param_type: "StrafeDirection".into(),
  140|       |                    required: true,
  141|       |                    description: "Direction to strafe (Left or Right)".into(),
  142|       |                },
  143|       |            ],
  144|       |            preconditions: vec!["Target entity must exist".into()],
  145|       |            effects: vec!["Agent circles target, harder to hit".into()],
  146|       |            cooldown: None,
  147|       |            cost: Some("stamina".into()),
  148|       |        },
  149|       |        ToolMetadata {
  150|       |            name: "patrol".into(),
  151|       |            category: "Movement".into(),
  152|       |            description: "Patrol between multiple waypoints".into(),
  153|       |            parameters: vec![ToolParameter {
  154|       |                name: "waypoints".into(),
  155|       |                param_type: "Vec<IVec2>".into(),
  156|       |                required: true,
  157|       |                description: "List of patrol waypoints".into(),
  158|       |            }],
  159|       |            preconditions: vec!["At least 2 waypoints required".into()],
  160|       |            effects: vec!["Agent moves between waypoints in sequence".into()],
  161|       |            cooldown: None,
  162|       |            cost: None,
  163|       |        },
  164|       |        // ═══════════════════════════════════════
  165|       |        // OFFENSIVE (8 tools)
  166|       |        // ═══════════════════════════════════════
  167|       |        ToolMetadata {
  168|       |            name: "attack".into(),
  169|       |            category: "Offensive".into(),
  170|       |            description: "Basic attack targeting entity (10 damage)".into(),
  171|       |            parameters: vec![ToolParameter {
  172|       |                name: "target_id".into(),
  173|       |                param_type: "Entity".into(),
  174|       |                required: true,
  175|       |                description: "Entity to attack".into(),
  176|       |            }],
  177|       |            preconditions: vec!["Target in range".into(), "Line of sight clear".into()],
  178|       |            effects: vec!["Deals 10 damage to target".into()],
  179|       |            cooldown: Some(1.0),
  180|       |            cost: None,
  181|       |        },
  182|       |        ToolMetadata {
  183|       |            name: "aimed_shot".into(),
  184|       |            category: "Offensive".into(),
  185|       |            description: "Aimed shot with higher accuracy and damage (15 damage)".into(),
  186|       |            parameters: vec![ToolParameter {
  187|       |                name: "target_id".into(),
  188|       |                param_type: "Entity".into(),
  189|       |                required: true,
  190|       |                description: "Entity to target".into(),
  191|       |            }],
  192|       |            preconditions: vec![
  193|       |                "Target in range".into(),
  194|       |                "Line of sight clear".into(),
  195|       |                "Not moving".into(),
  196|       |            ],
  197|       |            effects: vec!["Deals 15 damage, higher accuracy".into()],
  198|       |            cooldown: Some(2.0),
  199|       |            cost: Some("ammo".into()),
  200|       |        },
  201|       |        ToolMetadata {
  202|       |            name: "quick_attack".into(),
  203|       |            category: "Offensive".into(),
  204|       |            description: "Fast attack with lower damage (5 damage)".into(),
  205|       |            parameters: vec![ToolParameter {
  206|       |                name: "target_id".into(),
  207|       |                param_type: "Entity".into(),
  208|       |                required: true,
  209|       |                description: "Entity to attack".into(),
  210|       |            }],
  211|       |            preconditions: vec!["Target in melee range".into()],
  212|       |            effects: vec!["Deals 5 damage, fast execution".into()],
  213|       |            cooldown: Some(0.5),
  214|       |            cost: None,
  215|       |        },
  216|       |        ToolMetadata {
  217|       |            name: "heavy_attack".into(),
  218|       |            category: "Offensive".into(),
  219|       |            description: "Powerful attack with high damage (25 damage)".into(),
  220|       |            parameters: vec![ToolParameter {
  221|       |                name: "target_id".into(),
  222|       |                param_type: "Entity".into(),
  223|       |                required: true,
  224|       |                description: "Entity to attack".into(),
  225|       |            }],
  226|       |            preconditions: vec!["Target in melee range".into(), "Sufficient stamina".into()],
  227|       |            effects: vec!["Deals 25 damage, slow execution".into()],
  228|       |            cooldown: Some(3.0),
  229|       |            cost: Some("stamina".into()),
  230|       |        },
  231|       |        ToolMetadata {
  232|       |            name: "aoe_attack".into(),
  233|       |            category: "Offensive".into(),
  234|       |            description: "Area-of-effect attack damaging all entities in radius".into(),
  235|       |            parameters: vec![
  236|       |                ToolParameter {
  237|       |                    name: "x".into(),
  238|       |                    param_type: "i32".into(),
  239|       |                    required: true,
  240|       |                    description: "Center X coordinate".into(),
  241|       |                },
  242|       |                ToolParameter {
  243|       |                    name: "y".into(),
  244|       |                    param_type: "i32".into(),
  245|       |                    required: true,
  246|       |                    description: "Center Y coordinate".into(),
  247|       |                },
  248|       |                ToolParameter {
  249|       |                    name: "radius".into(),
  250|       |                    param_type: "f32".into(),
  251|       |                    required: true,
  252|       |                    description: "Effect radius".into(),
  253|       |                },
  254|       |            ],
  255|       |            preconditions: vec!["Target area in range".into()],
  256|       |            effects: vec!["Damages all entities in radius".into()],
  257|       |            cooldown: Some(5.0),
  258|       |            cost: Some("ability charge".into()),
  259|       |        },
  260|       |        ToolMetadata {
  261|       |            name: "throw_explosive".into(),
  262|       |            category: "Offensive".into(),
  263|       |            description: "Throw grenade or explosive to target location".into(),
  264|       |            parameters: vec![
  265|       |                ToolParameter {
  266|       |                    name: "x".into(),
  267|       |                    param_type: "i32".into(),
  268|       |                    required: true,
  269|       |                    description: "Target X coordinate".into(),
  270|       |                },
  271|       |                ToolParameter {
  272|       |                    name: "y".into(),
  273|       |                    param_type: "i32".into(),
  274|       |                    required: true,
  275|       |                    description: "Target Y coordinate".into(),
  276|       |                },
  277|       |            ],
  278|       |            preconditions: vec!["Grenade in inventory".into(), "Line of sight clear".into()],
  279|       |            effects: vec!["Area damage at target location".into()],
  280|       |            cooldown: Some(8.0),
  281|       |            cost: Some("grenade".into()),
  282|       |        },
  283|       |        ToolMetadata {
  284|       |            name: "cover_fire".into(),
  285|       |            category: "Offensive".into(),
  286|       |            description: "Suppressive fire on target for duration".into(),
  287|       |            parameters: vec![
  288|       |                ToolParameter {
  289|       |                    name: "target_id".into(),
  290|       |                    param_type: "Entity".into(),
  291|       |                    required: true,
  292|       |                    description: "Entity to suppress".into(),
  293|       |                },
  294|       |                ToolParameter {
  295|       |                    name: "duration".into(),
  296|       |                    param_type: "f32".into(),
  297|       |                    required: true,
  298|       |                    description: "Duration in seconds".into(),
  299|       |                },
  300|       |            ],
  301|       |            preconditions: vec!["Ammo available".into(), "Line of sight clear".into()],
  302|       |            effects: vec!["Target suppressed, continuous damage".into()],
  303|       |            cooldown: Some(4.0),
  304|       |            cost: Some("ammo".into()),
  305|       |        },
  306|       |        ToolMetadata {
  307|       |            name: "charge".into(),
  308|       |            category: "Offensive".into(),
  309|       |            description: "Rush at target and attack".into(),
  310|       |            parameters: vec![ToolParameter {
  311|       |                name: "target_id".into(),
  312|       |                param_type: "Entity".into(),
  313|       |                required: true,
  314|       |                description: "Entity to charge".into(),
  315|       |            }],
  316|       |            preconditions: vec!["Target visible".into(), "Path clear".into()],
  317|       |            effects: vec!["Rapid movement to target, melee attack".into()],
  318|       |            cooldown: Some(6.0),
  319|       |            cost: Some("stamina".into()),
  320|       |        },
  321|       |        // ═══════════════════════════════════════
  322|       |        // DEFENSIVE (6 tools)
  323|       |        // ═══════════════════════════════════════
  324|       |        ToolMetadata {
  325|       |            name: "block".into(),
  326|       |            category: "Defensive".into(),
  327|       |            description: "Block incoming attack".into(),
  328|       |            parameters: vec![],
  329|       |            preconditions: vec!["Enemy attack incoming".into()],
  330|       |            effects: vec!["Reduces damage by 50%".into()],
  331|       |            cooldown: Some(1.0),
  332|       |            cost: None,
  333|       |        },
  334|       |        ToolMetadata {
  335|       |            name: "dodge".into(),
  336|       |            category: "Defensive".into(),
  337|       |            description: "Dodge incoming attack".into(),
  338|       |            parameters: vec![ToolParameter {
  339|       |                name: "direction".into(),
  340|       |                param_type: "StrafeDirection?".into(),
  341|       |                required: false,
  342|       |                description: "Optional: dodge direction".into(),
  343|       |            }],
  344|       |            preconditions: vec!["Enemy attack incoming".into(), "Sufficient stamina".into()],
  345|       |            effects: vec!["Avoid attack completely".into()],
  346|       |            cooldown: Some(2.0),
  347|       |            cost: Some("stamina".into()),
  348|       |        },
  349|       |        ToolMetadata {
  350|       |            name: "parry".into(),
  351|       |            category: "Defensive".into(),
  352|       |            description: "Parry incoming attack and counter".into(),
  353|       |            parameters: vec![],
  354|       |            preconditions: vec![
  355|       |                "Enemy attack incoming".into(),
  356|       |                "Melee weapon equipped".into(),
  357|       |            ],
  358|       |            effects: vec!["Blocks attack, stuns attacker".into()],
  359|       |            cooldown: Some(3.0),
  360|       |            cost: None,
  361|       |        },
  362|       |        ToolMetadata {
  363|       |            name: "throw_smoke".into(),
  364|       |            category: "Defensive".into(),
  365|       |            description: "Throw smoke grenade to obscure area".into(),
  366|       |            parameters: vec![
  367|       |                ToolParameter {
  368|       |                    name: "x".into(),
  369|       |                    param_type: "i32".into(),
  370|       |                    required: true,
  371|       |                    description: "Target X coordinate".into(),
  372|       |                },
  373|       |                ToolParameter {
  374|       |                    name: "y".into(),
  375|       |                    param_type: "i32".into(),
  376|       |                    required: true,
  377|       |                    description: "Target Y coordinate".into(),
  378|       |                },
  379|       |            ],
  380|       |            preconditions: vec![
  381|       |                "Smoke grenade in inventory".into(),
  382|       |                "Line of sight clear".into(),
  383|       |            ],
  384|       |            effects: vec!["Blocks line of sight in area".into()],
  385|       |            cooldown: Some(8.0),
  386|       |            cost: Some("smoke grenade".into()),
  387|       |        },
  388|       |        ToolMetadata {
  389|       |            name: "heal".into(),
  390|       |            category: "Defensive".into(),
  391|       |            description: "Heal self or ally (restores 20 HP)".into(),
  392|       |            parameters: vec![ToolParameter {
  393|       |                name: "target_id".into(),
  394|       |                param_type: "Entity?".into(),
  395|       |                required: false,
  396|       |                description: "Optional: ally to heal (self if not specified)".into(),
  397|       |            }],
  398|       |            preconditions: vec!["Medical kit available".into()],
  399|       |            effects: vec!["Restores 20 HP to target".into()],
  400|       |            cooldown: Some(10.0),
  401|       |            cost: Some("medical kit".into()),
  402|       |        },
  403|       |        ToolMetadata {
  404|       |            name: "use_defensive_ability".into(),
  405|       |            category: "Defensive".into(),
  406|       |            description: "Activate defensive ability (shield, armor buff, etc.)".into(),
  407|       |            parameters: vec![ToolParameter {
  408|       |                name: "ability_name".into(),
  409|       |                param_type: "String".into(),
  410|       |                required: true,
  411|       |                description: "Name of defensive ability".into(),
  412|       |            }],
  413|       |            preconditions: vec!["Ability available".into(), "Ability off cooldown".into()],
  414|       |            effects: vec!["Activates defensive effect".into()],
  415|       |            cooldown: Some(15.0),
  416|       |            cost: Some("ability charge".into()),
  417|       |        },
  418|       |        // ═══════════════════════════════════════
  419|       |        // EQUIPMENT (5 tools)
  420|       |        // ═══════════════════════════════════════
  421|       |        ToolMetadata {
  422|       |            name: "equip_weapon".into(),
  423|       |            category: "Equipment".into(),
  424|       |            description: "Equip weapon from inventory".into(),
  425|       |            parameters: vec![ToolParameter {
  426|       |                name: "weapon_name".into(),
  427|       |                param_type: "String".into(),
  428|       |                required: true,
  429|       |                description: "Name of weapon to equip".into(),
  430|       |            }],
  431|       |            preconditions: vec!["Weapon in inventory".into()],
  432|       |            effects: vec!["Weapon equipped and ready".into()],
  433|       |            cooldown: Some(1.0),
  434|       |            cost: None,
  435|       |        },
  436|       |        ToolMetadata {
  437|       |            name: "switch_weapon".into(),
  438|       |            category: "Equipment".into(),
  439|       |            description: "Switch to weapon in different slot".into(),
  440|       |            parameters: vec![ToolParameter {
  441|       |                name: "slot".into(),
  442|       |                param_type: "u32".into(),
  443|       |                required: true,
  444|       |                description: "Weapon slot number (0, 1, 2)".into(),
  445|       |            }],
  446|       |            preconditions: vec!["Weapon in slot".into()],
  447|       |            effects: vec!["Switches active weapon".into()],
  448|       |            cooldown: Some(0.5),
  449|       |            cost: None,
  450|       |        },
  451|       |        ToolMetadata {
  452|       |            name: "reload".into(),
  453|       |            category: "Equipment".into(),
  454|       |            description: "Reload current weapon to full ammo".into(),
  455|       |            parameters: vec![],
  456|       |            preconditions: vec!["Reserve ammo available".into()],
  457|       |            effects: vec!["Restores weapon ammo to max".into()],
  458|       |            cooldown: Some(2.0),
  459|       |            cost: Some("reserve ammo".into()),
  460|       |        },
  461|       |        ToolMetadata {
  462|       |            name: "use_item".into(),
  463|       |            category: "Equipment".into(),
  464|       |            description: "Use consumable item from inventory".into(),
  465|       |            parameters: vec![ToolParameter {
  466|       |                name: "item_name".into(),
  467|       |                param_type: "String".into(),
  468|       |                required: true,
  469|       |                description: "Name of item to use".into(),
  470|       |            }],
  471|       |            preconditions: vec!["Item in inventory".into()],
  472|       |            effects: vec!["Item effect applied".into()],
  473|       |            cooldown: Some(1.0),
  474|       |            cost: Some("item consumed".into()),
  475|       |        },
  476|       |        ToolMetadata {
  477|       |            name: "drop_item".into(),
  478|       |            category: "Equipment".into(),
  479|       |            description: "Drop item from inventory".into(),
  480|       |            parameters: vec![ToolParameter {
  481|       |                name: "item_name".into(),
  482|       |                param_type: "String".into(),
  483|       |                required: true,
  484|       |                description: "Name of item to drop".into(),
  485|       |            }],
  486|       |            preconditions: vec!["Item in inventory".into()],
  487|       |            effects: vec!["Item removed from inventory".into()],
  488|       |            cooldown: None,
  489|       |            cost: None,
  490|       |        },
  491|       |        // ═══════════════════════════════════════
  492|       |        // TACTICAL (7 tools)
  493|       |        // ═══════════════════════════════════════
  494|       |        ToolMetadata {
  495|       |            name: "call_reinforcements".into(),
  496|       |            category: "Tactical".into(),
  497|       |            description: "Request allied reinforcements".into(),
  498|       |            parameters: vec![ToolParameter {
  499|       |                name: "count".into(),
  500|       |                param_type: "u32".into(),
  501|       |                required: true,
  502|       |                description: "Number of reinforcements to call".into(),
  503|       |            }],
  504|       |            preconditions: vec!["Reinforcements available".into()],
  505|       |            effects: vec!["Allies spawn at friendly location".into()],
  506|       |            cooldown: Some(60.0),
  507|       |            cost: Some("command points".into()),
  508|       |        },
  509|       |        ToolMetadata {
  510|       |            name: "mark_target".into(),
  511|       |            category: "Tactical".into(),
  512|       |            description: "Mark target for allies to focus fire".into(),
  513|       |            parameters: vec![ToolParameter {
  514|       |                name: "target_id".into(),
  515|       |                param_type: "Entity".into(),
  516|       |                required: true,
  517|       |                description: "Entity to mark".into(),
  518|       |            }],
  519|       |            preconditions: vec!["Target visible".into()],
  520|       |            effects: vec!["Allies prioritize marked target".into()],
  521|       |            cooldown: Some(5.0),
  522|       |            cost: None,
  523|       |        },
  524|       |        ToolMetadata {
  525|       |            name: "request_cover".into(),
  526|       |            category: "Tactical".into(),
  527|       |            description: "Request covering fire from allies".into(),
  528|       |            parameters: vec![ToolParameter {
  529|       |                name: "duration".into(),
  530|       |                param_type: "f32".into(),
  531|       |                required: true,
  532|       |                description: "Duration in seconds".into(),
  533|       |            }],
  534|       |            preconditions: vec!["Allies available".into()],
  535|       |            effects: vec!["Allies provide suppressing fire".into()],
  536|       |            cooldown: Some(10.0),
  537|       |            cost: None,
  538|       |        },
  539|       |        ToolMetadata {
  540|       |            name: "coordinate_attack".into(),
  541|       |            category: "Tactical".into(),
  542|       |            description: "Coordinate simultaneous attack with allies".into(),
  543|       |            parameters: vec![ToolParameter {
  544|       |                name: "target_id".into(),
  545|       |                param_type: "Entity".into(),
  546|       |                required: true,
  547|       |                description: "Entity to attack together".into(),
  548|       |            }],
  549|       |            preconditions: vec!["Allies available".into(), "Target visible".into()],
  550|       |            effects: vec!["Synchronized attack with bonus damage".into()],
  551|       |            cooldown: Some(15.0),
  552|       |            cost: None,
  553|       |        },
  554|       |        ToolMetadata {
  555|       |            name: "set_ambush".into(),
  556|       |            category: "Tactical".into(),
  557|       |            description: "Set up ambush at position".into(),
  558|       |            parameters: vec![ToolParameter {
  559|       |                name: "position".into(),
  560|       |                param_type: "IVec2".into(),
  561|       |                required: true,
  562|       |                description: "Ambush position".into(),
  563|       |            }],
  564|       |            preconditions: vec!["Position has cover".into()],
  565|       |            effects: vec!["Gains stealth and first strike bonus".into()],
  566|       |            cooldown: Some(20.0),
  567|       |            cost: None,
  568|       |        },
  569|       |        ToolMetadata {
  570|       |            name: "distract".into(),
  571|       |            category: "Tactical".into(),
  572|       |            description: "Distract enemy to draw attention".into(),
  573|       |            parameters: vec![ToolParameter {
  574|       |                name: "target_id".into(),
  575|       |                param_type: "Entity".into(),
  576|       |                required: true,
  577|       |                description: "Entity to distract".into(),
  578|       |            }],
  579|       |            preconditions: vec!["Target visible".into()],
  580|       |            effects: vec!["Target focuses on agent, allies gain advantage".into()],
  581|       |            cooldown: Some(8.0),
  582|       |            cost: None,
  583|       |        },
  584|       |        ToolMetadata {
  585|       |            name: "regroup".into(),
  586|       |            category: "Tactical".into(),
  587|       |            description: "Rally allies to position".into(),
  588|       |            parameters: vec![ToolParameter {
  589|       |                name: "rally_point".into(),
  590|       |                param_type: "IVec2".into(),
  591|       |                required: true,
  592|       |                description: "Rally point coordinates".into(),
  593|       |            }],
  594|       |            preconditions: vec!["Allies available".into()],
  595|       |            effects: vec!["Allies move to rally point".into()],
  596|       |            cooldown: Some(10.0),
  597|       |            cost: None,
  598|       |        },
  599|       |        // ═══════════════════════════════════════
  600|       |        // UTILITY (5 tools)
  601|       |        // ═══════════════════════════════════════
  602|       |        ToolMetadata {
  603|       |            name: "scan".into(),
  604|       |            category: "Utility".into(),
  605|       |            description: "Scan area for threats and items".into(),
  606|       |            parameters: vec![ToolParameter {
  607|       |                name: "radius".into(),
  608|       |                param_type: "f32".into(),
  609|       |                required: true,
  610|       |                description: "Scan radius".into(),
  611|       |            }],
  612|       |            preconditions: vec![],
  613|       |            effects: vec!["Reveals enemies and items in radius".into()],
  614|       |            cooldown: Some(5.0),
  615|       |            cost: None,
  616|       |        },
  617|       |        ToolMetadata {
  618|       |            name: "wait".into(),
  619|       |            category: "Utility".into(),
  620|       |            description: "Wait for specified duration".into(),
  621|       |            parameters: vec![ToolParameter {
  622|       |                name: "duration".into(),
  623|       |                param_type: "f32".into(),
  624|       |                required: true,
  625|       |                description: "Duration in seconds".into(),
  626|       |            }],
  627|       |            preconditions: vec![],
  628|       |            effects: vec!["Agent waits, no action taken".into()],
  629|       |            cooldown: None,
  630|       |            cost: None,
  631|       |        },
  632|       |        ToolMetadata {
  633|       |            name: "interact".into(),
  634|       |            category: "Utility".into(),
  635|       |            description: "Interact with object or NPC".into(),
  636|       |            parameters: vec![ToolParameter {
  637|       |                name: "target_id".into(),
  638|       |                param_type: "Entity".into(),
  639|       |                required: true,
  640|       |                description: "Object or NPC to interact with".into(),
  641|       |            }],
  642|       |            preconditions: vec!["Target in range".into(), "Target is interactable".into()],
  643|       |            effects: vec!["Triggers interaction (open door, talk, etc.)".into()],
  644|       |            cooldown: Some(1.0),
  645|       |            cost: None,
  646|       |        },
  647|       |        ToolMetadata {
  648|       |            name: "use_ability".into(),
  649|       |            category: "Utility".into(),
  650|       |            description: "Use special ability".into(),
  651|       |            parameters: vec![ToolParameter {
  652|       |                name: "ability_name".into(),
  653|       |                param_type: "String".into(),
  654|       |                required: true,
  655|       |                description: "Name of ability to use".into(),
  656|       |            }],
  657|       |            preconditions: vec!["Ability available".into(), "Ability off cooldown".into()],
  658|       |            effects: vec!["Ability effect applied".into()],
  659|       |            cooldown: Some(10.0),
  660|       |            cost: Some("ability charge".into()),
  661|       |        },
  662|       |        ToolMetadata {
  663|       |            name: "taunt".into(),
  664|       |            category: "Utility".into(),
  665|       |            description: "Taunt enemy to provoke attack".into(),
  666|       |            parameters: vec![ToolParameter {
  667|       |                name: "target_id".into(),
  668|       |                param_type: "Entity".into(),
  669|       |                required: true,
  670|       |                description: "Entity to taunt".into(),
  671|       |            }],
  672|       |            preconditions: vec!["Target visible".into()],
  673|       |            effects: vec!["Target prioritizes agent for attack".into()],
  674|       |            cooldown: Some(6.0),
  675|       |            cost: None,
  676|       |        },
  677|       |    ]
  678|       |}
  679|       |
  680|       |/// Get tool categories for organization
  681|       |pub fn get_categories() -> Vec<String> {
  682|       |    vec![
  683|       |        "Movement".into(),
  684|       |        "Offensive".into(),
  685|       |        "Defensive".into(),
  686|       |        "Equipment".into(),
  687|       |        "Tactical".into(),
  688|       |        "Utility".into(),
  689|       |    ]
  690|       |}
  691|       |
  692|       |/// Get tools by category
  693|       |pub fn get_tools_by_category(category: &str) -> Vec<ToolMetadata> {
  694|       |    get_all_tools()
  695|       |        .into_iter()
  696|      0|        .filter(|t| t.category == category)
  697|       |        .collect()
  698|       |}
  699|       |
  700|       |/// Generate JSON schema for tool parameters (for LLM prompts)
  701|       |pub fn generate_tool_schema(tool: &ToolMetadata) -> String {
  702|       |    let mut schema = format!(r#"{{"act": "{}""#, tool.name);
  703|       |
  704|       |    for param in &tool.parameters {
  705|       |        if param.required {
  706|       |            schema.push_str(&format!(r#", "{}": <{}>"#, param.name, param.param_type));
  707|       |        } else {
  708|       |            schema.push_str(&format!(r#", "{}": <{}>?"#, param.name, param.param_type));
  709|       |        }
  710|       |    }
  711|       |
  712|       |    schema.push('}');
  713|       |    schema
  714|       |}
  715|       |
  716|       |#[cfg(test)]
  717|       |mod tests {
  718|       |    use super::*;
  719|       |
  720|       |    #[test]
  721|       |    fn test_all_tools_present() {
  722|       |        let tools = get_all_tools();
  723|       |        assert_eq!(tools.len(), 37, "Should have 37 tools");
  724|       |    }
  725|       |
  726|       |    #[test]
  727|       |    fn test_categories() {
  728|       |        let categories = get_categories();
  729|       |        assert_eq!(categories.len(), 6, "Should have 6 categories");
  730|       |
  731|       |        let tools = get_all_tools();
  732|       |        for tool in &tools {
  733|       |            assert!(
  734|       |                categories.contains(&tool.category),
  735|       |                "Tool {} has invalid category {}",
  736|       |                tool.name,
  737|       |                tool.category
  738|       |            );
  739|       |        }
  740|       |    }
  741|       |
  742|       |    #[test]
  743|       |    fn test_tools_by_category() {
  744|       |        let movement_tools = get_tools_by_category("Movement");
  745|       |        assert_eq!(movement_tools.len(), 6, "Should have 6 movement tools");
  746|       |
  747|       |        let offensive_tools = get_tools_by_category("Offensive");
  748|       |        assert_eq!(offensive_tools.len(), 8, "Should have 8 offensive tools");
  749|       |
  750|       |        let defensive_tools = get_tools_by_category("Defensive");
  751|       |        assert_eq!(defensive_tools.len(), 6, "Should have 6 defensive tools");
  752|       |
  753|       |        let equipment_tools = get_tools_by_category("Equipment");
  754|       |        assert_eq!(equipment_tools.len(), 5, "Should have 5 equipment tools");
  755|       |
  756|       |        let tactical_tools = get_tools_by_category("Tactical");
  757|       |        assert_eq!(tactical_tools.len(), 7, "Should have 7 tactical tools");
  758|       |
  759|       |        let utility_tools = get_tools_by_category("Utility");
  760|       |        assert_eq!(utility_tools.len(), 5, "Should have 5 utility tools");
  761|       |    }
  762|       |
  763|       |    #[test]
  764|       |    fn test_schema_generation() {
  765|       |        let tool = ToolMetadata {
  766|       |            name: "move_to".into(),
  767|       |            category: "Movement".into(),
  768|       |            description: "Test".into(),
  769|       |            parameters: vec![
  770|       |                ToolParameter {
  771|       |                    name: "x".into(),
  772|       |                    param_type: "i32".into(),
  773|       |                    required: true,
  774|       |                    description: "X coord".into(),
  775|       |                },
  776|       |                ToolParameter {
  777|       |                    name: "y".into(),
  778|       |                    param_type: "i32".into(),
  779|       |                    required: true,
  780|       |                    description: "Y coord".into(),
  781|       |                },
  782|       |            ],
  783|       |            preconditions: vec![],
  784|       |            effects: vec![],
  785|       |            cooldown: None,
  786|       |            cost: None,
  787|       |        };
  788|       |
  789|       |        let schema = generate_tool_schema(&tool);
  790|       |        // Tool name is converted to snake_case
  791|       |        assert!(schema.contains(r#""act": "move_to""#));
  792|       |        assert!(schema.contains(r#""x": <i32>"#));
  793|       |        assert!(schema.contains(r#""y": <i32>"#));
  794|       |    }
  795|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-core\src\tools.rs:
    1|       |use serde::{Deserialize, Serialize};
    2|       |use std::collections::{HashMap, HashSet};
    3|       |// Import glam::IVec2 with an alias to avoid name conflicts
    4|       |use glam::IVec2 as GlamIVec2;
    5|       |
    6|       |#[derive(Debug, Clone)]
    7|       |pub struct Poi {
    8|       |    /// Unique key or name for the POI
    9|       |    pub key: String,
   10|       |    /// Grid or world position of the POI
   11|       |    pub position: GlamIVec2,
   12|       |    /// Description or lore for the POI
   13|       |    pub description: Option<String>,
   14|       |    /// Is the POI currently active or discoverable in the world?
   15|       |    pub active: bool,
   16|       |}
   17|       |
   18|       |#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, Hash)]
   19|       |pub enum Tool {
   20|       |    MoveTo,
   21|       |    Throw,     // item: smoke|grenade
   22|       |    CoverFire, // duration
   23|       |    Revive,
   24|       |}
   25|       |
   26|       |#[derive(Default)]
   27|       |pub struct ToolCtx {
   28|       |    pub allowed: HashSet<Tool>,
   29|       |    pub argspecs: HashMap<Tool, Vec<(&'static str, &'static str)>>, // (arg_name, type)
   30|       |}
   31|       |
   32|       |impl ToolCtx {
   33|      0|    pub fn basic_combat() -> Self {
   34|       |        use Tool::*;
   35|      0|        let mut allowed = HashSet::new();
   36|      0|        allowed.insert(MoveTo);
   37|      0|        allowed.insert(Throw);
   38|      0|        allowed.insert(CoverFire);
   39|      0|        allowed.insert(Revive);
   40|      0|        let mut argspecs = HashMap::new();
   41|      0|        argspecs.insert(MoveTo, vec![("x", "i32"), ("y", "i32")]);
   42|      0|        argspecs.insert(
   43|      0|            Throw,
   44|      0|            vec![("item", "enum[smoke,grenade]"), ("x", "i32"), ("y", "i32")],
   45|       |        );
   46|      0|        argspecs.insert(CoverFire, vec![("target_id", "u32"), ("duration", "f32")]);
   47|      0|        argspecs.insert(Revive, vec![("ally_id", "u32")]);
   48|      0|        Self { allowed, argspecs }
   49|      0|    }
   50|       |}
   51|       |
   52|       |// Convert from schema::IVec2 to glam::IVec2
   53|     50|pub fn schema_to_glam(v: crate::IVec2) -> GlamIVec2 {
   54|     50|    GlamIVec2::new(v.x, v.y)
   55|     50|}
   56|       |
   57|       |// Convert from glam::IVec2 to schema::IVec2
   58|      0|pub fn glam_to_schema(v: GlamIVec2) -> crate::IVec2 {
   59|      0|    crate::IVec2 { x: v.x, y: v.y }
   60|      0|}
   61|       |
   62|       |// simple grid LOS
   63|      0|pub fn los_clear(
   64|      0|    obstacles: &std::collections::HashSet<(i32, i32)>,
   65|      0|    a: crate::IVec2,
   66|      0|    b: crate::IVec2,
   67|      0|) -> bool {
   68|       |    // Convert schema::IVec2 to glam::IVec2
   69|      0|    let a_glam = schema_to_glam(a);
   70|      0|    let b_glam = schema_to_glam(b);
   71|       |
   72|      0|    let mut x = a_glam.x;
   73|      0|    let mut y = a_glam.y;
   74|      0|    let dx = (b_glam.x - a_glam.x).signum();
   75|      0|    let dy = (b_glam.y - a_glam.y).signum();
   76|      0|    while x != b_glam.x || y != b_glam.y {
   77|      0|        if obstacles.contains(&(x, y)) {
   78|      0|            return false;
   79|      0|        }
   80|      0|        if x != b_glam.x {
   81|      0|            x += dx;
   82|      0|        }
   83|      0|        if y != b_glam.y {
   84|      0|            y += dy;
   85|      0|        }
   86|       |    }
   87|      0|    true
   88|      0|}
   89|       |
   90|       |// 4-neighbor BFS for path existence
   91|     25|pub fn path_exists(
   92|     25|    obstacles: &HashSet<(i32, i32)>,
   93|     25|    start: crate::IVec2,
   94|     25|    goal: crate::IVec2,
   95|     25|    bounds: (i32, i32, i32, i32),
   96|     25|) -> bool {
   97|       |    // Convert schema::IVec2 to glam::IVec2
   98|     25|    let start_glam = schema_to_glam(start);
   99|     25|    let goal_glam = schema_to_glam(goal);
  100|       |
  101|       |    use std::collections::VecDeque;
  102|     25|    let (minx, miny, maxx, maxy) = bounds;
  103|     25|    let mut q = VecDeque::new();
  104|     25|    let mut seen = HashSet::new();
  105|     25|    q.push_back(start_glam);
  106|     25|    seen.insert((start_glam.x, start_glam.y));
  107|    453|    while let Some(p) = q.pop_front() {
                                 ^451
  108|    451|        if p.x == goal_glam.x && p.y == goal_glam.y {
                                               ^26
  109|     23|            return true;
  110|    428|        }
  111|  1.71k|        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)] {
                                       ^428    ^428     ^428    ^428
  112|  1.71k|            let nx = p.x + dx;
  113|  1.71k|            let ny = p.y + dy;
  114|  1.71k|            if nx < minx || ny < miny || nx > maxx || ny > maxy {
                                          ^1.69k       ^1.63k       ^1.61k
  115|    138|                continue;
  116|  1.57k|            }
  117|  1.57k|            if obstacles.contains(&(nx, ny)) {
  118|     44|                continue;
  119|  1.53k|            }
  120|  1.53k|            if seen.insert((nx, ny)) {
  121|    487|                q.push_back(GlamIVec2::new(nx, ny));
  122|  1.04k|            }
  123|       |        }
  124|       |    }
  125|      2|    false
  126|     25|}
  127|       |
  128|       |use std::cmp::Ordering;
  129|       |
  130|       |// A* grid path (4-neighbor) returning a path (including start & goal) or empty if none.
  131|      0|pub fn astar_path(
  132|      0|    obstacles: &std::collections::HashSet<(i32, i32)>,
  133|      0|    start: crate::IVec2,
  134|      0|    goal: crate::IVec2,
  135|      0|    bounds: (i32, i32, i32, i32),
  136|      0|) -> Vec<crate::IVec2> {
  137|       |    // Convert schema::IVec2 to glam::IVec2
  138|      0|    let start_glam = schema_to_glam(start);
  139|      0|    let goal_glam = schema_to_glam(goal);
  140|       |
  141|       |    use std::collections::{BinaryHeap, HashMap, HashSet};
  142|       |    #[derive(Copy, Clone, Eq, PartialEq)]
  143|       |    struct Node {
  144|       |        f: i32,
  145|       |        x: i32,
  146|       |        y: i32,
  147|       |    }
  148|       |    impl Ord for Node {
  149|      0|        fn cmp(&self, other: &Self) -> Ordering {
  150|      0|            other.f.cmp(&self.f)
  151|      0|        }
  152|       |    }
  153|       |    impl PartialOrd for Node {
  154|      0|        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
  155|      0|            Some(self.cmp(other))
  156|      0|        }
  157|       |    }
  158|       |
  159|      0|    let (minx, miny, maxx, maxy) = bounds;
  160|      0|    let h = |a: GlamIVec2, b: GlamIVec2| (a.x - b.x).abs() + (a.y - b.y).abs();
  161|      0|    let mut open = BinaryHeap::new();
  162|      0|    let mut came: HashMap<(i32, i32), (i32, i32)> = HashMap::new();
  163|      0|    let mut g: HashMap<(i32, i32), i32> = HashMap::new();
  164|      0|    let mut seen: HashSet<(i32, i32)> = HashSet::new();
  165|       |
  166|      0|    let s = (start_glam.x, start_glam.y);
  167|      0|    let t = (goal_glam.x, goal_glam.y);
  168|      0|    g.insert(s, 0);
  169|      0|    open.push(Node {
  170|      0|        f: h(start_glam, goal_glam),
  171|      0|        x: start_glam.x,
  172|      0|        y: start_glam.y,
  173|      0|    });
  174|      0|    seen.insert(s);
  175|       |
  176|      0|    while let Some(Node { f: _, x, y }) = open.pop() {
  177|      0|        if (x, y) == t {
  178|       |            // reconstruct
  179|      0|            let mut path = vec![glam_to_schema(GlamIVec2::new(x, y))];
  180|      0|            let mut cur = (x, y);
  181|      0|            while let Some(&prev) = came.get(&cur) {
  182|      0|                if prev == cur {
  183|      0|                    break;
  184|      0|                }
  185|      0|                cur = prev;
  186|      0|                path.push(glam_to_schema(GlamIVec2::new(cur.0, cur.1)));
  187|       |            }
  188|      0|            path.reverse();
  189|      0|            return path;
  190|      0|        }
  191|      0|        let cur_g = *g.get(&(x, y)).unwrap_or(&i32::MAX);
  192|      0|        for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)] {
  193|      0|            let nx = x + dx;
  194|      0|            let ny = y + dy;
  195|      0|            if nx < minx || ny < miny || nx > maxx || ny > maxy {
  196|      0|                continue;
  197|      0|            }
  198|      0|            if obstacles.contains(&(nx, ny)) {
  199|      0|                continue;
  200|      0|            }
  201|      0|            let ng = cur_g + 1;
  202|      0|            let pos = (nx, ny);
  203|      0|            if ng < *g.get(&pos).unwrap_or(&i32::MAX) {
  204|      0|                came.insert(pos, (x, y));
  205|      0|                g.insert(pos, ng);
  206|      0|                let prio = ng + h(GlamIVec2::new(nx, ny), goal_glam);
  207|      0|                open.push(Node {
  208|      0|                    f: prio,
  209|      0|                    x: nx,
  210|      0|                    y: ny,
  211|      0|                });
  212|      0|            }
  213|       |        }
  214|       |    }
  215|      0|    vec![]
  216|      0|}
  217|       |
  218|       |// Find positions within radius of `from` that have LOS from player but *not* from enemy (crude "cover")
  219|      0|pub fn find_cover_positions(
  220|      0|    obstacles: &std::collections::HashSet<(i32, i32)>,
  221|      0|    bounds: (i32, i32, i32, i32),
  222|      0|    from: crate::IVec2,
  223|      0|    player: crate::IVec2,
  224|      0|    enemy: crate::IVec2,
  225|      0|    radius: i32,
  226|      0|) -> Vec<crate::IVec2> {
  227|       |    // Convert schema::IVec2 to glam::IVec2
  228|      0|    let from_glam = schema_to_glam(from);
  229|      0|    let _player_glam = schema_to_glam(player);
  230|      0|    let _enemy_glam = schema_to_glam(enemy);
  231|       |
  232|      0|    let (minx, miny, maxx, maxy) = bounds;
  233|      0|    let mut out = vec![];
  234|      0|    for dx in -radius..=radius {
  235|      0|        for dy in -radius..=radius {
  236|      0|            let nx = from_glam.x + dx;
  237|      0|            let ny = from_glam.y + dy;
  238|      0|            if nx < minx || ny < miny || nx > maxx || ny > maxy {
  239|      0|                continue;
  240|      0|            }
  241|      0|            if obstacles.contains(&(nx, ny)) {
  242|      0|                continue;
  243|      0|            }
  244|      0|            let p = GlamIVec2::new(nx, ny);
  245|      0|            let los_player = los_clear(obstacles, player, glam_to_schema(p));
  246|      0|            let los_enemy = los_clear(obstacles, enemy, glam_to_schema(p));
  247|      0|            if los_player && !los_enemy {
  248|      0|                out.push(glam_to_schema(p));
  249|      0|            }
  250|       |        }
  251|       |    }
  252|      0|    out
  253|      0|}
  254|       |
  255|       |#[cfg(test)]
  256|       |mod tests {
  257|       |    use super::*;
  258|       |
  259|       |    // Helper to create schema IVec2
  260|       |    fn iv2(x: i32, y: i32) -> crate::IVec2 {
  261|       |        crate::IVec2 { x, y }
  262|       |    }
  263|       |
  264|       |    // ===== POI Tests =====
  265|       |    #[test]
  266|       |    fn test_poi_creation() {
  267|       |        let poi = Poi {
  268|       |            key: "waypoint_1".to_string(),
  269|       |            position: GlamIVec2::new(10, 20),
  270|       |            description: Some("Test waypoint".to_string()),
  271|       |            active: true,
  272|       |        };
  273|       |        assert_eq!(poi.key, "waypoint_1");
  274|       |        assert_eq!(poi.position, GlamIVec2::new(10, 20));
  275|       |        assert!(poi.active);
  276|       |    }
  277|       |
  278|       |    #[test]
  279|       |    fn test_poi_inactive() {
  280|       |        let poi = Poi {
  281|       |            key: "hidden".to_string(),
  282|       |            position: GlamIVec2::new(5, 5),
  283|       |            description: None,
  284|       |            active: false,
  285|       |        };
  286|       |        assert!(!poi.active);
  287|       |        assert!(poi.description.is_none());
  288|       |    }
  289|       |
  290|       |    // ===== Tool & ToolCtx Tests =====
  291|       |    #[test]
  292|       |    fn test_tool_ctx_basic_combat() {
  293|       |        let ctx = ToolCtx::basic_combat();
  294|       |        assert!(ctx.allowed.contains(&Tool::MoveTo));
  295|       |        assert!(ctx.allowed.contains(&Tool::Throw));
  296|       |        assert!(ctx.allowed.contains(&Tool::CoverFire));
  297|       |        assert!(ctx.allowed.contains(&Tool::Revive));
  298|       |        assert_eq!(ctx.allowed.len(), 4);
  299|       |    }
  300|       |
  301|       |    #[test]
  302|       |    fn test_tool_ctx_argspecs_moveto() {
  303|       |        let ctx = ToolCtx::basic_combat();
  304|       |        let specs = ctx.argspecs.get(&Tool::MoveTo).unwrap();
  305|       |        assert_eq!(specs.len(), 2);
  306|       |        assert_eq!(specs[0], ("x", "i32"));
  307|       |        assert_eq!(specs[1], ("y", "i32"));
  308|       |    }
  309|       |
  310|       |    #[test]
  311|       |    fn test_tool_ctx_argspecs_throw() {
  312|       |        let ctx = ToolCtx::basic_combat();
  313|       |        let specs = ctx.argspecs.get(&Tool::Throw).unwrap();
  314|       |        assert_eq!(specs.len(), 3);
  315|       |        assert_eq!(specs[0], ("item", "enum[smoke,grenade]"));
  316|       |        assert_eq!(specs[1], ("x", "i32"));
  317|       |        assert_eq!(specs[2], ("y", "i32"));
  318|       |    }
  319|       |
  320|       |    #[test]
  321|       |    fn test_tool_ctx_argspecs_coverfire() {
  322|       |        let ctx = ToolCtx::basic_combat();
  323|       |        let specs = ctx.argspecs.get(&Tool::CoverFire).unwrap();
  324|       |        assert_eq!(specs.len(), 2);
  325|       |        assert_eq!(specs[0], ("target_id", "u32"));
  326|       |        assert_eq!(specs[1], ("duration", "f32"));
  327|       |    }
  328|       |
  329|       |    #[test]
  330|       |    fn test_tool_ctx_argspecs_revive() {
  331|       |        let ctx = ToolCtx::basic_combat();
  332|       |        let specs = ctx.argspecs.get(&Tool::Revive).unwrap();
  333|       |        assert_eq!(specs.len(), 1);
  334|       |        assert_eq!(specs[0], ("ally_id", "u32"));
  335|       |    }
  336|       |
  337|       |    // ===== Coordinate Conversion Tests =====
  338|       |    #[test]
  339|       |    fn test_schema_to_glam_conversion() {
  340|       |        let schema = iv2(10, 20);
  341|       |        let glam = schema_to_glam(schema);
  342|       |        assert_eq!(glam.x, 10);
  343|       |        assert_eq!(glam.y, 20);
  344|       |    }
  345|       |
  346|       |    #[test]
  347|       |    fn test_glam_to_schema_conversion() {
  348|       |        let glam = GlamIVec2::new(30, 40);
  349|       |        let schema = glam_to_schema(glam);
  350|       |        assert_eq!(schema.x, 30);
  351|       |        assert_eq!(schema.y, 40);
  352|       |    }
  353|       |
  354|       |    #[test]
  355|       |    fn test_roundtrip_conversion() {
  356|       |        let original = iv2(15, 25);
  357|       |        let glam = schema_to_glam(original);
  358|       |        let back = glam_to_schema(glam);
  359|       |        assert_eq!(original.x, back.x);
  360|       |        assert_eq!(original.y, back.y);
  361|       |    }
  362|       |
  363|       |    #[test]
  364|       |    fn test_conversion_negative_coords() {
  365|       |        let schema = iv2(-10, -20);
  366|       |        let glam = schema_to_glam(schema);
  367|       |        assert_eq!(glam.x, -10);
  368|       |        assert_eq!(glam.y, -20);
  369|       |        let back = glam_to_schema(glam);
  370|       |        assert_eq!(back.x, -10);
  371|       |        assert_eq!(back.y, -20);
  372|       |    }
  373|       |
  374|       |    // ===== LOS Tests =====
  375|       |    #[test]
  376|       |    fn test_los_clear_no_obstacles() {
  377|       |        let obstacles = HashSet::new();
  378|       |        let a = iv2(0, 0);
  379|       |        let b = iv2(5, 5);
  380|       |        assert!(los_clear(&obstacles, a, b));
  381|       |    }
  382|       |
  383|       |    #[test]
  384|       |    fn test_los_blocked_by_obstacle() {
  385|       |        let mut obstacles = HashSet::new();
  386|       |        obstacles.insert((2, 2));
  387|       |        let a = iv2(0, 0);
  388|       |        let b = iv2(5, 5);
  389|       |        assert!(!los_clear(&obstacles, a, b));
  390|       |    }
  391|       |
  392|       |    #[test]
  393|       |    fn test_los_clear_horizontal() {
  394|       |        let obstacles = HashSet::new();
  395|       |        let a = iv2(0, 5);
  396|       |        let b = iv2(10, 5);
  397|       |        assert!(los_clear(&obstacles, a, b));
  398|       |    }
  399|       |
  400|       |    #[test]
  401|       |    fn test_los_clear_vertical() {
  402|       |        let obstacles = HashSet::new();
  403|       |        let a = iv2(5, 0);
  404|       |        let b = iv2(5, 10);
  405|       |        assert!(los_clear(&obstacles, a, b));
  406|       |    }
  407|       |
  408|       |    #[test]
  409|       |    fn test_los_same_position() {
  410|       |        let obstacles = HashSet::new();
  411|       |        let a = iv2(5, 5);
  412|       |        let b = iv2(5, 5);
  413|       |        assert!(los_clear(&obstacles, a, b));
  414|       |    }
  415|       |
  416|       |    #[test]
  417|       |    fn test_los_obstacle_not_on_line() {
  418|       |        let mut obstacles = HashSet::new();
  419|       |        obstacles.insert((10, 10)); // Far from path
  420|       |        let a = iv2(0, 0);
  421|       |        let b = iv2(5, 0);
  422|       |        assert!(los_clear(&obstacles, a, b));
  423|       |    }
  424|       |
  425|       |    // ===== Path Exists Tests =====
  426|       |    #[test]
  427|       |    fn test_path_exists_straight_line() {
  428|       |        let obstacles = HashSet::new();
  429|       |        let start = iv2(0, 0);
  430|       |        let goal = iv2(5, 0);
  431|       |        let bounds = (-10, -10, 10, 10);
  432|       |        assert!(path_exists(&obstacles, start, goal, bounds));
  433|       |    }
  434|       |
  435|       |    #[test]
  436|       |    fn test_path_exists_with_obstacle() {
  437|       |        let mut obstacles = HashSet::new();
  438|       |        obstacles.insert((2, 0));
  439|       |        let start = iv2(0, 0);
  440|       |        let goal = iv2(5, 0);
  441|       |        let bounds = (-10, -10, 10, 10);
  442|       |        // Path should go around obstacle
  443|       |        assert!(path_exists(&obstacles, start, goal, bounds));
  444|       |    }
  445|       |
  446|       |    #[test]
  447|       |    fn test_path_blocked_completely() {
  448|       |        let mut obstacles = HashSet::new();
  449|       |        // Create wall blocking path
  450|       |        for y in -10..=10 {
  451|       |            obstacles.insert((5, y));
  452|       |        }
  453|       |        let start = iv2(0, 0);
  454|       |        let goal = iv2(10, 0);
  455|       |        let bounds = (-10, -10, 15, 10);
  456|       |        assert!(!path_exists(&obstacles, start, goal, bounds));
  457|       |    }
  458|       |
  459|       |    #[test]
  460|       |    fn test_path_exists_same_position() {
  461|       |        let obstacles = HashSet::new();
  462|       |        let pos = iv2(5, 5);
  463|       |        let bounds = (-10, -10, 10, 10);
  464|       |        assert!(path_exists(&obstacles, pos, pos, bounds));
  465|       |    }
  466|       |
  467|       |    #[test]
  468|       |    fn test_path_exists_out_of_bounds() {
  469|       |        let obstacles = HashSet::new();
  470|       |        let start = iv2(0, 0);
  471|       |        let goal = iv2(20, 20);
  472|       |        let bounds = (-5, -5, 5, 5);
  473|       |        assert!(!path_exists(&obstacles, start, goal, bounds));
  474|       |    }
  475|       |
  476|       |    #[test]
  477|       |    fn test_path_exists_around_corner() {
  478|       |        let mut obstacles = HashSet::new();
  479|       |        obstacles.insert((5, 5));
  480|       |        let start = iv2(0, 0);
  481|       |        let goal = iv2(10, 10);
  482|       |        let bounds = (-10, -10, 15, 15);
  483|       |        assert!(path_exists(&obstacles, start, goal, bounds));
  484|       |    }
  485|       |
  486|       |    // ===== A* Path Tests =====
  487|       |    #[test]
  488|       |    fn test_astar_path_straight_line() {
  489|       |        let obstacles = HashSet::new();
  490|       |        let start = iv2(0, 0);
  491|       |        let goal = iv2(3, 0);
  492|       |        let bounds = (-10, -10, 10, 10);
  493|       |        let path = astar_path(&obstacles, start, goal, bounds);
  494|       |        assert!(!path.is_empty());
  495|       |        assert_eq!(path[0].x, 0);
  496|       |        assert_eq!(path[0].y, 0);
  497|       |        assert_eq!(path.last().unwrap().x, 3);
  498|       |        assert_eq!(path.last().unwrap().y, 0);
  499|       |    }
  500|       |
  501|       |    #[test]
  502|       |    fn test_astar_path_around_obstacle() {
  503|       |        let mut obstacles = HashSet::new();
  504|       |        obstacles.insert((1, 0));
  505|       |        let start = iv2(0, 0);
  506|       |        let goal = iv2(2, 0);
  507|       |        let bounds = (-10, -10, 10, 10);
  508|       |        let path = astar_path(&obstacles, start, goal, bounds);
  509|       |        assert!(!path.is_empty());
  510|       |        // Path should go around (0,0) -> (0,1) or (0,-1) -> (1,1) or (1,-1) -> (2,0)
  511|       |        assert_eq!(path[0].x, 0);
  512|       |        assert_eq!(path.last().unwrap().x, 2);
  513|       |    }
  514|       |
  515|       |    #[test]
  516|       |    fn test_astar_path_blocked_completely() {
  517|       |        let mut obstacles = HashSet::new();
  518|       |        // Create wall
  519|       |        for y in -10..=10 {
  520|       |            obstacles.insert((5, y));
  521|       |        }
  522|       |        let start = iv2(0, 0);
  523|       |        let goal = iv2(10, 0);
  524|       |        let bounds = (-10, -10, 15, 10);
  525|       |        let path = astar_path(&obstacles, start, goal, bounds);
  526|       |        assert!(path.is_empty());
  527|       |    }
  528|       |
  529|       |    #[test]
  530|       |    fn test_astar_path_same_position() {
  531|       |        let obstacles = HashSet::new();
  532|       |        let pos = iv2(5, 5);
  533|       |        let bounds = (-10, -10, 10, 10);
  534|       |        let path = astar_path(&obstacles, pos, pos, bounds);
  535|       |        assert!(!path.is_empty());
  536|       |        assert_eq!(path.len(), 1);
  537|       |        assert_eq!(path[0].x, 5);
  538|       |        assert_eq!(path[0].y, 5);
  539|       |    }
  540|       |
  541|       |    #[test]
  542|       |    fn test_astar_path_complex_maze() {
  543|       |        let mut obstacles = HashSet::new();
  544|       |        // Create L-shaped obstacle
  545|       |        obstacles.insert((2, 0));
  546|       |        obstacles.insert((2, 1));
  547|       |        obstacles.insert((2, 2));
  548|       |        obstacles.insert((3, 2));
  549|       |        obstacles.insert((4, 2));
  550|       |
  551|       |        let start = iv2(0, 0);
  552|       |        let goal = iv2(4, 0);
  553|       |        let bounds = (-10, -10, 10, 10);
  554|       |        let path = astar_path(&obstacles, start, goal, bounds);
  555|       |        assert!(!path.is_empty());
  556|       |        assert_eq!(path[0].x, 0);
  557|       |        assert_eq!(path.last().unwrap().x, 4);
  558|       |        assert_eq!(path.last().unwrap().y, 0);
  559|       |    }
  560|       |
  561|       |    #[test]
  562|       |    fn test_astar_path_out_of_bounds() {
  563|       |        let obstacles = HashSet::new();
  564|       |        let start = iv2(0, 0);
  565|       |        let goal = iv2(20, 20);
  566|       |        let bounds = (-5, -5, 5, 5);
  567|       |        let path = astar_path(&obstacles, start, goal, bounds);
  568|       |        assert!(path.is_empty());
  569|       |    }
  570|       |
  571|       |    // ===== Find Cover Positions Tests =====
  572|       |    #[test]
  573|       |    fn test_find_cover_positions_basic() {
  574|       |        let mut obstacles = HashSet::new();
  575|       |        // Add obstacle that blocks enemy LOS but not player LOS
  576|       |        obstacles.insert((3, 0));
  577|       |
  578|       |        let bounds = (-10, -10, 10, 10);
  579|       |        let from = iv2(0, 0);
  580|       |        let player = iv2(-5, 0); // Player to the left
  581|       |        let enemy = iv2(5, 0); // Enemy to the right
  582|       |        let radius = 5;
  583|       |
  584|       |        let cover = find_cover_positions(&obstacles, bounds, from, player, enemy, radius);
  585|       |        // Should find positions behind obstacle (relative to enemy)
  586|       |        // Not asserting exact count as geometry is complex, just that some exist
  587|       |        // Actually, with symmetric setup and single obstacle, might find none
  588|       |        // Let's verify function runs without panic
  589|       |        assert!(cover.len() >= 0);
  590|       |    }
  591|       |
  592|       |    #[test]
  593|       |    fn test_find_cover_positions_with_obstacles() {
  594|       |        let mut obstacles = HashSet::new();
  595|       |        obstacles.insert((2, 0)); // Obstacle between from and enemy
  596|       |
  597|       |        let bounds = (-10, -10, 10, 10);
  598|       |        let from = iv2(0, 0);
  599|       |        let player = iv2(-5, 0);
  600|       |        let enemy = iv2(5, 0);
  601|       |        let radius = 3;
  602|       |
  603|       |        let cover = find_cover_positions(&obstacles, bounds, from, player, enemy, radius);
  604|       |        // Positions behind obstacle should provide cover from enemy
  605|       |        for pos in &cover {
  606|       |            assert!(los_clear(&obstacles, player, *pos));
  607|       |            assert!(!los_clear(&obstacles, enemy, *pos));
  608|       |        }
  609|       |    }
  610|       |
  611|       |    #[test]
  612|       |    fn test_find_cover_positions_no_cover() {
  613|       |        let obstacles = HashSet::new();
  614|       |        let bounds = (-10, -10, 10, 10);
  615|       |        let from = iv2(0, 0);
  616|       |        let player = iv2(0, 0);
  617|       |        let enemy = iv2(0, 1);
  618|       |        let radius = 1;
  619|       |
  620|       |        // All nearby positions have LOS from both player and enemy (same line)
  621|       |        let cover = find_cover_positions(&obstacles, bounds, from, player, enemy, radius);
  622|       |        // Should be empty or very limited
  623|       |        assert!(cover.len() < 5); // Expect few or no positions
  624|       |    }
  625|       |
  626|       |    #[test]
  627|       |    fn test_find_cover_positions_respects_bounds() {
  628|       |        let obstacles = HashSet::new();
  629|       |        let bounds = (-2, -2, 2, 2);
  630|       |        let from = iv2(0, 0);
  631|       |        let player = iv2(-5, 0);
  632|       |        let enemy = iv2(5, 0);
  633|       |        let radius = 10; // Large radius but bounded
  634|       |
  635|       |        let cover = find_cover_positions(&obstacles, bounds, from, player, enemy, radius);
  636|       |        // All positions should be within bounds
  637|       |        for pos in &cover {
  638|       |            assert!(pos.x >= -2 && pos.x <= 2);
  639|       |            assert!(pos.y >= -2 && pos.y <= 2);
  640|       |        }
  641|       |    }
  642|       |
  643|       |    #[test]
  644|       |    fn test_find_cover_positions_excludes_obstacles() {
  645|       |        let mut obstacles = HashSet::new();
  646|       |        obstacles.insert((1, 0));
  647|       |        obstacles.insert((0, 1));
  648|       |
  649|       |        let bounds = (-10, -10, 10, 10);
  650|       |        let from = iv2(0, 0);
  651|       |        let player = iv2(-5, 0);
  652|       |        let enemy = iv2(5, 0);
  653|       |        let radius = 2;
  654|       |
  655|       |        let cover = find_cover_positions(&obstacles, bounds, from, player, enemy, radius);
  656|       |        // Cover positions should not include obstacles
  657|       |        for pos in &cover {
  658|       |            assert!(!obstacles.contains(&(pos.x, pos.y)));
  659|       |        }
  660|       |    }
  661|       |
  662|       |    #[test]
  663|       |    fn test_find_cover_positions_zero_radius() {
  664|       |        let obstacles = HashSet::new();
  665|       |        let bounds = (-10, -10, 10, 10);
  666|       |        let from = iv2(0, 0);
  667|       |        let player = iv2(-5, 0);
  668|       |        let enemy = iv2(5, 0);
  669|       |        let radius = 0;
  670|       |
  671|       |        let cover = find_cover_positions(&obstacles, bounds, from, player, enemy, radius);
  672|       |        // Radius 0 means only check (0,0)
  673|       |        assert!(cover.len() <= 1);
  674|       |    }
  675|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-core\src\validation.rs:
    1|       |use crate::{
    2|       |    tools::{los_clear, path_exists},
    3|       |    ActionStep, EngineError, Entity, IVec2, PlanIntent, World,
    4|       |};
    5|       |
    6|       |pub struct ValidateCfg {
    7|       |    pub world_bounds: (i32, i32, i32, i32),
    8|       |}
    9|       |
   10|     25|pub fn validate_and_execute(
   11|     25|    w: &mut World,
   12|     25|    actor: Entity,
   13|     25|    intent: &PlanIntent,
   14|     25|    cfg: &ValidateCfg,
   15|     25|    log: &mut impl FnMut(String),
   16|     25|) -> Result<(), EngineError> {
   17|     25|    log(format!(
   18|     25|        "Plan {} with {} steps",
   19|     25|        intent.plan_id,
   20|     25|        intent.steps.len()
   21|     25|    ));
   22|     25|    for (i, step) in intent.steps.iter().enumerate() {
   23|     25|        match step {
   24|       |            // ═══════════════════════════════════════
   25|       |            // MOVEMENT
   26|       |            // ═══════════════════════════════════════
   27|     25|            ActionStep::MoveTo { x, y, speed } => {
   28|     25|                let from = w.pos_of(actor).ok_or_else(|| {
                                                                       ^0
   29|      0|                    EngineError::InvalidAction("Actor has no position".to_string())
   30|      0|                })?;
   31|     25|                let to = IVec2 { x: *x, y: *y };
   32|     25|                if !path_exists(&w.obstacles, from, to, cfg.world_bounds) {
   33|      2|                    return Err(EngineError::NoPath);
   34|     23|                }
   35|     23|                w.pose_mut(actor)
   36|     23|                    .ok_or_else(|| EngineError::InvalidAction("Actor has no pose".to_string()))?
                                                                            ^0                  ^0           ^0
   37|     23|                    .pos = to;
   38|     23|                let speed_str = speed
   39|     23|                    .as_ref()
   40|     23|                    .map(|s| format!("{:?}", s))
                                                   ^0
   41|     23|                    .unwrap_or_default();
   42|     23|                log(format!(
   43|     23|                    "  [{}] MOVE_TO -> ({},{}) {:?}",
   44|     23|                    i, x, y, speed_str
   45|     23|                ));
   46|       |            }
   47|       |
   48|       |            ActionStep::Approach {
   49|      0|                target_id,
   50|      0|                distance,
   51|       |            } => {
   52|       |                // Simplified: move toward target (full implementation would maintain distance)
   53|      0|                let _target_pos = w
   54|      0|                    .pos_of(*target_id)
   55|      0|                    .ok_or_else(|| EngineError::InvalidAction("Target not found".to_string()))?;
   56|      0|                log(format!(
   57|      0|                    "  [{}] APPROACH #{} at distance {:.1}",
   58|      0|                    i, target_id, distance
   59|      0|                ));
   60|       |                // Implementation stub - actual pathfinding would be here
   61|       |            }
   62|       |
   63|       |            ActionStep::Retreat {
   64|      0|                target_id,
   65|      0|                distance,
   66|      0|            } => {
   67|      0|                log(format!(
   68|      0|                    "  [{}] RETREAT from #{} to distance {:.1}",
   69|      0|                    i, target_id, distance
   70|      0|                ));
   71|      0|                // Implementation stub
   72|      0|            }
   73|       |
   74|      0|            ActionStep::TakeCover { position } => {
   75|      0|                log(format!("  [{}] TAKE_COVER at {:?}", i, position));
   76|      0|                // Implementation stub
   77|      0|            }
   78|       |
   79|       |            ActionStep::Strafe {
   80|      0|                target_id,
   81|      0|                direction,
   82|      0|            } => {
   83|      0|                log(format!(
   84|      0|                    "  [{}] STRAFE {:?} around #{}",
   85|      0|                    i, direction, target_id
   86|      0|                ));
   87|      0|                // Implementation stub
   88|      0|            }
   89|       |
   90|      0|            ActionStep::Patrol { waypoints } => {
   91|      0|                log(format!("  [{}] PATROL {} waypoints", i, waypoints.len()));
   92|      0|                // Implementation stub
   93|      0|            }
   94|       |
   95|       |            // ═══════════════════════════════════════
   96|       |            // OFFENSIVE
   97|       |            // ═══════════════════════════════════════
   98|      0|            ActionStep::Attack { target_id } => {
   99|      0|                log(format!("  [{}] ATTACK #{}", i, target_id));
  100|       |                // Simplified damage
  101|      0|                if let Some(h) = w.health_mut(*target_id) {
  102|      0|                    h.hp -= 10;
  103|      0|                }
  104|       |            }
  105|       |
  106|      0|            ActionStep::AimedShot { target_id } => {
  107|      0|                log(format!("  [{}] AIMED_SHOT #{}", i, target_id));
  108|      0|                if let Some(h) = w.health_mut(*target_id) {
  109|      0|                    h.hp -= 15; // Higher damage
  110|      0|                }
  111|       |            }
  112|       |
  113|      0|            ActionStep::QuickAttack { target_id } => {
  114|      0|                log(format!("  [{}] QUICK_ATTACK #{}", i, target_id));
  115|      0|                if let Some(h) = w.health_mut(*target_id) {
  116|      0|                    h.hp -= 5; // Lower damage
  117|      0|                }
  118|       |            }
  119|       |
  120|      0|            ActionStep::HeavyAttack { target_id } => {
  121|      0|                log(format!("  [{}] HEAVY_ATTACK #{}", i, target_id));
  122|      0|                if let Some(h) = w.health_mut(*target_id) {
  123|      0|                    h.hp -= 25; // High damage
  124|      0|                }
  125|       |            }
  126|       |
  127|      0|            ActionStep::AoEAttack { x, y, radius } => {
  128|      0|                log(format!(
  129|      0|                    "  [{}] AOE_ATTACK at ({},{}) radius {:.1}",
  130|      0|                    i, x, y, radius
  131|      0|                ));
  132|      0|                // Implementation stub - would damage all entities in radius
  133|      0|            }
  134|       |
  135|      0|            ActionStep::ThrowExplosive { x, y } => {
  136|      0|                log(format!("  [{}] THROW_EXPLOSIVE at ({},{})", i, x, y));
  137|      0|                // Implementation stub
  138|      0|            }
  139|       |
  140|      0|            ActionStep::Charge { target_id } => {
  141|      0|                log(format!("  [{}] CHARGE #{}", i, target_id));
  142|      0|                // Implementation stub - move to target + attack
  143|      0|            }
  144|       |
  145|       |            // ═══════════════════════════════════════
  146|       |            // DEFENSIVE
  147|       |            // ═══════════════════════════════════════
  148|      0|            ActionStep::Block => {
  149|      0|                log(format!("  [{}] BLOCK", i));
  150|      0|                // Implementation stub
  151|      0|            }
  152|       |
  153|      0|            ActionStep::Dodge { direction } => {
  154|      0|                log(format!("  [{}] DODGE {:?}", i, direction));
  155|      0|                // Implementation stub
  156|      0|            }
  157|       |
  158|      0|            ActionStep::Parry => {
  159|      0|                log(format!("  [{}] PARRY", i));
  160|      0|                // Implementation stub
  161|      0|            }
  162|       |
  163|      0|            ActionStep::ThrowSmoke { x, y } => {
  164|      0|                let from = w.pos_of(actor).ok_or_else(|| {
  165|      0|                    EngineError::InvalidAction("Actor has no position".to_string())
  166|      0|                })?;
  167|      0|                let target = IVec2 { x: *x, y: *y };
  168|      0|                if !los_clear(&w.obstacles, from, target) {
  169|      0|                    return Err(EngineError::LosBlocked);
  170|      0|                }
  171|      0|                log(format!("  [{}] THROW_SMOKE -> ({},{})", i, x, y));
  172|       |            }
  173|       |
  174|      0|            ActionStep::Heal { target_id } => {
  175|      0|                let tid = target_id.unwrap_or(actor);
  176|      0|                log(format!("  [{}] HEAL #{}", i, tid));
  177|      0|                if let Some(h) = w.health_mut(tid) {
  178|      0|                    h.hp += 20;
  179|      0|                }
  180|       |            }
  181|       |
  182|      0|            ActionStep::UseDefensiveAbility { ability_name } => {
  183|      0|                log(format!("  [{}] USE_DEFENSIVE_ABILITY: {}", i, ability_name));
  184|      0|                // Implementation stub
  185|      0|            }
  186|       |
  187|       |            // ═══════════════════════════════════════
  188|       |            // EQUIPMENT
  189|       |            // ═══════════════════════════════════════
  190|      0|            ActionStep::EquipWeapon { weapon_name } => {
  191|      0|                log(format!("  [{}] EQUIP_WEAPON: {}", i, weapon_name));
  192|      0|                // Implementation stub
  193|      0|            }
  194|       |
  195|      0|            ActionStep::SwitchWeapon { slot } => {
  196|      0|                log(format!("  [{}] SWITCH_WEAPON to slot {}", i, slot));
  197|      0|                // Implementation stub
  198|      0|            }
  199|       |
  200|       |            ActionStep::Reload => {
  201|      0|                log(format!("  [{}] RELOAD", i));
  202|      0|                if let Some(ammo) = w.ammo_mut(actor) {
  203|      0|                    ammo.rounds = 30; // Reload to full
  204|      0|                }
  205|       |            }
  206|       |
  207|      0|            ActionStep::UseItem { item_name } => {
  208|      0|                log(format!("  [{}] USE_ITEM: {}", i, item_name));
  209|      0|                // Implementation stub
  210|      0|            }
  211|       |
  212|      0|            ActionStep::DropItem { item_name } => {
  213|      0|                log(format!("  [{}] DROP_ITEM: {}", i, item_name));
  214|      0|                // Implementation stub
  215|      0|            }
  216|       |
  217|       |            // ═══════════════════════════════════════
  218|       |            // TACTICAL
  219|       |            // ═══════════════════════════════════════
  220|      0|            ActionStep::CallReinforcements { count } => {
  221|      0|                log(format!("  [{}] CALL_REINFORCEMENTS: {}", i, count));
  222|      0|                // Implementation stub
  223|      0|            }
  224|       |
  225|      0|            ActionStep::MarkTarget { target_id } => {
  226|      0|                log(format!("  [{}] MARK_TARGET #{}", i, target_id));
  227|      0|                // Implementation stub
  228|      0|            }
  229|       |
  230|      0|            ActionStep::RequestCover { duration } => {
  231|      0|                log(format!("  [{}] REQUEST_COVER for {:.1}s", i, duration));
  232|      0|                // Implementation stub
  233|      0|            }
  234|       |
  235|      0|            ActionStep::CoordinateAttack { target_id } => {
  236|      0|                log(format!("  [{}] COORDINATE_ATTACK on #{}", i, target_id));
  237|      0|                // Implementation stub
  238|      0|            }
  239|       |
  240|      0|            ActionStep::SetAmbush { position } => {
  241|      0|                log(format!("  [{}] SET_AMBUSH at {:?}", i, position));
  242|      0|                // Implementation stub
  243|      0|            }
  244|       |
  245|      0|            ActionStep::Distract { target_id } => {
  246|      0|                log(format!("  [{}] DISTRACT #{}", i, target_id));
  247|      0|                // Implementation stub
  248|      0|            }
  249|       |
  250|      0|            ActionStep::Regroup { rally_point } => {
  251|      0|                log(format!("  [{}] REGROUP at {:?}", i, rally_point));
  252|      0|                // Implementation stub
  253|      0|            }
  254|       |
  255|       |            // ═══════════════════════════════════════
  256|       |            // UTILITY
  257|       |            // ═══════════════════════════════════════
  258|      0|            ActionStep::Scan { radius } => {
  259|      0|                log(format!("  [{}] SCAN radius {:.1}", i, radius));
  260|      0|                // Implementation stub
  261|      0|            }
  262|       |
  263|      0|            ActionStep::Wait { duration } => {
  264|      0|                log(format!("  [{}] WAIT {:.1}s", i, duration));
  265|      0|                // Implementation stub
  266|      0|            }
  267|       |
  268|      0|            ActionStep::Interact { target_id } => {
  269|      0|                log(format!("  [{}] INTERACT with #{}", i, target_id));
  270|      0|                // Implementation stub
  271|      0|            }
  272|       |
  273|      0|            ActionStep::UseAbility { ability_name } => {
  274|      0|                log(format!("  [{}] USE_ABILITY: {}", i, ability_name));
  275|      0|                // Implementation stub
  276|      0|            }
  277|       |
  278|      0|            ActionStep::Taunt { target_id } => {
  279|      0|                log(format!("  [{}] TAUNT #{}", i, target_id));
  280|      0|                // Implementation stub
  281|      0|            }
  282|       |
  283|       |            // ═══════════════════════════════════════
  284|       |            // LEGACY
  285|       |            // ═══════════════════════════════════════
  286|      0|            ActionStep::Throw { item, x, y } => {
  287|      0|                let from = w.pos_of(actor).ok_or_else(|| {
  288|      0|                    EngineError::InvalidAction("Actor has no position".to_string())
  289|      0|                })?;
  290|      0|                let target = IVec2 { x: *x, y: *y };
  291|      0|                if !los_clear(&w.obstacles, from, target) {
  292|      0|                    return Err(EngineError::LosBlocked);
  293|      0|                }
  294|      0|                let cds = w.cooldowns_mut(actor).ok_or_else(|| {
  295|      0|                    EngineError::InvalidAction("Actor has no cooldowns".to_string())
  296|      0|                })?;
  297|      0|                let cd_key = format!("throw:{}", item);
  298|      0|                if cds.map.get(&cd_key).copied().unwrap_or(0.0) > 0.0 {
  299|      0|                    return Err(EngineError::Cooldown(cd_key));
  300|      0|                }
  301|      0|                cds.map.insert(cd_key.clone(), 8.0);
  302|      0|                log(format!("  [{}] THROW {} -> ({},{})", i, item, x, y));
  303|       |            }
  304|       |            ActionStep::CoverFire {
  305|      0|                target_id,
  306|      0|                duration,
  307|       |            } => {
  308|      0|                let my = w.pos_of(actor).unwrap();
  309|      0|                let tgt = w
  310|      0|                    .pos_of(*target_id)
  311|      0|                    .ok_or_else(|| EngineError::InvalidAction("target gone".into()))?;
  312|      0|                if !los_clear(&w.obstacles, my, tgt) {
  313|      0|                    return Err(EngineError::LosBlocked);
  314|      0|                }
  315|       |                // Ensure ammo present
  316|      0|                if let Some(am) = w.ammo(actor) {
  317|      0|                    if am.rounds <= 0 {
  318|      0|                        return Err(EngineError::Resource("ammo".into()));
  319|      0|                    }
  320|      0|                }
  321|       |                // simulate: reduce target hp a bit depending on duration
  322|      0|                if let Some(h) = w.health_mut(*target_id) {
  323|      0|                    let dmg = ((*duration) * 5.0) as i32;
  324|      0|                    h.hp -= dmg.max(1);
  325|      0|                }
  326|      0|                let ammo = w.ammo_mut(actor).unwrap();
  327|      0|                ammo.rounds = (ammo.rounds - 3).max(0);
  328|      0|                log(format!(
  329|      0|                    "  [{}] COVER_FIRE on #{} for {:.1}s",
  330|      0|                    i, target_id, duration
  331|      0|                ));
  332|       |            }
  333|      0|            ActionStep::Revive { ally_id } => {
  334|      0|                if let Some(h) = w.health_mut(*ally_id) {
  335|      0|                    if h.hp <= 0 {
  336|      0|                        h.hp = 20;
  337|      0|                    }
  338|      0|                }
  339|      0|                log(format!("  [{}] REVIVE #{}", i, ally_id));
  340|       |            }
  341|       |
  342|       |            // ═══════════════════════════════════════
  343|       |            // TERRAIN (AI-Orchestrated Dynamic Terrain)
  344|       |            // ═══════════════════════════════════════
  345|       |            ActionStep::ModifyTerrain {
  346|      0|                request_id,
  347|      0|                payload,
  348|       |            } => {
  349|       |                // Validate the terrain request
  350|      0|                if let Err(e) = payload.validate() {
  351|      0|                    return Err(EngineError::InvalidAction(format!(
  352|      0|                        "Invalid terrain request: {}",
  353|      0|                        e
  354|      0|                    )));
  355|      0|                }
  356|      0|                log(format!(
  357|      0|                    "  [{}] MODIFY_TERRAIN request_id={} feature={:?}",
  358|      0|                    i, request_id, payload.feature_type
  359|      0|                ));
  360|       |                // Note: Actual terrain modification is handled by TerrainSolver
  361|       |                // This validation ensures the request is structurally valid
  362|       |            }
  363|       |        }
  364|       |    }
  365|     23|    Ok(())
  366|     25|}
  367|       |
  368|       |use crate::{DirectorOp, DirectorPlan, Rect};
  369|       |
  370|       |fn fill_rect_obs(obs: &mut std::collections::HashSet<(i32, i32)>, r: Rect) {
  371|       |    for x in r.x0.min(r.x1)..=r.x0.max(r.x1) {
  372|       |        for y in r.y0.min(r.y1)..=r.y0.max(r.y1) {
  373|       |            obs.insert((x, y));
  374|       |        }
  375|       |    }
  376|       |}
  377|       |
  378|       |#[cfg(test)]
  379|       |mod tests {
  380|       |    use super::*;
  381|       |    use crate::{MovementSpeed, Team, World};
  382|       |
  383|       |    fn mk_world_clear() -> World {
  384|       |        World::new()
  385|       |    }
  386|       |
  387|       |    #[test]
  388|       |    fn cover_fire_requires_ammo() {
  389|       |        let mut w = mk_world_clear();
  390|       |        let actor = w.spawn("ally", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 0);
  391|       |        let enemy = w.spawn("enemy", IVec2 { x: 3, y: 0 }, Team { id: 2 }, 50, 0);
  392|       |        let intent = PlanIntent {
  393|       |            plan_id: "t".into(),
  394|       |            steps: vec![ActionStep::CoverFire {
  395|       |                target_id: enemy,
  396|       |                duration: 1.0,
  397|       |            }],
  398|       |        };
  399|       |        let cfg = ValidateCfg {
  400|       |            world_bounds: (-10, -10, 10, 10),
  401|       |        };
  402|       |        let mut log = |_s: String| {};
  403|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  404|       |        match res {
  405|       |            Err(EngineError::Resource(k)) => assert_eq!(k, "ammo"),
  406|       |            _ => panic!("expected Resource(ammo)"),
  407|       |        }
  408|       |    }
  409|       |
  410|       |    #[test]
  411|       |    fn cover_fire_consumes_ammo_and_damages() {
  412|       |        let mut w = mk_world_clear();
  413|       |        let actor = w.spawn("ally", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
  414|       |        let enemy = w.spawn("enemy", IVec2 { x: 2, y: 0 }, Team { id: 2 }, 50, 0);
  415|       |        let intent = PlanIntent {
  416|       |            plan_id: "t".into(),
  417|       |            steps: vec![ActionStep::CoverFire {
  418|       |                target_id: enemy,
  419|       |                duration: 1.0,
  420|       |            }],
  421|       |        };
  422|       |        let cfg = ValidateCfg {
  423|       |            world_bounds: (-10, -10, 10, 10),
  424|       |        };
  425|       |        let mut log = |_s: String| {};
  426|       |        let hp_before = w.health(enemy).unwrap().hp;
  427|       |        let ammo_before = w.ammo(actor).unwrap().rounds;
  428|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  429|       |        assert!(res.is_ok());
  430|       |        let hp_after = w.health(enemy).unwrap().hp;
  431|       |        let ammo_after = w.ammo(actor).unwrap().rounds;
  432|       |        assert!(hp_after < hp_before, "enemy should take damage");
  433|       |        assert_eq!(ammo_after, (ammo_before - 3).max(0));
  434|       |    }
  435|       |
  436|       |    // ════════════════════════════════════════════════════════════════════
  437|       |    // NEW TESTS (Week 2 Day 3 - Task 6)
  438|       |    // ════════════════════════════════════════════════════════════════════
  439|       |
  440|       |    #[test]
  441|       |    fn test_moveto_validation_success() {
  442|       |        let mut w = mk_world_clear();
  443|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
  444|       |
  445|       |        let intent = PlanIntent {
  446|       |            plan_id: "move-001".into(),
  447|       |            steps: vec![ActionStep::MoveTo {
  448|       |                x: 5,
  449|       |                y: 5,
  450|       |                speed: Some(MovementSpeed::Run),
  451|       |            }],
  452|       |        };
  453|       |
  454|       |        let cfg = ValidateCfg {
  455|       |            world_bounds: (-10, -10, 10, 10),
  456|       |        };
  457|       |        let mut log = |_s: String| {};
  458|       |
  459|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  460|       |        assert!(res.is_ok());
  461|       |
  462|       |        let final_pos = w.pos_of(actor).unwrap();
  463|       |        assert_eq!(final_pos, IVec2 { x: 5, y: 5 });
  464|       |    }
  465|       |
  466|       |    #[test]
  467|       |    fn test_moveto_path_blocked() {
  468|       |        let mut w = mk_world_clear();
  469|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
  470|       |
  471|       |        // Add obstacles creating a wall that blocks path
  472|       |        // Create vertical wall from (-10, -10) to (-10, 10) blocking path to (-5, 0)
  473|       |        for y in -10..=10 {
  474|       |            w.obstacles.insert((-5, y));
  475|       |        }
  476|       |
  477|       |        let intent = PlanIntent {
  478|       |            plan_id: "move-blocked".into(),
  479|       |            steps: vec![ActionStep::MoveTo {
  480|       |                x: -8,
  481|       |                y: 0,
  482|       |                speed: None,
  483|       |            }],
  484|       |        };
  485|       |
  486|       |        let cfg = ValidateCfg {
  487|       |            world_bounds: (-10, -10, 10, 10),
  488|       |        };
  489|       |        let mut log = |_s: String| {};
  490|       |
  491|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  492|       |        match res {
  493|       |            Err(EngineError::NoPath) => {} // Expected
  494|       |            _ => panic!("Expected NoPath error"),
  495|       |        }
  496|       |    }
  497|       |
  498|       |    #[test]
  499|       |    fn test_attack_damages_target() {
  500|       |        let mut w = mk_world_clear();
  501|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
  502|       |        let enemy = w.spawn("enemy", IVec2 { x: 3, y: 0 }, Team { id: 2 }, 50, 0);
  503|       |
  504|       |        let intent = PlanIntent {
  505|       |            plan_id: "attack-001".into(),
  506|       |            steps: vec![ActionStep::Attack { target_id: enemy }],
  507|       |        };
  508|       |
  509|       |        let cfg = ValidateCfg {
  510|       |            world_bounds: (-10, -10, 10, 10),
  511|       |        };
  512|       |        let mut log = |_s: String| {};
  513|       |
  514|       |        let hp_before = w.health(enemy).unwrap().hp;
  515|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  516|       |        assert!(res.is_ok());
  517|       |
  518|       |        let hp_after = w.health(enemy).unwrap().hp;
  519|       |        assert_eq!(hp_after, hp_before - 10); // Attack does 10 damage
  520|       |    }
  521|       |
  522|       |    #[test]
  523|       |    fn test_heal_self() {
  524|       |        let mut w = mk_world_clear();
  525|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 50, 10);
  526|       |
  527|       |        let intent = PlanIntent {
  528|       |            plan_id: "heal-self".into(),
  529|       |            steps: vec![ActionStep::Heal { target_id: None }], // None = heal self
  530|       |        };
  531|       |
  532|       |        let cfg = ValidateCfg {
  533|       |            world_bounds: (-10, -10, 10, 10),
  534|       |        };
  535|       |        let mut log = |_s: String| {};
  536|       |
  537|       |        let hp_before = w.health(actor).unwrap().hp;
  538|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  539|       |        assert!(res.is_ok());
  540|       |
  541|       |        let hp_after = w.health(actor).unwrap().hp;
  542|       |        assert_eq!(hp_after, hp_before + 20); // Heal restores 20 HP
  543|       |    }
  544|       |
  545|       |    #[test]
  546|       |    fn test_heal_ally() {
  547|       |        let mut w = mk_world_clear();
  548|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
  549|       |        let ally = w.spawn("ally", IVec2 { x: 1, y: 0 }, Team { id: 1 }, 30, 0);
  550|       |
  551|       |        let intent = PlanIntent {
  552|       |            plan_id: "heal-ally".into(),
  553|       |            steps: vec![ActionStep::Heal {
  554|       |                target_id: Some(ally),
  555|       |            }],
  556|       |        };
  557|       |
  558|       |        let cfg = ValidateCfg {
  559|       |            world_bounds: (-10, -10, 10, 10),
  560|       |        };
  561|       |        let mut log = |_s: String| {};
  562|       |
  563|       |        let hp_before = w.health(ally).unwrap().hp;
  564|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  565|       |        assert!(res.is_ok());
  566|       |
  567|       |        let hp_after = w.health(ally).unwrap().hp;
  568|       |        assert_eq!(hp_after, hp_before + 20);
  569|       |    }
  570|       |
  571|       |    #[test]
  572|       |    fn test_reload_refills_ammo() {
  573|       |        let mut w = mk_world_clear();
  574|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 5);
  575|       |
  576|       |        let intent = PlanIntent {
  577|       |            plan_id: "reload-001".into(),
  578|       |            steps: vec![ActionStep::Reload],
  579|       |        };
  580|       |
  581|       |        let cfg = ValidateCfg {
  582|       |            world_bounds: (-10, -10, 10, 10),
  583|       |        };
  584|       |        let mut log = |_s: String| {};
  585|       |
  586|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  587|       |        assert!(res.is_ok());
  588|       |
  589|       |        let ammo_after = w.ammo(actor).unwrap().rounds;
  590|       |        assert_eq!(ammo_after, 30); // Reload fills to 30
  591|       |    }
  592|       |
  593|       |    #[test]
  594|       |    fn test_throw_smoke_los_blocked() {
  595|       |        let mut w = mk_world_clear();
  596|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
  597|       |
  598|       |        // Add obstacle blocking line of sight
  599|       |        w.obstacles.insert((2, 2));
  600|       |
  601|       |        let intent = PlanIntent {
  602|       |            plan_id: "smoke-blocked".into(),
  603|       |            steps: vec![ActionStep::ThrowSmoke { x: 5, y: 5 }],
  604|       |        };
  605|       |
  606|       |        let cfg = ValidateCfg {
  607|       |            world_bounds: (-10, -10, 10, 10),
  608|       |        };
  609|       |        let mut log = |_s: String| {};
  610|       |
  611|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  612|       |        match res {
  613|       |            Err(EngineError::LosBlocked) => {} // Expected
  614|       |            _ => panic!("Expected LosBlocked error"),
  615|       |        }
  616|       |    }
  617|       |
  618|       |    #[test]
  619|       |    fn test_throw_with_cooldown() {
  620|       |        let mut w = mk_world_clear();
  621|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
  622|       |
  623|       |        let intent = PlanIntent {
  624|       |            plan_id: "throw-cd".into(),
  625|       |            steps: vec![ActionStep::Throw {
  626|       |                item: "grenade".into(),
  627|       |                x: 3,
  628|       |                y: 3,
  629|       |            }],
  630|       |        };
  631|       |
  632|       |        let cfg = ValidateCfg {
  633|       |            world_bounds: (-10, -10, 10, 10),
  634|       |        };
  635|       |        let mut log = |_s: String| {};
  636|       |
  637|       |        // First throw should succeed
  638|       |        let res1 = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  639|       |        assert!(res1.is_ok());
  640|       |
  641|       |        // Second throw should fail (cooldown active)
  642|       |        let res2 = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  643|       |        match res2 {
  644|       |            Err(EngineError::Cooldown(cd)) => {
  645|       |                assert_eq!(cd, "throw:grenade");
  646|       |            }
  647|       |            _ => panic!("Expected Cooldown error"),
  648|       |        }
  649|       |    }
  650|       |
  651|       |    #[test]
  652|       |    fn test_revive_dead_ally() {
  653|       |        let mut w = mk_world_clear();
  654|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
  655|       |        let ally = w.spawn("ally", IVec2 { x: 1, y: 0 }, Team { id: 1 }, 0, 0); // Dead (0 HP)
  656|       |
  657|       |        let intent = PlanIntent {
  658|       |            plan_id: "revive-001".into(),
  659|       |            steps: vec![ActionStep::Revive { ally_id: ally }],
  660|       |        };
  661|       |
  662|       |        let cfg = ValidateCfg {
  663|       |            world_bounds: (-10, -10, 10, 10),
  664|       |        };
  665|       |        let mut log = |_s: String| {};
  666|       |
  667|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  668|       |        assert!(res.is_ok());
  669|       |
  670|       |        let hp_after = w.health(ally).unwrap().hp;
  671|       |        assert_eq!(hp_after, 20); // Revive sets HP to 20
  672|       |    }
  673|       |
  674|       |    #[test]
  675|       |    fn test_multi_step_execution() {
  676|       |        let mut w = mk_world_clear();
  677|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 30);
  678|       |        let enemy = w.spawn("enemy", IVec2 { x: 5, y: 5 }, Team { id: 2 }, 100, 0);
  679|       |
  680|       |        let intent = PlanIntent {
  681|       |            plan_id: "multi-001".into(),
  682|       |            steps: vec![
  683|       |                ActionStep::MoveTo {
  684|       |                    x: 3,
  685|       |                    y: 3,
  686|       |                    speed: Some(MovementSpeed::Sprint),
  687|       |                },
  688|       |                ActionStep::Attack { target_id: enemy },
  689|       |                ActionStep::Reload,
  690|       |            ],
  691|       |        };
  692|       |
  693|       |        let cfg = ValidateCfg {
  694|       |            world_bounds: (-10, -10, 10, 10),
  695|       |        };
  696|       |        let mut log = |_s: String| {};
  697|       |
  698|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  699|       |        assert!(res.is_ok());
  700|       |
  701|       |        // Validate final state
  702|       |        let final_pos = w.pos_of(actor).unwrap();
  703|       |        assert_eq!(final_pos, IVec2 { x: 3, y: 3 });
  704|       |
  705|       |        let enemy_hp = w.health(enemy).unwrap().hp;
  706|       |        assert_eq!(enemy_hp, 90); // Took 10 damage
  707|       |
  708|       |        let ammo = w.ammo(actor).unwrap().rounds;
  709|       |        assert_eq!(ammo, 30); // Reloaded to full
  710|       |    }
  711|       |
  712|       |    #[test]
  713|       |    fn test_invalid_actor_not_found() {
  714|       |        let mut w = mk_world_clear();
  715|       |        let actor = 9999; // Non-existent entity
  716|       |
  717|       |        let intent = PlanIntent {
  718|       |            plan_id: "invalid".into(),
  719|       |            steps: vec![ActionStep::MoveTo {
  720|       |                x: 5,
  721|       |                y: 5,
  722|       |                speed: None,
  723|       |            }],
  724|       |        };
  725|       |
  726|       |        let cfg = ValidateCfg {
  727|       |            world_bounds: (-10, -10, 10, 10),
  728|       |        };
  729|       |        let mut log = |_s: String| {};
  730|       |
  731|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  732|       |        match res {
  733|       |            Err(EngineError::InvalidAction(msg)) => {
  734|       |                assert!(msg.contains("no position"));
  735|       |            }
  736|       |            _ => panic!("Expected InvalidAction error for non-existent actor"),
  737|       |        }
  738|       |    }
  739|       |
  740|       |    // ════════════════════════════════════════════════════════════════════
  741|       |    // COMPREHENSIVE ACTION STEP TESTS (95%+ Coverage Push)
  742|       |    // ════════════════════════════════════════════════════════════════════
  743|       |
  744|       |    #[test]
  745|       |    fn test_approach_action() {
  746|       |        let mut w = mk_world_clear();
  747|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
  748|       |        let target = w.spawn("target", IVec2 { x: 10, y: 10 }, Team { id: 2 }, 100, 0);
  749|       |
  750|       |        let intent = PlanIntent {
  751|       |            plan_id: "approach-001".into(),
  752|       |            steps: vec![ActionStep::Approach {
  753|       |                target_id: target,
  754|       |                distance: 2.0,
  755|       |            }],
  756|       |        };
  757|       |
  758|       |        let cfg = ValidateCfg {
  759|       |            world_bounds: (-10, -10, 10, 10),
  760|       |        };
  761|       |        let mut log = |_s: String| {};
  762|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  763|       |        assert!(res.is_ok());
  764|       |    }
  765|       |
  766|       |    #[test]
  767|       |    fn test_retreat_action() {
  768|       |        let mut w = mk_world_clear();
  769|       |        let actor = w.spawn("actor", IVec2 { x: 5, y: 5 }, Team { id: 1 }, 100, 10);
  770|       |        let target = w.spawn("target", IVec2 { x: 3, y: 3 }, Team { id: 2 }, 100, 0);
  771|       |
  772|       |        let intent = PlanIntent {
  773|       |            plan_id: "retreat-001".into(),
  774|       |            steps: vec![ActionStep::Retreat {
  775|       |                target_id: target,
  776|       |                distance: 10.0,
  777|       |            }],
  778|       |        };
  779|       |
  780|       |        let cfg = ValidateCfg {
  781|       |            world_bounds: (-10, -10, 10, 10),
  782|       |        };
  783|       |        let mut log = |_s: String| {};
  784|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  785|       |        assert!(res.is_ok());
  786|       |    }
  787|       |
  788|       |    #[test]
  789|       |    fn test_take_cover_action() {
  790|       |        let mut w = mk_world_clear();
  791|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
  792|       |
  793|       |        let intent = PlanIntent {
  794|       |            plan_id: "cover-001".into(),
  795|       |            steps: vec![ActionStep::TakeCover {
  796|       |                position: Some(IVec2 { x: 5, y: 5 }),
  797|       |            }],
  798|       |        };
  799|       |
  800|       |        let cfg = ValidateCfg {
  801|       |            world_bounds: (-10, -10, 10, 10),
  802|       |        };
  803|       |        let mut log = |_s: String| {};
  804|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  805|       |        assert!(res.is_ok());
  806|       |    }
  807|       |
  808|       |    #[test]
  809|       |    fn test_strafe_action() {
  810|       |        let mut w = mk_world_clear();
  811|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
  812|       |        let target = w.spawn("target", IVec2 { x: 5, y: 5 }, Team { id: 2 }, 100, 0);
  813|       |
  814|       |        let intent = PlanIntent {
  815|       |            plan_id: "strafe-001".into(),
  816|       |            steps: vec![ActionStep::Strafe {
  817|       |                target_id: target,
  818|       |                direction: crate::StrafeDirection::Left,
  819|       |            }],
  820|       |        };
  821|       |
  822|       |        let cfg = ValidateCfg {
  823|       |            world_bounds: (-10, -10, 10, 10),
  824|       |        };
  825|       |        let mut log = |_s: String| {};
  826|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  827|       |        assert!(res.is_ok());
  828|       |    }
  829|       |
  830|       |    #[test]
  831|       |    fn test_patrol_action() {
  832|       |        let mut w = mk_world_clear();
  833|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
  834|       |
  835|       |        let intent = PlanIntent {
  836|       |            plan_id: "patrol-001".into(),
  837|       |            steps: vec![ActionStep::Patrol {
  838|       |                waypoints: vec![
  839|       |                    IVec2 { x: 0, y: 0 },
  840|       |                    IVec2 { x: 5, y: 0 },
  841|       |                    IVec2 { x: 5, y: 5 },
  842|       |                ],
  843|       |            }],
  844|       |        };
  845|       |
  846|       |        let cfg = ValidateCfg {
  847|       |            world_bounds: (-10, -10, 10, 10),
  848|       |        };
  849|       |        let mut log = |_s: String| {};
  850|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  851|       |        assert!(res.is_ok());
  852|       |    }
  853|       |
  854|       |    #[test]
  855|       |    fn test_aimed_shot_damages_target() {
  856|       |        let mut w = mk_world_clear();
  857|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
  858|       |        let target = w.spawn("target", IVec2 { x: 5, y: 5 }, Team { id: 2 }, 100, 0);
  859|       |
  860|       |        let hp_before = w.health(target).unwrap().hp;
  861|       |
  862|       |        let intent = PlanIntent {
  863|       |            plan_id: "aimed-001".into(),
  864|       |            steps: vec![ActionStep::AimedShot { target_id: target }],
  865|       |        };
  866|       |
  867|       |        let cfg = ValidateCfg {
  868|       |            world_bounds: (-10, -10, 10, 10),
  869|       |        };
  870|       |        let mut log = |_s: String| {};
  871|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  872|       |        assert!(res.is_ok());
  873|       |
  874|       |        let hp_after = w.health(target).unwrap().hp;
  875|       |        assert_eq!(hp_after, hp_before - 15);
  876|       |    }
  877|       |
  878|       |    #[test]
  879|       |    fn test_quick_attack_damages_target() {
  880|       |        let mut w = mk_world_clear();
  881|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
  882|       |        let target = w.spawn("target", IVec2 { x: 5, y: 5 }, Team { id: 2 }, 100, 0);
  883|       |
  884|       |        let hp_before = w.health(target).unwrap().hp;
  885|       |
  886|       |        let intent = PlanIntent {
  887|       |            plan_id: "quick-001".into(),
  888|       |            steps: vec![ActionStep::QuickAttack { target_id: target }],
  889|       |        };
  890|       |
  891|       |        let cfg = ValidateCfg {
  892|       |            world_bounds: (-10, -10, 10, 10),
  893|       |        };
  894|       |        let mut log = |_s: String| {};
  895|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  896|       |        assert!(res.is_ok());
  897|       |
  898|       |        let hp_after = w.health(target).unwrap().hp;
  899|       |        assert_eq!(hp_after, hp_before - 5);
  900|       |    }
  901|       |
  902|       |    #[test]
  903|       |    fn test_heavy_attack_damages_target() {
  904|       |        let mut w = mk_world_clear();
  905|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
  906|       |        let target = w.spawn("target", IVec2 { x: 5, y: 5 }, Team { id: 2 }, 100, 0);
  907|       |
  908|       |        let hp_before = w.health(target).unwrap().hp;
  909|       |
  910|       |        let intent = PlanIntent {
  911|       |            plan_id: "heavy-001".into(),
  912|       |            steps: vec![ActionStep::HeavyAttack { target_id: target }],
  913|       |        };
  914|       |
  915|       |        let cfg = ValidateCfg {
  916|       |            world_bounds: (-10, -10, 10, 10),
  917|       |        };
  918|       |        let mut log = |_s: String| {};
  919|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  920|       |        assert!(res.is_ok());
  921|       |
  922|       |        let hp_after = w.health(target).unwrap().hp;
  923|       |        assert_eq!(hp_after, hp_before - 25);
  924|       |    }
  925|       |
  926|       |    #[test]
  927|       |    fn test_aoe_attack_action() {
  928|       |        let mut w = mk_world_clear();
  929|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
  930|       |
  931|       |        let intent = PlanIntent {
  932|       |            plan_id: "aoe-001".into(),
  933|       |            steps: vec![ActionStep::AoEAttack {
  934|       |                x: 5,
  935|       |                y: 5,
  936|       |                radius: 3.0,
  937|       |            }],
  938|       |        };
  939|       |
  940|       |        let cfg = ValidateCfg {
  941|       |            world_bounds: (-10, -10, 10, 10),
  942|       |        };
  943|       |        let mut log = |_s: String| {};
  944|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  945|       |        assert!(res.is_ok());
  946|       |    }
  947|       |
  948|       |    #[test]
  949|       |    fn test_throw_explosive_action() {
  950|       |        let mut w = mk_world_clear();
  951|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
  952|       |
  953|       |        let intent = PlanIntent {
  954|       |            plan_id: "explosive-001".into(),
  955|       |            steps: vec![ActionStep::ThrowExplosive { x: 5, y: 5 }],
  956|       |        };
  957|       |
  958|       |        let cfg = ValidateCfg {
  959|       |            world_bounds: (-10, -10, 10, 10),
  960|       |        };
  961|       |        let mut log = |_s: String| {};
  962|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  963|       |        assert!(res.is_ok());
  964|       |    }
  965|       |
  966|       |    #[test]
  967|       |    fn test_charge_action() {
  968|       |        let mut w = mk_world_clear();
  969|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
  970|       |        let target = w.spawn("target", IVec2 { x: 5, y: 5 }, Team { id: 2 }, 100, 0);
  971|       |
  972|       |        let intent = PlanIntent {
  973|       |            plan_id: "charge-001".into(),
  974|       |            steps: vec![ActionStep::Charge { target_id: target }],
  975|       |        };
  976|       |
  977|       |        let cfg = ValidateCfg {
  978|       |            world_bounds: (-10, -10, 10, 10),
  979|       |        };
  980|       |        let mut log = |_s: String| {};
  981|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
  982|       |        assert!(res.is_ok());
  983|       |    }
  984|       |
  985|       |    #[test]
  986|       |    fn test_block_action() {
  987|       |        let mut w = mk_world_clear();
  988|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
  989|       |
  990|       |        let intent = PlanIntent {
  991|       |            plan_id: "block-001".into(),
  992|       |            steps: vec![ActionStep::Block],
  993|       |        };
  994|       |
  995|       |        let cfg = ValidateCfg {
  996|       |            world_bounds: (-10, -10, 10, 10),
  997|       |        };
  998|       |        let mut log = |_s: String| {};
  999|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1000|       |        assert!(res.is_ok());
 1001|       |    }
 1002|       |
 1003|       |    #[test]
 1004|       |    fn test_dodge_action() {
 1005|       |        let mut w = mk_world_clear();
 1006|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1007|       |
 1008|       |        let intent = PlanIntent {
 1009|       |            plan_id: "dodge-001".into(),
 1010|       |            steps: vec![ActionStep::Dodge {
 1011|       |                direction: Some(crate::StrafeDirection::Left),
 1012|       |            }],
 1013|       |        };
 1014|       |
 1015|       |        let cfg = ValidateCfg {
 1016|       |            world_bounds: (-10, -10, 10, 10),
 1017|       |        };
 1018|       |        let mut log = |_s: String| {};
 1019|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1020|       |        assert!(res.is_ok());
 1021|       |    }
 1022|       |
 1023|       |    #[test]
 1024|       |    fn test_parry_action() {
 1025|       |        let mut w = mk_world_clear();
 1026|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1027|       |
 1028|       |        let intent = PlanIntent {
 1029|       |            plan_id: "parry-001".into(),
 1030|       |            steps: vec![ActionStep::Parry],
 1031|       |        };
 1032|       |
 1033|       |        let cfg = ValidateCfg {
 1034|       |            world_bounds: (-10, -10, 10, 10),
 1035|       |        };
 1036|       |        let mut log = |_s: String| {};
 1037|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1038|       |        assert!(res.is_ok());
 1039|       |    }
 1040|       |
 1041|       |    #[test]
 1042|       |    fn test_use_defensive_ability_action() {
 1043|       |        let mut w = mk_world_clear();
 1044|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1045|       |
 1046|       |        let intent = PlanIntent {
 1047|       |            plan_id: "def-001".into(),
 1048|       |            steps: vec![ActionStep::UseDefensiveAbility {
 1049|       |                ability_name: "Shield Bash".to_string(),
 1050|       |            }],
 1051|       |        };
 1052|       |
 1053|       |        let cfg = ValidateCfg {
 1054|       |            world_bounds: (-10, -10, 10, 10),
 1055|       |        };
 1056|       |        let mut log = |_s: String| {};
 1057|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1058|       |        assert!(res.is_ok());
 1059|       |    }
 1060|       |
 1061|       |    #[test]
 1062|       |    fn test_equip_weapon_action() {
 1063|       |        let mut w = mk_world_clear();
 1064|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1065|       |
 1066|       |        let intent = PlanIntent {
 1067|       |            plan_id: "equip-001".into(),
 1068|       |            steps: vec![ActionStep::EquipWeapon {
 1069|       |                weapon_name: "Plasma Rifle".to_string(),
 1070|       |            }],
 1071|       |        };
 1072|       |
 1073|       |        let cfg = ValidateCfg {
 1074|       |            world_bounds: (-10, -10, 10, 10),
 1075|       |        };
 1076|       |        let mut log = |_s: String| {};
 1077|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1078|       |        assert!(res.is_ok());
 1079|       |    }
 1080|       |
 1081|       |    #[test]
 1082|       |    fn test_switch_weapon_action() {
 1083|       |        let mut w = mk_world_clear();
 1084|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1085|       |
 1086|       |        let intent = PlanIntent {
 1087|       |            plan_id: "switch-001".into(),
 1088|       |            steps: vec![ActionStep::SwitchWeapon { slot: 2 }],
 1089|       |        };
 1090|       |
 1091|       |        let cfg = ValidateCfg {
 1092|       |            world_bounds: (-10, -10, 10, 10),
 1093|       |        };
 1094|       |        let mut log = |_s: String| {};
 1095|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1096|       |        assert!(res.is_ok());
 1097|       |    }
 1098|       |
 1099|       |    #[test]
 1100|       |    fn test_use_item_action() {
 1101|       |        let mut w = mk_world_clear();
 1102|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1103|       |
 1104|       |        let intent = PlanIntent {
 1105|       |            plan_id: "item-001".into(),
 1106|       |            steps: vec![ActionStep::UseItem {
 1107|       |                item_name: "Health Potion".to_string(),
 1108|       |            }],
 1109|       |        };
 1110|       |
 1111|       |        let cfg = ValidateCfg {
 1112|       |            world_bounds: (-10, -10, 10, 10),
 1113|       |        };
 1114|       |        let mut log = |_s: String| {};
 1115|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1116|       |        assert!(res.is_ok());
 1117|       |    }
 1118|       |
 1119|       |    #[test]
 1120|       |    fn test_drop_item_action() {
 1121|       |        let mut w = mk_world_clear();
 1122|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1123|       |
 1124|       |        let intent = PlanIntent {
 1125|       |            plan_id: "drop-001".into(),
 1126|       |            steps: vec![ActionStep::DropItem {
 1127|       |                item_name: "Heavy Armor".to_string(),
 1128|       |            }],
 1129|       |        };
 1130|       |
 1131|       |        let cfg = ValidateCfg {
 1132|       |            world_bounds: (-10, -10, 10, 10),
 1133|       |        };
 1134|       |        let mut log = |_s: String| {};
 1135|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1136|       |        assert!(res.is_ok());
 1137|       |    }
 1138|       |
 1139|       |    #[test]
 1140|       |    fn test_call_reinforcements_action() {
 1141|       |        let mut w = mk_world_clear();
 1142|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1143|       |
 1144|       |        let intent = PlanIntent {
 1145|       |            plan_id: "reinforce-001".into(),
 1146|       |            steps: vec![ActionStep::CallReinforcements { count: 3 }],
 1147|       |        };
 1148|       |
 1149|       |        let cfg = ValidateCfg {
 1150|       |            world_bounds: (-10, -10, 10, 10),
 1151|       |        };
 1152|       |        let mut log = |_s: String| {};
 1153|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1154|       |        assert!(res.is_ok());
 1155|       |    }
 1156|       |
 1157|       |    #[test]
 1158|       |    fn test_mark_target_action() {
 1159|       |        let mut w = mk_world_clear();
 1160|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1161|       |        let target = w.spawn("target", IVec2 { x: 5, y: 5 }, Team { id: 2 }, 100, 0);
 1162|       |
 1163|       |        let intent = PlanIntent {
 1164|       |            plan_id: "mark-001".into(),
 1165|       |            steps: vec![ActionStep::MarkTarget { target_id: target }],
 1166|       |        };
 1167|       |
 1168|       |        let cfg = ValidateCfg {
 1169|       |            world_bounds: (-10, -10, 10, 10),
 1170|       |        };
 1171|       |        let mut log = |_s: String| {};
 1172|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1173|       |        assert!(res.is_ok());
 1174|       |    }
 1175|       |
 1176|       |    #[test]
 1177|       |    fn test_request_cover_action() {
 1178|       |        let mut w = mk_world_clear();
 1179|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1180|       |
 1181|       |        let intent = PlanIntent {
 1182|       |            plan_id: "req-cover-001".into(),
 1183|       |            steps: vec![ActionStep::RequestCover { duration: 5.0 }],
 1184|       |        };
 1185|       |
 1186|       |        let cfg = ValidateCfg {
 1187|       |            world_bounds: (-10, -10, 10, 10),
 1188|       |        };
 1189|       |        let mut log = |_s: String| {};
 1190|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1191|       |        assert!(res.is_ok());
 1192|       |    }
 1193|       |
 1194|       |    #[test]
 1195|       |    fn test_coordinate_attack_action() {
 1196|       |        let mut w = mk_world_clear();
 1197|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1198|       |        let target = w.spawn("target", IVec2 { x: 5, y: 5 }, Team { id: 2 }, 100, 0);
 1199|       |
 1200|       |        let intent = PlanIntent {
 1201|       |            plan_id: "coord-001".into(),
 1202|       |            steps: vec![ActionStep::CoordinateAttack { target_id: target }],
 1203|       |        };
 1204|       |
 1205|       |        let cfg = ValidateCfg {
 1206|       |            world_bounds: (-10, -10, 10, 10),
 1207|       |        };
 1208|       |        let mut log = |_s: String| {};
 1209|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1210|       |        assert!(res.is_ok());
 1211|       |    }
 1212|       |
 1213|       |    #[test]
 1214|       |    fn test_set_ambush_action() {
 1215|       |        let mut w = mk_world_clear();
 1216|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1217|       |
 1218|       |        let intent = PlanIntent {
 1219|       |            plan_id: "ambush-001".into(),
 1220|       |            steps: vec![ActionStep::SetAmbush {
 1221|       |                position: IVec2 { x: 8, y: 8 },
 1222|       |            }],
 1223|       |        };
 1224|       |
 1225|       |        let cfg = ValidateCfg {
 1226|       |            world_bounds: (-10, -10, 10, 10),
 1227|       |        };
 1228|       |        let mut log = |_s: String| {};
 1229|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1230|       |        assert!(res.is_ok());
 1231|       |    }
 1232|       |
 1233|       |    #[test]
 1234|       |    fn test_distract_action() {
 1235|       |        let mut w = mk_world_clear();
 1236|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1237|       |        let target = w.spawn("target", IVec2 { x: 5, y: 5 }, Team { id: 2 }, 100, 0);
 1238|       |
 1239|       |        let intent = PlanIntent {
 1240|       |            plan_id: "distract-001".into(),
 1241|       |            steps: vec![ActionStep::Distract { target_id: target }],
 1242|       |        };
 1243|       |
 1244|       |        let cfg = ValidateCfg {
 1245|       |            world_bounds: (-10, -10, 10, 10),
 1246|       |        };
 1247|       |        let mut log = |_s: String| {};
 1248|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1249|       |        assert!(res.is_ok());
 1250|       |    }
 1251|       |
 1252|       |    #[test]
 1253|       |    fn test_regroup_action() {
 1254|       |        let mut w = mk_world_clear();
 1255|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1256|       |
 1257|       |        let intent = PlanIntent {
 1258|       |            plan_id: "regroup-001".into(),
 1259|       |            steps: vec![ActionStep::Regroup {
 1260|       |                rally_point: IVec2 { x: -5, y: -5 },
 1261|       |            }],
 1262|       |        };
 1263|       |
 1264|       |        let cfg = ValidateCfg {
 1265|       |            world_bounds: (-10, -10, 10, 10),
 1266|       |        };
 1267|       |        let mut log = |_s: String| {};
 1268|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1269|       |        assert!(res.is_ok());
 1270|       |    }
 1271|       |
 1272|       |    #[test]
 1273|       |    fn test_scan_action() {
 1274|       |        let mut w = mk_world_clear();
 1275|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1276|       |
 1277|       |        let intent = PlanIntent {
 1278|       |            plan_id: "scan-001".into(),
 1279|       |            steps: vec![ActionStep::Scan { radius: 10.0 }],
 1280|       |        };
 1281|       |
 1282|       |        let cfg = ValidateCfg {
 1283|       |            world_bounds: (-10, -10, 10, 10),
 1284|       |        };
 1285|       |        let mut log = |_s: String| {};
 1286|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1287|       |        assert!(res.is_ok());
 1288|       |    }
 1289|       |
 1290|       |    #[test]
 1291|       |    fn test_wait_action() {
 1292|       |        let mut w = mk_world_clear();
 1293|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1294|       |
 1295|       |        let intent = PlanIntent {
 1296|       |            plan_id: "wait-001".into(),
 1297|       |            steps: vec![ActionStep::Wait { duration: 2.5 }],
 1298|       |        };
 1299|       |
 1300|       |        let cfg = ValidateCfg {
 1301|       |            world_bounds: (-10, -10, 10, 10),
 1302|       |        };
 1303|       |        let mut log = |_s: String| {};
 1304|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1305|       |        assert!(res.is_ok());
 1306|       |    }
 1307|       |
 1308|       |    #[test]
 1309|       |    fn test_interact_action() {
 1310|       |        let mut w = mk_world_clear();
 1311|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1312|       |        let target = w.spawn("object", IVec2 { x: 1, y: 1 }, Team { id: 0 }, 100, 0);
 1313|       |
 1314|       |        let intent = PlanIntent {
 1315|       |            plan_id: "interact-001".into(),
 1316|       |            steps: vec![ActionStep::Interact { target_id: target }],
 1317|       |        };
 1318|       |
 1319|       |        let cfg = ValidateCfg {
 1320|       |            world_bounds: (-10, -10, 10, 10),
 1321|       |        };
 1322|       |        let mut log = |_s: String| {};
 1323|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1324|       |        assert!(res.is_ok());
 1325|       |    }
 1326|       |
 1327|       |    #[test]
 1328|       |    fn test_use_ability_action() {
 1329|       |        let mut w = mk_world_clear();
 1330|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1331|       |
 1332|       |        let intent = PlanIntent {
 1333|       |            plan_id: "ability-001".into(),
 1334|       |            steps: vec![ActionStep::UseAbility {
 1335|       |                ability_name: "Teleport".to_string(),
 1336|       |            }],
 1337|       |        };
 1338|       |
 1339|       |        let cfg = ValidateCfg {
 1340|       |            world_bounds: (-10, -10, 10, 10),
 1341|       |        };
 1342|       |        let mut log = |_s: String| {};
 1343|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1344|       |        assert!(res.is_ok());
 1345|       |    }
 1346|       |
 1347|       |    #[test]
 1348|       |    fn test_taunt_action() {
 1349|       |        let mut w = mk_world_clear();
 1350|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1351|       |        let target = w.spawn("target", IVec2 { x: 5, y: 5 }, Team { id: 2 }, 100, 0);
 1352|       |
 1353|       |        let intent = PlanIntent {
 1354|       |            plan_id: "taunt-001".into(),
 1355|       |            steps: vec![ActionStep::Taunt { target_id: target }],
 1356|       |        };
 1357|       |
 1358|       |        let cfg = ValidateCfg {
 1359|       |            world_bounds: (-10, -10, 10, 10),
 1360|       |        };
 1361|       |        let mut log = |_s: String| {};
 1362|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1363|       |        assert!(res.is_ok());
 1364|       |    }
 1365|       |
 1366|       |    #[test]
 1367|       |    fn test_multi_step_plan() {
 1368|       |        let mut w = mk_world_clear();
 1369|       |        let actor = w.spawn("actor", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 50, 10);
 1370|       |        let enemy = w.spawn("enemy", IVec2 { x: 10, y: 10 }, Team { id: 2 }, 80, 0);
 1371|       |
 1372|       |        let intent = PlanIntent {
 1373|       |            plan_id: "multi-001".into(),
 1374|       |            steps: vec![
 1375|       |                ActionStep::Scan { radius: 15.0 },
 1376|       |                ActionStep::MoveTo {
 1377|       |                    x: 8,
 1378|       |                    y: 8,
 1379|       |                    speed: Some(MovementSpeed::Run),
 1380|       |                },
 1381|       |                ActionStep::AimedShot { target_id: enemy },
 1382|       |                ActionStep::TakeCover {
 1383|       |                    position: Some(IVec2 { x: 7, y: 7 }),
 1384|       |                },
 1385|       |                ActionStep::Heal { target_id: None },
 1386|       |            ],
 1387|       |        };
 1388|       |
 1389|       |        let cfg = ValidateCfg {
 1390|       |            world_bounds: (-10, -10, 15, 15),
 1391|       |        };
 1392|       |        let mut log = |_s: String| {};
 1393|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1394|       |        assert!(res.is_ok());
 1395|       |
 1396|       |        // Verify actor moved
 1397|       |        let final_pos = w.pos_of(actor).unwrap();
 1398|       |        assert_eq!(final_pos, IVec2 { x: 8, y: 8 });
 1399|       |
 1400|       |        // Verify enemy took damage
 1401|       |        let enemy_hp = w.health(enemy).unwrap().hp;
 1402|       |        assert_eq!(enemy_hp, 65); // 80 - 15 (aimed shot)
 1403|       |
 1404|       |        // Verify actor healed
 1405|       |        let actor_hp = w.health(actor).unwrap().hp;
 1406|       |        assert_eq!(actor_hp, 70); // 50 + 20 (heal)
 1407|       |    }
 1408|       |
 1409|       |    #[test]
 1410|       |    fn test_director_fortify_operation() {
 1411|       |        let mut w = mk_world_clear();
 1412|       |        let mut budget = crate::DirectorBudget {
 1413|       |            traps: 2,
 1414|       |            spawns: 5,
 1415|       |            terrain_edits: 3,
 1416|       |        };
 1417|       |
 1418|       |        let plan = crate::DirectorPlan {
 1419|       |            ops: vec![crate::DirectorOp::Fortify {
 1420|       |                rect: crate::Rect {
 1421|       |                    x0: 0,
 1422|       |                    y0: 0,
 1423|       |                    x1: 2,
 1424|       |                    y1: 2,
 1425|       |                },
 1426|       |            }],
 1427|       |        };
 1428|       |
 1429|       |        let mut log = |_s: String| {};
 1430|       |        apply_director_plan(&mut w, &mut budget, &plan, &mut log);
 1431|       |
 1432|       |        // Verify budget was decremented
 1433|       |        assert_eq!(budget.terrain_edits, 2);
 1434|       |
 1435|       |        // Verify obstacles were added (at least one point in rect)
 1436|       |        assert!(
 1437|       |            w.obstacles.contains(&(0, 0))
 1438|       |                || w.obstacles.contains(&(1, 1))
 1439|       |                || w.obstacles.contains(&(2, 2))
 1440|       |        );
 1441|       |    }
 1442|       |
 1443|       |    #[test]
 1444|       |    fn test_director_collapse_operation() {
 1445|       |        let mut w = mk_world_clear();
 1446|       |        let mut budget = crate::DirectorBudget {
 1447|       |            traps: 2,
 1448|       |            spawns: 5,
 1449|       |            terrain_edits: 3,
 1450|       |        };
 1451|       |
 1452|       |        let plan = crate::DirectorPlan {
 1453|       |            ops: vec![crate::DirectorOp::Collapse {
 1454|       |                a: IVec2 { x: 0, y: 0 },
 1455|       |                b: IVec2 { x: 5, y: 5 },
 1456|       |            }],
 1457|       |        };
 1458|       |
 1459|       |        let mut log = |_s: String| {};
 1460|       |        apply_director_plan(&mut w, &mut budget, &plan, &mut log);
 1461|       |
 1462|       |        // Verify budget was decremented
 1463|       |        assert_eq!(budget.terrain_edits, 2);
 1464|       |
 1465|       |        // Verify obstacles were added along the line
 1466|       |        assert!(w.obstacles.contains(&(0, 0)));
 1467|       |    }
 1468|       |
 1469|       |    #[test]
 1470|       |    fn test_director_spawn_wave_operation() {
 1471|       |        let mut w = mk_world_clear();
 1472|       |        let mut budget = crate::DirectorBudget {
 1473|       |            traps: 2,
 1474|       |            spawns: 5,
 1475|       |            terrain_edits: 3,
 1476|       |        };
 1477|       |
 1478|       |        let plan = crate::DirectorPlan {
 1479|       |            ops: vec![crate::DirectorOp::SpawnWave {
 1480|       |                archetype: "zombie".to_string(),
 1481|       |                count: 3,
 1482|       |                origin: IVec2 { x: 10, y: 10 },
 1483|       |            }],
 1484|       |        };
 1485|       |
 1486|       |        let mut log = |_s: String| {};
 1487|       |        apply_director_plan(&mut w, &mut budget, &plan, &mut log);
 1488|       |
 1489|       |        // Verify budget was decremented
 1490|       |        assert_eq!(budget.spawns, 4);
 1491|       |    }
 1492|       |
 1493|       |    #[test]
 1494|       |    fn test_director_budget_enforcement() {
 1495|       |        let mut w = mk_world_clear();
 1496|       |        let mut budget = crate::DirectorBudget {
 1497|       |            traps: 0,
 1498|       |            spawns: 0, // Zero budget
 1499|       |            terrain_edits: 0,
 1500|       |        };
 1501|       |
 1502|       |        let plan = crate::DirectorPlan {
 1503|       |            ops: vec![
 1504|       |                crate::DirectorOp::SpawnWave {
 1505|       |                    archetype: "enemy".to_string(),
 1506|       |                    count: 5,
 1507|       |                    origin: IVec2 { x: 0, y: 0 },
 1508|       |                },
 1509|       |                crate::DirectorOp::Fortify {
 1510|       |                    rect: crate::Rect {
 1511|       |                        x0: 0,
 1512|       |                        y0: 0,
 1513|       |                        x1: 2,
 1514|       |                        y1: 2,
 1515|       |                    },
 1516|       |                },
 1517|       |            ],
 1518|       |        };
 1519|       |
 1520|       |        let initial_obstacle_count = w.obstacles.len();
 1521|       |
 1522|       |        let mut log = |_s: String| {};
 1523|       |        apply_director_plan(&mut w, &mut budget, &plan, &mut log);
 1524|       |
 1525|       |        // Verify nothing happened due to zero budget (obstacles should not change)
 1526|       |        assert_eq!(w.obstacles.len(), initial_obstacle_count);
 1527|       |        assert_eq!(budget.spawns, 0);
 1528|       |        assert_eq!(budget.terrain_edits, 0);
 1529|       |    }
 1530|       |
 1531|       |    #[test]
 1532|       |    fn test_throw_smoke_success() {
 1533|       |        // COVERAGE TARGET: Lines 143-144 (log statement in ThrowSmoke success path)
 1534|       |        let mut w = mk_world_clear();
 1535|       |        let actor = w.spawn("ally", IVec2 { x: 0, y: 0 }, Team { id: 1 }, 100, 10);
 1536|       |        let intent = PlanIntent {
 1537|       |            plan_id: "t".into(),
 1538|       |            steps: vec![ActionStep::ThrowSmoke { x: 3, y: 0 }], // LOS clear, should succeed
 1539|       |        };
 1540|       |        let cfg = ValidateCfg {
 1541|       |            world_bounds: (-10, -10, 10, 10),
 1542|       |        };
 1543|       |        let mut captured_log = String::new();
 1544|       |        let mut log = |s: String| {
 1545|       |            captured_log.push_str(&s);
 1546|       |        };
 1547|       |        let res = validate_and_execute(&mut w, actor, &intent, &cfg, &mut log);
 1548|       |
 1549|       |        // Should succeed (no obstacles between (0,0) and (3,0))
 1550|       |        assert!(res.is_ok(), "ThrowSmoke should succeed with clear LOS");
 1551|       |        // Verify log statement was executed (lines 143-144)
 1552|       |        assert!(
 1553|       |            captured_log.contains("THROW_SMOKE"),
 1554|       |            "Log should contain THROW_SMOKE"
 1555|       |        );
 1556|       |    }
 1557|       |
 1558|       |    #[test]
 1559|       |    fn test_director_collapse_budget_skip() {
 1560|       |        // COVERAGE TARGET: Lines 1450-1451 (Collapse SKIPPED budget logic)
 1561|       |        let mut w = mk_world_clear();
 1562|       |        let mut budget = crate::DirectorBudget {
 1563|       |            traps: 10,
 1564|       |            spawns: 10,
 1565|       |            terrain_edits: 0, // Zero terrain budget
 1566|       |        };
 1567|       |
 1568|       |        let plan = crate::DirectorPlan {
 1569|       |            ops: vec![crate::DirectorOp::Collapse {
 1570|       |                a: IVec2 { x: 0, y: 0 },
 1571|       |                b: IVec2 { x: 5, y: 5 },
 1572|       |            }],
 1573|       |        };
 1574|       |
 1575|       |        let initial_obstacle_count = w.obstacles.len();
 1576|       |
 1577|       |        let mut captured_log = String::new();
 1578|       |        let mut log = |s: String| {
 1579|       |            captured_log.push_str(&s);
 1580|       |            captured_log.push_str("\n");
 1581|       |        };
 1582|       |        apply_director_plan(&mut w, &mut budget, &plan, &mut log);
 1583|       |
 1584|       |        // Verify Collapse was skipped (lines 1450-1451)
 1585|       |        assert_eq!(
 1586|       |            w.obstacles.len(),
 1587|       |            initial_obstacle_count,
 1588|       |            "Obstacles should not change"
 1589|       |        );
 1590|       |        assert!(
 1591|       |            captured_log.contains("Collapse SKIPPED (budget)"),
 1592|       |            "Log should show budget skip"
 1593|       |        );
 1594|       |        assert_eq!(budget.terrain_edits, 0, "Budget should remain zero");
 1595|       |    }
 1596|       |}
 1597|       |fn draw_line_obs(obs: &mut std::collections::HashSet<(i32, i32)>, a: IVec2, b: IVec2) {
 1598|       |    let mut x = a.x;
 1599|       |    let mut y = a.y;
 1600|       |    let dx = (b.x - a.x).signum();
 1601|       |    let dy = (b.y - a.y).signum();
 1602|       |    while x != b.x || y != b.y {
 1603|       |        obs.insert((x, y));
 1604|       |        if x != b.x {
 1605|       |            x += dx;
 1606|       |        }
 1607|       |        if y != b.y {
 1608|       |            y += dy;
 1609|       |        }
 1610|       |    }
 1611|       |    obs.insert((b.x, b.y));
 1612|       |}
 1613|       |
 1614|       |// Execute a DirectorPlan with crude budgets (you can move this into a Director crate too)
 1615|       |pub fn apply_director_plan(
 1616|       |    w: &mut World,
 1617|       |    budget: &mut crate::DirectorBudget,
 1618|       |    plan: &DirectorPlan,
 1619|       |    log: &mut impl FnMut(String),
 1620|       |) {
 1621|       |    for (i, op) in plan.ops.iter().enumerate() {
 1622|       |        match op {
 1623|       |            DirectorOp::Fortify { rect } => {
 1624|       |                if budget.terrain_edits <= 0 {
 1625|       |                    log(format!("  [op{}] Fortify SKIPPED (budget)", i));
 1626|       |                    continue;
 1627|       |                }
 1628|       |                fill_rect_obs(&mut w.obstacles, *rect);
 1629|       |                budget.terrain_edits -= 1;
 1630|       |                log(format!(
 1631|       |                    "  [op{}] Fortify rect=({},{}..{},{}))",
 1632|       |                    i, rect.x0, rect.y0, rect.x1, rect.y1
 1633|       |                ));
 1634|       |            }
 1635|       |            DirectorOp::Collapse { a, b } => {
 1636|       |                if budget.terrain_edits <= 0 {
 1637|       |                    log(format!("  [op{}] Collapse SKIPPED (budget)", i));
 1638|       |                    continue;
 1639|       |                }
 1640|       |                draw_line_obs(&mut w.obstacles, *a, *b);
 1641|       |                budget.terrain_edits -= 1;
 1642|       |                log(format!(
 1643|       |                    "  [op{}] Collapse line=({},{})→({},{})",
 1644|       |                    i, a.x, a.y, b.x, b.y
 1645|       |                ));
 1646|       |            }
 1647|       |            DirectorOp::SpawnWave {
 1648|       |                archetype,
 1649|       |                count,
 1650|       |                origin,
 1651|       |            } => {
 1652|       |                if budget.spawns <= 0 {
 1653|       |                    log(format!("  [op{}] SpawnWave SKIPPED (budget)", i));
 1654|       |                    continue;
 1655|       |                }
 1656|       |                for k in 0..*count {
 1657|       |                    let off = IVec2 {
 1658|       |                        x: origin.x + (k as i32 % 3) - 1,
 1659|       |                        y: origin.y + (k as i32 / 3),
 1660|       |                    };
 1661|       |                    let id = w.spawn(
 1662|       |                        &format!("{}{}", archetype, k),
 1663|       |                        off,
 1664|       |                        crate::Team { id: 2 },
 1665|       |                        40,
 1666|       |                        0,
 1667|       |                    );
 1668|       |                    log(format!("  [op{}] Spawned {} at {:?}", i, id, off));
 1669|       |                }
 1670|       |                budget.spawns -= 1;
 1671|       |            }
 1672|       |        }
 1673|       |    }
 1674|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-core\src\world.rs:
    1|       |use crate::{Entity, IVec2};
    2|       |use astraweave_behavior::BehaviorGraph;
    3|       |use std::collections::{HashMap, HashSet};
    4|       |
    5|       |#[derive(Clone, Copy, Debug)]
    6|       |pub struct Health {
    7|       |    pub hp: i32,
    8|       |}
    9|       |
   10|       |#[derive(Clone, Copy, Debug)]
   11|       |pub struct Team {
   12|       |    pub id: u8,
   13|       |} // 0: player, 1: companion, 2: enemy
   14|       |
   15|       |#[derive(Clone, Copy, Debug)]
   16|       |pub struct Ammo {
   17|       |    pub rounds: i32,
   18|       |}
   19|       |
   20|       |#[derive(Clone, Debug)]
   21|       |pub struct Cooldowns {
   22|       |    pub map: HashMap<String, f32>,
   23|       |}
   24|       |
   25|       |#[derive(Clone, Copy, Debug)]
   26|       |pub struct Pose {
   27|       |    pub pos: IVec2,
   28|       |    pub rotation: f32, // Rotation in radians around Y axis (primary, for compatibility)
   29|       |    pub rotation_x: f32, // Pitch (rotation around X axis)
   30|       |    pub rotation_z: f32, // Roll (rotation around Z axis)
   31|       |    pub scale: f32,    // Uniform scale factor
   32|       |}
   33|       |
   34|       |#[derive(Default)]
   35|       |pub struct World {
   36|       |    pub t: f32,
   37|       |    pub next_id: Entity,
   38|       |    pub obstacles: HashSet<(i32, i32)>,
   39|       |    poses: HashMap<Entity, Pose>,
   40|       |    health: HashMap<Entity, Health>,
   41|       |    team: HashMap<Entity, Team>,
   42|       |    ammo: HashMap<Entity, Ammo>,
   43|       |    cds: HashMap<Entity, Cooldowns>,
   44|       |    names: HashMap<Entity, String>,
   45|       |    behavior_graphs: HashMap<Entity, BehaviorGraph>,
   46|       |}
   47|       |
   48|       |impl World {
   49|     55|    pub fn new() -> Self {
   50|     55|        Self {
   51|     55|            t: 0.0,
   52|     55|            next_id: 1,
   53|     55|            ..Default::default()
   54|     55|        }
   55|     55|    }
   56|       |
   57|    215|    pub fn spawn(&mut self, name: &str, pos: IVec2, team: Team, hp: i32, ammo: i32) -> Entity {
   58|    215|        let id = self.next_id;
   59|    215|        self.next_id += 1;
   60|    215|        self.insert_entity(id, name, pos, team, hp, ammo)
   61|    215|    }
   62|       |
   63|       |    /// Spawn an entity with an explicit id (used for deterministic serialization).
   64|      0|    pub fn spawn_with_id(
   65|      0|        &mut self,
   66|      0|        id: Entity,
   67|      0|        name: &str,
   68|      0|        pos: IVec2,
   69|      0|        team: Team,
   70|      0|        hp: i32,
   71|      0|        ammo: i32,
   72|      0|    ) -> Entity {
   73|      0|        if id >= self.next_id {
   74|      0|            self.next_id = id + 1;
   75|      0|        }
   76|      0|        self.insert_entity(id, name, pos, team, hp, ammo)
   77|      0|    }
   78|       |
   79|    215|    fn insert_entity(
   80|    215|        &mut self,
   81|    215|        id: Entity,
   82|    215|        name: &str,
   83|    215|        pos: IVec2,
   84|    215|        team: Team,
   85|    215|        hp: i32,
   86|    215|        ammo: i32,
   87|    215|    ) -> Entity {
   88|    215|        debug_assert!(!self.poses.contains_key(&id), "entity {id} already exists");
                                                                   ^0
   89|    215|        self.poses.insert(
   90|    215|            id,
   91|    215|            Pose {
   92|    215|                pos,
   93|    215|                rotation: 0.0,
   94|    215|                rotation_x: 0.0,
   95|    215|                rotation_z: 0.0,
   96|    215|                scale: 1.0,
   97|    215|            },
   98|       |        );
   99|    215|        self.health.insert(id, Health { hp });
  100|    215|        self.team.insert(id, team);
  101|    215|        self.ammo.insert(id, Ammo { rounds: ammo });
  102|    215|        self.cds.insert(
  103|    215|            id,
  104|    215|            Cooldowns {
  105|    215|                map: HashMap::new(),
  106|    215|            },
  107|       |        );
  108|    215|        self.names.insert(id, name.to_string());
  109|    215|        id
  110|    215|    }
  111|       |
  112|  1.55k|    pub fn tick(&mut self, dt: f32) {
  113|  1.55k|        self.t += dt;
  114|  6.08k|        for cd in self.cds.values_mut() {
                                ^1.55k   ^1.55k
  115|  6.08k|            for v in cd.map.values_mut() {
                              ^0
  116|      0|                *v = (*v - dt).max(0.0);
  117|      0|            }
  118|       |        }
  119|  1.55k|    }
  120|       |
  121|       |    /// Destroy an entity, removing all its components from the world.
  122|       |    /// Returns true if the entity existed and was destroyed, false otherwise.
  123|      0|    pub fn destroy_entity(&mut self, e: Entity) -> bool {
  124|      0|        let existed = self.poses.remove(&e).is_some();
  125|      0|        if existed {
  126|      0|            self.health.remove(&e);
  127|      0|            self.team.remove(&e);
  128|      0|            self.ammo.remove(&e);
  129|      0|            self.cds.remove(&e);
  130|      0|            self.names.remove(&e);
  131|      0|            self.behavior_graphs.remove(&e);
  132|      0|        }
  133|      0|        existed
  134|      0|    }
  135|       |
  136|       |    // getters/setters
  137|      0|    pub fn pose(&self, e: Entity) -> Option<Pose> {
  138|      0|        self.poses.get(&e).copied()
  139|      0|    }
  140|     37|    pub fn pose_mut(&mut self, e: Entity) -> Option<&mut Pose> {
  141|     37|        self.poses.get_mut(&e)
  142|     37|    }
  143|  6.53k|    pub fn health(&self, e: Entity) -> Option<Health> {
  144|  6.53k|        self.health.get(&e).copied()
  145|  6.53k|    }
  146|     60|    pub fn health_mut(&mut self, e: Entity) -> Option<&mut Health> {
  147|     60|        self.health.get_mut(&e)
  148|     60|    }
  149|  6.53k|    pub fn team(&self, e: Entity) -> Option<Team> {
  150|  6.53k|        self.team.get(&e).copied()
  151|  6.53k|    }
  152|      0|    pub fn team_mut(&mut self, e: Entity) -> Option<&mut Team> {
  153|      0|        self.team.get_mut(&e)
  154|      0|    }
  155|  6.53k|    pub fn ammo(&self, e: Entity) -> Option<Ammo> {
  156|  6.53k|        self.ammo.get(&e).copied()
  157|  6.53k|    }
  158|      1|    pub fn ammo_mut(&mut self, e: Entity) -> Option<&mut Ammo> {
  159|      1|        self.ammo.get_mut(&e)
  160|      1|    }
  161|      0|    pub fn cooldowns(&self, e: Entity) -> Option<&Cooldowns> {
  162|      0|        self.cds.get(&e)
  163|      0|    }
  164|      0|    pub fn cooldowns_mut(&mut self, e: Entity) -> Option<&mut Cooldowns> {
  165|      0|        self.cds.get_mut(&e)
  166|      0|    }
  167|      0|    pub fn name(&self, e: Entity) -> Option<&str> {
  168|      0|        self.names.get(&e).map(|s| s.as_str())
  169|      0|    }
  170|      0|    pub fn behavior_graph(&self, e: Entity) -> Option<&BehaviorGraph> {
  171|      0|        self.behavior_graphs.get(&e)
  172|      0|    }
  173|      0|    pub fn behavior_graph_mut(&mut self, e: Entity) -> Option<&mut BehaviorGraph> {
  174|      0|        self.behavior_graphs.get_mut(&e)
  175|      0|    }
  176|      0|    pub fn set_behavior_graph(&mut self, e: Entity, graph: BehaviorGraph) {
  177|      0|        self.behavior_graphs.insert(e, graph);
  178|      0|    }
  179|      0|    pub fn remove_behavior_graph(&mut self, e: Entity) -> Option<BehaviorGraph> {
  180|      0|        self.behavior_graphs.remove(&e)
  181|      0|    }
  182|       |
  183|  5.05k|    pub fn all_of_team(&self, team_id: u8) -> Vec<Entity> {
  184|  5.05k|        self.team
  185|  5.05k|            .iter()
  186|  19.6k|            .filter_map(|(e, t)| if t.id == team_id { Some(*e) } else { None })
                           ^5.05k                                   ^6.54k            ^13.0k
  187|  5.05k|            .collect()
  188|  5.05k|    }
  189|      0|    pub fn enemies_of(&self, team_id: u8) -> Vec<Entity> {
  190|      0|        self.team
  191|      0|            .iter()
  192|      0|            .filter_map(|(e, t)| if t.id != team_id { Some(*e) } else { None })
  193|      0|            .collect()
  194|      0|    }
  195|  6.55k|    pub fn pos_of(&self, e: Entity) -> Option<IVec2> {
  196|  6.55k|        self.poses.get(&e).map(|p| p.pos)
  197|  6.55k|    }
  198|       |    /// Return a list of all entity ids currently present in the world.
  199|      0|    pub fn entities(&self) -> Vec<Entity> {
  200|      0|        self.poses.keys().copied().collect()
  201|      0|    }
  202|      0|    pub fn obstacle(&self, p: IVec2) -> bool {
  203|      0|        self.obstacles.contains(&(p.x, p.y))
  204|      0|    }
  205|       |}
  206|       |
  207|       |#[cfg(test)]
  208|       |mod tests {
  209|       |    use super::*;
  210|       |
  211|       |    #[test]
  212|       |    fn test_world_new() {
  213|       |        let w = World::new();
  214|       |        assert_eq!(w.t, 0.0);
  215|       |        assert_eq!(w.next_id, 1);
  216|       |        assert!(w.obstacles.is_empty());
  217|       |        assert!(w.entities().is_empty());
  218|       |    }
  219|       |
  220|       |    #[test]
  221|       |    fn test_world_default() {
  222|       |        let w = World::default();
  223|       |        assert_eq!(w.t, 0.0);
  224|       |        assert_eq!(w.next_id, 0);
  225|       |        assert!(w.obstacles.is_empty());
  226|       |    }
  227|       |
  228|       |    #[test]
  229|       |    fn test_spawn_entity() {
  230|       |        let mut w = World::new();
  231|       |        let e = w.spawn("player", IVec2 { x: 5, y: 10 }, Team { id: 0 }, 100, 30);
  232|       |
  233|       |        assert_eq!(e, 1);
  234|       |        assert_eq!(w.next_id, 2);
  235|       |        assert_eq!(w.name(e), Some("player"));
  236|       |        assert_eq!(w.pose(e).unwrap().pos, IVec2 { x: 5, y: 10 });
  237|       |        assert_eq!(w.health(e).unwrap().hp, 100);
  238|       |        assert_eq!(w.team(e).unwrap().id, 0);
  239|       |        assert_eq!(w.ammo(e).unwrap().rounds, 30);
  240|       |        assert!(w.cooldowns(e).unwrap().map.is_empty());
  241|       |    }
  242|       |
  243|       |    #[test]
  244|       |    fn test_spawn_multiple_entities() {
  245|       |        let mut w = World::new();
  246|       |        let e1 = w.spawn("player", IVec2 { x: 0, y: 0 }, Team { id: 0 }, 100, 30);
  247|       |        let e2 = w.spawn("enemy", IVec2 { x: 10, y: 10 }, Team { id: 2 }, 50, 15);
  248|       |        let e3 = w.spawn("companion", IVec2 { x: 5, y: 5 }, Team { id: 1 }, 80, 20);
  249|       |
  250|       |        assert_eq!(e1, 1);
  251|       |        assert_eq!(e2, 2);
  252|       |        assert_eq!(e3, 3);
  253|       |        assert_eq!(w.next_id, 4);
  254|       |        assert_eq!(w.entities().len(), 3);
  255|       |    }
  256|       |
  257|       |    #[test]
  258|       |    fn test_spawn_with_id_preserves_entity_id() {
  259|       |        let mut w = World::new();
  260|       |        let e = w.spawn_with_id(42, "custom", IVec2 { x: 1, y: 2 }, Team { id: 0 }, 90, 12);
  261|       |
  262|       |        assert_eq!(e, 42);
  263|       |        assert_eq!(w.next_id, 43);
  264|       |        assert_eq!(w.pose(42).unwrap().pos, IVec2 { x: 1, y: 2 });
  265|       |    }
  266|       |
  267|       |    #[test]
  268|       |    fn test_tick_updates_time() {
  269|       |        let mut w = World::new();
  270|       |        w.tick(0.1);
  271|       |        assert!((w.t - 0.1).abs() < 1e-6);
  272|       |        w.tick(0.2);
  273|       |        assert!((w.t - 0.3).abs() < 1e-6);
  274|       |    }
  275|       |
  276|       |    #[test]
  277|       |    fn test_tick_decrements_cooldowns() {
  278|       |        let mut w = World::new();
  279|       |        let e = w.spawn("player", IVec2 { x: 0, y: 0 }, Team { id: 0 }, 100, 30);
  280|       |
  281|       |        w.cooldowns_mut(e).unwrap().map.insert("attack".into(), 5.0);
  282|       |        w.cooldowns_mut(e).unwrap().map.insert("heal".into(), 10.0);
  283|       |
  284|       |        w.tick(2.0);
  285|       |
  286|       |        let cds = w.cooldowns(e).unwrap();
  287|       |        assert!((cds.map.get("attack").unwrap() - 3.0).abs() < 1e-6);
  288|       |        assert!((cds.map.get("heal").unwrap() - 8.0).abs() < 1e-6);
  289|       |    }
  290|       |
  291|       |    #[test]
  292|       |    fn test_tick_cooldowns_bottom_at_zero() {
  293|       |        let mut w = World::new();
  294|       |        let e = w.spawn("player", IVec2 { x: 0, y: 0 }, Team { id: 0 }, 100, 30);
  295|       |
  296|       |        w.cooldowns_mut(e).unwrap().map.insert("attack".into(), 1.0);
  297|       |        w.tick(2.0);
  298|       |
  299|       |        let cds = w.cooldowns(e).unwrap();
  300|       |        assert_eq!(*cds.map.get("attack").unwrap(), 0.0);
  301|       |    }
  302|       |
  303|       |    #[test]
  304|       |    fn test_pose_getter() {
  305|       |        let mut w = World::new();
  306|       |        let e = w.spawn("player", IVec2 { x: 7, y: 13 }, Team { id: 0 }, 100, 30);
  307|       |
  308|       |        let pose = w.pose(e).unwrap();
  309|       |        assert_eq!(pose.pos.x, 7);
  310|       |        assert_eq!(pose.pos.y, 13);
  311|       |    }
  312|       |
  313|       |    #[test]
  314|       |    fn test_pose_mut() {
  315|       |        let mut w = World::new();
  316|       |        let e = w.spawn("player", IVec2 { x: 0, y: 0 }, Team { id: 0 }, 100, 30);
  317|       |
  318|       |        w.pose_mut(e).unwrap().pos = IVec2 { x: 20, y: 30 };
  319|       |
  320|       |        assert_eq!(w.pose(e).unwrap().pos, IVec2 { x: 20, y: 30 });
  321|       |    }
  322|       |
  323|       |    #[test]
  324|       |    fn test_pose_nonexistent_entity() {
  325|       |        let w = World::new();
  326|       |        assert!(w.pose(999).is_none());
  327|       |        assert_eq!(w.pos_of(999), None);
  328|       |    }
  329|       |
  330|       |    #[test]
  331|       |    fn test_health_getter() {
  332|       |        let mut w = World::new();
  333|       |        let e = w.spawn("player", IVec2 { x: 0, y: 0 }, Team { id: 0 }, 75, 30);
  334|       |
  335|       |        assert_eq!(w.health(e).unwrap().hp, 75);
  336|       |    }
  337|       |
  338|       |    #[test]
  339|       |    fn test_health_mut() {
  340|       |        let mut w = World::new();
  341|       |        let e = w.spawn("player", IVec2 { x: 0, y: 0 }, Team { id: 0 }, 100, 30);
  342|       |
  343|       |        w.health_mut(e).unwrap().hp = 50;
  344|       |
  345|       |        assert_eq!(w.health(e).unwrap().hp, 50);
  346|       |    }
  347|       |
  348|       |    #[test]
  349|       |    fn test_health_nonexistent_entity() {
  350|       |        let w = World::new();
  351|       |        assert!(w.health(999).is_none());
  352|       |    }
  353|       |
  354|       |    #[test]
  355|       |    fn test_team_getter() {
  356|       |        let mut w = World::new();
  357|       |        let e = w.spawn("enemy", IVec2 { x: 0, y: 0 }, Team { id: 2 }, 50, 15);
  358|       |
  359|       |        assert_eq!(w.team(e).unwrap().id, 2);
  360|       |    }
  361|       |
  362|       |    #[test]
  363|       |    fn test_team_nonexistent_entity() {
  364|       |        let w = World::new();
  365|       |        assert!(w.team(999).is_none());
  366|       |    }
  367|       |
  368|       |    #[test]
  369|       |    fn test_ammo_getter() {
  370|       |        let mut w = World::new();
  371|       |        let e = w.spawn("player", IVec2 { x: 0, y: 0 }, Team { id: 0 }, 100, 42);
  372|       |
  373|       |        assert_eq!(w.ammo(e).unwrap().rounds, 42);
  374|       |    }
  375|       |
  376|       |    #[test]
  377|       |    fn test_ammo_mut() {
  378|       |        let mut w = World::new();
  379|       |        let e = w.spawn("player", IVec2 { x: 0, y: 0 }, Team { id: 0 }, 100, 30);
  380|       |
  381|       |        w.ammo_mut(e).unwrap().rounds = 10;
  382|       |
  383|       |        assert_eq!(w.ammo(e).unwrap().rounds, 10);
  384|       |    }
  385|       |
  386|       |    #[test]
  387|       |    fn test_ammo_nonexistent_entity() {
  388|       |        let w = World::new();
  389|       |        assert!(w.ammo(999).is_none());
  390|       |    }
  391|       |
  392|       |    #[test]
  393|       |    fn test_cooldowns_getter() {
  394|       |        let mut w = World::new();
  395|       |        let e = w.spawn("player", IVec2 { x: 0, y: 0 }, Team { id: 0 }, 100, 30);
  396|       |
  397|       |        let cds = w.cooldowns(e).unwrap();
  398|       |        assert!(cds.map.is_empty());
  399|       |    }
  400|       |
  401|       |    #[test]
  402|       |    fn test_cooldowns_mut() {
  403|       |        let mut w = World::new();
  404|       |        let e = w.spawn("player", IVec2 { x: 0, y: 0 }, Team { id: 0 }, 100, 30);
  405|       |
  406|       |        w.cooldowns_mut(e).unwrap().map.insert("attack".into(), 5.0);
  407|       |
  408|       |        let cds = w.cooldowns(e).unwrap();
  409|       |        assert_eq!(*cds.map.get("attack").unwrap(), 5.0);
  410|       |    }
  411|       |
  412|       |    #[test]
  413|       |    fn test_cooldowns_nonexistent_entity() {
  414|       |        let w = World::new();
  415|       |        assert!(w.cooldowns(999).is_none());
  416|       |    }
  417|       |
  418|       |    #[test]
  419|       |    fn test_name_getter() {
  420|       |        let mut w = World::new();
  421|       |        let e = w.spawn("hero", IVec2 { x: 0, y: 0 }, Team { id: 0 }, 100, 30);
  422|       |
  423|       |        assert_eq!(w.name(e), Some("hero"));
  424|       |    }
  425|       |
  426|       |    #[test]
  427|       |    fn test_name_nonexistent_entity() {
  428|       |        let w = World::new();
  429|       |        assert!(w.name(999).is_none());
  430|       |    }
  431|       |
  432|       |    #[test]
  433|       |    fn test_behavior_graph_assignment_and_retrieval() {
  434|       |        use astraweave_behavior::{BehaviorGraph, BehaviorNode};
  435|       |
  436|       |        let mut world = World::new();
  437|       |        let entity = world.spawn("ai", IVec2 { x: 0, y: 0 }, Team { id: 0 }, 100, 30);
  438|       |        let graph = BehaviorGraph::new(BehaviorNode::Action("idle".into()));
  439|       |
  440|       |        world.set_behavior_graph(entity, graph.clone());
  441|       |        let stored = world.behavior_graph(entity).expect("graph stored");
  442|       |        if let BehaviorNode::Action(name) = &stored.root {
  443|       |            assert_eq!(name, "idle");
  444|       |        } else {
  445|       |            panic!("expected action node");
  446|       |        }
  447|       |
  448|       |        let removed = world.remove_behavior_graph(entity);
  449|       |        assert!(removed.is_some());
  450|       |        assert!(world.behavior_graph(entity).is_none());
  451|       |    }
  452|       |
  453|       |    #[test]
  454|       |    fn test_all_of_team() {
  455|       |        let mut w = World::new();
  456|       |        let p1 = w.spawn("player", IVec2 { x: 0, y: 0 }, Team { id: 0 }, 100, 30);
  457|       |        let e1 = w.spawn("enemy1", IVec2 { x: 10, y: 10 }, Team { id: 2 }, 50, 15);
  458|       |        let e2 = w.spawn("enemy2", IVec2 { x: 15, y: 15 }, Team { id: 2 }, 50, 15);
  459|       |        let c1 = w.spawn("companion", IVec2 { x: 5, y: 5 }, Team { id: 1 }, 80, 20);
  460|       |
  461|       |        let team_0 = w.all_of_team(0);
  462|       |        assert_eq!(team_0.len(), 1);
  463|       |        assert!(team_0.contains(&p1));
  464|       |
  465|       |        let team_1 = w.all_of_team(1);
  466|       |        assert_eq!(team_1.len(), 1);
  467|       |        assert!(team_1.contains(&c1));
  468|       |
  469|       |        let team_2 = w.all_of_team(2);
  470|       |        assert_eq!(team_2.len(), 2);
  471|       |        assert!(team_2.contains(&e1));
  472|       |        assert!(team_2.contains(&e2));
  473|       |    }
  474|       |
  475|       |    #[test]
  476|       |    fn test_all_of_team_empty() {
  477|       |        let w = World::new();
  478|       |        let team_0 = w.all_of_team(0);
  479|       |        assert!(team_0.is_empty());
  480|       |    }
  481|       |
  482|       |    #[test]
  483|       |    fn test_enemies_of() {
  484|       |        let mut w = World::new();
  485|       |        let p1 = w.spawn("player", IVec2 { x: 0, y: 0 }, Team { id: 0 }, 100, 30);
  486|       |        let e1 = w.spawn("enemy1", IVec2 { x: 10, y: 10 }, Team { id: 2 }, 50, 15);
  487|       |        let e2 = w.spawn("enemy2", IVec2 { x: 15, y: 15 }, Team { id: 2 }, 50, 15);
  488|       |        let c1 = w.spawn("companion", IVec2 { x: 5, y: 5 }, Team { id: 1 }, 80, 20);
  489|       |
  490|       |        let enemies_of_player = w.enemies_of(0);
  491|       |        assert_eq!(enemies_of_player.len(), 3);
  492|       |        assert!(enemies_of_player.contains(&e1));
  493|       |        assert!(enemies_of_player.contains(&e2));
  494|       |        assert!(enemies_of_player.contains(&c1));
  495|       |        assert!(!enemies_of_player.contains(&p1));
  496|       |    }
  497|       |
  498|       |    #[test]
  499|       |    fn test_enemies_of_empty() {
  500|       |        let w = World::new();
  501|       |        let enemies = w.enemies_of(0);
  502|       |        assert!(enemies.is_empty());
  503|       |    }
  504|       |
  505|       |    #[test]
  506|       |    fn test_pos_of() {
  507|       |        let mut w = World::new();
  508|       |        let e = w.spawn("player", IVec2 { x: 12, y: 34 }, Team { id: 0 }, 100, 30);
  509|       |
  510|       |        let pos = w.pos_of(e).unwrap();
  511|       |        assert_eq!(pos.x, 12);
  512|       |        assert_eq!(pos.y, 34);
  513|       |    }
  514|       |
  515|       |    #[test]
  516|       |    fn test_pos_of_nonexistent() {
  517|       |        let w = World::new();
  518|       |        assert!(w.pos_of(999).is_none());
  519|       |    }
  520|       |
  521|       |    #[test]
  522|       |    fn test_entities() {
  523|       |        let mut w = World::new();
  524|       |        assert!(w.entities().is_empty());
  525|       |
  526|       |        let e1 = w.spawn("player", IVec2 { x: 0, y: 0 }, Team { id: 0 }, 100, 30);
  527|       |        let e2 = w.spawn("enemy", IVec2 { x: 10, y: 10 }, Team { id: 2 }, 50, 15);
  528|       |
  529|       |        let entities = w.entities();
  530|       |        assert_eq!(entities.len(), 2);
  531|       |        assert!(entities.contains(&e1));
  532|       |        assert!(entities.contains(&e2));
  533|       |    }
  534|       |
  535|       |    #[test]
  536|       |    fn test_obstacle_present() {
  537|       |        let mut w = World::new();
  538|       |        w.obstacles.insert((5, 10));
  539|       |
  540|       |        assert!(w.obstacle(IVec2 { x: 5, y: 10 }));
  541|       |    }
  542|       |
  543|       |    #[test]
  544|       |    fn test_obstacle_absent() {
  545|       |        let w = World::new();
  546|       |        assert!(!w.obstacle(IVec2 { x: 5, y: 10 }));
  547|       |    }
  548|       |
  549|       |    #[test]
  550|       |    fn test_obstacle_multiple() {
  551|       |        let mut w = World::new();
  552|       |        w.obstacles.insert((0, 0));
  553|       |        w.obstacles.insert((5, 5));
  554|       |        w.obstacles.insert((10, 10));
  555|       |
  556|       |        assert!(w.obstacle(IVec2 { x: 0, y: 0 }));
  557|       |        assert!(w.obstacle(IVec2 { x: 5, y: 5 }));
  558|       |        assert!(w.obstacle(IVec2 { x: 10, y: 10 }));
  559|       |        assert!(!w.obstacle(IVec2 { x: 7, y: 7 }));
  560|       |    }
  561|       |
  562|       |    #[test]
  563|       |    fn test_destroy_entity_removes_all_components() {
  564|       |        let mut w = World::new();
  565|       |        let e = w.spawn("player", IVec2 { x: 5, y: 10 }, Team { id: 0 }, 100, 30);
  566|       |
  567|       |        assert!(w.pose(e).is_some());
  568|       |        assert!(w.health(e).is_some());
  569|       |        assert!(w.team(e).is_some());
  570|       |        assert!(w.ammo(e).is_some());
  571|       |        assert!(w.cooldowns(e).is_some());
  572|       |        assert!(w.name(e).is_some());
  573|       |
  574|       |        let destroyed = w.destroy_entity(e);
  575|       |        assert!(destroyed);
  576|       |
  577|       |        assert!(w.pose(e).is_none());
  578|       |        assert!(w.health(e).is_none());
  579|       |        assert!(w.team(e).is_none());
  580|       |        assert!(w.ammo(e).is_none());
  581|       |        assert!(w.cooldowns(e).is_none());
  582|       |        assert!(w.name(e).is_none());
  583|       |        assert!(w.behavior_graph(e).is_none());
  584|       |    }
  585|       |
  586|       |    #[test]
  587|       |    fn test_destroy_entity_returns_false_for_nonexistent_entity() {
  588|       |        let mut w = World::new();
  589|       |        let destroyed = w.destroy_entity(999);
  590|       |        assert!(!destroyed);
  591|       |    }
  592|       |
  593|       |    #[test]
  594|       |    fn test_destroy_entity_updates_entities_list() {
  595|       |        let mut w = World::new();
  596|       |        let e1 = w.spawn("entity1", IVec2 { x: 0, y: 0 }, Team { id: 0 }, 100, 30);
  597|       |        let e2 = w.spawn("entity2", IVec2 { x: 5, y: 5 }, Team { id: 0 }, 100, 30);
  598|       |        let e3 = w.spawn("entity3", IVec2 { x: 10, y: 10 }, Team { id: 0 }, 100, 30);
  599|       |
  600|       |        assert_eq!(w.entities().len(), 3);
  601|       |
  602|       |        w.destroy_entity(e2);
  603|       |
  604|       |        let entities = w.entities();
  605|       |        assert_eq!(entities.len(), 2);
  606|       |        assert!(entities.contains(&e1));
  607|       |        assert!(!entities.contains(&e2));
  608|       |        assert!(entities.contains(&e3));
  609|       |    }
  610|       |
  611|       |    #[test]
  612|       |    fn test_destroy_entity_preserves_other_entities() {
  613|       |        let mut w = World::new();
  614|       |        let e1 = w.spawn("entity1", IVec2 { x: 0, y: 0 }, Team { id: 0 }, 100, 30);
  615|       |        let e2 = w.spawn("entity2", IVec2 { x: 5, y: 5 }, Team { id: 1 }, 80, 20);
  616|       |
  617|       |        w.destroy_entity(e1);
  618|       |
  619|       |        assert!(w.pose(e1).is_none());
  620|       |        assert!(w.pose(e2).is_some());
  621|       |        assert_eq!(w.pose(e2).unwrap().pos, IVec2 { x: 5, y: 5 });
  622|       |        assert_eq!(w.health(e2).unwrap().hp, 80);
  623|       |        assert_eq!(w.team(e2).unwrap().id, 1);
  624|       |        assert_eq!(w.ammo(e2).unwrap().rounds, 20);
  625|       |    }
  626|       |}
  627|       |

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\archetype.rs:
    1|       |//! AstraWeave ECS — Production-grade, AI-native ECS for game development.
    2|       |
    3|       |use std::any::TypeId;
    4|       |use std::collections::{BTreeMap, HashMap};
    5|       |
    6|       |#[cfg(feature = "profiling")]
    7|       |use astraweave_profiling::span;
    8|       |
    9|       |use crate::sparse_set::SparseSet;
   10|       |use crate::{Component, Entity};
   11|       |
   12|       |/// Unique identifier for an archetype (set of component types)
   13|       |#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
   14|       |pub struct ArchetypeId(u64);
   15|       |
   16|       |/// Describes the component layout of an archetype
   17|       |#[derive(Clone, Debug, PartialEq, Eq, Hash)]
   18|       |pub struct ArchetypeSignature {
   19|       |    /// Sorted list of component TypeIds for deterministic comparison
   20|       |    pub components: Vec<TypeId>,
   21|       |}
   22|       |
   23|       |impl ArchetypeSignature {
   24|      0|    pub fn new(mut components: Vec<TypeId>) -> Self {
   25|      0|        components.sort_unstable();
   26|      0|        components.dedup();
   27|      0|        Self { components }
   28|      0|    }
   29|       |
   30|      0|    pub fn contains(&self, ty: TypeId) -> bool {
   31|      0|        self.components.binary_search(&ty).is_ok()
   32|      0|    }
   33|       |
   34|      0|    pub fn len(&self) -> usize {
   35|      0|        self.components.len()
   36|      0|    }
   37|       |
   38|      0|    pub fn is_empty(&self) -> bool {
   39|      0|        self.components.is_empty()
   40|      0|    }
   41|       |}
   42|       |
   43|       |/// Archetype storage: all entities with the same component signature
   44|       |pub struct Archetype {
   45|       |    pub id: ArchetypeId,
   46|       |    pub signature: ArchetypeSignature,
   47|       |
   48|       |    /// NEW: Packed entity list for iteration (cache-friendly)
   49|       |    entities: Vec<Entity>,
   50|       |
   51|       |    /// NEW: O(1) entity lookup (replaces BTreeMap)
   52|       |    entity_index: SparseSet,
   53|       |
   54|       |    /// Component columns: TypeId -> Vec<Box<dyn Any>>
   55|       |    /// NOTE: Still using Box for now (type-erased storage)
   56|       |    /// Future: Replace with BlobVec once we add type registry
   57|       |    components: HashMap<TypeId, Vec<Box<dyn std::any::Any + Send + Sync>>>,
   58|       |}
   59|       |
   60|       |impl Archetype {
   61|      0|    pub fn new(id: ArchetypeId, signature: ArchetypeSignature) -> Self {
   62|      0|        let mut components = HashMap::new();
   63|      0|        for ty in &signature.components {
   64|      0|            components.insert(*ty, Vec::new());
   65|      0|        }
   66|      0|        Self {
   67|      0|            id,
   68|      0|            signature,
   69|      0|            entities: Vec::new(),
   70|      0|            entity_index: SparseSet::new(),
   71|      0|            components,
   72|      0|        }
   73|      0|    }
   74|       |
   75|       |    /// Add an entity with its components (must match signature)
   76|      0|    pub fn add_entity(
   77|      0|        &mut self,
   78|      0|        entity: Entity,
   79|      0|        mut component_data: HashMap<TypeId, Box<dyn std::any::Any + Send + Sync>>,
   80|      0|    ) {
   81|       |        // NEW: Use SparseSet for O(1) lookup (12-57× faster than BTreeMap)
   82|      0|        self.entity_index.insert(entity);
   83|      0|        self.entities.push(entity);
   84|       |
   85|      0|        for ty in &self.signature.components {
   86|      0|            if let Some(data) = component_data.remove(ty) {
   87|      0|                // Move the Box from component_data into the column
   88|      0|                let column = self
   89|      0|                    .components
   90|      0|                    .get_mut(ty)
   91|      0|                    .expect("BUG: signature component should have column");
   92|      0|                column.push(data);
   93|      0|            }
   94|       |        }
   95|      0|    }
   96|       |
   97|       |    /// Get component for entity
   98|      0|    pub fn get<T: Component>(&self, entity: Entity) -> Option<&T> {
   99|       |        // NEW: O(1) lookup with SparseSet (12-57× faster than BTreeMap)
  100|      0|        let row = self.entity_index.get(entity)?;
  101|      0|        let column = self.components.get(&TypeId::of::<T>())?;
  102|      0|        let boxed = column.get(row)?;
  103|      0|        boxed.downcast_ref::<T>()
  104|      0|    }
  105|       |
  106|       |    /// Get mutable component for entity
  107|      0|    pub fn get_mut<T: Component>(&mut self, entity: Entity) -> Option<&mut T> {
  108|       |        // NEW: O(1) lookup with SparseSet (12-57× faster than BTreeMap)
  109|      0|        let row = self.entity_index.get(entity)?;
  110|      0|        let column = self.components.get_mut(&TypeId::of::<T>())?;
  111|      0|        let boxed = column.get_mut(row)?;
  112|      0|        boxed.downcast_mut::<T>()
  113|      0|    }
  114|       |
  115|      0|    pub fn remove_entity(&mut self, entity: Entity) -> Option<usize> {
  116|       |        // NEW: O(1) removal with SparseSet (4-7× faster than BTreeMap)
  117|      0|        self.entity_index.remove(entity)
  118|      0|    }
  119|       |
  120|       |    /// Remove entity from archetype and return its components
  121|      0|    pub fn remove_entity_components(
  122|      0|        &mut self,
  123|      0|        entity: Entity,
  124|      0|    ) -> HashMap<TypeId, Box<dyn std::any::Any + Send + Sync>> {
  125|       |        // NEW: O(1) removal with SparseSet
  126|      0|        let row = match self.entity_index.remove(entity) {
  127|      0|            Some(r) => r,
  128|      0|            None => return HashMap::new(),
  129|       |        };
  130|       |
  131|       |        // Remove from packed entity list using swap_remove
  132|      0|        let entities_len = self.entities.len();
  133|      0|        if row < entities_len - 1 {
  134|      0|            self.entities.swap(row, entities_len - 1);
  135|      0|            // Update the swapped entity's index in SparseSet
  136|      0|            let swapped_entity = self.entities[row];
  137|      0|            self.entity_index.insert(swapped_entity); // Will update to correct row
  138|      0|        }
  139|      0|        self.entities.pop();
  140|       |
  141|      0|        let mut components = HashMap::new();
  142|      0|        for (ty, column) in self.components.iter_mut() {
  143|      0|            let component = column.swap_remove(row);
  144|      0|            components.insert(*ty, component);
  145|      0|        }
  146|       |
  147|      0|        components
  148|      0|    }
  149|       |
  150|      0|    pub fn len(&self) -> usize {
  151|      0|        self.entities.len()
  152|      0|    }
  153|       |
  154|      0|    pub fn is_empty(&self) -> bool {
  155|      0|        self.entities.is_empty()
  156|      0|    }
  157|       |
  158|       |    /// Get a slice of entities in this archetype (zero-cost, cache-friendly!)
  159|      0|    pub fn entities_vec(&self) -> &[Entity] {
  160|      0|        &self.entities
  161|      0|    }
  162|       |
  163|       |    /// Iterate over (entity, component) pairs for batch processing.
  164|       |    ///
  165|       |    /// This is much faster than repeated get() calls as it avoids per-entity lookups.
  166|       |    ///
  167|       |    /// ## Performance Notes (Week 10)
  168|       |    ///
  169|       |    /// With SparseSet integration, get() is now O(1) instead of O(log n), providing
  170|       |    /// 12-57× speedup over the old BTreeMap approach. This iterator provides additional
  171|       |    /// benefits by reducing function call overhead and improving cache locality.
  172|       |    ///
  173|       |    /// ## Mutable Iterator Limitation
  174|       |    ///
  175|       |    /// Note: A mutable version (`iter_components_mut<T>()`) is **not feasible** due to
  176|       |    /// Rust's borrow checker limitations. The issue is:
  177|       |    ///
  178|       |    /// ```rust,ignore
  179|       |    /// pub fn iter_components_mut<T>(&mut self) -> impl Iterator<Item = (Entity, &mut T)> {
  180|       |    ///     let column = self.components.get_mut(&TypeId::of::<T>())?;
  181|       |    ///     self.entities.iter().filter_map(|(idx, &entity)| {
  182|       |    ///         column.get_mut(idx)  // ❌ ERROR: captured variable escapes FnMut closure
  183|       |    ///     })
  184|       |    /// }
  185|       |    /// ```
  186|       |    ///
  187|       |    /// Rust prevents this because the closure captures `column` and tries to return
  188|       |    /// `&mut T` borrowed from it. The borrow checker rule is: **references captured in
  189|       |    /// closures cannot escape the closure scope**. This prevents dangling references.
  190|       |    ///
  191|       |    /// **Workarounds considered**:
  192|       |    /// - Unsafe raw pointers: Would work but loses safety guarantees (not worth it)
  193|       |    /// - Index-based batch API: Complex redesign with uncertain performance gains
  194|       |    /// - Type registry + BlobVec: Full solution but requires architectural changes (Week 13+)
  195|       |    ///
  196|       |    /// **Current approach**: Accept that SparseSet O(1) already provides 2.4× frame time
  197|       |    /// improvement (2.70ms → 1.144ms) and 9.4× faster movement (1,000µs → 106µs). Further
  198|       |    /// query optimization has diminishing returns vs complexity/safety trade-offs.
  199|      0|    pub fn iter_components<T: Component>(&self) -> impl Iterator<Item = (Entity, &T)> + '_ {
  200|      0|        let column = self.components.get(&TypeId::of::<T>());
  201|      0|        self.entities
  202|      0|            .iter()
  203|      0|            .enumerate()
  204|      0|            .filter_map(move |(idx, &entity)| {
  205|      0|                column
  206|      0|                    .and_then(|col| col.get(idx))
  207|      0|                    .and_then(|boxed| boxed.downcast_ref::<T>())
  208|      0|                    .map(|component| (entity, component))
  209|      0|            })
  210|      0|    }
  211|       |}
  212|       |
  213|       |/// Manages all archetypes and entity->archetype mapping
  214|       |///
  215|       |/// # Determinism Guarantee
  216|       |///
  217|       |/// **CRITICAL**: This uses `BTreeMap` for archetype storage to ensure deterministic iteration.
  218|       |/// Iteration order is sorted by `ArchetypeId`, which preserves archetype creation order
  219|       |/// (IDs assigned sequentially via `next_id`).
  220|       |///
  221|       |/// **Why BTreeMap?**
  222|       |/// - HashMap iteration order is **non-deterministic** (depends on hash function, memory layout)
  223|       |/// - BTreeMap iteration order is **deterministic** (sorted by key)
  224|       |/// - For AI agents, deterministic entity iteration is **critical** for reproducible behavior
  225|       |///
  226|       |/// **Performance Note**:
  227|       |/// - BTreeMap operations are O(log n) vs HashMap O(1)
  228|       |/// - With ~100 archetypes typical, log₂(100) ≈ 7 operations (negligible)
  229|       |/// - Entity queries iterate archetypes (O(archetypes)), so iteration order matters more than lookup
  230|       |///
  231|       |/// # Zero-Allocation Hot Path
  232|       |///
  233|       |/// **CRITICAL**: Entity-to-archetype mapping uses `Vec<Option<ArchetypeId>>` indexed by entity ID
  234|       |/// instead of HashMap to ensure zero heap allocations during component access hot paths.
  235|       |/// HashMap uses RandomState hasher which can allocate thread-local state on first access.
  236|       |#[derive(Default)]
  237|       |pub struct ArchetypeStorage {
  238|       |    next_id: u64,
  239|       |    /// Map from signature to archetype ID
  240|       |    signature_to_id: HashMap<ArchetypeSignature, ArchetypeId>,
  241|       |    /// All archetypes (BTreeMap for deterministic iteration by ID)
  242|       |    archetypes: BTreeMap<ArchetypeId, Archetype>,
  243|       |    /// Entity to archetype mapping (sparse array indexed by entity ID for zero-alloc lookup)
  244|       |    /// Uses Vec<Option<ArchetypeId>> instead of HashMap for zero-alloc hot path.
  245|       |    entity_to_archetype: Vec<Option<ArchetypeId>>,
  246|       |}
  247|       |
  248|       |impl ArchetypeStorage {
  249|      0|    pub fn new() -> Self {
  250|      0|        Self {
  251|      0|            next_id: 0,
  252|      0|            signature_to_id: HashMap::new(),
  253|      0|            archetypes: BTreeMap::new(),
  254|      0|            entity_to_archetype: Vec::new(),
  255|      0|        }
  256|      0|    }
  257|       |
  258|       |    /// Get or create archetype for a signature
  259|      0|    pub fn get_or_create_archetype(&mut self, signature: ArchetypeSignature) -> ArchetypeId {
  260|      0|        if let Some(&id) = self.signature_to_id.get(&signature) {
  261|      0|            return id;
  262|      0|        }
  263|       |
  264|      0|        let id = ArchetypeId(self.next_id);
  265|      0|        self.next_id += 1;
  266|       |
  267|      0|        let archetype = Archetype::new(id, signature.clone());
  268|      0|        self.archetypes.insert(id, archetype);
  269|      0|        self.signature_to_id.insert(signature, id);
  270|       |
  271|      0|        id
  272|      0|    }
  273|       |
  274|      0|    pub fn get_archetype(&self, id: ArchetypeId) -> Option<&Archetype> {
  275|      0|        self.archetypes.get(&id)
  276|      0|    }
  277|       |
  278|      0|    pub fn get_archetype_mut(&mut self, id: ArchetypeId) -> Option<&mut Archetype> {
  279|      0|        self.archetypes.get_mut(&id)
  280|      0|    }
  281|       |
  282|       |    /// Get archetype for an entity (zero-alloc O(1) lookup)
  283|       |    #[inline]
  284|      0|    pub fn get_entity_archetype(&self, entity: Entity) -> Option<ArchetypeId> {
  285|      0|        let id = entity.id() as usize;
  286|      0|        self.entity_to_archetype.get(id).copied().flatten()
  287|      0|    }
  288|       |
  289|       |    /// Set archetype for an entity (may allocate if entity ID is larger than current capacity)
  290|      0|    pub fn set_entity_archetype(&mut self, entity: Entity, archetype: ArchetypeId) {
  291|      0|        let id = entity.id() as usize;
  292|       |        // Grow the sparse array if needed (only allocates during warmup/setup)
  293|      0|        if id >= self.entity_to_archetype.len() {
  294|      0|            self.entity_to_archetype.resize(id + 1, None);
  295|      0|        }
  296|      0|        self.entity_to_archetype[id] = Some(archetype);
  297|      0|    }
  298|       |
  299|       |    /// Remove archetype mapping for an entity (zero-alloc)
  300|       |    #[inline]
  301|      0|    pub fn remove_entity(&mut self, entity: Entity) -> Option<ArchetypeId> {
  302|      0|        let id = entity.id() as usize;
  303|      0|        if id < self.entity_to_archetype.len() {
  304|      0|            self.entity_to_archetype[id].take()
  305|       |        } else {
  306|      0|            None
  307|       |        }
  308|      0|    }
  309|       |
  310|       |    /// Iterate over all archetypes
  311|      0|    pub fn archetypes(&self) -> impl Iterator<Item = &Archetype> {
  312|      0|        self.archetypes.values()
  313|      0|    }
  314|       |
  315|       |    /// Iterate over all archetypes (alias for consistency with standard iterator naming)
  316|      0|    pub fn iter(&self) -> impl Iterator<Item = &Archetype> {
  317|      0|        self.archetypes.values()
  318|      0|    }
  319|       |
  320|       |    /// Iterate mutably over all archetypes
  321|      0|    pub fn archetypes_mut(&mut self) -> impl Iterator<Item = &mut Archetype> {
  322|      0|        self.archetypes.values_mut()
  323|      0|    }
  324|       |
  325|       |    /// Find archetypes that contain a specific component
  326|      0|    pub fn archetypes_with_component(&self, ty: TypeId) -> impl Iterator<Item = &Archetype> {
  327|       |        #[cfg(feature = "profiling")]
  328|       |        span!("ECS::Archetype::archetypes_with_component");
  329|       |
  330|      0|        self.archetypes
  331|      0|            .values()
  332|      0|            .filter(move |arch| arch.signature.contains(ty))
  333|      0|    }
  334|       |}
  335|       |
  336|       |#[cfg(test)]
  337|       |mod tests {
  338|       |    use super::*;
  339|       |
  340|       |    #[derive(Clone, Copy, Debug, PartialEq)]
  341|       |    struct Health(i32);
  342|       |
  343|       |    #[derive(Clone, Copy, Debug, PartialEq)]
  344|       |    struct Position(f32, f32);
  345|       |
  346|       |    #[test]
  347|       |    fn test_signature_creation() {
  348|       |        let sig1 = ArchetypeSignature::new(vec![TypeId::of::<Health>(), TypeId::of::<Position>()]);
  349|       |        let sig2 = ArchetypeSignature::new(vec![TypeId::of::<Position>(), TypeId::of::<Health>()]);
  350|       |        assert_eq!(sig1, sig2); // Order-independent
  351|       |    }
  352|       |
  353|       |    #[test]
  354|       |    fn test_archetype_storage() {
  355|       |        let mut storage = ArchetypeStorage::new();
  356|       |        let sig = ArchetypeSignature::new(vec![TypeId::of::<Health>()]);
  357|       |
  358|       |        let id1 = storage.get_or_create_archetype(sig.clone());
  359|       |        let id2 = storage.get_or_create_archetype(sig.clone());
  360|       |
  361|       |        assert_eq!(id1, id2); // Same signature returns same archetype
  362|       |    }
  363|       |
  364|       |    // ====================
  365|       |    // Day 3: Surgical Coverage Improvements - archetype.rs
  366|       |    // ====================
  367|       |
  368|       |    #[test]
  369|       |    fn test_signature_methods() {
  370|       |        // Tests contains(), len(), is_empty()
  371|       |        let sig = ArchetypeSignature::new(vec![TypeId::of::<Health>(), TypeId::of::<Position>()]);
  372|       |
  373|       |        assert!(sig.contains(TypeId::of::<Health>()));
  374|       |        assert!(sig.contains(TypeId::of::<Position>()));
  375|       |        assert!(!sig.contains(TypeId::of::<i32>()));
  376|       |
  377|       |        assert_eq!(sig.len(), 2);
  378|       |        assert!(!sig.is_empty());
  379|       |
  380|       |        let empty_sig = ArchetypeSignature::new(vec![]);
  381|       |        assert_eq!(empty_sig.len(), 0);
  382|       |        assert!(empty_sig.is_empty());
  383|       |    }
  384|       |
  385|       |    #[test]
  386|       |    fn test_archetype_entity_operations() {
  387|       |        // Tests add_entity, get, get_mut, len, is_empty, entities_vec
  388|       |        let sig = ArchetypeSignature::new(vec![TypeId::of::<Health>(), TypeId::of::<Position>()]);
  389|       |        let mut archetype = Archetype::new(ArchetypeId(0), sig);
  390|       |
  391|       |        assert_eq!(archetype.len(), 0);
  392|       |        assert!(archetype.is_empty());
  393|       |        assert_eq!(archetype.entities_vec().len(), 0);
  394|       |
  395|       |        // Add entity with components
  396|       |        let entity = unsafe { Entity::from_raw(1) };
  397|       |        let mut components = HashMap::new();
  398|       |        components.insert(
  399|       |            TypeId::of::<Health>(),
  400|       |            Box::new(Health(100)) as Box<dyn std::any::Any + Send + Sync>,
  401|       |        );
  402|       |        components.insert(
  403|       |            TypeId::of::<Position>(),
  404|       |            Box::new(Position(1.0, 2.0)) as Box<dyn std::any::Any + Send + Sync>,
  405|       |        );
  406|       |
  407|       |        archetype.add_entity(entity, components);
  408|       |
  409|       |        assert_eq!(archetype.len(), 1);
  410|       |        assert!(!archetype.is_empty());
  411|       |        assert_eq!(archetype.entities_vec().len(), 1);
  412|       |        assert_eq!(archetype.entities_vec()[0], entity);
  413|       |
  414|       |        // Test get
  415|       |        let health = archetype.get::<Health>(entity).unwrap();
  416|       |        assert_eq!(health.0, 100);
  417|       |
  418|       |        let pos = archetype.get::<Position>(entity).unwrap();
  419|       |        assert_eq!(pos.0, 1.0);
  420|       |        assert_eq!(pos.1, 2.0);
  421|       |
  422|       |        // Test get_mut
  423|       |        {
  424|       |            let health_mut = archetype.get_mut::<Health>(entity).unwrap();
  425|       |            health_mut.0 = 50;
  426|       |        }
  427|       |
  428|       |        let health = archetype.get::<Health>(entity).unwrap();
  429|       |        assert_eq!(health.0, 50);
  430|       |    }
  431|       |
  432|       |    #[test]
  433|       |    fn test_archetype_remove_entity() {
  434|       |        // Tests remove_entity and remove_entity_components
  435|       |        let sig = ArchetypeSignature::new(vec![TypeId::of::<Health>()]);
  436|       |        let mut archetype = Archetype::new(ArchetypeId(0), sig);
  437|       |
  438|       |        let entity1 = unsafe { Entity::from_raw(1) };
  439|       |        let entity2 = unsafe { Entity::from_raw(2) };
  440|       |
  441|       |        let mut components1 = HashMap::new();
  442|       |        components1.insert(
  443|       |            TypeId::of::<Health>(),
  444|       |            Box::new(Health(100)) as Box<dyn std::any::Any + Send + Sync>,
  445|       |        );
  446|       |        archetype.add_entity(entity1, components1);
  447|       |
  448|       |        let mut components2 = HashMap::new();
  449|       |        components2.insert(
  450|       |            TypeId::of::<Health>(),
  451|       |            Box::new(Health(200)) as Box<dyn std::any::Any + Send + Sync>,
  452|       |        );
  453|       |        archetype.add_entity(entity2, components2);
  454|       |
  455|       |        assert_eq!(archetype.len(), 2);
  456|       |
  457|       |        // Remove entity1
  458|       |        let removed_components = archetype.remove_entity_components(entity1);
  459|       |        assert_eq!(archetype.len(), 1);
  460|       |        assert!(removed_components.contains_key(&TypeId::of::<Health>()));
  461|       |
  462|       |        // entity2 should still be accessible
  463|       |        let health = archetype.get::<Health>(entity2).unwrap();
  464|       |        assert_eq!(health.0, 200);
  465|       |
  466|       |        // entity1 should be gone
  467|       |        assert!(archetype.get::<Health>(entity1).is_none());
  468|       |    }
  469|       |
  470|       |    #[test]
  471|       |    fn test_archetype_iter_components() {
  472|       |        // Tests iter_components batch iterator
  473|       |        let sig = ArchetypeSignature::new(vec![TypeId::of::<Health>()]);
  474|       |        let mut archetype = Archetype::new(ArchetypeId(0), sig);
  475|       |
  476|       |        let entity1 = unsafe { Entity::from_raw(1) };
  477|       |        let entity2 = unsafe { Entity::from_raw(2) };
  478|       |        let entity3 = unsafe { Entity::from_raw(3) };
  479|       |
  480|       |        let mut components1 = HashMap::new();
  481|       |        components1.insert(
  482|       |            TypeId::of::<Health>(),
  483|       |            Box::new(Health(100)) as Box<dyn std::any::Any + Send + Sync>,
  484|       |        );
  485|       |        archetype.add_entity(entity1, components1);
  486|       |
  487|       |        let mut components2 = HashMap::new();
  488|       |        components2.insert(
  489|       |            TypeId::of::<Health>(),
  490|       |            Box::new(Health(200)) as Box<dyn std::any::Any + Send + Sync>,
  491|       |        );
  492|       |        archetype.add_entity(entity2, components2);
  493|       |
  494|       |        let mut components3 = HashMap::new();
  495|       |        components3.insert(
  496|       |            TypeId::of::<Health>(),
  497|       |            Box::new(Health(300)) as Box<dyn std::any::Any + Send + Sync>,
  498|       |        );
  499|       |        archetype.add_entity(entity3, components3);
  500|       |
  501|       |        // Collect all health values via iterator
  502|       |        let healths: Vec<i32> = archetype
  503|       |            .iter_components::<Health>()
  504|       |            .map(|(_, health)| health.0)
  505|       |            .collect();
  506|       |
  507|       |        assert_eq!(healths.len(), 3);
  508|       |        assert!(healths.contains(&100));
  509|       |        assert!(healths.contains(&200));
  510|       |        assert!(healths.contains(&300));
  511|       |    }
  512|       |
  513|       |    #[test]
  514|       |    fn test_archetype_storage_comprehensive() {
  515|       |        // Tests get_archetype, get_entity_archetype, set_entity_archetype, remove_entity,
  516|       |        // archetypes(), iter(), archetypes_mut(), archetypes_with_component()
  517|       |        let mut storage = ArchetypeStorage::new();
  518|       |
  519|       |        let sig1 = ArchetypeSignature::new(vec![TypeId::of::<Health>()]);
  520|       |        let sig2 = ArchetypeSignature::new(vec![TypeId::of::<Position>()]);
  521|       |        let sig3 = ArchetypeSignature::new(vec![TypeId::of::<Health>(), TypeId::of::<Position>()]);
  522|       |
  523|       |        let id1 = storage.get_or_create_archetype(sig1);
  524|       |        let id2 = storage.get_or_create_archetype(sig2);
  525|       |        let id3 = storage.get_or_create_archetype(sig3);
  526|       |
  527|       |        // Test get_archetype
  528|       |        assert!(storage.get_archetype(id1).is_some());
  529|       |        assert!(storage.get_archetype(id2).is_some());
  530|       |        assert!(storage.get_archetype(id3).is_some());
  531|       |
  532|       |        // Test entity->archetype mapping
  533|       |        let entity = unsafe { Entity::from_raw(42) };
  534|       |        assert!(storage.get_entity_archetype(entity).is_none());
  535|       |
  536|       |        storage.set_entity_archetype(entity, id1);
  537|       |        assert_eq!(storage.get_entity_archetype(entity), Some(id1));
  538|       |
  539|       |        // Test remove_entity
  540|       |        let removed = storage.remove_entity(entity);
  541|       |        assert_eq!(removed, Some(id1));
  542|       |        assert!(storage.get_entity_archetype(entity).is_none());
  543|       |
  544|       |        // Test archetypes() iterator
  545|       |        let count = storage.archetypes().count();
  546|       |        assert_eq!(count, 3);
  547|       |
  548|       |        // Test iter() (alias)
  549|       |        let count2 = storage.iter().count();
  550|       |        assert_eq!(count2, 3);
  551|       |
  552|       |        // Test archetypes_mut()
  553|       |        let mut_count = storage.archetypes_mut().count();
  554|       |        assert_eq!(mut_count, 3);
  555|       |
  556|       |        // Test archetypes_with_component
  557|       |        let with_health = storage
  558|       |            .archetypes_with_component(TypeId::of::<Health>())
  559|       |            .count();
  560|       |        assert_eq!(with_health, 2); // sig1 and sig3 have Health
  561|       |
  562|       |        let with_position = storage
  563|       |            .archetypes_with_component(TypeId::of::<Position>())
  564|       |            .count();
  565|       |        assert_eq!(with_position, 2); // sig2 and sig3 have Position
  566|       |
  567|       |        let with_nothing = storage
  568|       |            .archetypes_with_component(TypeId::of::<i32>())
  569|       |            .count();
  570|       |        assert_eq!(with_nothing, 0);
  571|       |    }
  572|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\blob_vec.rs:
    1|       |// SPDX-License-Identifier: MIT
    2|       |//! Type-erased contiguous storage for components
    3|       |//!
    4|       |//! Inspired by Bevy's BlobVec, this provides cache-friendly storage without
    5|       |//! the overhead of Box<dyn Any> indirection. Components are stored as raw bytes
    6|       |//! with proper alignment and drop handling.
    7|       |
    8|       |use std::alloc::{alloc, dealloc, realloc, Layout};
    9|       |use std::ptr::{self, NonNull};
   10|       |
   11|       |/// Type-erased vector of components stored contiguously in memory.
   12|       |///
   13|       |/// This is the foundation for high-performance ECS storage, providing:
   14|       |/// - Zero heap indirection (vs Box<dyn Any>)
   15|       |/// - SIMD-friendly contiguous memory
   16|       |/// - Cache-friendly iteration
   17|       |/// - Proper drop handling via function pointer
   18|       |pub struct BlobVec {
   19|       |    /// Raw pointer to the start of component data
   20|       |    data: NonNull<u8>,
   21|       |    /// Number of components currently stored
   22|       |    len: usize,
   23|       |    /// Allocated capacity (in number of components)
   24|       |    capacity: usize,
   25|       |    /// Memory layout of a single component
   26|       |    item_layout: Layout,
   27|       |    /// Function to drop a single component
   28|       |    /// SAFETY: Must be called with a valid pointer to T
   29|       |    drop_fn: Option<unsafe fn(*mut u8)>,
   30|       |}
   31|       |
   32|       |impl BlobVec {
   33|       |    /// Create a new BlobVec for components of type T
   34|      0|    pub fn new<T: 'static>() -> Self {
   35|      0|        let item_layout = Layout::new::<T>();
   36|      0|        let drop_fn = if std::mem::needs_drop::<T>() {
   37|      0|            Some(Self::drop_fn_of::<T>() as unsafe fn(*mut u8))
   38|       |        } else {
   39|      0|            None
   40|       |        };
   41|       |
   42|      0|        Self {
   43|      0|            data: NonNull::dangling(),
   44|      0|            len: 0,
   45|      0|            capacity: 0,
   46|      0|            item_layout,
   47|      0|            drop_fn,
   48|      0|        }
   49|      0|    }
   50|       |
   51|       |    /// Create a new BlobVec with specified capacity
   52|      0|    pub fn with_capacity<T: 'static>(capacity: usize) -> Self {
   53|      0|        let mut blob = Self::new::<T>();
   54|      0|        if capacity > 0 {
   55|      0|            blob.reserve(capacity);
   56|      0|        }
   57|      0|        blob
   58|      0|    }
   59|       |
   60|       |    /// Get the drop function for type T
   61|      0|    fn drop_fn_of<T>() -> unsafe fn(*mut u8) {
   62|       |        |ptr| unsafe {
   63|      0|            ptr.cast::<T>().drop_in_place();
   64|      0|        }
   65|      0|    }
   66|       |
   67|       |    /// Reserve space for at least `additional` more components
   68|      0|    pub fn reserve(&mut self, additional: usize) {
   69|      0|        let required_cap = self.len.checked_add(additional).expect("capacity overflow");
   70|      0|        if required_cap <= self.capacity {
   71|      0|            return;
   72|      0|        }
   73|       |
   74|      0|        let new_capacity = required_cap.max(self.capacity * 2).max(4);
   75|       |
   76|      0|        let new_layout = Layout::from_size_align(
   77|      0|            self.item_layout.size() * new_capacity,
   78|      0|            self.item_layout.align(),
   79|       |        )
   80|      0|        .expect("invalid layout");
   81|       |
   82|      0|        let new_data = if self.capacity == 0 {
   83|       |            // First allocation
   84|      0|            unsafe { NonNull::new(alloc(new_layout)).expect("allocation failed") }
   85|       |        } else {
   86|       |            // Reallocate existing memory
   87|      0|            let old_layout = Layout::from_size_align(
   88|      0|                self.item_layout.size() * self.capacity,
   89|      0|                self.item_layout.align(),
   90|       |            )
   91|      0|            .expect("invalid layout");
   92|       |
   93|       |            unsafe {
   94|      0|                let new_ptr = realloc(self.data.as_ptr(), old_layout, new_layout.size());
   95|      0|                NonNull::new(new_ptr).expect("reallocation failed")
   96|       |            }
   97|       |        };
   98|       |
   99|      0|        self.data = new_data;
  100|      0|        self.capacity = new_capacity;
  101|      0|    }
  102|       |
  103|       |    /// Push a component onto the end of the vector
  104|       |    ///
  105|       |    /// # Safety
  106|       |    /// Type T must match the type this BlobVec was created for
  107|      0|    pub unsafe fn push<T>(&mut self, value: T) {
  108|      0|        if self.len == self.capacity {
  109|      0|            self.reserve(1);
  110|      0|        }
  111|       |
  112|      0|        let ptr = self.data.as_ptr().add(self.len * self.item_layout.size());
  113|      0|        ptr.cast::<T>().write(value);
  114|      0|        self.len += 1;
  115|      0|    }
  116|       |
  117|       |    /// Get a reference to a component at the specified index
  118|       |    ///
  119|       |    /// # Safety
  120|       |    /// - Index must be in bounds
  121|       |    /// - Type T must match the type this BlobVec was created for
  122|      0|    pub unsafe fn get<T>(&self, index: usize) -> Option<&T> {
  123|      0|        if index >= self.len {
  124|      0|            return None;
  125|      0|        }
  126|       |
  127|      0|        let ptr = self.data.as_ptr().add(index * self.item_layout.size());
  128|      0|        Some(&*ptr.cast::<T>())
  129|      0|    }
  130|       |
  131|       |    /// Get a mutable reference to a component at the specified index
  132|       |    ///
  133|       |    /// # Safety
  134|       |    /// - Index must be in bounds
  135|       |    /// - Type T must match the type this BlobVec was created for
  136|      0|    pub unsafe fn get_mut<T>(&mut self, index: usize) -> Option<&mut T> {
  137|      0|        if index >= self.len {
  138|      0|            return None;
  139|      0|        }
  140|       |
  141|      0|        let ptr = self.data.as_ptr().add(index * self.item_layout.size());
  142|      0|        Some(&mut *ptr.cast::<T>())
  143|      0|    }
  144|       |
  145|       |    /// Get the component data as a contiguous slice
  146|       |    ///
  147|       |    /// This is the key to high-performance iteration - direct memory access!
  148|       |    ///
  149|       |    /// # Safety
  150|       |    /// Type T must match the type this BlobVec was created for
  151|      0|    pub unsafe fn as_slice<T>(&self) -> &[T] {
  152|      0|        if self.len == 0 {
  153|      0|            return &[];
  154|      0|        }
  155|      0|        std::slice::from_raw_parts(self.data.as_ptr().cast::<T>(), self.len)
  156|      0|    }
  157|       |
  158|       |    /// Get the component data as a mutable contiguous slice
  159|       |    ///
  160|       |    /// # Safety
  161|       |    /// Type T must match the type this BlobVec was created for
  162|      0|    pub unsafe fn as_slice_mut<T>(&mut self) -> &mut [T] {
  163|      0|        if self.len == 0 {
  164|      0|            return &mut [];
  165|      0|        }
  166|      0|        std::slice::from_raw_parts_mut(self.data.as_ptr().cast::<T>(), self.len)
  167|      0|    }
  168|       |
  169|       |    /// Remove and return the component at the specified index
  170|       |    /// Uses swap_remove for O(1) performance (order not preserved)
  171|       |    ///
  172|       |    /// # Safety
  173|       |    /// - Index must be in bounds
  174|       |    /// - Type T must match the type this BlobVec was created for
  175|      0|    pub unsafe fn swap_remove<T>(&mut self, index: usize) -> T {
  176|      0|        assert!(index < self.len, "index out of bounds");
  177|       |
  178|      0|        let last_index = self.len - 1;
  179|      0|        let ptr = self
  180|      0|            .data
  181|      0|            .as_ptr()
  182|      0|            .add(index * self.item_layout.size())
  183|      0|            .cast::<T>();
  184|       |
  185|      0|        if index != last_index {
  186|      0|            // Swap with last element
  187|      0|            let last_ptr = self
  188|      0|                .data
  189|      0|                .as_ptr()
  190|      0|                .add(last_index * self.item_layout.size())
  191|      0|                .cast::<T>();
  192|      0|            ptr::swap(ptr, last_ptr);
  193|      0|        }
  194|       |
  195|      0|        self.len -= 1;
  196|      0|        ptr::read(
  197|      0|            self.data
  198|      0|                .as_ptr()
  199|      0|                .add(self.len * self.item_layout.size())
  200|      0|                .cast::<T>(),
  201|       |        )
  202|      0|    }
  203|       |
  204|       |    /// Get the number of components stored
  205|      0|    pub fn len(&self) -> usize {
  206|      0|        self.len
  207|      0|    }
  208|       |
  209|       |    /// Check if the BlobVec is empty
  210|      0|    pub fn is_empty(&self) -> bool {
  211|      0|        self.len == 0
  212|      0|    }
  213|       |
  214|       |    /// Get the current capacity
  215|      0|    pub fn capacity(&self) -> usize {
  216|      0|        self.capacity
  217|      0|    }
  218|       |
  219|       |    /// Clear all components, calling their drop functions
  220|      0|    pub fn clear(&mut self) {
  221|      0|        if let Some(drop_fn) = self.drop_fn {
  222|      0|            for i in 0..self.len {
  223|      0|                unsafe {
  224|      0|                    let ptr = self.data.as_ptr().add(i * self.item_layout.size());
  225|      0|                    drop_fn(ptr);
  226|      0|                }
  227|       |            }
  228|      0|        }
  229|      0|        self.len = 0;
  230|      0|    }
  231|       |}
  232|       |
  233|       |impl Drop for BlobVec {
  234|      0|    fn drop(&mut self) {
  235|      0|        self.clear();
  236|       |
  237|      0|        if self.capacity > 0 {
  238|      0|            let layout = Layout::from_size_align(
  239|      0|                self.item_layout.size() * self.capacity,
  240|      0|                self.item_layout.align(),
  241|       |            )
  242|      0|            .expect("invalid layout");
  243|       |
  244|      0|            unsafe {
  245|      0|                dealloc(self.data.as_ptr(), layout);
  246|      0|            }
  247|      0|        }
  248|      0|    }
  249|       |}
  250|       |
  251|       |unsafe impl Send for BlobVec {}
  252|       |unsafe impl Sync for BlobVec {}
  253|       |
  254|       |#[cfg(test)]
  255|       |mod tests {
  256|       |    use super::*;
  257|       |
  258|       |    #[derive(Clone, Copy, Debug, PartialEq)]
  259|       |    struct Position {
  260|       |        x: f32,
  261|       |        y: f32,
  262|       |        z: f32,
  263|       |    }
  264|       |
  265|       |    #[derive(Debug, PartialEq)]
  266|       |    struct DropTest {
  267|       |        value: i32,
  268|       |        dropped: std::rc::Rc<std::cell::Cell<bool>>,
  269|       |    }
  270|       |
  271|       |    impl Drop for DropTest {
  272|       |        fn drop(&mut self) {
  273|       |            self.dropped.set(true);
  274|       |        }
  275|       |    }
  276|       |
  277|       |    #[test]
  278|       |    fn test_push_and_get() {
  279|       |        let mut blob = BlobVec::new::<Position>();
  280|       |
  281|       |        unsafe {
  282|       |            blob.push(Position {
  283|       |                x: 1.0,
  284|       |                y: 2.0,
  285|       |                z: 3.0,
  286|       |            });
  287|       |            blob.push(Position {
  288|       |                x: 4.0,
  289|       |                y: 5.0,
  290|       |                z: 6.0,
  291|       |            });
  292|       |        }
  293|       |
  294|       |        assert_eq!(blob.len(), 2);
  295|       |
  296|       |        unsafe {
  297|       |            let pos1 = blob.get::<Position>(0).unwrap();
  298|       |            assert_eq!(pos1.x, 1.0);
  299|       |            assert_eq!(pos1.y, 2.0);
  300|       |
  301|       |            let pos2 = blob.get::<Position>(1).unwrap();
  302|       |            assert_eq!(pos2.x, 4.0);
  303|       |            assert_eq!(pos2.y, 5.0);
  304|       |        }
  305|       |    }
  306|       |
  307|       |    #[test]
  308|       |    fn test_as_slice() {
  309|       |        let mut blob = BlobVec::new::<Position>();
  310|       |
  311|       |        unsafe {
  312|       |            blob.push(Position {
  313|       |                x: 1.0,
  314|       |                y: 2.0,
  315|       |                z: 3.0,
  316|       |            });
  317|       |            blob.push(Position {
  318|       |                x: 4.0,
  319|       |                y: 5.0,
  320|       |                z: 6.0,
  321|       |            });
  322|       |            blob.push(Position {
  323|       |                x: 7.0,
  324|       |                y: 8.0,
  325|       |                z: 9.0,
  326|       |            });
  327|       |
  328|       |            let slice = blob.as_slice::<Position>();
  329|       |            assert_eq!(slice.len(), 3);
  330|       |            assert_eq!(slice[0].x, 1.0);
  331|       |            assert_eq!(slice[1].x, 4.0);
  332|       |            assert_eq!(slice[2].x, 7.0);
  333|       |        }
  334|       |    }
  335|       |
  336|       |    #[test]
  337|       |    fn test_as_slice_mut() {
  338|       |        let mut blob = BlobVec::new::<Position>();
  339|       |
  340|       |        unsafe {
  341|       |            blob.push(Position {
  342|       |                x: 1.0,
  343|       |                y: 2.0,
  344|       |                z: 3.0,
  345|       |            });
  346|       |            blob.push(Position {
  347|       |                x: 4.0,
  348|       |                y: 5.0,
  349|       |                z: 6.0,
  350|       |            });
  351|       |
  352|       |            let slice = blob.as_slice_mut::<Position>();
  353|       |            slice[0].x = 100.0;
  354|       |            slice[1].y = 200.0;
  355|       |
  356|       |            let slice = blob.as_slice::<Position>();
  357|       |            assert_eq!(slice[0].x, 100.0);
  358|       |            assert_eq!(slice[1].y, 200.0);
  359|       |        }
  360|       |    }
  361|       |
  362|       |    #[test]
  363|       |    fn test_swap_remove() {
  364|       |        let mut blob = BlobVec::new::<Position>();
  365|       |
  366|       |        unsafe {
  367|       |            blob.push(Position {
  368|       |                x: 1.0,
  369|       |                y: 2.0,
  370|       |                z: 3.0,
  371|       |            });
  372|       |            blob.push(Position {
  373|       |                x: 4.0,
  374|       |                y: 5.0,
  375|       |                z: 6.0,
  376|       |            });
  377|       |            blob.push(Position {
  378|       |                x: 7.0,
  379|       |                y: 8.0,
  380|       |                z: 9.0,
  381|       |            });
  382|       |
  383|       |            let removed = blob.swap_remove::<Position>(1);
  384|       |            assert_eq!(removed.x, 4.0);
  385|       |
  386|       |            assert_eq!(blob.len(), 2);
  387|       |
  388|       |            // Element at index 1 should now be the former last element
  389|       |            let pos = blob.get::<Position>(1).unwrap();
  390|       |            assert_eq!(pos.x, 7.0);
  391|       |        }
  392|       |    }
  393|       |
  394|       |    #[test]
  395|       |    fn test_drop_handling() {
  396|       |        let dropped = std::rc::Rc::new(std::cell::Cell::new(false));
  397|       |
  398|       |        {
  399|       |            let mut blob = BlobVec::new::<DropTest>();
  400|       |
  401|       |            unsafe {
  402|       |                blob.push(DropTest {
  403|       |                    value: 42,
  404|       |                    dropped: dropped.clone(),
  405|       |                });
  406|       |            }
  407|       |
  408|       |            assert!(!dropped.get());
  409|       |        } // BlobVec dropped here
  410|       |
  411|       |        assert!(dropped.get());
  412|       |    }
  413|       |
  414|       |    #[test]
  415|       |    fn test_clear() {
  416|       |        let dropped1 = std::rc::Rc::new(std::cell::Cell::new(false));
  417|       |        let dropped2 = std::rc::Rc::new(std::cell::Cell::new(false));
  418|       |
  419|       |        let mut blob = BlobVec::new::<DropTest>();
  420|       |
  421|       |        unsafe {
  422|       |            blob.push(DropTest {
  423|       |                value: 1,
  424|       |                dropped: dropped1.clone(),
  425|       |            });
  426|       |            blob.push(DropTest {
  427|       |                value: 2,
  428|       |                dropped: dropped2.clone(),
  429|       |            });
  430|       |        }
  431|       |
  432|       |        assert!(!dropped1.get());
  433|       |        assert!(!dropped2.get());
  434|       |
  435|       |        blob.clear();
  436|       |
  437|       |        assert!(dropped1.get());
  438|       |        assert!(dropped2.get());
  439|       |        assert_eq!(blob.len(), 0);
  440|       |    }
  441|       |
  442|       |    #[test]
  443|       |    fn test_reserve() {
  444|       |        let mut blob = BlobVec::new::<Position>();
  445|       |        assert_eq!(blob.capacity(), 0);
  446|       |
  447|       |        blob.reserve(10);
  448|       |        assert!(blob.capacity() >= 10);
  449|       |
  450|       |        let old_capacity = blob.capacity();
  451|       |        blob.reserve(5); // Should not reallocate
  452|       |        assert_eq!(blob.capacity(), old_capacity);
  453|       |    }
  454|       |
  455|       |    // ====================
  456|       |    // Day 3: Surgical Coverage Improvements - blob_vec.rs
  457|       |    // ====================
  458|       |
  459|       |    #[test]
  460|       |    fn test_with_capacity() {
  461|       |        // Tests constructor pre-allocation
  462|       |        let blob = BlobVec::with_capacity::<Position>(50);
  463|       |        assert!(blob.capacity() >= 50);
  464|       |        assert_eq!(blob.len(), 0);
  465|       |        assert!(blob.is_empty());
  466|       |    }
  467|       |
  468|       |    #[test]
  469|       |    fn test_with_capacity_zero() {
  470|       |        // Tests edge case: capacity = 0
  471|       |        let blob = BlobVec::with_capacity::<Position>(0);
  472|       |        assert_eq!(blob.capacity(), 0);
  473|       |        assert_eq!(blob.len(), 0);
  474|       |    }
  475|       |
  476|       |    #[test]
  477|       |    fn test_capacity_method() {
  478|       |        // Tests capacity() accessor method
  479|       |        let mut blob = BlobVec::new::<i32>();
  480|       |        assert_eq!(blob.capacity(), 0);
  481|       |
  482|       |        unsafe {
  483|       |            blob.push(42);
  484|       |        }
  485|       |        assert!(blob.capacity() >= 1);
  486|       |
  487|       |        let cap = blob.capacity();
  488|       |        unsafe {
  489|       |            blob.push(99);
  490|       |        }
  491|       |        assert_eq!(blob.capacity(), cap); // Should not reallocate
  492|       |    }
  493|       |
  494|       |    #[test]
  495|       |    fn test_as_slice_empty() {
  496|       |        // Tests as_slice() when len == 0 (early return path)
  497|       |        let blob = BlobVec::new::<Position>();
  498|       |        unsafe {
  499|       |            let slice = blob.as_slice::<Position>();
  500|       |            assert_eq!(slice.len(), 0);
  501|       |        }
  502|       |    }
  503|       |
  504|       |    #[test]
  505|       |    fn test_as_slice_mut_empty() {
  506|       |        // Tests as_slice_mut() when len == 0 (early return path)
  507|       |        let mut blob = BlobVec::new::<Position>();
  508|       |        unsafe {
  509|       |            let slice = blob.as_slice_mut::<Position>();
  510|       |            assert_eq!(slice.len(), 0);
  511|       |        }
  512|       |    }
  513|       |
  514|       |    #[test]
  515|       |    fn test_get_out_of_bounds() {
  516|       |        // Tests get() error handling for invalid index
  517|       |        let mut blob = BlobVec::new::<i32>();
  518|       |        unsafe {
  519|       |            blob.push(10);
  520|       |            blob.push(20);
  521|       |        }
  522|       |
  523|       |        unsafe {
  524|       |            assert!(blob.get::<i32>(0).is_some());
  525|       |            assert!(blob.get::<i32>(1).is_some());
  526|       |            assert!(blob.get::<i32>(2).is_none()); // Out of bounds
  527|       |            assert!(blob.get::<i32>(999).is_none()); // Way out of bounds
  528|       |        }
  529|       |    }
  530|       |
  531|       |    #[test]
  532|       |    fn test_get_mut_out_of_bounds() {
  533|       |        // Tests get_mut() error handling for invalid index
  534|       |        let mut blob = BlobVec::new::<i32>();
  535|       |        unsafe {
  536|       |            blob.push(10);
  537|       |            blob.push(20);
  538|       |        }
  539|       |
  540|       |        unsafe {
  541|       |            assert!(blob.get_mut::<i32>(0).is_some());
  542|       |            assert!(blob.get_mut::<i32>(1).is_some());
  543|       |            assert!(blob.get_mut::<i32>(2).is_none()); // Out of bounds
  544|       |            assert!(blob.get_mut::<i32>(999).is_none()); // Way out of bounds
  545|       |        }
  546|       |    }
  547|       |
  548|       |    #[test]
  549|       |    fn test_swap_remove_last_element() {
  550|       |        // Tests no-swap path when removing last element (index == last_index)
  551|       |        let mut blob = BlobVec::new::<i32>();
  552|       |        unsafe {
  553|       |            blob.push(10);
  554|       |            blob.push(20);
  555|       |            blob.push(30);
  556|       |        }
  557|       |
  558|       |        unsafe {
  559|       |            // Remove last element - should not swap
  560|       |            let removed = blob.swap_remove::<i32>(2);
  561|       |            assert_eq!(removed, 30);
  562|       |            assert_eq!(blob.len(), 2);
  563|       |
  564|       |            // Remaining elements unchanged
  565|       |            assert_eq!(*blob.get::<i32>(0).unwrap(), 10);
  566|       |            assert_eq!(*blob.get::<i32>(1).unwrap(), 20);
  567|       |        }
  568|       |    }
  569|       |
  570|       |    #[test]
  571|       |    fn test_no_drop_type() {
  572|       |        // Tests BlobVec with types that don't need drop (drop_fn = None path)
  573|       |        let mut blob = BlobVec::new::<i32>();
  574|       |
  575|       |        unsafe {
  576|       |            blob.push(1);
  577|       |            blob.push(2);
  578|       |            blob.push(3);
  579|       |        }
  580|       |
  581|       |        assert_eq!(blob.len(), 3);
  582|       |        blob.clear();
  583|       |        assert_eq!(blob.len(), 0);
  584|       |
  585|       |        // Should not panic even though drop_fn is None for i32
  586|       |    }
  587|       |
  588|       |    #[test]
  589|       |    fn test_large_capacity_growth() {
  590|       |        // Tests capacity growth algorithm with large reserves
  591|       |        let mut blob = BlobVec::new::<u8>();
  592|       |
  593|       |        // Force multiple reallocations
  594|       |        blob.reserve(1000);
  595|       |        let cap1 = blob.capacity();
  596|       |        assert!(cap1 >= 1000);
  597|       |
  598|       |        unsafe {
  599|       |            for i in 0..500 {
  600|       |                blob.push(i as u8);
  601|       |            }
  602|       |        }
  603|       |
  604|       |        blob.reserve(2000);
  605|       |        let cap2 = blob.capacity();
  606|       |        assert!(cap2 >= 2500); // 500 existing + 2000 additional
  607|       |
  608|       |        assert_eq!(blob.len(), 500);
  609|       |    }
  610|       |
  611|       |    #[test]
  612|       |    fn test_is_empty() {
  613|       |        // Tests is_empty() method (simple but uncovered)
  614|       |        let mut blob = BlobVec::new::<i32>();
  615|       |        assert!(blob.is_empty());
  616|       |
  617|       |        unsafe {
  618|       |            blob.push(42);
  619|       |        }
  620|       |        assert!(!blob.is_empty());
  621|       |
  622|       |        blob.clear();
  623|       |        assert!(blob.is_empty());
  624|       |    }
  625|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\command_buffer.rs:
    1|       |//! Command buffer for deferred structural changes.
    2|       |//!
    3|       |//! Allows queueing of spawn, insert, remove, and despawn operations that will be
    4|       |//! applied later via `flush()`. This prevents iterator invalidation during iteration.
    5|       |//!
    6|       |//! # Example
    7|       |//! ```
    8|       |//! # use astraweave_ecs::{World, CommandBuffer};
    9|       |//! # #[derive(Clone, Copy, Debug, PartialEq)]
   10|       |//! # struct Position { x: f32, y: f32 }
   11|       |//! # let mut world = World::new();
   12|       |//! # world.register_component::<Position>();
   13|       |//! # let e1 = world.spawn();
   14|       |//! # let e2 = world.spawn();
   15|       |//! let mut commands = CommandBuffer::new();
   16|       |//!
   17|       |//! // Queue operations on entities (safe during iteration)
   18|       |//! commands.insert(e1, Position { x: 10.0, y: 20.0 });
   19|       |//! commands.insert(e2, Position { x: 30.0, y: 40.0 });
   20|       |//!
   21|       |//! // Apply all queued operations (batch update)
   22|       |//! commands.flush(&mut world);
   23|       |//!
   24|       |//! assert_eq!(world.get::<Position>(e1), Some(&Position { x: 10.0, y: 20.0 }));
   25|       |//! ```
   26|       |
   27|       |use crate::{Component, Entity, World};
   28|       |use std::any::{Any, TypeId};
   29|       |
   30|       |/// A command that modifies the World structure.
   31|       |#[derive(Debug)]
   32|       |enum Command {
   33|       |    /// Spawn a new entity with optional components.
   34|       |    Spawn {
   35|       |        /// Components to insert on spawn (type-erased).
   36|       |        components: Vec<(TypeId, Box<dyn Any + Send + Sync>)>,
   37|       |    },
   38|       |    /// Insert a component on an entity.
   39|       |    Insert {
   40|       |        entity: Entity,
   41|       |        type_id: TypeId,
   42|       |        component: Box<dyn Any + Send + Sync>,
   43|       |    },
   44|       |    /// Remove a component from an entity.
   45|       |    Remove { entity: Entity, type_id: TypeId },
   46|       |    /// Despawn an entity.
   47|       |    Despawn { entity: Entity },
   48|       |}
   49|       |
   50|       |/// Buffer for deferred structural changes to the World.
   51|       |///
   52|       |/// Queues spawn, insert, remove, and despawn operations that are applied
   53|       |/// via `flush()`. This allows safe mutation during iteration.
   54|       |///
   55|       |/// # Thread Safety
   56|       |/// CommandBuffer is `!Send + !Sync` to match World's single-threaded access model.
   57|       |pub struct CommandBuffer {
   58|       |    commands: Vec<Command>,
   59|       |    spawn_buffer: Vec<(TypeId, Box<dyn Any + Send + Sync>)>,
   60|       |}
   61|       |
   62|       |impl CommandBuffer {
   63|       |    /// Create a new empty command buffer.
   64|       |    pub fn new() -> Self {
   65|       |        Self {
   66|       |            commands: Vec::new(),
   67|       |            spawn_buffer: Vec::new(),
   68|       |        }
   69|       |    }
   70|       |
   71|       |    /// Create a command buffer with pre-allocated capacity.
   72|       |    pub fn with_capacity(capacity: usize) -> Self {
   73|       |        Self {
   74|       |            commands: Vec::with_capacity(capacity),
   75|       |            spawn_buffer: Vec::new(),
   76|       |        }
   77|       |    }
   78|       |
   79|       |    /// Queue a spawn operation.
   80|       |    ///
   81|       |    /// The entity will be spawned when `flush()` is called. Returns a builder
   82|       |    /// for adding components to the spawned entity.
   83|       |    ///
   84|       |    /// # Example
   85|       |    /// ```
   86|       |    /// # use astraweave_ecs::CommandBuffer;
   87|       |    /// # #[derive(Clone, Copy)]
   88|       |    /// # struct Position { x: f32, y: f32 }
   89|       |    /// # struct Velocity { x: f32, y: f32 }
   90|       |    /// let mut commands = CommandBuffer::new();
   91|       |    /// commands.spawn()
   92|       |    ///     .with(Position { x: 0.0, y: 0.0 })
   93|       |    ///     .with(Velocity { x: 1.0, y: 0.0 });
   94|       |    /// ```
   95|       |    pub fn spawn(&mut self) -> SpawnBuilder<'_> {
   96|       |        SpawnBuilder { buffer: self }
   97|       |    }
   98|       |
   99|       |    /// Queue an insert operation.
  100|       |    ///
  101|       |    /// The component will be inserted when `flush()` is called. If the entity
  102|       |    /// is stale (despawned), the operation is silently ignored.
  103|      0|    pub fn insert<T: Component>(&mut self, entity: Entity, component: T) {
  104|      0|        self.commands.push(Command::Insert {
  105|      0|            entity,
  106|      0|            type_id: TypeId::of::<T>(),
  107|      0|            component: Box::new(component),
  108|      0|        });
  109|      0|    }
  110|       |
  111|       |    /// Queue a remove operation.
  112|       |    ///
  113|       |    /// The component will be removed when `flush()` is called. If the entity
  114|       |    /// is stale or doesn't have the component, the operation is silently ignored.
  115|      0|    pub fn remove<T: Component>(&mut self, entity: Entity) {
  116|      0|        self.commands.push(Command::Remove {
  117|      0|            entity,
  118|      0|            type_id: TypeId::of::<T>(),
  119|      0|        });
  120|      0|    }
  121|       |
  122|       |    /// Queue a despawn operation.
  123|       |    ///
  124|       |    /// The entity will be despawned when `flush()` is called. If the entity
  125|       |    /// is stale (already despawned), the operation is silently ignored.
  126|       |    pub fn despawn(&mut self, entity: Entity) {
  127|       |        self.commands.push(Command::Despawn { entity });
  128|       |    }
  129|       |
  130|       |    /// Apply all queued commands to the World.
  131|       |    ///
  132|       |    /// Commands are applied in FIFO order:
  133|       |    /// 1. Spawn operations
  134|       |    /// 2. Insert operations
  135|       |    /// 3. Remove operations
  136|       |    /// 4. Despawn operations
  137|       |    ///
  138|       |    /// After flushing, the buffer is cleared and ready for reuse.
  139|       |    ///
  140|       |    /// # Panic Safety
  141|       |    /// If a command panics (e.g., component Drop panics), the buffer may be
  142|       |    /// left in a partially-applied state. Use `try_flush()` for Result-based
  143|       |    /// error handling.
  144|       |    pub fn flush(&mut self, world: &mut World) {
  145|       |        for command in self.commands.drain(..) {
  146|       |            match command {
  147|       |                Command::Spawn { components } => {
  148|       |                    let entity = world.spawn();
  149|       |                    for (type_id, component) in components {
  150|       |                        // Type erasure: We know component is T where TypeId::of::<T>() == type_id,
  151|       |                        // but we can't downcast without unsafe. Use insert_raw() or similar.
  152|       |                        // For now, we'll need to refactor World::insert to accept Box<dyn Any>.
  153|       |                        // Deferred: We'll add insert_raw() helper in World.
  154|       |                        world.insert_boxed(entity, type_id, component);
  155|       |                    }
  156|       |                }
  157|       |                Command::Insert {
  158|       |                    entity,
  159|       |                    type_id,
  160|       |                    component,
  161|       |                } => {
  162|       |                    world.insert_boxed(entity, type_id, component);
  163|       |                }
  164|       |                Command::Remove { entity, type_id } => {
  165|       |                    world.remove_by_type_id(entity, type_id);
  166|       |                }
  167|       |                Command::Despawn { entity } => {
  168|       |                    world.despawn(entity);
  169|       |                }
  170|       |            }
  171|       |        }
  172|       |    }
  173|       |
  174|       |    /// Get the number of queued commands.
  175|       |    pub fn len(&self) -> usize {
  176|       |        self.commands.len()
  177|       |    }
  178|       |
  179|       |    /// Check if the buffer is empty.
  180|       |    pub fn is_empty(&self) -> bool {
  181|       |        self.commands.is_empty()
  182|       |    }
  183|       |
  184|       |    /// Clear all queued commands without applying them.
  185|       |    pub fn clear(&mut self) {
  186|       |        self.commands.clear();
  187|       |        self.spawn_buffer.clear();
  188|       |    }
  189|       |}
  190|       |
  191|       |impl Default for CommandBuffer {
  192|       |    fn default() -> Self {
  193|       |        Self::new()
  194|       |    }
  195|       |}
  196|       |
  197|       |/// Builder for spawning entities with components.
  198|       |///
  199|       |/// Created by `CommandBuffer::spawn()`. Chain `with()` calls to add components.
  200|       |pub struct SpawnBuilder<'a> {
  201|       |    buffer: &'a mut CommandBuffer,
  202|       |}
  203|       |
  204|       |impl<'a> SpawnBuilder<'a> {
  205|       |    /// Add a component to the spawned entity.
  206|       |    ///
  207|       |    /// Returns self for chaining.
  208|      0|    pub fn with<T: Component>(self, component: T) -> Self {
  209|      0|        self.buffer
  210|      0|            .spawn_buffer
  211|      0|            .push((TypeId::of::<T>(), Box::new(component)));
  212|      0|        self
  213|      0|    }
  214|       |}
  215|       |
  216|       |impl<'a> Drop for SpawnBuilder<'a> {
  217|      0|    fn drop(&mut self) {
  218|       |        // Finalize spawn command by moving buffered components into Command::Spawn
  219|      0|        let components = std::mem::take(&mut self.buffer.spawn_buffer);
  220|      0|        self.buffer.commands.push(Command::Spawn { components });
  221|      0|    }
  222|       |}
  223|       |
  224|       |// ============================================================================
  225|       |// Tests
  226|       |// ============================================================================
  227|       |
  228|       |#[cfg(test)]
  229|       |mod tests {
  230|       |    use super::*;
  231|       |
  232|       |    #[derive(Clone, Copy, Debug, PartialEq)]
  233|       |    struct Position {
  234|       |        x: f32,
  235|       |        y: f32,
  236|       |    }
  237|       |
  238|       |    #[derive(Clone, Copy, Debug, PartialEq)]
  239|       |    struct Velocity {
  240|       |        x: f32,
  241|       |        y: f32,
  242|       |    }
  243|       |
  244|       |    #[test]
  245|       |    fn test_command_buffer_creation() {
  246|       |        let buffer = CommandBuffer::new();
  247|       |        assert_eq!(buffer.len(), 0);
  248|       |        assert!(buffer.is_empty());
  249|       |    }
  250|       |
  251|       |    #[test]
  252|       |    fn test_command_buffer_with_capacity() {
  253|       |        let buffer = CommandBuffer::with_capacity(10);
  254|       |        assert_eq!(buffer.len(), 0);
  255|       |        assert!(buffer.is_empty());
  256|       |    }
  257|       |
  258|       |    #[test]
  259|       |    fn test_queue_insert() {
  260|       |        let mut buffer = CommandBuffer::new();
  261|       |        let entity = Entity::new(0, 0);
  262|       |
  263|       |        buffer.insert(entity, Position { x: 1.0, y: 2.0 });
  264|       |        assert_eq!(buffer.len(), 1);
  265|       |        assert!(!buffer.is_empty());
  266|       |    }
  267|       |
  268|       |    #[test]
  269|       |    fn test_queue_remove() {
  270|       |        let mut buffer = CommandBuffer::new();
  271|       |        let entity = Entity::new(0, 0);
  272|       |
  273|       |        buffer.remove::<Position>(entity);
  274|       |        assert_eq!(buffer.len(), 1);
  275|       |    }
  276|       |
  277|       |    #[test]
  278|       |    fn test_queue_despawn() {
  279|       |        let mut buffer = CommandBuffer::new();
  280|       |        let entity = Entity::new(0, 0);
  281|       |
  282|       |        buffer.despawn(entity);
  283|       |        assert_eq!(buffer.len(), 1);
  284|       |    }
  285|       |
  286|       |    #[test]
  287|       |    fn test_queue_spawn() {
  288|       |        let mut buffer = CommandBuffer::new();
  289|       |
  290|       |        buffer.spawn().with(Position { x: 1.0, y: 2.0 });
  291|       |        assert_eq!(buffer.len(), 1);
  292|       |    }
  293|       |
  294|       |    #[test]
  295|       |    fn test_spawn_with_multiple_components() {
  296|       |        let mut buffer = CommandBuffer::new();
  297|       |
  298|       |        buffer
  299|       |            .spawn()
  300|       |            .with(Position { x: 1.0, y: 2.0 })
  301|       |            .with(Velocity { x: 0.5, y: 0.0 });
  302|       |
  303|       |        assert_eq!(buffer.len(), 1);
  304|       |    }
  305|       |
  306|       |    #[test]
  307|       |    fn test_clear() {
  308|       |        let mut buffer = CommandBuffer::new();
  309|       |        let entity = Entity::new(0, 0);
  310|       |
  311|       |        buffer.insert(entity, Position { x: 1.0, y: 2.0 });
  312|       |        buffer.despawn(entity);
  313|       |        assert_eq!(buffer.len(), 2);
  314|       |
  315|       |        buffer.clear();
  316|       |        assert_eq!(buffer.len(), 0);
  317|       |        assert!(buffer.is_empty());
  318|       |    }
  319|       |
  320|       |    #[test]
  321|       |    fn test_command_ordering() {
  322|       |        let mut buffer = CommandBuffer::new();
  323|       |        let e1 = Entity::new(0, 0);
  324|       |        let e2 = Entity::new(1, 0);
  325|       |
  326|       |        // Queue in specific order
  327|       |        buffer.spawn().with(Position { x: 1.0, y: 1.0 });
  328|       |        buffer.insert(e1, Velocity { x: 2.0, y: 2.0 });
  329|       |        buffer.remove::<Position>(e2);
  330|       |        buffer.despawn(e1);
  331|       |
  332|       |        assert_eq!(buffer.len(), 4);
  333|       |    }
  334|       |
  335|       |    #[test]
  336|       |    fn test_flush_insert_remove() {
  337|       |        let mut world = World::new();
  338|       |        world.register_component::<Position>();
  339|       |        world.register_component::<Velocity>();
  340|       |
  341|       |        let mut buffer = CommandBuffer::new();
  342|       |        let entity = world.spawn();
  343|       |
  344|       |        buffer.insert(entity, Position { x: 1.0, y: 2.0 });
  345|       |        buffer.flush(&mut world);
  346|       |
  347|       |        assert_eq!(world.get::<Position>(entity), Some(&Position { x: 1.0, y: 2.0 }));
  348|       |    }
  349|       |
  350|       |    #[test]
  351|       |    fn test_multiple_flushes() {
  352|       |        let mut world = World::new();
  353|       |        let mut buffer = CommandBuffer::new();
  354|       |
  355|       |        // First flush (empty)
  356|       |        buffer.flush(&mut world);
  357|       |        assert_eq!(buffer.len(), 0);
  358|       |
  359|       |        // Second flush (empty)
  360|       |        buffer.flush(&mut world);
  361|       |        assert_eq!(buffer.len(), 0);
  362|       |    }
  363|       |
  364|       |    #[test]
  365|       |    fn test_spawn_builder_drop() {
  366|       |        let mut buffer = CommandBuffer::new();
  367|       |
  368|       |        {
  369|       |            let _builder = buffer.spawn().with(Position { x: 1.0, y: 2.0 });
  370|       |            // Builder dropped here, should finalize spawn command
  371|       |        }
  372|       |
  373|       |        assert_eq!(buffer.len(), 1);
  374|       |    }
  375|       |
  376|       |    #[test]
  377|       |    fn test_flush_spawn() {
  378|       |        let mut world = World::new();
  379|       |        world.register_component::<Position>();
  380|       |        world.register_component::<Velocity>();
  381|       |
  382|       |        let mut buffer = CommandBuffer::new();
  383|       |
  384|       |        buffer
  385|       |            .spawn()
  386|       |            .with(Position { x: 5.0, y: 10.0 })
  387|       |            .with(Velocity { x: 1.0, y: 2.0 });
  388|       |
  389|       |        assert_eq!(world.entity_count(), 0);
  390|       |        buffer.flush(&mut world);
  391|       |
  392|       |        assert_eq!(world.entity_count(), 1);
  393|       |    }
  394|       |
  395|       |    #[test]
  396|       |    fn test_flush_despawn() {
  397|       |        let mut world = World::new();
  398|       |        let mut buffer = CommandBuffer::new();
  399|       |
  400|       |        let entity = world.spawn();
  401|       |        assert_eq!(world.entity_count(), 1);
  402|       |
  403|       |        buffer.despawn(entity);
  404|       |        buffer.flush(&mut world);
  405|       |
  406|       |        assert_eq!(world.entity_count(), 0);
  407|       |        assert!(!world.is_alive(entity));
  408|       |    }
  409|       |
  410|       |    #[test]
  411|       |    fn test_insert_during_iteration() {
  412|       |        let mut world = World::new();
  413|       |        world.register_component::<Position>();
  414|       |
  415|       |        let e1 = world.spawn();
  416|       |        let e2 = world.spawn();
  417|       |        let e3 = world.spawn();
  418|       |
  419|       |        let mut buffer = CommandBuffer::new();
  420|       |
  421|       |        for entity in [e1, e2, e3] {
  422|       |            buffer.insert(entity, Position { x: 1.0, y: 2.0 });
  423|       |        }
  424|       |
  425|       |        buffer.flush(&mut world);
  426|       |
  427|       |        assert_eq!(world.get::<Position>(e1), Some(&Position { x: 1.0, y: 2.0 }));
  428|       |        assert_eq!(world.get::<Position>(e2), Some(&Position { x: 1.0, y: 2.0 }));
  429|       |        assert_eq!(world.get::<Position>(e3), Some(&Position { x: 1.0, y: 2.0 }));
  430|       |    }
  431|       |
  432|       |    #[test]
  433|       |    fn test_stale_entity_ignored() {
  434|       |        // This test verifies that stale entities are silently ignored during flush.
  435|       |        // Since insert_boxed checks is_alive() first, it returns early without calling
  436|       |        // the (unimplemented) type dispatch, so no panic occurs.
  437|       |        let mut world = World::new();
  438|       |        world.register_component::<Position>();
  439|       |
  440|       |        let mut buffer = CommandBuffer::new();
  441|       |
  442|       |        let entity = world.spawn();
  443|       |        world.despawn(entity); // Entity now stale
  444|       |
  445|       |        buffer.insert(entity, Position { x: 1.0, y: 2.0 });
  446|       |        buffer.flush(&mut world); // No panic - stale entity ignored
  447|       |
  448|       |        assert!(!world.is_alive(entity));
  449|       |    }
  450|       |
  451|       |    #[test]
  452|       |    fn test_command_ordering_preservation() {
  453|       |        let mut world = World::new();
  454|       |        world.register_component::<Position>();
  455|       |
  456|       |        let mut buffer = CommandBuffer::new();
  457|       |
  458|       |        let e1 = world.spawn();
  459|       |
  460|       |        buffer.insert(e1, Position { x: 1.0, y: 1.0 });
  461|       |        buffer.remove::<Position>(e1);
  462|       |        buffer.insert(e1, Position { x: 2.0, y: 2.0 });
  463|       |
  464|       |        buffer.flush(&mut world);
  465|       |
  466|       |        assert_eq!(world.get::<Position>(e1), Some(&Position { x: 2.0, y: 2.0 }));
  467|       |    }
  468|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\entity_allocator.rs:
    1|       |//! Entity allocator with generational indices for safe entity lifecycle management.
    2|       |//!
    3|       |//! # Problem
    4|       |//!
    5|       |//! Without generational indices, entity IDs are recycled after despawn, leading to
    6|       |//! use-after-free bugs:
    7|       |//!
    8|       |//! ```rust,ignore
    9|       |//! let e1 = world.spawn();  // ID = 1
   10|       |//! world.despawn(e1);
   11|       |//! let e2 = world.spawn();  // ID = 1 (reused!)
   12|       |//! world.get::<Position>(e1);  // ❌ Accesses e2's data! (use-after-free)
   13|       |//! ```
   14|       |//!
   15|       |//! # Solution
   16|       |//!
   17|       |//! Generational indices add a generation counter that increments on reuse:
   18|       |//!
   19|       |//! ```rust,ignore
   20|       |//! let e1 = world.spawn();  // Entity { id: 1, generation: 0 }
   21|       |//! world.despawn(e1);       // Generation[1] = 1
   22|       |//! let e2 = world.spawn();  // Entity { id: 1, generation: 1 }
   23|       |//! world.get::<Position>(e1);  // ✅ Returns None (generation mismatch)
   24|       |//! ```
   25|       |//!
   26|       |//! # Performance
   27|       |//!
   28|       |//! - Entity struct: 64-bit (no size increase from bare u64)
   29|       |//! - Validation: O(1) array lookup
   30|       |//! - Spawn/despawn: O(1) amortized (free list)
   31|       |
   32|       |use std::fmt;
   33|       |
   34|       |/// Entity identifier with generational index for safe lifecycle management.
   35|       |///
   36|       |/// # Memory Layout
   37|       |///
   38|       |/// ```text
   39|       |/// Entity (8 bytes):
   40|       |/// ┌──────────────────────────────────┬──────────────────────────────────┐
   41|       |/// │         ID (32 bits)             │      Generation (32 bits)        │
   42|       |/// └──────────────────────────────────┴──────────────────────────────────┘
   43|       |/// ```
   44|       |///
   45|       |/// - **ID**: Entity index (recycled after despawn)
   46|       |/// - **Generation**: Counter incremented on reuse (detects stale handles)
   47|       |///
   48|       |/// # Guarantees
   49|       |///
   50|       |/// - Deterministic: Same operations → same entities
   51|       |/// - Safe: Stale entity handles rejected (no use-after-free)
   52|       |/// - Ordered: Implements `Ord` for stable iteration
   53|       |#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
   54|       |pub struct Entity {
   55|       |    id: u32,
   56|       |    generation: u32,
   57|       |}
   58|       |
   59|       |impl Entity {
   60|       |    /// Create a new entity with given ID and generation.
   61|       |    ///
   62|       |    /// # Internal Use Only
   63|       |    ///
   64|       |    /// This is used by `EntityAllocator`. User code should use `World::spawn()`.
   65|       |    #[inline]
   66|      0|    pub(crate) fn new(id: u32, generation: u32) -> Self {
   67|      0|        Self { id, generation }
   68|      0|    }
   69|       |
   70|       |    /// Get the entity index (recycled).
   71|       |    ///
   72|       |    /// # Note
   73|       |    ///
   74|       |    /// This is the slot index in the allocator, not a unique identifier.
   75|       |    /// Use the full `Entity` (id + generation) for identity checks.
   76|       |    #[inline]
   77|      0|    pub fn id(&self) -> u32 {
   78|      0|        self.id
   79|      0|    }
   80|       |
   81|       |    /// Get the generation counter.
   82|       |    ///
   83|       |    /// # Generation Semantics
   84|       |    ///
   85|       |    /// - Starts at 0 for first spawn
   86|       |    /// - Increments on each despawn
   87|       |    /// - Used to detect stale entity handles
   88|       |    #[inline]
   89|      0|    pub fn generation(&self) -> u32 {
   90|      0|        self.generation
   91|      0|    }
   92|       |
   93|       |    /// Convert to raw u64 for serialization or external APIs.
   94|       |    ///
   95|       |    /// # Format
   96|       |    ///
   97|       |    /// ```text
   98|       |    /// u64 = (id as u64) | ((generation as u64) << 32)
   99|       |    /// ```
  100|       |    #[inline]
  101|      0|    pub fn to_raw(&self) -> u64 {
  102|      0|        (self.id as u64) | ((self.generation as u64) << 32)
  103|      0|    }
  104|       |
  105|       |    /// Reconstruct entity from raw u64.
  106|       |    ///
  107|       |    /// # Safety
  108|       |    ///
  109|       |    /// The caller must ensure this entity is valid in the target `World`.
  110|       |    /// Use `World::is_alive(entity)` to validate.
  111|       |    #[inline]
  112|      0|    pub unsafe fn from_raw(raw: u64) -> Self {
  113|      0|        Self {
  114|      0|            id: raw as u32,
  115|      0|            generation: (raw >> 32) as u32,
  116|      0|        }
  117|      0|    }
  118|       |
  119|       |    /// Create a null entity (invalid, for initialization).
  120|       |    ///
  121|       |    /// # Note
  122|       |    ///
  123|       |    /// Null entities fail all `is_alive()` checks.
  124|       |    #[inline]
  125|      0|    pub const fn null() -> Self {
  126|      0|        Self {
  127|      0|            id: u32::MAX,
  128|      0|            generation: u32::MAX,
  129|      0|        }
  130|      0|    }
  131|       |
  132|       |    /// Check if this is a null entity.
  133|       |    #[inline]
  134|      0|    pub const fn is_null(&self) -> bool {
  135|      0|        self.id == u32::MAX && self.generation == u32::MAX
  136|      0|    }
  137|       |}
  138|       |
  139|       |impl fmt::Debug for Entity {
  140|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  141|      0|        write!(f, "Entity({}v{})", self.id, self.generation)
  142|      0|    }
  143|       |}
  144|       |
  145|       |impl fmt::Display for Entity {
  146|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  147|      0|        write!(f, "{}v{}", self.id, self.generation)
  148|      0|    }
  149|       |}
  150|       |
  151|       |/// Entity allocator with generational index tracking.
  152|       |///
  153|       |/// # Algorithm
  154|       |///
  155|       |/// - **Free List**: Recycled IDs stored in `Vec<u32>` (LIFO)
  156|       |/// - **Generations**: Per-slot generation counter in `Vec<u32>`
  157|       |/// - **Spawn**: Pop from free list or allocate new ID
  158|       |/// - **Despawn**: Increment generation, push to free list
  159|       |///
  160|       |/// # Complexity
  161|       |///
  162|       |/// - Spawn: O(1) amortized
  163|       |/// - Despawn: O(1)
  164|       |/// - Is Alive: O(1) array lookup
  165|       |///
  166|       |/// # Capacity
  167|       |///
  168|       |/// - Max entities: 2^32 - 1 (4.2 billion)
  169|       |/// - Max generations per slot: 2^32 - 1 (4.2 billion reuses)
  170|       |#[derive(Debug, Clone)]
  171|       |pub struct EntityAllocator {
  172|       |    /// Free list of recycled entity IDs (LIFO)
  173|       |    free_list: Vec<u32>,
  174|       |
  175|       |    /// Generation counter per entity slot
  176|       |    generations: Vec<u32>,
  177|       |
  178|       |    /// Next entity ID if free list is empty
  179|       |    next_id: u32,
  180|       |
  181|       |    /// Total entities spawned (for statistics)
  182|       |    spawned_count: u64,
  183|       |
  184|       |    /// Total entities despawned (for statistics)
  185|       |    despawned_count: u64,
  186|       |}
  187|       |
  188|       |impl EntityAllocator {
  189|       |    /// Create a new entity allocator.
  190|      0|    pub fn new() -> Self {
  191|      0|        Self {
  192|      0|            free_list: Vec::new(),
  193|      0|            generations: Vec::new(),
  194|      0|            next_id: 0,
  195|      0|            spawned_count: 0,
  196|      0|            despawned_count: 0,
  197|      0|        }
  198|      0|    }
  199|       |
  200|       |    /// Create allocator with pre-allocated capacity.
  201|       |    ///
  202|       |    /// # Example
  203|       |    ///
  204|       |    /// ```
  205|       |    /// use astraweave_ecs::entity_allocator::EntityAllocator;
  206|       |    ///
  207|       |    /// let allocator = EntityAllocator::with_capacity(10_000);
  208|       |    /// // No allocations until entity count exceeds 10,000
  209|       |    /// ```
  210|      0|    pub fn with_capacity(capacity: usize) -> Self {
  211|      0|        Self {
  212|      0|            free_list: Vec::new(),
  213|      0|            generations: Vec::with_capacity(capacity),
  214|      0|            next_id: 0,
  215|      0|            spawned_count: 0,
  216|      0|            despawned_count: 0,
  217|      0|        }
  218|      0|    }
  219|       |
  220|       |    /// Spawn a new entity.
  221|       |    ///
  222|       |    /// # Algorithm
  223|       |    ///
  224|       |    /// 1. Pop from free list if available
  225|       |    /// 2. Otherwise allocate new ID
  226|       |    /// 3. Return `Entity { id, generation }`
  227|       |    ///
  228|       |    /// # Example
  229|       |    ///
  230|       |    /// ```
  231|       |    /// use astraweave_ecs::entity_allocator::EntityAllocator;
  232|       |    ///
  233|       |    /// let mut allocator = EntityAllocator::new();
  234|       |    /// let e1 = allocator.spawn();  // Entity(0v0)
  235|       |    /// let e2 = allocator.spawn();  // Entity(1v0)
  236|       |    /// ```
  237|      0|    pub fn spawn(&mut self) -> Entity {
  238|      0|        let id = if let Some(id) = self.free_list.pop() {
  239|       |            // Reuse recycled ID with current generation
  240|      0|            id
  241|       |        } else {
  242|       |            // Allocate new ID
  243|      0|            let id = self.next_id;
  244|      0|            self.next_id = self.next_id.checked_add(1).expect(
  245|      0|                "Entity ID overflow: spawned 2^32 entities. \
  246|      0|                 Consider increasing entity slot size or implementing entity pooling.",
  247|      0|            );
  248|      0|            self.generations.push(0);
  249|      0|            id
  250|       |        };
  251|       |
  252|      0|        let generation = self.generations[id as usize];
  253|      0|        self.spawned_count += 1;
  254|       |
  255|      0|        Entity::new(id, generation)
  256|      0|    }
  257|       |
  258|       |    /// Despawn an entity.
  259|       |    ///
  260|       |    /// # Returns
  261|       |    ///
  262|       |    /// - `true` if entity was alive and despawned
  263|       |    /// - `false` if entity was already dead (stale handle)
  264|       |    ///
  265|       |    /// # Algorithm
  266|       |    ///
  267|       |    /// 1. Check generation matches (is alive)
  268|       |    /// 2. Increment generation
  269|       |    /// 3. Add to free list
  270|       |    ///
  271|       |    /// # Example
  272|       |    ///
  273|       |    /// ```
  274|       |    /// use astraweave_ecs::entity_allocator::EntityAllocator;
  275|       |    ///
  276|       |    /// let mut allocator = EntityAllocator::new();
  277|       |    /// let e1 = allocator.spawn();
  278|       |    ///
  279|       |    /// assert!(allocator.despawn(e1));  // First despawn succeeds
  280|       |    /// assert!(!allocator.despawn(e1)); // Second despawn fails (stale)
  281|       |    /// ```
  282|      0|    pub fn despawn(&mut self, entity: Entity) -> bool {
  283|      0|        let id = entity.id as usize;
  284|       |
  285|       |        // Validate entity exists
  286|      0|        if id >= self.generations.len() {
  287|      0|            return false;
  288|      0|        }
  289|       |
  290|       |        // Check generation (is alive)
  291|      0|        if self.generations[id] != entity.generation {
  292|      0|            return false; // Stale entity
  293|      0|        }
  294|       |
  295|       |        // Increment generation
  296|      0|        self.generations[id] = self.generations[id].wrapping_add(1);
  297|       |
  298|       |        // Add to free list
  299|      0|        self.free_list.push(entity.id);
  300|       |
  301|      0|        self.despawned_count += 1;
  302|       |
  303|      0|        true
  304|      0|    }
  305|       |
  306|       |    /// Check if an entity is alive.
  307|       |    ///
  308|       |    /// # Returns
  309|       |    ///
  310|       |    /// - `true` if entity ID and generation match
  311|       |    /// - `false` if entity is dead or never existed
  312|       |    ///
  313|       |    /// # Complexity
  314|       |    ///
  315|       |    /// O(1) array lookup
  316|       |    ///
  317|       |    /// # Example
  318|       |    ///
  319|       |    /// ```
  320|       |    /// use astraweave_ecs::entity_allocator::EntityAllocator;
  321|       |    ///
  322|       |    /// let mut allocator = EntityAllocator::new();
  323|       |    /// let e1 = allocator.spawn();
  324|       |    ///
  325|       |    /// assert!(allocator.is_alive(e1));
  326|       |    ///
  327|       |    /// allocator.despawn(e1);
  328|       |    /// assert!(!allocator.is_alive(e1));
  329|       |    /// ```
  330|       |    #[inline]
  331|      0|    pub fn is_alive(&self, entity: Entity) -> bool {
  332|      0|        let id = entity.id as usize;
  333|      0|        self.generations
  334|      0|            .get(id)
  335|      0|            .map(|&gen| gen == entity.generation)
  336|      0|            .unwrap_or(false)
  337|      0|    }
  338|       |
  339|       |    /// Get the current generation for an entity slot.
  340|       |    ///
  341|       |    /// Returns `None` if the ID has never been allocated.
  342|       |    #[inline]
  343|      0|    pub fn generation(&self, id: u32) -> Option<u32> {
  344|      0|        self.generations.get(id as usize).copied()
  345|      0|    }
  346|       |
  347|       |    /// Get total number of entities currently alive.
  348|       |    #[inline]
  349|      0|    pub fn alive_count(&self) -> usize {
  350|      0|        (self.spawned_count - self.despawned_count) as usize
  351|      0|    }
  352|       |
  353|       |    /// Get total number of entity slots allocated.
  354|       |    #[inline]
  355|      0|    pub fn capacity(&self) -> usize {
  356|      0|        self.generations.len()
  357|      0|    }
  358|       |
  359|       |    /// Get total number of entities spawned (including despawned).
  360|       |    #[inline]
  361|      0|    pub fn spawned_count(&self) -> u64 {
  362|      0|        self.spawned_count
  363|      0|    }
  364|       |
  365|       |    /// Get total number of entities despawned.
  366|       |    #[inline]
  367|      0|    pub fn despawned_count(&self) -> u64 {
  368|      0|        self.despawned_count
  369|      0|    }
  370|       |
  371|       |    /// Clear all entities and reset allocator.
  372|       |    ///
  373|       |    /// # Warning
  374|       |    ///
  375|       |    /// All existing `Entity` handles become invalid.
  376|      0|    pub fn clear(&mut self) {
  377|      0|        self.free_list.clear();
  378|      0|        self.generations.clear();
  379|      0|        self.next_id = 0;
  380|      0|        self.spawned_count = 0;
  381|      0|        self.despawned_count = 0;
  382|      0|    }
  383|       |
  384|       |    /// Reserve capacity for additional entities.
  385|       |    ///
  386|       |    /// This pre-allocates space to avoid reallocation during spawn.
  387|      0|    pub fn reserve(&mut self, additional: usize) {
  388|      0|        self.generations.reserve(additional);
  389|      0|    }
  390|       |}
  391|       |
  392|       |impl Default for EntityAllocator {
  393|      0|    fn default() -> Self {
  394|      0|        Self::new()
  395|      0|    }
  396|       |}
  397|       |
  398|       |#[cfg(test)]
  399|       |mod tests {
  400|       |    use super::*;
  401|       |
  402|       |    #[test]
  403|       |    fn test_spawn_despawn_cycle() {
  404|       |        let mut allocator = EntityAllocator::new();
  405|       |
  406|       |        let e1 = allocator.spawn();
  407|       |        assert_eq!(e1.id(), 0);
  408|       |        assert_eq!(e1.generation(), 0);
  409|       |        assert!(allocator.is_alive(e1));
  410|       |
  411|       |        allocator.despawn(e1);
  412|       |        assert!(!allocator.is_alive(e1));
  413|       |
  414|       |        let e2 = allocator.spawn();
  415|       |        assert_eq!(e2.id(), 0); // Reused ID
  416|       |        assert_eq!(e2.generation(), 1); // Incremented generation
  417|       |        assert!(!allocator.is_alive(e1)); // Old handle invalid
  418|       |        assert!(allocator.is_alive(e2)); // New handle valid
  419|       |    }
  420|       |
  421|       |    #[test]
  422|       |    fn test_stale_entity_rejection() {
  423|       |        let mut allocator = EntityAllocator::new();
  424|       |
  425|       |        let e1 = allocator.spawn();
  426|       |        allocator.despawn(e1);
  427|       |
  428|       |        // Trying to despawn again should fail
  429|       |        assert!(!allocator.despawn(e1));
  430|       |        assert!(!allocator.is_alive(e1));
  431|       |    }
  432|       |
  433|       |    #[test]
  434|       |    fn test_multiple_entities() {
  435|       |        let mut allocator = EntityAllocator::new();
  436|       |
  437|       |        let e1 = allocator.spawn();
  438|       |        let e2 = allocator.spawn();
  439|       |        let e3 = allocator.spawn();
  440|       |
  441|       |        assert_eq!(e1.id(), 0);
  442|       |        assert_eq!(e2.id(), 1);
  443|       |        assert_eq!(e3.id(), 2);
  444|       |
  445|       |        assert!(allocator.is_alive(e1));
  446|       |        assert!(allocator.is_alive(e2));
  447|       |        assert!(allocator.is_alive(e3));
  448|       |
  449|       |        allocator.despawn(e2);
  450|       |        assert!(allocator.is_alive(e1));
  451|       |        assert!(!allocator.is_alive(e2));
  452|       |        assert!(allocator.is_alive(e3));
  453|       |    }
  454|       |
  455|       |    #[test]
  456|       |    fn test_generation_overflow() {
  457|       |        let mut allocator = EntityAllocator::new();
  458|       |
  459|       |        let e1 = allocator.spawn();
  460|       |        let id = e1.id();
  461|       |
  462|       |        // Simulate many despawn/spawn cycles
  463|       |        for i in 0..10 {
  464|       |            allocator.despawn(Entity::new(id, i));
  465|       |            let e = allocator.spawn();
  466|       |            assert_eq!(e.id(), id);
  467|       |            assert_eq!(e.generation(), i + 1);
  468|       |        }
  469|       |    }
  470|       |
  471|       |    #[test]
  472|       |    fn test_entity_ordering() {
  473|       |        let e1 = Entity::new(0, 0);
  474|       |        let e2 = Entity::new(1, 0);
  475|       |        let e3 = Entity::new(0, 1);
  476|       |
  477|       |        assert!(e1 < e2); // Different IDs
  478|       |        assert!(e1 < e3); // Same ID, different generation
  479|       |        assert!(e3 < e2); // Generation comparison
  480|       |    }
  481|       |
  482|       |    #[test]
  483|       |    fn test_entity_display() {
  484|       |        let e = Entity::new(42, 7);
  485|       |        assert_eq!(format!("{}", e), "42v7");
  486|       |        assert_eq!(format!("{:?}", e), "Entity(42v7)");
  487|       |    }
  488|       |
  489|       |    #[test]
  490|       |    fn test_null_entity() {
  491|       |        let null = Entity::null();
  492|       |        assert!(null.is_null());
  493|       |
  494|       |        let allocator = EntityAllocator::new();
  495|       |        assert!(!allocator.is_alive(null));
  496|       |    }
  497|       |
  498|       |    #[test]
  499|       |    fn test_raw_conversion() {
  500|       |        let e = Entity::new(0x12345678, 0xABCDEF01);
  501|       |        let raw = e.to_raw();
  502|       |        let restored = unsafe { Entity::from_raw(raw) };
  503|       |
  504|       |        assert_eq!(e, restored);
  505|       |        assert_eq!(e.id(), restored.id());
  506|       |        assert_eq!(e.generation(), restored.generation());
  507|       |    }
  508|       |
  509|       |    #[test]
  510|       |    fn test_capacity_tracking() {
  511|       |        let mut allocator = EntityAllocator::new();
  512|       |
  513|       |        assert_eq!(allocator.alive_count(), 0);
  514|       |        assert_eq!(allocator.capacity(), 0);
  515|       |
  516|       |        let e1 = allocator.spawn();
  517|       |        assert_eq!(allocator.alive_count(), 1);
  518|       |        assert_eq!(allocator.capacity(), 1);
  519|       |
  520|       |        let _e2 = allocator.spawn();
  521|       |        assert_eq!(allocator.alive_count(), 2);
  522|       |        assert_eq!(allocator.capacity(), 2);
  523|       |
  524|       |        allocator.despawn(e1);
  525|       |        assert_eq!(allocator.alive_count(), 1);
  526|       |        assert_eq!(allocator.capacity(), 2); // Capacity doesn't shrink
  527|       |    }
  528|       |
  529|       |    #[test]
  530|       |    fn test_with_capacity() {
  531|       |        let allocator = EntityAllocator::with_capacity(100);
  532|       |        assert_eq!(allocator.capacity(), 0); // No entities spawned yet
  533|       |        assert!(allocator.generations.capacity() >= 100);
  534|       |    }
  535|       |
  536|       |    #[test]
  537|       |    fn test_clear() {
  538|       |        let mut allocator = EntityAllocator::new();
  539|       |
  540|       |        let e1 = allocator.spawn();
  541|       |        let e2 = allocator.spawn();
  542|       |
  543|       |        allocator.clear();
  544|       |
  545|       |        assert_eq!(allocator.alive_count(), 0);
  546|       |        assert_eq!(allocator.capacity(), 0);
  547|       |        assert!(!allocator.is_alive(e1));
  548|       |        assert!(!allocator.is_alive(e2));
  549|       |
  550|       |        let e3 = allocator.spawn();
  551|       |        assert_eq!(e3.id(), 0); // Reset to ID 0
  552|       |        assert_eq!(e3.generation(), 0); // Reset generation
  553|       |    }
  554|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\events.rs:
    1|       |//! Event system for AI-native game engine.
    2|       |//!
    3|       |//! Events are crucial for AI perception and reactive behaviors.
    4|       |//! This system provides deterministic event ordering and efficient queries.
    5|       |
    6|       |#[cfg(feature = "profiling")]
    7|       |use astraweave_profiling::span;
    8|       |
    9|       |use std::any::{Any, TypeId};
   10|       |use std::collections::{HashMap, VecDeque};
   11|       |use std::marker::PhantomData;
   12|       |
   13|       |/// Event trait marker
   14|       |pub trait Event: 'static + Send + Sync {}
   15|       |
   16|       |/// Event storage for a single event type
   17|       |struct EventQueue<E: Event> {
   18|       |    events: VecDeque<E>,
   19|       |    /// Frame when events were added (for cleanup)
   20|       |    frame_added: VecDeque<u64>,
   21|       |}
   22|       |
   23|       |impl<E: Event> EventQueue<E> {
   24|      0|    fn new() -> Self {
   25|      0|        Self {
   26|      0|            events: VecDeque::new(),
   27|      0|            frame_added: VecDeque::new(),
   28|      0|        }
   29|      0|    }
   30|       |
   31|      0|    fn send(&mut self, event: E, frame: u64) {
   32|      0|        self.events.push_back(event);
   33|      0|        self.frame_added.push_back(frame);
   34|      0|    }
   35|       |
   36|      0|    fn drain(&mut self) -> impl Iterator<Item = E> + '_ {
   37|      0|        self.frame_added.clear();
   38|      0|        self.events.drain(..)
   39|      0|    }
   40|       |
   41|      0|    fn iter(&self) -> impl Iterator<Item = &E> {
   42|      0|        self.events.iter()
   43|      0|    }
   44|       |
   45|       |    /// Remove events older than N frames
   46|       |    #[allow(dead_code)]
   47|      0|    fn cleanup(&mut self, current_frame: u64, keep_frames: u64) {
   48|      0|        while let Some(&frame) = self.frame_added.front() {
   49|      0|            if current_frame.saturating_sub(frame) > keep_frames {
   50|      0|                self.events.pop_front();
   51|      0|                self.frame_added.pop_front();
   52|      0|            } else {
   53|      0|                break;
   54|       |            }
   55|       |        }
   56|      0|    }
   57|       |
   58|      0|    fn len(&self) -> usize {
   59|      0|        self.events.len()
   60|      0|    }
   61|       |
   62|      0|    fn clear(&mut self) {
   63|      0|        self.events.clear();
   64|      0|        self.frame_added.clear();
   65|      0|    }
   66|       |}
   67|       |
   68|       |/// Central event registry for all event types
   69|       |pub struct Events {
   70|       |    /// Map from TypeId to type-erased event queue
   71|       |    queues: HashMap<TypeId, Box<dyn Any + Send + Sync>>,
   72|       |    /// Current simulation frame
   73|       |    current_frame: u64,
   74|       |    /// How many frames to keep events before cleanup
   75|       |    keep_frames: u64,
   76|       |}
   77|       |
   78|       |impl Events {
   79|       |    pub fn new() -> Self {
   80|       |        Self {
   81|       |            queues: HashMap::new(),
   82|       |            current_frame: 0,
   83|       |            keep_frames: 2, // Keep events for 2 frames by default
   84|       |        }
   85|       |    }
   86|       |
   87|       |    pub fn with_keep_frames(mut self, frames: u64) -> Self {
   88|       |        self.keep_frames = frames;
   89|       |        self
   90|       |    }
   91|       |
   92|       |    /// Send an event
   93|      0|    pub fn send<E: Event>(&mut self, event: E) {
   94|      0|        let queue = self
   95|      0|            .queues
   96|      0|            .entry(TypeId::of::<E>())
   97|      0|            .or_insert_with(|| Box::new(EventQueue::<E>::new()));
   98|       |
   99|      0|        let queue = queue.downcast_mut::<EventQueue<E>>().expect(
  100|      0|            "EventQueue type mismatch: just inserted correct type, downcast should never fail",
  101|       |        );
  102|      0|        queue.send(event, self.current_frame);
  103|      0|    }
  104|       |
  105|       |    /// Get event reader for type E
  106|      0|    pub fn get_reader<E: Event>(&self) -> EventReader<E> {
  107|      0|        EventReader {
  108|      0|            type_id: TypeId::of::<E>(),
  109|      0|            _marker: PhantomData,
  110|      0|        }
  111|      0|    }
  112|       |
  113|       |    /// Read events of type E
  114|      0|    pub fn read<E: Event>(&self) -> impl Iterator<Item = &E> {
  115|      0|        self.queues
  116|      0|            .get(&TypeId::of::<E>())
  117|      0|            .and_then(|q| q.downcast_ref::<EventQueue<E>>())
  118|      0|            .map(|q| q.iter())
  119|      0|            .into_iter()
  120|      0|            .flatten()
  121|      0|    }
  122|       |
  123|       |    /// Drain all events of type E (consumes them)
  124|      0|    pub fn drain<E: Event>(&mut self) -> impl Iterator<Item = E> + '_ {
  125|      0|        self.queues
  126|      0|            .get_mut(&TypeId::of::<E>())
  127|      0|            .and_then(|q| q.downcast_mut::<EventQueue<E>>())
  128|      0|            .map(|q| q.drain())
  129|      0|            .into_iter()
  130|      0|            .flatten()
  131|      0|    }
  132|       |
  133|       |    /// Clear all events of type E
  134|      0|    pub fn clear<E: Event>(&mut self) {
  135|      0|        if let Some(queue) = self.queues.get_mut(&TypeId::of::<E>()) {
  136|      0|            if let Some(q) = queue.downcast_mut::<EventQueue<E>>() {
  137|      0|                q.clear();
  138|      0|            }
  139|      0|        }
  140|      0|    }
  141|       |
  142|       |    /// Get event count for type E
  143|      0|    pub fn len<E: Event>(&self) -> usize {
  144|      0|        self.queues
  145|      0|            .get(&TypeId::of::<E>())
  146|      0|            .and_then(|q| q.downcast_ref::<EventQueue<E>>())
  147|      0|            .map(|q| q.len())
  148|      0|            .unwrap_or(0)
  149|      0|    }
  150|       |
  151|       |    /// Check if events queue is empty for type E
  152|      0|    pub fn is_empty<E: Event>(&self) -> bool {
  153|      0|        self.len::<E>() == 0
  154|      0|    }
  155|       |
  156|       |    /// Advance frame and cleanup old events
  157|       |    pub fn update(&mut self) {
  158|       |        #[cfg(feature = "profiling")]
  159|       |        span!("ECS::Events::update");
  160|       |
  161|       |        self.current_frame += 1;
  162|       |
  163|       |        // Cleanup old events from all queues
  164|       |        for _queue in self.queues.values_mut() {
  165|       |            // Type erasure: we need to cast to EventQueue<T> but don't know T
  166|       |            // For now, we'll skip automatic cleanup and rely on explicit clear
  167|       |            // TODO: Store cleanup function pointer or use trait object
  168|       |        }
  169|       |    }
  170|       |
  171|       |    /// Clear all events
  172|       |    pub fn clear_all(&mut self) {
  173|       |        self.queues.clear();
  174|       |    }
  175|       |
  176|       |    pub fn current_frame(&self) -> u64 {
  177|       |        self.current_frame
  178|       |    }
  179|       |}
  180|       |
  181|       |impl Default for Events {
  182|       |    fn default() -> Self {
  183|       |        Self::new()
  184|       |    }
  185|       |}
  186|       |
  187|       |// Note: Events implements Resource via the blanket impl in lib.rs
  188|       |// impl Resource for Events {} // Removed - conflicts with blanket impl
  189|       |
  190|       |/// Event reader - provides a handle to read events of a specific type
  191|       |#[allow(dead_code)]
  192|       |pub struct EventReader<E: Event> {
  193|       |    type_id: TypeId,
  194|       |    _marker: PhantomData<E>,
  195|       |}
  196|       |
  197|       |impl<E: Event> EventReader<E> {
  198|       |    /// Read events from the Events resource
  199|      0|    pub fn read<'a>(&self, events: &'a Events) -> impl Iterator<Item = &'a E> {
  200|      0|        events.read::<E>()
  201|      0|    }
  202|       |}
  203|       |
  204|       |// Common game events for AI systems
  205|       |
  206|       |/// Entity spawned event
  207|       |#[derive(Clone, Debug)]
  208|       |pub struct EntitySpawnedEvent {
  209|       |    pub entity: crate::Entity,
  210|       |    pub entity_type: String,
  211|       |}
  212|       |impl Event for EntitySpawnedEvent {}
  213|       |
  214|       |/// Entity despawned event
  215|       |#[derive(Clone, Debug)]
  216|       |pub struct EntityDespawnedEvent {
  217|       |    pub entity: crate::Entity,
  218|       |}
  219|       |impl Event for EntityDespawnedEvent {}
  220|       |
  221|       |/// Health changed event (for AI perception)
  222|       |#[derive(Clone, Debug)]
  223|       |pub struct HealthChangedEvent {
  224|       |    pub entity: crate::Entity,
  225|       |    pub old_health: i32,
  226|       |    pub new_health: i32,
  227|       |    pub source: Option<crate::Entity>,
  228|       |}
  229|       |impl Event for HealthChangedEvent {}
  230|       |
  231|       |/// AI planning failed event
  232|       |#[derive(Clone, Debug)]
  233|       |pub struct AiPlanningFailedEvent {
  234|       |    pub entity: crate::Entity,
  235|       |    pub reason: String,
  236|       |}
  237|       |impl Event for AiPlanningFailedEvent {}
  238|       |
  239|       |/// Tool validation failed event
  240|       |#[derive(Clone, Debug)]
  241|       |pub struct ToolValidationFailedEvent {
  242|       |    pub entity: crate::Entity,
  243|       |    pub tool_name: String,
  244|       |    pub reason: String,
  245|       |}
  246|       |impl Event for ToolValidationFailedEvent {}
  247|       |
  248|       |#[cfg(test)]
  249|       |mod tests {
  250|       |    use super::*;
  251|       |
  252|       |    #[derive(Clone, Debug, PartialEq)]
  253|       |    struct TestEvent {
  254|       |        value: i32,
  255|       |    }
  256|       |    impl Event for TestEvent {}
  257|       |
  258|       |    #[test]
  259|       |    fn test_send_and_read_events() {
  260|       |        let mut events = Events::new();
  261|       |
  262|       |        events.send(TestEvent { value: 42 });
  263|       |        events.send(TestEvent { value: 100 });
  264|       |
  265|       |        let collected: Vec<_> = events.read::<TestEvent>().collect();
  266|       |        assert_eq!(collected.len(), 2);
  267|       |        assert_eq!(collected[0].value, 42);
  268|       |        assert_eq!(collected[1].value, 100);
  269|       |    }
  270|       |
  271|       |    #[test]
  272|       |    fn test_drain_events() {
  273|       |        let mut events = Events::new();
  274|       |
  275|       |        events.send(TestEvent { value: 1 });
  276|       |        events.send(TestEvent { value: 2 });
  277|       |
  278|       |        let drained: Vec<_> = events.drain::<TestEvent>().collect();
  279|       |        assert_eq!(drained.len(), 2);
  280|       |
  281|       |        // Events should be gone after drain
  282|       |        assert_eq!(events.len::<TestEvent>(), 0);
  283|       |    }
  284|       |
  285|       |    #[test]
  286|       |    fn test_clear_events() {
  287|       |        let mut events = Events::new();
  288|       |
  289|       |        events.send(TestEvent { value: 1 });
  290|       |        events.send(TestEvent { value: 2 });
  291|       |
  292|       |        assert_eq!(events.len::<TestEvent>(), 2);
  293|       |
  294|       |        events.clear::<TestEvent>();
  295|       |        assert_eq!(events.len::<TestEvent>(), 0);
  296|       |    }
  297|       |
  298|       |    #[test]
  299|       |    fn test_event_reader() {
  300|       |        let mut events = Events::new();
  301|       |        let reader = events.get_reader::<TestEvent>();
  302|       |
  303|       |        events.send(TestEvent { value: 42 });
  304|       |
  305|       |        let collected: Vec<_> = reader.read(&events).collect();
  306|       |        assert_eq!(collected.len(), 1);
  307|       |        assert_eq!(collected[0].value, 42);
  308|       |    }
  309|       |
  310|       |    #[test]
  311|       |    fn test_frame_tracking() {
  312|       |        let mut events = Events::new();
  313|       |        assert_eq!(events.current_frame(), 0);
  314|       |
  315|       |        events.update();
  316|       |        assert_eq!(events.current_frame(), 1);
  317|       |
  318|       |        events.update();
  319|       |        assert_eq!(events.current_frame(), 2);
  320|       |    }
  321|       |
  322|       |    // ========================================================================
  323|       |    // Phase 3.3: Event Ordering Tests (Determinism)
  324|       |    // ========================================================================
  325|       |
  326|       |    #[test]
  327|       |    fn test_events_delivered_in_fifo_order() {
  328|       |        let mut events = Events::new();
  329|       |
  330|       |        // Send 100 events in sequence
  331|       |        for i in 0..100 {
  332|       |            events.send(TestEvent { value: i });
  333|       |        }
  334|       |
  335|       |        // Read events and verify FIFO order
  336|       |        let collected: Vec<_> = events.read::<TestEvent>().collect();
  337|       |        assert_eq!(collected.len(), 100, "Should have 100 events");
  338|       |
  339|       |        for (i, event) in collected.iter().enumerate() {
  340|       |            assert_eq!(
  341|       |                event.value, i as i32,
  342|       |                "Event {} should have value {}, got {}",
  343|       |                i, i, event.value
  344|       |            );
  345|       |        }
  346|       |    }
  347|       |
  348|       |    #[test]
  349|       |    fn test_drain_preserves_fifo_order() {
  350|       |        let mut events = Events::new();
  351|       |
  352|       |        // Send events
  353|       |        for i in 0..50 {
  354|       |            events.send(TestEvent { value: i });
  355|       |        }
  356|       |
  357|       |        // Drain events and verify FIFO order
  358|       |        let drained: Vec<_> = events.drain::<TestEvent>().collect();
  359|       |        assert_eq!(drained.len(), 50, "Should have drained 50 events");
  360|       |
  361|       |        for (i, event) in drained.iter().enumerate() {
  362|       |            assert_eq!(
  363|       |                event.value, i as i32,
  364|       |                "Drained event {} should have value {}, got {}",
  365|       |                i, i, event.value
  366|       |            );
  367|       |        }
  368|       |
  369|       |        // Verify events are gone
  370|       |        assert_eq!(
  371|       |            events.len::<TestEvent>(),
  372|       |            0,
  373|       |            "Events should be consumed after drain"
  374|       |        );
  375|       |    }
  376|       |
  377|       |    #[test]
  378|       |    fn test_frame_boundaries_respected() {
  379|       |        let mut events = Events::new();
  380|       |        assert_eq!(events.current_frame(), 0);
  381|       |
  382|       |        // Frame 0: Send events
  383|       |        events.send(TestEvent { value: 1 });
  384|       |        events.send(TestEvent { value: 2 });
  385|       |
  386|       |        // Advance to frame 1
  387|       |        events.update();
  388|       |        assert_eq!(events.current_frame(), 1);
  389|       |
  390|       |        // Frame 1: Send more events
  391|       |        events.send(TestEvent { value: 3 });
  392|       |        events.send(TestEvent { value: 4 });
  393|       |
  394|       |        // All events should still be present (no cross-frame interference)
  395|       |        let collected: Vec<_> = events.read::<TestEvent>().collect();
  396|       |        assert_eq!(collected.len(), 4, "Should have all 4 events");
  397|       |
  398|       |        // Verify FIFO order across frames
  399|       |        assert_eq!(collected[0].value, 1);
  400|       |        assert_eq!(collected[1].value, 2);
  401|       |        assert_eq!(collected[2].value, 3);
  402|       |        assert_eq!(collected[3].value, 4);
  403|       |    }
  404|       |
  405|       |    #[test]
  406|       |    fn test_multiple_readers_independent() {
  407|       |        let mut events = Events::new();
  408|       |
  409|       |        events.send(TestEvent { value: 42 });
  410|       |        events.send(TestEvent { value: 100 });
  411|       |
  412|       |        // Create two independent readers
  413|       |        let reader1 = events.get_reader::<TestEvent>();
  414|       |        let reader2 = events.get_reader::<TestEvent>();
  415|       |
  416|       |        // Both readers should see same events
  417|       |        let collected1: Vec<_> = reader1.read(&events).collect();
  418|       |        let collected2: Vec<_> = reader2.read(&events).collect();
  419|       |
  420|       |        assert_eq!(collected1.len(), 2);
  421|       |        assert_eq!(collected2.len(), 2);
  422|       |        assert_eq!(collected1[0].value, collected2[0].value);
  423|       |        assert_eq!(collected1[1].value, collected2[1].value);
  424|       |    }
  425|       |
  426|       |    #[test]
  427|       |    fn test_clear_removes_all_events() {
  428|       |        let mut events = Events::new();
  429|       |
  430|       |        // Send events
  431|       |        for i in 0..20 {
  432|       |            events.send(TestEvent { value: i });
  433|       |        }
  434|       |
  435|       |        assert_eq!(events.len::<TestEvent>(), 20);
  436|       |
  437|       |        // Clear all events
  438|       |        events.clear::<TestEvent>();
  439|       |
  440|       |        // Verify all events removed
  441|       |        assert_eq!(events.len::<TestEvent>(), 0);
  442|       |        let collected: Vec<_> = events.read::<TestEvent>().collect();
  443|       |        assert_eq!(collected.len(), 0);
  444|       |    }
  445|       |
  446|       |    #[test]
  447|       |    fn test_multiple_event_types_independent() {
  448|       |        #[derive(Clone, Debug)]
  449|       |        struct EventA {
  450|       |            id: u32,
  451|       |        }
  452|       |        impl Event for EventA {}
  453|       |
  454|       |        #[derive(Clone, Debug)]
  455|       |        struct EventB {
  456|       |            name: String,
  457|       |        }
  458|       |        impl Event for EventB {}
  459|       |
  460|       |        let mut events = Events::new();
  461|       |
  462|       |        // Send events of different types
  463|       |        events.send(EventA { id: 1 });
  464|       |        events.send(EventB {
  465|       |            name: "first".to_string(),
  466|       |        });
  467|       |        events.send(EventA { id: 2 });
  468|       |        events.send(EventB {
  469|       |            name: "second".to_string(),
  470|       |        });
  471|       |
  472|       |        // Each type should maintain its own FIFO order
  473|       |        let a_events: Vec<_> = events.read::<EventA>().collect();
  474|       |        let b_events: Vec<_> = events.read::<EventB>().collect();
  475|       |
  476|       |        assert_eq!(a_events.len(), 2);
  477|       |        assert_eq!(b_events.len(), 2);
  478|       |
  479|       |        assert_eq!(a_events[0].id, 1);
  480|       |        assert_eq!(a_events[1].id, 2);
  481|       |        assert_eq!(b_events[0].name, "first");
  482|       |        assert_eq!(b_events[1].name, "second");
  483|       |    }
  484|       |
  485|       |    #[test]
  486|       |    fn test_clear_one_type_preserves_others() {
  487|       |        #[derive(Clone, Debug)]
  488|       |        struct EventA {
  489|       |            #[allow(dead_code)]
  490|       |            value: i32,
  491|       |        }
  492|       |        impl Event for EventA {}
  493|       |
  494|       |        #[derive(Clone, Debug)]
  495|       |        struct EventB {
  496|       |            #[allow(dead_code)]
  497|       |            value: i32,
  498|       |        }
  499|       |        impl Event for EventB {}
  500|       |
  501|       |        let mut events = Events::new();
  502|       |
  503|       |        events.send(EventA { value: 1 });
  504|       |        events.send(EventB { value: 2 });
  505|       |
  506|       |        assert_eq!(events.len::<EventA>(), 1);
  507|       |        assert_eq!(events.len::<EventB>(), 1);
  508|       |
  509|       |        // Clear only EventA
  510|       |        events.clear::<EventA>();
  511|       |
  512|       |        // EventA should be gone, EventB should remain
  513|       |        assert_eq!(events.len::<EventA>(), 0);
  514|       |        assert_eq!(events.len::<EventB>(), 1);
  515|       |
  516|       |        let b_events: Vec<_> = events.read::<EventB>().collect();
  517|       |        assert_eq!(b_events[0].value, 2);
  518|       |    }
  519|       |
  520|       |    #[test]
  521|       |    fn test_interleaved_send_and_read() {
  522|       |        let mut events = Events::new();
  523|       |
  524|       |        // Send first batch
  525|       |        events.send(TestEvent { value: 1 });
  526|       |        events.send(TestEvent { value: 2 });
  527|       |
  528|       |        // Read (non-consuming)
  529|       |        let first_read: Vec<_> = events.read::<TestEvent>().collect();
  530|       |        assert_eq!(first_read.len(), 2);
  531|       |
  532|       |        // Send more events
  533|       |        events.send(TestEvent { value: 3 });
  534|       |        events.send(TestEvent { value: 4 });
  535|       |
  536|       |        // Read again (should see all events in FIFO order)
  537|       |        let second_read: Vec<_> = events.read::<TestEvent>().collect();
  538|       |        assert_eq!(second_read.len(), 4);
  539|       |        assert_eq!(second_read[0].value, 1);
  540|       |        assert_eq!(second_read[1].value, 2);
  541|       |        assert_eq!(second_read[2].value, 3);
  542|       |        assert_eq!(second_read[3].value, 4);
  543|       |    }
  544|       |
  545|       |    #[test]
  546|       |    fn test_repeated_drain_produces_empty_results() {
  547|       |        let mut events = Events::new();
  548|       |
  549|       |        events.send(TestEvent { value: 42 });
  550|       |
  551|       |        // First drain
  552|       |        let first_drain: Vec<_> = events.drain::<TestEvent>().collect();
  553|       |        assert_eq!(first_drain.len(), 1);
  554|       |
  555|       |        // Second drain (should be empty)
  556|       |        let second_drain: Vec<_> = events.drain::<TestEvent>().collect();
  557|       |        assert_eq!(second_drain.len(), 0);
  558|       |
  559|       |        // Third drain (should still be empty)
  560|       |        let third_drain: Vec<_> = events.drain::<TestEvent>().collect();
  561|       |        assert_eq!(third_drain.len(), 0);
  562|       |    }
  563|       |
  564|       |    #[test]
  565|       |    fn test_large_event_batch_maintains_order() {
  566|       |        let mut events = Events::new();
  567|       |        const BATCH_SIZE: usize = 10_000;
  568|       |
  569|       |        // Send large batch
  570|       |        for i in 0..BATCH_SIZE {
  571|       |            events.send(TestEvent { value: i as i32 });
  572|       |        }
  573|       |
  574|       |        assert_eq!(events.len::<TestEvent>(), BATCH_SIZE);
  575|       |
  576|       |        // Verify all events in correct order
  577|       |        let collected: Vec<_> = events.read::<TestEvent>().collect();
  578|       |        assert_eq!(collected.len(), BATCH_SIZE);
  579|       |
  580|       |        for (i, event) in collected.iter().enumerate() {
  581|       |            assert_eq!(event.value, i as i32, "Event {} out of order", i);
  582|       |        }
  583|       |    }
  584|       |
  585|       |    #[test]
  586|       |    fn test_clear_all_removes_all_event_types() {
  587|       |        #[derive(Clone, Debug)]
  588|       |        struct EventA {
  589|       |            #[allow(dead_code)]
  590|       |            value: i32,
  591|       |        }
  592|       |        impl Event for EventA {}
  593|       |
  594|       |        #[derive(Clone, Debug)]
  595|       |        struct EventB {
  596|       |            #[allow(dead_code)]
  597|       |            value: i32,
  598|       |        }
  599|       |        impl Event for EventB {}
  600|       |
  601|       |        let mut events = Events::new();
  602|       |
  603|       |        events.send(EventA { value: 1 });
  604|       |        events.send(EventB { value: 2 });
  605|       |
  606|       |        assert_eq!(events.len::<EventA>(), 1);
  607|       |        assert_eq!(events.len::<EventB>(), 1);
  608|       |
  609|       |        // Clear all event types
  610|       |        events.clear_all();
  611|       |
  612|       |        // Both types should be gone
  613|       |        assert_eq!(events.len::<EventA>(), 0);
  614|       |        assert_eq!(events.len::<EventB>(), 0);
  615|       |    }
  616|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\lib.rs:
    1|       |//! AstraWeave ECS — Production-grade, AI-native ECS for game development.
    2|       |//!
    3|       |//! This ECS is designed specifically for AI-first game engines, providing:
    4|       |//! - **Archetype-based storage** for cache-friendly iteration (like Bevy/Flecs)
    5|       |//! - **Deterministic execution** via fixed schedules and ordered iteration
    6|       |//! - **Event system** for AI perception and reactive behaviors
    7|       |//! - **System parameters** for ergonomic system signatures
    8|       |//! - **Plugin architecture** for modular game systems
    9|       |//!
   10|       |//! ## Architecture
   11|       |//!
   12|       |//! The AI-native game loop follows: **Perception → Reasoning → Planning → Action**
   13|       |//!
   14|       |//! ### System Stages:
   15|       |//! 1. **Perception**: Build WorldSnapshots, update AI sensors
   16|       |//! 2. **Simulation**: Game logic, cooldowns, state updates
   17|       |//! 3. **AI Planning**: Generate PlanIntents from AI orchestrators
   18|       |//! 4. **Physics**: Apply forces, resolve collisions
   19|       |//! 5. **Presentation**: Rendering, audio, UI updates
   20|       |//!
   21|       |//! ## Example
   22|       |//!
   23|       |//! ```rust,ignore
   24|       |//! use astraweave_ecs::*;
   25|       |//!
   26|       |//! #[derive(Clone, Copy)]
   27|       |//! struct Position { x: f32, y: f32 }
   28|       |//!
   29|       |//! #[derive(Clone, Copy)]
   30|       |//! struct Velocity { x: f32, y: f32 }
   31|       |//!
   32|       |//! fn movement_system(world: &mut World) {
   33|       |//!     let mut query = QueryMut::<Position>::new(world);
   34|       |//!     for (entity, pos) in query.iter_mut() {
   35|       |//!         if let Some(vel) = world.get::<Velocity>(entity) {
   36|       |//!             pos.x += vel.x;
   37|       |//!             pos.y += vel.y;
   38|       |//!         }
   39|       |//!     }
   40|       |//! }
   41|       |//!
   42|       |//! let mut app = App::new();
   43|       |//! app.add_system("simulation", movement_system);
   44|       |//! app = app.run_fixed(100); // Run 100 ticks
   45|       |//! ```
   46|       |
   47|       |#[cfg(feature = "profiling")]
   48|       |use astraweave_profiling::{plot, span};
   49|       |
   50|       |pub mod archetype;
   51|       |pub mod blob_vec;
   52|       |pub mod command_buffer;
   53|       |pub mod entity_allocator;
   54|       |pub mod events;
   55|       |pub mod rng;
   56|       |pub mod sparse_set;
   57|       |mod system_param;
   58|       |pub mod type_registry;
   59|       |
   60|       |#[cfg(feature = "alloc-counter")]
   61|       |pub mod counting_alloc;
   62|       |
   63|       |#[cfg(test)]
   64|       |mod determinism_tests;
   65|       |
   66|       |#[cfg(test)]
   67|       |mod property_tests;
   68|       |
   69|       |use std::any::TypeId;
   70|       |use std::collections::HashMap;
   71|       |
   72|       |use archetype::{ArchetypeSignature, ArchetypeStorage};
   73|       |pub use command_buffer::CommandBuffer;
   74|       |pub use entity_allocator::{Entity, EntityAllocator};
   75|       |pub use events::{Event, EventReader, Events};
   76|       |pub use rng::Rng;
   77|       |pub use system_param::{Query, Query2, Query2Mut, SystemParam};
   78|       |pub use type_registry::TypeRegistry;
   79|       |
   80|       |pub trait Component: 'static + Send + Sync {}
   81|       |impl<T: 'static + Send + Sync> Component for T {}
   82|       |
   83|       |/// Marker trait for resources (singletons in World)
   84|       |pub trait Resource: 'static + Send + Sync {}
   85|       |impl<T: 'static + Send + Sync> Resource for T {}
   86|       |
   87|       |/// System stage identifiers for the AI-native game loop
   88|       |pub struct SystemStage;
   89|       |
   90|       |impl SystemStage {
   91|       |    pub const PRE_SIMULATION: &'static str = "pre_simulation";
   92|       |    pub const PERCEPTION: &'static str = "perception";
   93|       |    pub const SIMULATION: &'static str = "simulation";
   94|       |    pub const AI_PLANNING: &'static str = "ai_planning";
   95|       |    pub const PHYSICS: &'static str = "physics";
   96|       |    pub const POST_SIMULATION: &'static str = "post_simulation";
   97|       |    pub const PRESENTATION: &'static str = "presentation";
   98|       |}
   99|       |// Entity and EntityAllocator are now exported from entity_allocator module
  100|       |
  101|       |#[derive(Default)]
  102|       |pub struct World {
  103|       |    entity_allocator: EntityAllocator,
  104|       |    archetypes: ArchetypeStorage,
  105|       |    resources: HashMap<TypeId, Box<dyn std::any::Any + Send + Sync>>, // singletons
  106|       |    type_registry: TypeRegistry,
  107|       |}
  108|       |
  109|       |impl World {
  110|      0|    pub fn new() -> Self {
  111|      0|        Self::default()
  112|      0|    }
  113|       |
  114|      0|    pub fn spawn(&mut self) -> Entity {
  115|       |        #[cfg(feature = "profiling")]
  116|       |        span!("ECS::World::spawn");
  117|       |
  118|      0|        let e = self.entity_allocator.spawn();
  119|       |
  120|       |        #[cfg(feature = "profiling")]
  121|       |        plot!(
  122|       |            "ECS::entity_count",
  123|       |            self.entity_allocator.alive_count() as u64
  124|       |        );
  125|       |
  126|       |        // An entity with no components lives in the empty archetype.
  127|      0|        let empty_sig = ArchetypeSignature::new(vec![]);
  128|      0|        let archetype_id = self.archetypes.get_or_create_archetype(empty_sig);
  129|      0|        self.archetypes.set_entity_archetype(e, archetype_id);
  130|      0|        let archetype = self
  131|      0|            .archetypes
  132|      0|            .get_archetype_mut(archetype_id)
  133|      0|            .expect("BUG: archetype should exist after get_or_create_archetype");
  134|      0|        archetype.add_entity(e, HashMap::new());
  135|      0|        e
  136|      0|    }
  137|       |
  138|       |    /// Check if an entity is alive in this world.
  139|       |    ///
  140|       |    /// # Returns
  141|       |    ///
  142|       |    /// - `true` if entity ID and generation match
  143|       |    /// - `false` if entity is dead or never existed
  144|       |    #[inline]
  145|      0|    pub fn is_alive(&self, entity: Entity) -> bool {
  146|      0|        self.entity_allocator.is_alive(entity)
  147|      0|    }
  148|       |
  149|      0|    pub fn insert<T: Component>(&mut self, e: Entity, c: T) {
  150|       |        // Validate entity is alive
  151|      0|        if !self.is_alive(e) {
  152|      0|            return; // Silently ignore stale entities
  153|      0|        }
  154|       |
  155|      0|        let mut components_to_add = HashMap::new();
  156|      0|        components_to_add.insert(
  157|      0|            TypeId::of::<T>(),
  158|      0|            Box::new(c) as Box<dyn std::any::Any + Send + Sync>,
  159|       |        );
  160|      0|        self.move_entity_to_new_archetype(e, components_to_add, false);
  161|      0|    }
  162|       |
  163|      0|    fn move_entity_to_new_archetype(
  164|      0|        &mut self,
  165|      0|        entity: Entity,
  166|      0|        new_components: HashMap<TypeId, Box<dyn std::any::Any + Send + Sync>>,
  167|      0|        is_removing: bool,
  168|      0|    ) {
  169|       |        // 1. Get current archetype and component data
  170|      0|        let old_archetype_id = self
  171|      0|            .archetypes
  172|      0|            .get_entity_archetype(entity)
  173|      0|            .expect("BUG: entity should have archetype");
  174|       |
  175|      0|        let mut current_components = {
  176|      0|            let old_archetype = self
  177|      0|                .archetypes
  178|      0|                .get_archetype_mut(old_archetype_id)
  179|      0|                .expect("BUG: archetype should exist for entity");
  180|      0|            old_archetype.remove_entity_components(entity)
  181|       |        };
  182|       |
  183|       |        // 2. Determine new signature
  184|      0|        let new_sig_types = {
  185|      0|            let old_archetype = self
  186|      0|                .archetypes
  187|      0|                .get_archetype(old_archetype_id)
  188|      0|                .expect("BUG: archetype should exist");
  189|      0|            let mut sig_types: Vec<_> = old_archetype.signature.components.clone();
  190|      0|            if is_removing {
  191|       |                // For removal, the `new_components` map just contains the TypeId of the component to remove.
  192|      0|                let type_to_remove = new_components
  193|      0|                    .keys()
  194|      0|                    .next()
  195|      0|                    .expect("BUG: remove should have at least one component type");
  196|      0|                sig_types.retain(|&tid| tid != *type_to_remove);
  197|      0|            } else {
  198|      0|                sig_types.extend(new_components.keys());
  199|      0|            }
  200|      0|            sig_types
  201|       |        };
  202|       |
  203|      0|        let new_signature = ArchetypeSignature::new(new_sig_types);
  204|       |
  205|       |        // 3. Get or create new archetype
  206|      0|        let new_archetype_id = self.archetypes.get_or_create_archetype(new_signature);
  207|       |
  208|       |        // 4. Move entity's archetype mapping
  209|      0|        self.archetypes
  210|      0|            .get_archetype_mut(old_archetype_id)
  211|      0|            .expect("BUG: old archetype should exist")
  212|      0|            .remove_entity(entity);
  213|      0|        self.archetypes
  214|      0|            .set_entity_archetype(entity, new_archetype_id);
  215|       |
  216|       |        // 5. Add entity with all components to new archetype
  217|      0|        let final_components = if is_removing {
  218|      0|            let type_to_remove = new_components
  219|      0|                .keys()
  220|      0|                .next()
  221|      0|                .expect("BUG: remove should have at least one component type");
  222|      0|            current_components.remove(type_to_remove);
  223|      0|            current_components
  224|       |        } else {
  225|      0|            current_components.extend(new_components);
  226|      0|            current_components
  227|       |        };
  228|       |
  229|      0|        let new_archetype = self
  230|      0|            .archetypes
  231|      0|            .get_archetype_mut(new_archetype_id)
  232|      0|            .expect("BUG: archetype should exist after get_or_create_archetype");
  233|      0|        new_archetype.add_entity(entity, final_components);
  234|      0|    }
  235|       |
  236|      0|    pub fn get<T: Component>(&self, e: Entity) -> Option<&T> {
  237|       |        #[cfg(feature = "profiling")]
  238|       |        span!("ECS::World::get");
  239|       |
  240|       |        // Validate entity is alive
  241|      0|        if !self.is_alive(e) {
  242|      0|            return None;
  243|      0|        }
  244|       |
  245|      0|        let archetype_id = self.archetypes.get_entity_archetype(e)?;
  246|      0|        let archetype = self.archetypes.get_archetype(archetype_id)?;
  247|      0|        archetype.get::<T>(e)
  248|      0|    }
  249|       |
  250|      0|    pub fn get_mut<T: Component>(&mut self, e: Entity) -> Option<&mut T> {
  251|       |        // Validate entity is alive
  252|      0|        if !self.is_alive(e) {
  253|      0|            return None;
  254|      0|        }
  255|       |
  256|      0|        let archetype_id = self.archetypes.get_entity_archetype(e)?;
  257|      0|        let archetype = self.archetypes.get_archetype_mut(archetype_id)?;
  258|      0|        archetype.get_mut::<T>(e)
  259|      0|    }
  260|       |
  261|      0|    pub fn insert_resource<T: 'static + Send + Sync>(&mut self, r: T) {
  262|      0|        self.resources.insert(TypeId::of::<T>(), Box::new(r));
  263|      0|    }
  264|       |
  265|      0|    pub fn get_resource<T: 'static + Send + Sync>(&self) -> Option<&T> {
  266|      0|        self.resources.get(&TypeId::of::<T>())?.downcast_ref()
  267|      0|    }
  268|       |
  269|      0|    pub fn get_resource_mut<T: 'static + Send + Sync>(&mut self) -> Option<&mut T> {
  270|      0|        self.resources.get_mut(&TypeId::of::<T>())?.downcast_mut()
  271|      0|    }
  272|       |
  273|      0|    pub fn each_mut<T: Component>(&mut self, mut f: impl FnMut(Entity, &mut T)) {
  274|      0|        let archetypes_with_t = self
  275|      0|            .archetypes
  276|      0|            .archetypes_with_component(TypeId::of::<T>())
  277|      0|            .map(|a| a.id)
  278|      0|            .collect::<Vec<_>>();
  279|       |
  280|      0|        for archetype_id in archetypes_with_t {
  281|      0|            let archetype = self
  282|      0|                .archetypes
  283|      0|                .get_archetype_mut(archetype_id)
  284|      0|                .expect("BUG: archetype should exist from archetypes_with_component");
  285|       |            // NEW: entities_vec() now returns &[Entity] (zero-cost!)
  286|      0|            let entities: Vec<Entity> = archetype.entities_vec().to_vec();
  287|      0|            for entity in entities {
  288|      0|                if let Some(component) = archetype.get_mut::<T>(entity) {
  289|      0|                    f(entity, component);
  290|      0|                }
  291|       |            }
  292|       |        }
  293|      0|    }
  294|       |
  295|      0|    pub fn count<T: Component>(&self) -> usize {
  296|      0|        self.archetypes
  297|      0|            .archetypes_with_component(TypeId::of::<T>())
  298|      0|            .map(|archetype| archetype.len())
  299|      0|            .sum()
  300|      0|    }
  301|       |
  302|      0|    pub fn has<T: Component>(&self, entity: Entity) -> bool {
  303|       |        // Validate entity is alive before checking components
  304|      0|        if !self.is_alive(entity) {
  305|      0|            return false;
  306|      0|        }
  307|      0|        self.get::<T>(entity).is_some()
  308|      0|    }
  309|       |
  310|      0|    pub fn entities_with<T: Component>(&self) -> Vec<Entity> {
  311|      0|        self.archetypes
  312|      0|            .archetypes_with_component(TypeId::of::<T>())
  313|      0|            .flat_map(|archetype| archetype.entities_vec().iter().copied())
  314|      0|            .collect()
  315|      0|    }
  316|       |
  317|      0|    pub fn remove<T: Component>(&mut self, e: Entity) -> bool {
  318|       |        // Validate entity is alive
  319|      0|        if !self.is_alive(e) {
  320|      0|            return false;
  321|      0|        }
  322|       |
  323|      0|        if !self.has::<T>(e) {
  324|      0|            return false;
  325|      0|        }
  326|      0|        let mut components_to_remove = HashMap::new();
  327|       |        // We just need the type id for the signature change. The value is irrelevant.
  328|      0|        components_to_remove.insert(
  329|      0|            TypeId::of::<T>(),
  330|      0|            Box::new(0) as Box<dyn std::any::Any + Send + Sync>,
  331|       |        );
  332|      0|        self.move_entity_to_new_archetype(e, components_to_remove, true);
  333|      0|        true
  334|      0|    }
  335|       |
  336|       |    /// Despawn an entity, removing it from the world.
  337|       |    ///
  338|       |    /// # Returns
  339|       |    ///
  340|       |    /// - `true` if entity was alive and despawned
  341|       |    /// - `false` if entity was already dead (stale handle)
  342|       |    ///
  343|       |    /// # Example
  344|       |    ///
  345|       |    /// ```
  346|       |    /// use astraweave_ecs::*;
  347|       |    ///
  348|       |    /// let mut world = World::new();
  349|       |    /// let e = world.spawn();
  350|       |    ///
  351|       |    /// assert!(world.despawn(e));  // First despawn succeeds
  352|       |    /// assert!(!world.despawn(e)); // Second despawn fails (stale)
  353|       |    /// ```
  354|      0|    pub fn despawn(&mut self, entity: Entity) -> bool {
  355|       |        // First validate entity is alive
  356|      0|        if !self.entity_allocator.is_alive(entity) {
  357|      0|            return false;
  358|      0|        }
  359|       |
  360|       |        // Remove from archetype (removes entity AND all components)
  361|      0|        if let Some(archetype_id) = self.archetypes.get_entity_archetype(entity) {
  362|      0|            let archetype = self
  363|      0|                .archetypes
  364|      0|                .get_archetype_mut(archetype_id)
  365|      0|                .expect("BUG: archetype should exist for entity");
  366|      0|            // Use remove_entity_components to properly clean up packed storage
  367|      0|            archetype.remove_entity_components(entity);
  368|      0|            self.archetypes.remove_entity(entity);
  369|      0|        }
  370|       |
  371|       |        // Despawn from allocator (increments generation)
  372|      0|        self.entity_allocator.despawn(entity)
  373|      0|    }
  374|       |
  375|       |    /// Get the number of entities currently alive.
  376|      0|    pub fn entity_count(&self) -> usize {
  377|      0|        self.entity_allocator.alive_count()
  378|      0|    }
  379|       |
  380|       |    /// Get read-only access to the archetype storage.
  381|       |    ///
  382|       |    /// # Use Cases
  383|       |    ///
  384|       |    /// - Iterating all entities across all archetypes
  385|       |    /// - Querying archetype metadata (signatures, counts)
  386|       |    /// - Testing determinism properties
  387|       |    ///
  388|       |    /// # Example
  389|       |    ///
  390|       |    /// ```rust,ignore
  391|       |    /// for archetype in world.archetypes().iter() {
  392|       |    ///     for &entity in archetype.entities_vec() {
  393|       |    ///         // Process entity
  394|       |    ///     }
  395|       |    /// }
  396|       |    /// ```
  397|      0|    pub fn archetypes(&self) -> &ArchetypeStorage {
  398|      0|        &self.archetypes
  399|      0|    }
  400|       |}
  401|       |
  402|       |// Schedule and systems
  403|       |pub type SystemFn = fn(&mut World);
  404|       |
  405|       |#[derive(Default)]
  406|       |pub struct Schedule {
  407|       |    pub stages: Vec<Stage>,
  408|       |}
  409|       |
  410|       |pub struct Stage {
  411|       |    pub name: &'static str,
  412|       |    pub systems: Vec<SystemFn>,
  413|       |}
  414|       |
  415|       |impl Schedule {
  416|      0|    pub fn with_stage(mut self, name: &'static str) -> Self {
  417|      0|        self.stages.push(Stage {
  418|      0|            name,
  419|      0|            systems: vec![],
  420|      0|        });
  421|      0|        self
  422|      0|    }
  423|      0|    pub fn add_system(&mut self, stage: &'static str, sys: SystemFn) {
  424|      0|        if let Some(s) = self.stages.iter_mut().find(|s| s.name == stage) {
  425|      0|            s.systems.push(sys);
  426|      0|        }
  427|      0|    }
  428|      0|    pub fn run(&self, world: &mut World) {
  429|       |        #[cfg(feature = "profiling")]
  430|       |        span!("ECS::Schedule::run");
  431|       |
  432|      0|        for s in &self.stages {
  433|      0|            for f in &s.systems {
  434|      0|                (f)(world);
  435|      0|            }
  436|       |        }
  437|      0|    }
  438|       |}
  439|       |
  440|       |// App-like builder with deterministic fixed-timestep driver
  441|       |pub struct App {
  442|       |    pub world: World,
  443|       |    pub schedule: Schedule,
  444|       |}
  445|       |
  446|       |impl Default for App {
  447|      0|    fn default() -> Self {
  448|      0|        Self::new()
  449|      0|    }
  450|       |}
  451|       |
  452|       |impl App {
  453|      0|    pub fn new() -> Self {
  454|      0|        let mut schedule = Schedule::default();
  455|      0|        schedule = schedule
  456|      0|            .with_stage("perception")
  457|      0|            .with_stage("simulation")
  458|      0|            .with_stage("ai_planning")
  459|      0|            .with_stage("physics")
  460|      0|            .with_stage("presentation");
  461|      0|        Self {
  462|      0|            world: World::new(),
  463|      0|            schedule,
  464|      0|        }
  465|      0|    }
  466|       |
  467|      0|    pub fn add_system(&mut self, stage: &'static str, sys: SystemFn) {
  468|      0|        self.schedule.add_system(stage, sys);
  469|      0|    }
  470|      0|    pub fn insert_resource<T: 'static + Send + Sync>(mut self, r: T) -> Self {
  471|      0|        self.world.insert_resource(r);
  472|      0|        self
  473|      0|    }
  474|      0|    pub fn run_fixed(mut self, steps: u32) -> Self {
  475|      0|        for _ in 0..steps {
  476|      0|            self.schedule.run(&mut self.world);
  477|      0|        }
  478|      0|        self
  479|      0|    }
  480|       |}
  481|       |
  482|       |impl World {
  483|       |    /// Register a component type for type-erased operations (used by CommandBuffer).
  484|       |    ///
  485|       |    /// This must be called for any component type that will be used with CommandBuffer.
  486|       |    ///
  487|       |    /// # Example
  488|       |    /// ```
  489|       |    /// # use astraweave_ecs::World;
  490|       |    /// # #[derive(Clone, Copy)]
  491|       |    /// # struct Position { x: f32, y: f32 }
  492|       |    /// let mut world = World::new();
  493|       |    /// world.register_component::<Position>();
  494|       |    /// ```
  495|      0|    pub fn register_component<T: Component>(&mut self) {
  496|      0|        self.type_registry.register::<T>();
  497|      0|    }
  498|       |
  499|       |    /// Insert a type-erased component (used by CommandBuffer).
  500|       |    ///
  501|       |    /// # Panics
  502|       |    /// Panics if the component type is not registered via `register_component<T>()`.
  503|      0|    pub(crate) fn insert_boxed(
  504|      0|        &mut self,
  505|      0|        entity: Entity,
  506|      0|        type_id: TypeId,
  507|      0|        component: Box<dyn std::any::Any + Send + Sync>,
  508|      0|    ) {
  509|      0|        if !self.is_alive(entity) {
  510|      0|            return; // Stale entity, silently ignore
  511|      0|        }
  512|       |
  513|      0|        let handler = self
  514|      0|            .type_registry
  515|      0|            .insert_handlers
  516|      0|            .get(&type_id)
  517|      0|            .cloned()
  518|      0|            .unwrap_or_else(|| {
  519|      0|                panic!(
  520|      0|                    "insert_boxed: type {:?} not registered (call register_component::<T>() first)",
  521|       |                    type_id
  522|       |                )
  523|       |            });
  524|       |
  525|      0|        handler(self, entity, component);
  526|      0|    }
  527|       |
  528|       |    /// Remove a component by TypeId (used by CommandBuffer).
  529|       |    ///
  530|       |    /// # Panics
  531|       |    /// Panics if the component type is not registered via `register_component<T>()`.
  532|      0|    pub(crate) fn remove_by_type_id(&mut self, entity: Entity, type_id: TypeId) {
  533|      0|        if !self.is_alive(entity) {
  534|      0|            return; // Stale entity, silently ignore
  535|      0|        }
  536|       |
  537|      0|        let handler = self
  538|      0|            .type_registry
  539|      0|            .remove_handlers
  540|      0|            .get(&type_id)
  541|      0|            .cloned()
  542|      0|            .unwrap_or_else(|| {
  543|      0|                panic!(
  544|      0|                    "remove_by_type_id: type {:?} not registered (call register_component::<T>() first)",
  545|       |                    type_id
  546|       |                )
  547|       |            });
  548|       |
  549|      0|        handler(self, entity);
  550|      0|    }
  551|       |}
  552|       |
  553|       |// Plugin pattern similar to Bevy
  554|       |pub trait Plugin {
  555|       |    fn build(&self, app: &mut App);
  556|       |}
  557|       |impl App {
  558|      0|    pub fn add_plugin(mut self, p: impl Plugin) -> Self {
  559|      0|        p.build(&mut self);
  560|      0|        self
  561|      0|    }
  562|       |}
  563|       |
  564|       |// SECTION: System Execution
  565|       |
  566|       |#[cfg(test)]
  567|       |mod tests {
  568|       |    use super::*;
  569|       |
  570|       |    #[derive(Clone, Copy, Debug, PartialEq)]
  571|       |    struct Position {
  572|       |        x: f32,
  573|       |        y: f32,
  574|       |    }
  575|       |
  576|       |    #[derive(Clone, Copy, Debug, PartialEq)]
  577|       |    struct Velocity {
  578|       |        vx: f32,
  579|       |        vy: f32,
  580|       |    }
  581|       |
  582|       |    #[derive(Debug, PartialEq)]
  583|       |    struct TestResource(i32);
  584|       |
  585|       |    #[test]
  586|       |    fn test_spawn_and_insert() {
  587|       |        let mut world = World::new();
  588|       |        let entity = world.spawn();
  589|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  590|       |
  591|       |        assert!(world.has::<Position>(entity));
  592|       |        assert!(!world.has::<Velocity>(entity));
  593|       |
  594|       |        let pos = world.get::<Position>(entity).unwrap();
  595|       |        assert_eq!(*pos, Position { x: 1.0, y: 2.0 });
  596|       |    }
  597|       |
  598|       |    #[test]
  599|       |    fn test_despawn() {
  600|       |        let mut world = World::new();
  601|       |        let entity = world.spawn();
  602|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  603|       |
  604|       |        assert!(world.is_alive(entity));
  605|       |        world.despawn(entity);
  606|       |        assert!(!world.is_alive(entity));
  607|       |        assert!(!world.has::<Position>(entity));
  608|       |    }
  609|       |
  610|       |    #[test]
  611|       |    fn test_remove_component() {
  612|       |        let mut world = World::new();
  613|       |        let entity = world.spawn();
  614|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  615|       |        world.insert(entity, Velocity { vx: 0.0, vy: 0.0 });
  616|       |
  617|       |        assert!(world.has::<Position>(entity));
  618|       |        world.remove::<Position>(entity);
  619|       |        assert!(!world.has::<Position>(entity));
  620|       |        assert!(world.has::<Velocity>(entity)); // Other components should remain
  621|       |    }
  622|       |
  623|       |    #[test]
  624|       |    fn test_query_single_component() {
  625|       |        let mut world = World::new();
  626|       |        let e1 = world.spawn();
  627|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  628|       |        let e2 = world.spawn();
  629|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  630|       |        let e3 = world.spawn();
  631|       |        world.insert(e3, Velocity { vx: 0.0, vy: 0.0 });
  632|       |
  633|       |        let query = Query::<Position>::new(&world);
  634|       |        let mut count = 0;
  635|       |        let mut total_x = 0.0;
  636|       |        for (entity, pos) in query {
  637|       |            count += 1;
  638|       |            total_x += pos.x;
  639|       |            assert!(entity == e1 || entity == e2);
  640|       |        }
  641|       |        assert_eq!(count, 2);
  642|       |        assert_eq!(total_x, 3.0);
  643|       |    }
  644|       |
  645|       |    #[test]
  646|       |    fn test_query_two_components() {
  647|       |        let mut world = World::new();
  648|       |        let e1 = world.spawn();
  649|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  650|       |        world.insert(e1, Velocity { vx: 1.0, vy: 1.0 });
  651|       |
  652|       |        let e2 = world.spawn();
  653|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  654|       |
  655|       |        let e3 = world.spawn();
  656|       |        world.insert(e3, Position { x: 3.0, y: 3.0 });
  657|       |        world.insert(e3, Velocity { vx: 3.0, vy: 3.0 });
  658|       |
  659|       |        let query = Query2::<Position, Velocity>::new(&world);
  660|       |        let mut count = 0;
  661|       |        for (entity, pos, vel) in query {
  662|       |            count += 1;
  663|       |            assert!(entity == e1 || entity == e3);
  664|       |            assert_eq!(pos.x, vel.vx);
  665|       |        }
  666|       |        assert_eq!(count, 2);
  667|       |    }
  668|       |
  669|       |    #[test]
  670|       |    fn test_resource_management() {
  671|       |        let mut world = World::new();
  672|       |        world.insert_resource(TestResource(42));
  673|       |
  674|       |        let resource = world.get_resource::<TestResource>().unwrap();
  675|       |        assert_eq!(resource.0, 42);
  676|       |
  677|       |        let resource_mut = world.get_resource_mut::<TestResource>().unwrap();
  678|       |        resource_mut.0 = 100;
  679|       |
  680|       |        let resource_after = world.get_resource::<TestResource>().unwrap();
  681|       |        assert_eq!(resource_after.0, 100);
  682|       |    }
  683|       |
  684|       |    #[test]
  685|       |    fn test_get_mut() {
  686|       |        let mut world = World::new();
  687|       |        let entity = world.spawn();
  688|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  689|       |
  690|       |        let pos_mut = world.get_mut::<Position>(entity).unwrap();
  691|       |        pos_mut.x = 5.0;
  692|       |
  693|       |        let pos = world.get::<Position>(entity).unwrap();
  694|       |        assert_eq!(pos.x, 5.0);
  695|       |    }
  696|       |
  697|       |    // ====================
  698|       |    // Day 2: World Advanced API Tests
  699|       |    // ====================
  700|       |
  701|       |    #[test]
  702|       |    fn test_count_single_component() {
  703|       |        let mut world = World::new();
  704|       |
  705|       |        assert_eq!(world.count::<Position>(), 0);
  706|       |
  707|       |        let e1 = world.spawn();
  708|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  709|       |        assert_eq!(world.count::<Position>(), 1);
  710|       |
  711|       |        let e2 = world.spawn();
  712|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  713|       |        assert_eq!(world.count::<Position>(), 2);
  714|       |
  715|       |        let _e3 = world.spawn();
  716|       |        world.insert(_e3, Velocity { vx: 1.0, vy: 1.0 });
  717|       |        assert_eq!(world.count::<Position>(), 2);
  718|       |        assert_eq!(world.count::<Velocity>(), 1);
  719|       |    }
  720|       |
  721|       |    #[test]
  722|       |    fn test_count_across_archetypes() {
  723|       |        let mut world = World::new();
  724|       |
  725|       |        // Archetype 1: Position only
  726|       |        let e1 = world.spawn();
  727|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  728|       |
  729|       |        // Archetype 2: Position + Velocity
  730|       |        let e2 = world.spawn();
  731|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  732|       |        world.insert(e2, Velocity { vx: 1.0, vy: 1.0 });
  733|       |
  734|       |        // Should count both
  735|       |        assert_eq!(world.count::<Position>(), 2);
  736|       |        assert_eq!(world.count::<Velocity>(), 1);
  737|       |    }
  738|       |
  739|       |    #[test]
  740|       |    fn test_entities_with_single_component() {
  741|       |        let mut world = World::new();
  742|       |
  743|       |        let e1 = world.spawn();
  744|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  745|       |
  746|       |        let e2 = world.spawn();
  747|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  748|       |
  749|       |        let _e3 = world.spawn();
  750|       |        world.insert(_e3, Velocity { vx: 1.0, vy: 1.0 });
  751|       |
  752|       |        let entities = world.entities_with::<Position>();
  753|       |        assert_eq!(entities.len(), 2);
  754|       |        assert!(entities.contains(&e1));
  755|       |        assert!(entities.contains(&e2));
  756|       |    }
  757|       |
  758|       |    #[test]
  759|       |    fn test_entities_with_empty_result() {
  760|       |        let world = World::new();
  761|       |        let entities = world.entities_with::<Position>();
  762|       |        assert_eq!(entities.len(), 0);
  763|       |    }
  764|       |
  765|       |    #[test]
  766|       |    fn test_entities_with_across_archetypes() {
  767|       |        let mut world = World::new();
  768|       |
  769|       |        let e1 = world.spawn();
  770|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  771|       |
  772|       |        let e2 = world.spawn();
  773|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  774|       |        world.insert(e2, Velocity { vx: 1.0, vy: 1.0 });
  775|       |
  776|       |        let entities = world.entities_with::<Position>();
  777|       |        assert_eq!(entities.len(), 2);
  778|       |        assert!(entities.contains(&e1));
  779|       |        assert!(entities.contains(&e2));
  780|       |    }
  781|       |
  782|       |    #[test]
  783|       |    fn test_each_mut_modify_components() {
  784|       |        let mut world = World::new();
  785|       |
  786|       |        let e1 = world.spawn();
  787|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  788|       |
  789|       |        let e2 = world.spawn();
  790|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  791|       |
  792|       |        world.each_mut::<Position>(|_e, pos| {
  793|       |            pos.x += 10.0;
  794|       |        });
  795|       |
  796|       |        assert_eq!(world.get::<Position>(e1).unwrap().x, 11.0);
  797|       |        assert_eq!(world.get::<Position>(e2).unwrap().x, 12.0);
  798|       |    }
  799|       |
  800|       |    #[test]
  801|       |    fn test_each_mut_with_entity_access() {
  802|       |        let mut world = World::new();
  803|       |
  804|       |        let e1 = world.spawn();
  805|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  806|       |
  807|       |        let e2 = world.spawn();
  808|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  809|       |
  810|       |        let mut visited = Vec::new();
  811|       |        world.each_mut::<Position>(|entity, _pos| {
  812|       |            visited.push(entity);
  813|       |        });
  814|       |
  815|       |        assert_eq!(visited.len(), 2);
  816|       |        assert!(visited.contains(&e1));
  817|       |        assert!(visited.contains(&e2));
  818|       |    }
  819|       |
  820|       |    #[test]
  821|       |    fn test_entity_count() {
  822|       |        let mut world = World::new();
  823|       |
  824|       |        assert_eq!(world.entity_count(), 0);
  825|       |
  826|       |        let e1 = world.spawn();
  827|       |        assert_eq!(world.entity_count(), 1);
  828|       |
  829|       |        let _e2 = world.spawn();
  830|       |        assert_eq!(world.entity_count(), 2);
  831|       |
  832|       |        world.despawn(e1);
  833|       |        assert_eq!(world.entity_count(), 1);
  834|       |    }
  835|       |
  836|       |    // ====================
  837|       |    // Day 2: Stale Entity Handling Tests
  838|       |    // ====================
  839|       |
  840|       |    #[test]
  841|       |    fn test_insert_on_stale_entity_ignored() {
  842|       |        let mut world = World::new();
  843|       |        let entity = world.spawn();
  844|       |        world.despawn(entity);
  845|       |
  846|       |        // Insert on stale entity should be ignored silently
  847|       |        world.insert(entity, Position { x: 1.0, y: 1.0 });
  848|       |
  849|       |        assert!(!world.has::<Position>(entity));
  850|       |        assert_eq!(world.count::<Position>(), 0);
  851|       |    }
  852|       |
  853|       |    #[test]
  854|       |    fn test_get_on_stale_entity_returns_none() {
  855|       |        let mut world = World::new();
  856|       |        let entity = world.spawn();
  857|       |        world.insert(entity, Position { x: 1.0, y: 1.0 });
  858|       |        world.despawn(entity);
  859|       |
  860|       |        assert!(world.get::<Position>(entity).is_none());
  861|       |    }
  862|       |
  863|       |    #[test]
  864|       |    fn test_get_mut_on_stale_entity_returns_none() {
  865|       |        let mut world = World::new();
  866|       |        let entity = world.spawn();
  867|       |        world.insert(entity, Position { x: 1.0, y: 1.0 });
  868|       |        world.despawn(entity);
  869|       |
  870|       |        assert!(world.get_mut::<Position>(entity).is_none());
  871|       |    }
  872|       |
  873|       |    #[test]
  874|       |    fn test_has_on_stale_entity_returns_false() {
  875|       |        let mut world = World::new();
  876|       |        let entity = world.spawn();
  877|       |        world.insert(entity, Position { x: 1.0, y: 1.0 });
  878|       |        world.despawn(entity);
  879|       |
  880|       |        assert!(!world.has::<Position>(entity));
  881|       |    }
  882|       |
  883|       |    #[test]
  884|       |    fn test_remove_on_stale_entity_returns_false() {
  885|       |        let mut world = World::new();
  886|       |        let entity = world.spawn();
  887|       |        world.insert(entity, Position { x: 1.0, y: 1.0 });
  888|       |        world.despawn(entity);
  889|       |
  890|       |        assert!(!world.remove::<Position>(entity));
  891|       |    }
  892|       |
  893|       |    #[test]
  894|       |    fn test_despawn_stale_entity_returns_false() {
  895|       |        let mut world = World::new();
  896|       |        let entity = world.spawn();
  897|       |
  898|       |        assert!(world.despawn(entity));
  899|       |        assert!(!world.despawn(entity)); // Second despawn should return false
  900|       |    }
  901|       |
  902|       |    #[test]
  903|       |    fn test_remove_nonexistent_component_returns_false() {
  904|       |        let mut world = World::new();
  905|       |        let entity = world.spawn();
  906|       |        world.insert(entity, Position { x: 1.0, y: 1.0 });
  907|       |
  908|       |        // Removing component that doesn't exist
  909|       |        assert!(!world.remove::<Velocity>(entity));
  910|       |    }
  911|       |
  912|       |    // ====================
  913|       |    // Day 2: Resource Edge Cases
  914|       |    // ====================
  915|       |
  916|       |    #[test]
  917|       |    fn test_resource_get_nonexistent_returns_none() {
  918|       |        let world = World::new();
  919|       |        assert!(world.get_resource::<TestResource>().is_none());
  920|       |    }
  921|       |
  922|       |    #[test]
  923|       |    fn test_resource_get_mut_nonexistent_returns_none() {
  924|       |        let mut world = World::new();
  925|       |        assert!(world.get_resource_mut::<TestResource>().is_none());
  926|       |    }
  927|       |
  928|       |    #[test]
  929|       |    fn test_resource_replace() {
  930|       |        let mut world = World::new();
  931|       |        world.insert_resource(TestResource(10));
  932|       |
  933|       |        world.insert_resource(TestResource(20));
  934|       |
  935|       |        let resource = world.get_resource::<TestResource>().unwrap();
  936|       |        assert_eq!(resource.0, 20);
  937|       |    }
  938|       |
  939|       |    // ====================
  940|       |    // Day 2: App/Schedule API Tests
  941|       |    // ====================
  942|       |
  943|       |    #[test]
  944|       |    fn test_app_creation() {
  945|       |        let app = App::new();
  946|       |        assert_eq!(app.world.entity_count(), 0);
  947|       |        assert_eq!(app.schedule.stages.len(), 5);
  948|       |    }
  949|       |
  950|       |    #[test]
  951|       |    fn test_app_insert_resource() {
  952|       |        let app = App::new().insert_resource(TestResource(42));
  953|       |
  954|       |        let resource = app.world.get_resource::<TestResource>().unwrap();
  955|       |        assert_eq!(resource.0, 42);
  956|       |    }
  957|       |
  958|       |    #[test]
  959|       |    fn test_schedule_execution() {
  960|       |        fn test_system(world: &mut World) {
  961|       |            world.insert_resource(TestResource(99));
  962|       |        }
  963|       |
  964|       |        let mut app = App::new();
  965|       |        app.add_system("simulation", test_system);
  966|       |        app = app.run_fixed(1);
  967|       |
  968|       |        let resource = app.world.get_resource::<TestResource>().unwrap();
  969|       |        assert_eq!(resource.0, 99);
  970|       |    }
  971|       |
  972|       |    #[test]
  973|       |    fn test_schedule_multiple_systems() {
  974|       |        fn system_a(world: &mut World) {
  975|       |            world.insert_resource(TestResource(10));
  976|       |        }
  977|       |
  978|       |        fn system_b(world: &mut World) {
  979|       |            if let Some(resource) = world.get_resource_mut::<TestResource>() {
  980|       |                resource.0 += 5;
  981|       |            }
  982|       |        }
  983|       |
  984|       |        let mut app = App::new();
  985|       |        app.add_system("simulation", system_a);
  986|       |        app.add_system("simulation", system_b);
  987|       |        app = app.run_fixed(1);
  988|       |
  989|       |        let resource = app.world.get_resource::<TestResource>().unwrap();
  990|       |        assert_eq!(resource.0, 15);
  991|       |    }
  992|       |
  993|       |    #[test]
  994|       |    fn test_run_fixed_multiple_steps() {
  995|       |        fn increment_system(world: &mut World) {
  996|       |            if let Some(resource) = world.get_resource_mut::<TestResource>() {
  997|       |                resource.0 += 1;
  998|       |            } else {
  999|       |                world.insert_resource(TestResource(1));
 1000|       |            }
 1001|       |        }
 1002|       |
 1003|       |        let mut app = App::new();
 1004|       |        app.add_system("simulation", increment_system);
 1005|       |        app = app.run_fixed(10);
 1006|       |
 1007|       |        let resource = app.world.get_resource::<TestResource>().unwrap();
 1008|       |        assert_eq!(resource.0, 10);
 1009|       |    }
 1010|       |
 1011|       |    // ====================
 1012|       |    // Day 2: Archetype Access Tests
 1013|       |    // ====================
 1014|       |
 1015|       |    #[test]
 1016|       |    fn test_archetypes_read_access() {
 1017|       |        let mut world = World::new();
 1018|       |
 1019|       |        let e1 = world.spawn();
 1020|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
 1021|       |
 1022|       |        let archetypes = world.archetypes();
 1023|       |        let archetype_count = archetypes.iter().count();
 1024|       |
 1025|       |        // Should have at least 2 archetypes: empty and Position-only
 1026|       |        assert!(archetype_count >= 2);
 1027|       |    }
 1028|       |
 1029|       |    #[test]
 1030|       |    fn test_spawn_creates_empty_archetype_entity() {
 1031|       |        let mut world = World::new();
 1032|       |        let entity = world.spawn();
 1033|       |
 1034|       |        // Entity should exist in empty archetype
 1035|       |        assert!(world.is_alive(entity));
 1036|       |        assert_eq!(world.entity_count(), 1);
 1037|       |    }
 1038|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\rng.rs:
    1|       |//! Deterministic RNG for reproducible AI behavior.
    2|       |//!
    3|       |//! # Overview
    4|       |//!
    5|       |//! This module provides a **deterministic random number generator** that ensures
    6|       |//! AI agents make reproducible decisions across runs, platforms, and network clients.
    7|       |//!
    8|       |//! # Why Determinism Matters for AI
    9|       |//!
   10|       |//! **Problem**: AI systems often use randomness for decision-making:
   11|       |//! - Combat: Damage rolls, critical hits, dodge chances
   12|       |//! - Pathfinding: Breaking ties between equal-cost paths
   13|       |//! - Behavior: Randomized animations, idle behaviors
   14|       |//! - PCG: Procedurally generated content
   15|       |//!
   16|       |//! **Without determinism**:
   17|       |//! ```rust,ignore
   18|       |//! // Run 1: AI rolls 42 damage → kills enemy
   19|       |//! // Run 2: AI rolls 15 damage → enemy survives
   20|       |//! // SAME world state, DIFFERENT outcome! 💥
   21|       |//! ```
   22|       |//!
   23|       |//! **With determinism**:
   24|       |//! ```rust,ignore
   25|       |//! // Both runs: AI rolls 42 damage → kills enemy
   26|       |//! // SAME world state → SAME outcome ✅
   27|       |//! ```
   28|       |//!
   29|       |//! # Design Principles
   30|       |//!
   31|       |//! 1. **Fixed Seed Initialization**: Set seed once at world creation
   32|       |//! 2. **ChaCha8Rng**: Cryptographically secure, fast, platform-independent
   33|       |//! 3. **Resource Pattern**: Stored in World as singleton (like any ECS resource)
   34|       |//! 4. **Serializable**: Save/load RNG state for replay systems
   35|       |//!
   36|       |//! # Usage
   37|       |//!
   38|       |//! ```rust,ignore
   39|       |//! use astraweave_ecs::{World, Rng};
   40|       |//!
   41|       |//! // Initialize with fixed seed
   42|       |//! let mut world = World::new();
   43|       |//! world.insert_resource(Rng::from_seed(12345));
   44|       |//!
   45|       |//! // Use in AI systems
   46|       |//! fn combat_system(world: &mut World) {
   47|       |//!     let mut rng = world.get_resource_mut::<Rng>().unwrap();
   48|       |//!     let damage = rng.gen_range(10..20);  // Deterministic roll!
   49|       |//! }
   50|       |//! ```
   51|       |//!
   52|       |//! # Cross-Platform Guarantees
   53|       |//!
   54|       |//! ChaCha8Rng guarantees **identical sequences** on:
   55|       |//! - Windows, Linux, macOS
   56|       |//! - x86_64, ARM64, WASM
   57|       |//! - Different compiler versions
   58|       |//! - Release vs debug builds
   59|       |//!
   60|       |//! **This is critical for networked multiplayer** (lockstep simulation).
   61|       |
   62|       |use rand::distr::uniform::{SampleRange, SampleUniform};
   63|       |use rand::prelude::IndexedRandom;
   64|       |use rand::rngs::StdRng;
   65|       |use rand::{Rng as RngTrait, RngCore, SeedableRng};
   66|       |use serde::{Deserialize, Serialize};
   67|       |
   68|       |/// Deterministic random number generator for AI systems.
   69|       |///
   70|       |/// # Implementation
   71|       |///
   72|       |/// Uses `StdRng` (ChaCha12 in rand 0.9) for:
   73|       |/// - **Platform independence**: Same seed → same sequence on all platforms
   74|       |/// - **Performance**: ~3 GB/s throughput (fast enough for game loops)
   75|       |/// - **Quality**: Passes TestU01 BigCrush suite
   76|       |/// - **Serialization**: Seed can be saved/loaded (RNG state not serialized)
   77|       |///
   78|       |/// # Memory Layout
   79|       |///
   80|       |/// ```text
   81|       |/// Rng:
   82|       |/// ┌──────────────────────────────────┐
   83|       |/// │ StdRng (ChaCha12 state)          │  ~136 bytes
   84|       |/// │ seed: u64                        │  8 bytes
   85|       |/// └──────────────────────────────────┘
   86|       |/// ```
   87|       |///
   88|       |/// # Example
   89|       |///
   90|       |/// ```rust,ignore
   91|       |/// let mut rng = Rng::from_seed(12345);
   92|       |/// assert_eq!(rng.gen_u32(), 3841292459);  // Deterministic!
   93|       |/// assert_eq!(rng.gen_u32(), 2374534555);  // Same every time!
   94|       |/// ```
   95|       |#[derive(Clone, Debug)]
   96|       |pub struct Rng {
   97|       |    inner: StdRng,
   98|       |    seed: u64, // Store seed for debugging/logging
   99|       |}
  100|       |
  101|       |// Manual Serialize/Deserialize implementation (StdRng doesn't implement Serialize in rand 0.9)
  102|       |impl Serialize for Rng {
  103|      0|    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
  104|      0|    where
  105|      0|        S: serde::Serializer,
  106|       |    {
  107|       |        // Serialize only the seed, not the full state
  108|       |        // This is sufficient for determinism (can reconstruct from seed)
  109|      0|        self.seed.serialize(serializer)
  110|      0|    }
  111|       |}
  112|       |
  113|       |impl<'de> Deserialize<'de> for Rng {
  114|      0|    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
  115|      0|    where
  116|      0|        D: serde::Deserializer<'de>,
  117|       |    {
  118|      0|        let seed = u64::deserialize(deserializer)?;
  119|      0|        Ok(Rng::from_seed(seed))
  120|      0|    }
  121|       |}
  122|       |
  123|       |impl Rng {
  124|       |    /// Create RNG from a 64-bit seed.
  125|       |    ///
  126|       |    /// # Determinism Guarantee
  127|       |    ///
  128|       |    /// **Same seed → same sequence** across:
  129|       |    /// - All platforms (Windows, Linux, macOS, WASM)
  130|       |    /// - All architectures (x86_64, ARM64)
  131|       |    /// - All compiler versions
  132|       |    ///
  133|       |    /// # Example
  134|       |    ///
  135|       |    /// ```rust,ignore
  136|       |    /// let rng1 = Rng::from_seed(12345);
  137|       |    /// let rng2 = Rng::from_seed(12345);
  138|       |    /// // rng1 and rng2 produce identical sequences
  139|       |    /// ```
  140|       |    pub fn from_seed(seed: u64) -> Self {
  141|       |        Self {
  142|       |            inner: StdRng::seed_from_u64(seed),
  143|       |            seed,
  144|       |        }
  145|       |    }
  146|       |
  147|       |    /// Get the seed used to initialize this RNG.
  148|       |    ///
  149|       |    /// Useful for logging/debugging reproducibility issues.
  150|       |    pub fn seed(&self) -> u64 {
  151|       |        self.seed
  152|       |    }
  153|       |
  154|       |    /// Generate a random u32 value.
  155|       |    ///
  156|       |    /// # Example
  157|       |    ///
  158|       |    /// ```rust,ignore
  159|       |    /// let x = rng.gen_u32();
  160|       |    /// ```
  161|       |    #[inline]
  162|      0|    pub fn gen_u32(&mut self) -> u32 {
  163|      0|        RngCore::next_u32(&mut self.inner)
  164|      0|    }
  165|       |
  166|       |    /// Generate a random u64 value.
  167|       |    ///
  168|       |    /// # Example
  169|       |    ///
  170|       |    /// ```rust,ignore
  171|       |    /// let x = rng.gen_u64();
  172|       |    /// ```
  173|       |    #[inline]
  174|      0|    pub fn gen_u64(&mut self) -> u64 {
  175|      0|        RngCore::next_u64(&mut self.inner)
  176|      0|    }
  177|       |
  178|       |    /// Generate a random value in the range [low, high).
  179|       |    ///
  180|       |    /// # Example
  181|       |    ///
  182|       |    /// ```rust,ignore
  183|       |    /// let damage = rng.gen_range(10..20);  // [10, 19]
  184|       |    /// let chance = rng.gen_range(0.0..1.0);  // [0.0, 1.0)
  185|       |    /// ```
  186|      0|    pub fn gen_range<T, R>(&mut self, range: R) -> T
  187|      0|    where
  188|      0|        T: SampleUniform,
  189|      0|        R: SampleRange<T>,
  190|       |    {
  191|      0|        self.inner.random_range(range)
  192|      0|    }
  193|       |
  194|       |    /// Generate a random boolean with probability `p`.
  195|       |    ///
  196|       |    /// # Example
  197|       |    ///
  198|       |    /// ```rust,ignore
  199|       |    /// if rng.gen_bool(0.25) {
  200|       |    ///     // 25% chance
  201|       |    /// }
  202|       |    /// ```
  203|       |    pub fn gen_bool(&mut self, p: f64) -> bool {
  204|       |        self.inner.random_bool(p)
  205|       |    }
  206|       |
  207|       |    /// Shuffle a slice in place.
  208|       |    ///
  209|       |    /// # Example
  210|       |    ///
  211|       |    /// ```rust,ignore
  212|       |    /// let mut deck = vec![1, 2, 3, 4, 5];
  213|       |    /// rng.shuffle(&mut deck);
  214|       |    /// ```
  215|      0|    pub fn shuffle<T>(&mut self, slice: &mut [T]) {
  216|       |        use rand::seq::SliceRandom;
  217|      0|        slice.shuffle(&mut self.inner);
  218|      0|    }
  219|       |
  220|       |    /// Choose a random element from a slice.
  221|       |    ///
  222|       |    /// Returns `None` if slice is empty.
  223|       |    ///
  224|       |    /// # Example
  225|       |    ///
  226|       |    /// ```rust,ignore
  227|       |    /// let actions = vec!["attack", "defend", "heal"];
  228|       |    /// let action = rng.choose(&actions).unwrap();
  229|       |    /// ```
  230|      0|    pub fn choose<'a, T>(&mut self, slice: &'a [T]) -> Option<&'a T> {
  231|      0|        slice.choose(&mut self.inner)
  232|      0|    }
  233|       |}
  234|       |
  235|       |impl RngCore for Rng {
  236|       |    fn next_u32(&mut self) -> u32 {
  237|       |        self.inner.next_u32()
  238|       |    }
  239|       |
  240|       |    fn next_u64(&mut self) -> u64 {
  241|       |        self.inner.next_u64()
  242|       |    }
  243|       |
  244|       |    fn fill_bytes(&mut self, dest: &mut [u8]) {
  245|       |        self.inner.fill_bytes(dest)
  246|       |    }
  247|       |}
  248|       |
  249|       |#[cfg(test)]
  250|       |mod tests {
  251|       |    use super::*;
  252|       |
  253|       |    // === Fixed Seed Reproducibility Tests ===
  254|       |
  255|       |    #[test]
  256|       |    fn test_fixed_seed_produces_same_sequence() {
  257|       |        let mut rng1 = Rng::from_seed(12345);
  258|       |        let mut rng2 = Rng::from_seed(12345);
  259|       |
  260|       |        // Generate 100 values, verify identical
  261|       |        for _ in 0..100 {
  262|       |            assert_eq!(
  263|       |                rng1.gen_u32(),
  264|       |                rng2.gen_u32(),
  265|       |                "Same seed should produce identical sequence"
  266|       |            );
  267|       |        }
  268|       |    }
  269|       |
  270|       |    #[test]
  271|       |    fn test_different_seeds_produce_different_sequences() {
  272|       |        let mut rng1 = Rng::from_seed(12345);
  273|       |        let mut rng2 = Rng::from_seed(54321);
  274|       |
  275|       |        // First values should differ (extremely high probability)
  276|       |        let val1 = rng1.gen_u64();
  277|       |        let val2 = rng2.gen_u64();
  278|       |
  279|       |        assert_ne!(
  280|       |            val1, val2,
  281|       |            "Different seeds should produce different sequences"
  282|       |        );
  283|       |    }
  284|       |
  285|       |    #[test]
  286|       |    fn test_seed_getter() {
  287|       |        let rng = Rng::from_seed(42);
  288|       |        assert_eq!(rng.seed(), 42, "Seed getter should return original seed");
  289|       |    }
  290|       |
  291|       |    #[test]
  292|       |    fn test_gen_u32_deterministic() {
  293|       |        let mut rng = Rng::from_seed(999);
  294|       |
  295|       |        // Known values for seed 999 (ChaCha12)
  296|       |        let val1 = rng.gen_u32();
  297|       |        let val2 = rng.gen_u32();
  298|       |        let val3 = rng.gen_u32();
  299|       |
  300|       |        // Reset with same seed
  301|       |        let mut rng_reset = Rng::from_seed(999);
  302|       |        assert_eq!(rng_reset.gen_u32(), val1, "First value should match");
  303|       |        assert_eq!(rng_reset.gen_u32(), val2, "Second value should match");
  304|       |        assert_eq!(rng_reset.gen_u32(), val3, "Third value should match");
  305|       |    }
  306|       |
  307|       |    #[test]
  308|       |    fn test_gen_range_deterministic() {
  309|       |        let mut rng1 = Rng::from_seed(555);
  310|       |        let mut rng2 = Rng::from_seed(555);
  311|       |
  312|       |        // Generate 50 values in range
  313|       |        for _ in 0..50 {
  314|       |            let val1 = rng1.gen_range(10..100);
  315|       |            let val2 = rng2.gen_range(10..100);
  316|       |
  317|       |            assert_eq!(val1, val2, "gen_range should be deterministic");
  318|       |            assert!(
  319|       |                val1 >= 10 && val1 < 100,
  320|       |                "Value should be in range [10, 100)"
  321|       |            );
  322|       |        }
  323|       |    }
  324|       |
  325|       |    #[test]
  326|       |    fn test_gen_bool_deterministic() {
  327|       |        let mut rng1 = Rng::from_seed(777);
  328|       |        let mut rng2 = Rng::from_seed(777);
  329|       |
  330|       |        // Generate 50 booleans
  331|       |        for _ in 0..50 {
  332|       |            let val1 = rng1.gen_bool(0.5);
  333|       |            let val2 = rng2.gen_bool(0.5);
  334|       |
  335|       |            assert_eq!(val1, val2, "gen_bool should be deterministic");
  336|       |        }
  337|       |    }
  338|       |
  339|       |    // === State Serialization Tests ===
  340|       |
  341|       |    #[test]
  342|       |    fn test_rng_serialization() {
  343|       |        let seed = 888;
  344|       |        let mut rng = Rng::from_seed(seed);
  345|       |
  346|       |        // Generate some values to advance state
  347|       |        let _ = rng.gen_u32();
  348|       |        let _ = rng.gen_u32();
  349|       |
  350|       |        // Serialize
  351|       |        let serialized = serde_json::to_string(&rng).expect("Serialization should succeed");
  352|       |
  353|       |        // Deserialize
  354|       |        let mut rng_restored: Rng =
  355|       |            serde_json::from_str(&serialized).expect("Deserialization should succeed");
  356|       |
  357|       |        // NOTE: We only serialize the seed, not the RNG state.
  358|       |        // This means deserialization gives us a fresh RNG from the same seed.
  359|       |        // Verify that the deserialized RNG has the correct seed
  360|       |        assert_eq!(
  361|       |            rng_restored.seed(),
  362|       |            seed,
  363|       |            "Deserialized RNG should have same seed"
  364|       |        );
  365|       |
  366|       |        // Verify that two RNGs from the same seed produce the same sequence
  367|       |        let mut rng_fresh = Rng::from_seed(seed);
  368|       |        let val1 = rng_fresh.gen_u32();
  369|       |        let val2 = rng_restored.gen_u32();
  370|       |
  371|       |        assert_eq!(
  372|       |            val1, val2,
  373|       |            "RNGs from same seed should produce same sequence"
  374|       |        );
  375|       |    }
  376|       |
  377|       |    #[test]
  378|       |    fn test_rng_clone_produces_same_sequence() {
  379|       |        let mut rng = Rng::from_seed(333);
  380|       |
  381|       |        // Generate some values
  382|       |        let _ = rng.gen_u32();
  383|       |        let _ = rng.gen_u32();
  384|       |
  385|       |        // Clone
  386|       |        let mut rng_clone = rng.clone();
  387|       |
  388|       |        // Verify both produce same sequence
  389|       |        for _ in 0..10 {
  390|       |            assert_eq!(
  391|       |                rng.gen_u32(),
  392|       |                rng_clone.gen_u32(),
  393|       |                "Cloned RNG should produce identical sequence"
  394|       |            );
  395|       |        }
  396|       |    }
  397|       |
  398|       |    // === Shuffle & Choose Tests ===
  399|       |
  400|       |    #[test]
  401|       |    fn test_shuffle_deterministic() {
  402|       |        let mut rng1 = Rng::from_seed(444);
  403|       |        let mut rng2 = Rng::from_seed(444);
  404|       |
  405|       |        let mut deck1 = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  406|       |        let mut deck2 = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  407|       |
  408|       |        rng1.shuffle(&mut deck1);
  409|       |        rng2.shuffle(&mut deck2);
  410|       |
  411|       |        assert_eq!(deck1, deck2, "Shuffle should be deterministic");
  412|       |    }
  413|       |
  414|       |    #[test]
  415|       |    fn test_choose_deterministic() {
  416|       |        let mut rng1 = Rng::from_seed(666);
  417|       |        let mut rng2 = Rng::from_seed(666);
  418|       |
  419|       |        let options = vec!["attack", "defend", "heal", "flee"];
  420|       |
  421|       |        for _ in 0..20 {
  422|       |            let choice1 = rng1.choose(&options);
  423|       |            let choice2 = rng2.choose(&options);
  424|       |
  425|       |            assert_eq!(choice1, choice2, "Choose should be deterministic");
  426|       |        }
  427|       |    }
  428|       |
  429|       |    #[test]
  430|       |    fn test_choose_empty_slice() {
  431|       |        let mut rng = Rng::from_seed(111);
  432|       |        let empty: Vec<i32> = vec![];
  433|       |
  434|       |        assert!(
  435|       |            rng.choose(&empty).is_none(),
  436|       |            "Choose on empty slice should return None"
  437|       |        );
  438|       |    }
  439|       |
  440|       |    // === Multiple RNG Instances (Independence) ===
  441|       |
  442|       |    #[test]
  443|       |    fn test_multiple_rngs_independent() {
  444|       |        let mut rng1 = Rng::from_seed(100);
  445|       |        let mut rng2 = Rng::from_seed(200);
  446|       |
  447|       |        // Generate values from both
  448|       |        let val1_from_rng1 = rng1.gen_u32();
  449|       |        let val1_from_rng2 = rng2.gen_u32();
  450|       |
  451|       |        // Should differ (different seeds)
  452|       |        assert_ne!(
  453|       |            val1_from_rng1, val1_from_rng2,
  454|       |            "Different RNG instances should produce different values"
  455|       |        );
  456|       |
  457|       |        // But each should be internally consistent
  458|       |        let mut rng1_reset = Rng::from_seed(100);
  459|       |        assert_eq!(
  460|       |            rng1_reset.gen_u32(),
  461|       |            val1_from_rng1,
  462|       |            "Resetting RNG should reproduce same value"
  463|       |        );
  464|       |    }
  465|       |
  466|       |    // === Cross-Run Consistency (Regression Test) ===
  467|       |
  468|       |    #[test]
  469|       |    fn test_known_sequence_regression() {
  470|       |        // This test catches if RNG implementation changes break determinism
  471|       |        let mut rng = Rng::from_seed(0);
  472|       |
  473|       |        // Known values for seed 0 (ChaCha12 via StdRng in rand 0.9)
  474|       |        // Note: These values are specific to rand 0.9's StdRng (ChaCha12)
  475|       |        // If rand updates, these values may change (that's OK - update expected values)
  476|       |
  477|       |        // We don't hardcode exact values (they change with rand versions)
  478|       |        // Instead, verify consistency within this run
  479|       |        let val1 = rng.gen_u64();
  480|       |        let val2 = rng.gen_u64();
  481|       |        let val3 = rng.gen_u64();
  482|       |
  483|       |        // Reset and verify
  484|       |        let mut rng_reset = Rng::from_seed(0);
  485|       |        assert_eq!(rng_reset.gen_u64(), val1);
  486|       |        assert_eq!(rng_reset.gen_u64(), val2);
  487|       |        assert_eq!(rng_reset.gen_u64(), val3);
  488|       |    }
  489|       |
  490|       |    // === Distribution Tests ===
  491|       |
  492|       |    #[test]
  493|       |    fn test_gen_range_bounds() {
  494|       |        let mut rng = Rng::from_seed(123);
  495|       |
  496|       |        // Test integer range
  497|       |        for _ in 0..100 {
  498|       |            let val = rng.gen_range(0..10);
  499|       |            assert!(val >= 0 && val < 10, "Value should be in range [0, 10)");
  500|       |        }
  501|       |
  502|       |        // Test float range
  503|       |        for _ in 0..100 {
  504|       |            let val = rng.gen_range(0.0..1.0);
  505|       |            assert!(
  506|       |                val >= 0.0 && val < 1.0,
  507|       |                "Value should be in range [0.0, 1.0)"
  508|       |            );
  509|       |        }
  510|       |    }
  511|       |
  512|       |    #[test]
  513|       |    fn test_gen_bool_probability() {
  514|       |        let mut rng = Rng::from_seed(456);
  515|       |
  516|       |        // Test p=0.0 (always false)
  517|       |        for _ in 0..100 {
  518|       |            assert!(!rng.gen_bool(0.0), "p=0.0 should always be false");
  519|       |        }
  520|       |
  521|       |        // Test p=1.0 (always true)
  522|       |        let mut rng = Rng::from_seed(789);
  523|       |        for _ in 0..100 {
  524|       |            assert!(rng.gen_bool(1.0), "p=1.0 should always be true");
  525|       |        }
  526|       |    }
  527|       |
  528|       |    // === Additional Coverage Tests (Week 6 Day 3 Part 4) ===
  529|       |
  530|       |    #[test]
  531|       |    fn test_fill_bytes_deterministic() {
  532|       |        // Test RngCore::fill_bytes implementation
  533|       |        let mut rng1 = Rng::from_seed(2024);
  534|       |        let mut rng2 = Rng::from_seed(2024);
  535|       |
  536|       |        let mut buf1 = [0u8; 32];
  537|       |        let mut buf2 = [0u8; 32];
  538|       |
  539|       |        rng1.fill_bytes(&mut buf1);
  540|       |        rng2.fill_bytes(&mut buf2);
  541|       |
  542|       |        assert_eq!(
  543|       |            buf1, buf2,
  544|       |            "fill_bytes should be deterministic with same seed"
  545|       |        );
  546|       |
  547|       |        // Verify it actually filled with non-zero bytes (extremely high probability)
  548|       |        let non_zero_count = buf1.iter().filter(|&&b| b != 0).count();
  549|       |        assert!(
  550|       |            non_zero_count > 0,
  551|       |            "fill_bytes should produce non-zero bytes"
  552|       |        );
  553|       |    }
  554|       |
  555|       |    #[test]
  556|       |    fn test_gen_u64_wrapper() {
  557|       |        // Explicit test for gen_u64() wrapper method
  558|       |        let mut rng1 = Rng::from_seed(2025);
  559|       |        let mut rng2 = Rng::from_seed(2025);
  560|       |
  561|       |        // Generate via wrapper method
  562|       |        let val1 = rng1.gen_u64();
  563|       |        let val2 = rng2.gen_u64();
  564|       |
  565|       |        assert_eq!(val1, val2, "gen_u64 should be deterministic");
  566|       |
  567|       |        // Verify via RngCore trait (should be identical)
  568|       |        let mut rng3 = Rng::from_seed(2025);
  569|       |        let val3 = RngCore::next_u64(&mut rng3);
  570|       |        assert_eq!(val1, val3, "gen_u64 wrapper should match RngCore::next_u64");
  571|       |
  572|       |        // Verify range (u64::MAX is valid)
  573|       |        assert!(val1 <= u64::MAX, "gen_u64 should produce valid u64 values");
  574|       |    }
  575|       |
  576|       |    #[test]
  577|       |    fn test_fill_bytes_empty_buffer() {
  578|       |        // Edge case: fill_bytes with zero-length buffer
  579|       |        let mut rng = Rng::from_seed(12345);
  580|       |        let mut buf = [];
  581|       |
  582|       |        // Should not panic
  583|       |        rng.fill_bytes(&mut buf);
  584|       |        assert_eq!(buf.len(), 0, "Empty buffer should remain empty");
  585|       |    }
  586|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\sparse_set.rs:
    1|       |// SPDX-License-Identifier: MIT
    2|       |//! Sparse set data structure for O(1) entity lookup
    3|       |//!
    4|       |//! Based on the classic sparse set pattern used by EnTT, Flecs, and Bevy.
    5|       |//! Provides O(1) insert, get, and remove operations with packed iteration.
    6|       |
    7|       |use crate::Entity;
    8|       |
    9|       |/// Sparse set mapping Entity → dense index
   10|       |///
   11|       |/// This data structure provides:
   12|       |/// - O(1) insert, get, remove
   13|       |/// - Packed dense array for cache-friendly iteration
   14|       |/// - Sparse array for fast entity → index lookup
   15|       |///
   16|       |/// Memory layout:
   17|       |/// ```text
   18|       |/// sparse: [None, Some(0), None, Some(1), None, Some(2), ...]
   19|       |///              ↓              ↓              ↓
   20|       |/// dense:  [Entity(1), Entity(3), Entity(5), ...]
   21|       |/// ```
   22|       |pub struct SparseSet {
   23|       |    /// Sparse array: Entity ID → dense index
   24|       |    /// Only allocated entries contain Some(index)
   25|       |    sparse: Vec<Option<usize>>,
   26|       |
   27|       |    /// Dense array: Packed list of entities
   28|       |    /// This is what we iterate over for cache-friendly access
   29|       |    dense: Vec<Entity>,
   30|       |}
   31|       |
   32|       |impl SparseSet {
   33|       |    /// Create a new empty SparseSet
   34|      0|    pub fn new() -> Self {
   35|      0|        Self {
   36|      0|            sparse: Vec::new(),
   37|      0|            dense: Vec::new(),
   38|      0|        }
   39|      0|    }
   40|       |
   41|       |    /// Create a new SparseSet with capacity for `capacity` entities
   42|      0|    pub fn with_capacity(capacity: usize) -> Self {
   43|      0|        Self {
   44|      0|            sparse: Vec::with_capacity(capacity),
   45|      0|            dense: Vec::with_capacity(capacity),
   46|      0|        }
   47|      0|    }
   48|       |
   49|       |    /// Insert an entity into the set
   50|       |    ///
   51|       |    /// Returns the dense index where the entity was inserted.
   52|       |    /// If the entity already exists, returns its existing index.
   53|      0|    pub fn insert(&mut self, entity: Entity) -> usize {
   54|      0|        let id = entity.id() as usize;
   55|       |
   56|       |        // Check if entity already exists
   57|      0|        if let Some(&index) = self.sparse.get(id).and_then(|opt| opt.as_ref()) {
   58|      0|            return index;
   59|      0|        }
   60|       |
   61|       |        // Expand sparse array if needed
   62|      0|        if id >= self.sparse.len() {
   63|      0|            self.sparse.resize(id + 1, None);
   64|      0|        }
   65|       |
   66|       |        // Add to dense array
   67|      0|        let dense_index = self.dense.len();
   68|      0|        self.dense.push(entity);
   69|      0|        self.sparse[id] = Some(dense_index);
   70|       |
   71|      0|        dense_index
   72|      0|    }
   73|       |
   74|       |    /// Get the dense index for an entity
   75|       |    ///
   76|       |    /// Returns None if the entity is not in the set.
   77|      0|    pub fn get(&self, entity: Entity) -> Option<usize> {
   78|      0|        let id = entity.id() as usize;
   79|      0|        self.sparse.get(id).and_then(|opt| *opt)
   80|      0|    }
   81|       |
   82|       |    /// Check if the set contains an entity
   83|      0|    pub fn contains(&self, entity: Entity) -> bool {
   84|      0|        self.get(entity).is_some()
   85|      0|    }
   86|       |
   87|       |    /// Remove an entity from the set
   88|       |    ///
   89|       |    /// Returns the dense index where the entity was located, or None if not found.
   90|       |    /// Uses swap_remove for O(1) performance (order not preserved).
   91|      0|    pub fn remove(&mut self, entity: Entity) -> Option<usize> {
   92|      0|        let id = entity.id() as usize;
   93|       |
   94|      0|        let dense_index = self.sparse.get_mut(id)?.take()?;
   95|       |
   96|       |        // Swap with last element for O(1) removal
   97|      0|        let last_index = self.dense.len() - 1;
   98|       |
   99|      0|        if dense_index != last_index {
  100|      0|            // Update the swapped entity's sparse index
  101|      0|            let swapped_entity = self.dense[last_index];
  102|      0|            self.dense.swap(dense_index, last_index);
  103|      0|            self.sparse[swapped_entity.id() as usize] = Some(dense_index);
  104|      0|        }
  105|       |
  106|      0|        self.dense.pop();
  107|       |
  108|      0|        Some(dense_index)
  109|      0|    }
  110|       |
  111|       |    /// Get the number of entities in the set
  112|      0|    pub fn len(&self) -> usize {
  113|      0|        self.dense.len()
  114|      0|    }
  115|       |
  116|       |    /// Check if the set is empty
  117|      0|    pub fn is_empty(&self) -> bool {
  118|      0|        self.dense.is_empty()
  119|      0|    }
  120|       |
  121|       |    /// Get the packed dense array of entities
  122|       |    ///
  123|       |    /// This is the array you should iterate over for cache-friendly access.
  124|      0|    pub fn entities(&self) -> &[Entity] {
  125|      0|        &self.dense
  126|      0|    }
  127|       |
  128|       |    /// Clear all entities from the set
  129|      0|    pub fn clear(&mut self) {
  130|      0|        self.dense.clear();
  131|      0|        self.sparse.clear();
  132|      0|    }
  133|       |
  134|       |    /// Get the capacity of the dense array
  135|      0|    pub fn capacity(&self) -> usize {
  136|      0|        self.dense.capacity()
  137|      0|    }
  138|       |
  139|       |    /// Reserve space for at least `additional` more entities
  140|      0|    pub fn reserve(&mut self, additional: usize) {
  141|      0|        self.dense.reserve(additional);
  142|      0|    }
  143|       |}
  144|       |
  145|       |impl Default for SparseSet {
  146|      0|    fn default() -> Self {
  147|      0|        Self::new()
  148|      0|    }
  149|       |}
  150|       |
  151|       |/// Generic sparse set for storing arbitrary data
  152|       |///
  153|       |/// This extends SparseSet to store data alongside entities.
  154|       |pub struct SparseSetData<T> {
  155|       |    /// Sparse array: Entity ID → dense index
  156|       |    sparse: Vec<Option<usize>>,
  157|       |
  158|       |    /// Dense array: Packed entities
  159|       |    entities: Vec<Entity>,
  160|       |
  161|       |    /// Dense array: Packed data
  162|       |    data: Vec<T>,
  163|       |}
  164|       |
  165|       |impl<T> SparseSetData<T> {
  166|       |    /// Create a new empty SparseSetData
  167|      0|    pub fn new() -> Self {
  168|      0|        Self {
  169|      0|            sparse: Vec::new(),
  170|      0|            entities: Vec::new(),
  171|      0|            data: Vec::new(),
  172|      0|        }
  173|      0|    }
  174|       |
  175|       |    /// Create a new SparseSetData with capacity
  176|      0|    pub fn with_capacity(capacity: usize) -> Self {
  177|      0|        Self {
  178|      0|            sparse: Vec::with_capacity(capacity),
  179|      0|            entities: Vec::with_capacity(capacity),
  180|      0|            data: Vec::with_capacity(capacity),
  181|      0|        }
  182|      0|    }
  183|       |
  184|       |    /// Insert an entity with associated data
  185|       |    ///
  186|       |    /// If the entity already exists, its data is replaced.
  187|       |    /// Returns the old data if it existed.
  188|      0|    pub fn insert(&mut self, entity: Entity, value: T) -> Option<T> {
  189|      0|        let id = entity.id() as usize;
  190|       |
  191|       |        // Check if entity already exists
  192|      0|        if let Some(&index) = self.sparse.get(id).and_then(|opt| opt.as_ref()) {
  193|      0|            return Some(std::mem::replace(&mut self.data[index], value));
  194|      0|        }
  195|       |
  196|       |        // Expand sparse array if needed
  197|      0|        if id >= self.sparse.len() {
  198|      0|            self.sparse.resize(id + 1, None);
  199|      0|        }
  200|       |
  201|       |        // Add to dense arrays
  202|      0|        let dense_index = self.entities.len();
  203|      0|        self.entities.push(entity);
  204|      0|        self.data.push(value);
  205|      0|        self.sparse[id] = Some(dense_index);
  206|       |
  207|      0|        None
  208|      0|    }
  209|       |
  210|       |    /// Get a reference to the data for an entity
  211|      0|    pub fn get(&self, entity: Entity) -> Option<&T> {
  212|      0|        let id = entity.id() as usize;
  213|      0|        let index = *self.sparse.get(id)?.as_ref()?;
  214|      0|        self.data.get(index)
  215|      0|    }
  216|       |
  217|       |    /// Get a mutable reference to the data for an entity
  218|      0|    pub fn get_mut(&mut self, entity: Entity) -> Option<&mut T> {
  219|      0|        let id = entity.id() as usize;
  220|      0|        let index = *self.sparse.get(id)?.as_ref()?;
  221|      0|        self.data.get_mut(index)
  222|      0|    }
  223|       |
  224|       |    /// Check if the set contains an entity
  225|      0|    pub fn contains(&self, entity: Entity) -> bool {
  226|      0|        let id = entity.id() as usize;
  227|      0|        self.sparse.get(id).and_then(|opt| *opt).is_some()
  228|      0|    }
  229|       |
  230|       |    /// Remove an entity and return its data
  231|      0|    pub fn remove(&mut self, entity: Entity) -> Option<T> {
  232|      0|        let id = entity.id() as usize;
  233|       |
  234|      0|        let dense_index = self.sparse.get_mut(id)?.take()?;
  235|       |
  236|       |        // Swap with last element for O(1) removal
  237|      0|        let last_index = self.entities.len() - 1;
  238|       |
  239|      0|        if dense_index != last_index {
  240|      0|            // Update the swapped entity's sparse index
  241|      0|            let swapped_entity = self.entities[last_index];
  242|      0|            self.entities.swap(dense_index, last_index);
  243|      0|            self.data.swap(dense_index, last_index);
  244|      0|            self.sparse[swapped_entity.id() as usize] = Some(dense_index);
  245|      0|        }
  246|       |
  247|      0|        self.entities.pop();
  248|      0|        self.data.pop()
  249|      0|    }
  250|       |
  251|       |    /// Get the number of entities
  252|      0|    pub fn len(&self) -> usize {
  253|      0|        self.entities.len()
  254|      0|    }
  255|       |
  256|       |    /// Check if the set is empty
  257|      0|    pub fn is_empty(&self) -> bool {
  258|      0|        self.entities.is_empty()
  259|      0|    }
  260|       |
  261|       |    /// Get the packed entities array
  262|      0|    pub fn entities(&self) -> &[Entity] {
  263|      0|        &self.entities
  264|      0|    }
  265|       |
  266|       |    /// Get the packed data array
  267|      0|    pub fn data(&self) -> &[T] {
  268|      0|        &self.data
  269|      0|    }
  270|       |
  271|       |    /// Get mutable packed data array
  272|      0|    pub fn data_mut(&mut self) -> &mut [T] {
  273|      0|        &mut self.data
  274|      0|    }
  275|       |
  276|       |    /// Iterate over (entity, data) pairs
  277|      0|    pub fn iter(&self) -> impl Iterator<Item = (Entity, &T)> {
  278|      0|        self.entities.iter().copied().zip(self.data.iter())
  279|      0|    }
  280|       |
  281|       |    /// Iterate mutably over (entity, data) pairs
  282|      0|    pub fn iter_mut(&mut self) -> impl Iterator<Item = (Entity, &mut T)> {
  283|      0|        self.entities.iter().copied().zip(self.data.iter_mut())
  284|      0|    }
  285|       |
  286|       |    /// Clear all entities and data
  287|      0|    pub fn clear(&mut self) {
  288|      0|        self.entities.clear();
  289|      0|        self.data.clear();
  290|      0|        self.sparse.clear();
  291|      0|    }
  292|       |}
  293|       |
  294|       |impl<T> Default for SparseSetData<T> {
  295|      0|    fn default() -> Self {
  296|      0|        Self::new()
  297|      0|    }
  298|       |}
  299|       |
  300|       |#[cfg(test)]
  301|       |mod tests {
  302|       |    use super::*;
  303|       |
  304|       |    #[test]
  305|       |    fn test_sparse_set_insert() {
  306|       |        let mut set = SparseSet::new();
  307|       |
  308|       |        let e1 = unsafe { Entity::from_raw(5) };
  309|       |        let e2 = unsafe { Entity::from_raw(10) };
  310|       |        let e3 = unsafe { Entity::from_raw(3) };
  311|       |
  312|       |        let idx1 = set.insert(e1);
  313|       |        let idx2 = set.insert(e2);
  314|       |        let idx3 = set.insert(e3);
  315|       |
  316|       |        assert_eq!(idx1, 0);
  317|       |        assert_eq!(idx2, 1);
  318|       |        assert_eq!(idx3, 2);
  319|       |        assert_eq!(set.len(), 3);
  320|       |    }
  321|       |
  322|       |    #[test]
  323|       |    fn test_sparse_set_get() {
  324|       |        let mut set = SparseSet::new();
  325|       |
  326|       |        let e1 = unsafe { Entity::from_raw(5) };
  327|       |        let e2 = unsafe { Entity::from_raw(10) };
  328|       |
  329|       |        set.insert(e1);
  330|       |        set.insert(e2);
  331|       |
  332|       |        assert_eq!(set.get(e1), Some(0));
  333|       |        assert_eq!(set.get(e2), Some(1));
  334|       |        assert_eq!(set.get(unsafe { Entity::from_raw(99) }), None);
  335|       |    }
  336|       |
  337|       |    #[test]
  338|       |    fn test_sparse_set_contains() {
  339|       |        let mut set = SparseSet::new();
  340|       |
  341|       |        let e1 = unsafe { Entity::from_raw(5) };
  342|       |        let e2 = unsafe { Entity::from_raw(10) };
  343|       |
  344|       |        set.insert(e1);
  345|       |
  346|       |        assert!(set.contains(e1));
  347|       |        assert!(!set.contains(e2));
  348|       |    }
  349|       |
  350|       |    #[test]
  351|       |    fn test_sparse_set_remove() {
  352|       |        let mut set = SparseSet::new();
  353|       |
  354|       |        let e1 = unsafe { Entity::from_raw(5) };
  355|       |        let e2 = unsafe { Entity::from_raw(10) };
  356|       |        let e3 = unsafe { Entity::from_raw(15) };
  357|       |
  358|       |        set.insert(e1);
  359|       |        set.insert(e2);
  360|       |        set.insert(e3);
  361|       |
  362|       |        assert_eq!(set.len(), 3);
  363|       |
  364|       |        // Remove middle element
  365|       |        let removed_idx = set.remove(e2);
  366|       |        assert_eq!(removed_idx, Some(1));
  367|       |        assert_eq!(set.len(), 2);
  368|       |
  369|       |        // e3 should have been swapped into e2's position
  370|       |        assert_eq!(set.get(e3), Some(1));
  371|       |        assert_eq!(set.get(e1), Some(0));
  372|       |        assert_eq!(set.get(e2), None);
  373|       |    }
  374|       |
  375|       |    #[test]
  376|       |    fn test_sparse_set_clear() {
  377|       |        let mut set = SparseSet::new();
  378|       |
  379|       |        set.insert(unsafe { Entity::from_raw(1) });
  380|       |        set.insert(unsafe { Entity::from_raw(2) });
  381|       |
  382|       |        assert_eq!(set.len(), 2);
  383|       |
  384|       |        set.clear();
  385|       |
  386|       |        assert_eq!(set.len(), 0);
  387|       |        assert!(set.is_empty());
  388|       |    }
  389|       |
  390|       |    #[test]
  391|       |    fn test_sparse_set_data_insert() {
  392|       |        let mut set = SparseSetData::new();
  393|       |
  394|       |        let e1 = unsafe { Entity::from_raw(5) };
  395|       |        let e2 = unsafe { Entity::from_raw(10) };
  396|       |
  397|       |        set.insert(e1, "hello");
  398|       |        set.insert(e2, "world");
  399|       |
  400|       |        assert_eq!(set.get(e1), Some(&"hello"));
  401|       |        assert_eq!(set.get(e2), Some(&"world"));
  402|       |    }
  403|       |
  404|       |    #[test]
  405|       |    fn test_sparse_set_data_replace() {
  406|       |        let mut set = SparseSetData::new();
  407|       |
  408|       |        let e1 = unsafe { Entity::from_raw(5) };
  409|       |
  410|       |        let old = set.insert(e1, 42);
  411|       |        assert_eq!(old, None);
  412|       |
  413|       |        let old = set.insert(e1, 100);
  414|       |        assert_eq!(old, Some(42));
  415|       |
  416|       |        assert_eq!(set.get(e1), Some(&100));
  417|       |    }
  418|       |
  419|       |    #[test]
  420|       |    fn test_sparse_set_data_remove() {
  421|       |        let mut set = SparseSetData::new();
  422|       |
  423|       |        let e1 = unsafe { Entity::from_raw(5) };
  424|       |        let e2 = unsafe { Entity::from_raw(10) };
  425|       |        let e3 = unsafe { Entity::from_raw(15) };
  426|       |
  427|       |        set.insert(e1, 1);
  428|       |        set.insert(e2, 2);
  429|       |        set.insert(e3, 3);
  430|       |
  431|       |        let removed = set.remove(e2);
  432|       |        assert_eq!(removed, Some(2));
  433|       |
  434|       |        assert_eq!(set.get(e1), Some(&1));
  435|       |        assert_eq!(set.get(e2), None);
  436|       |        assert_eq!(set.get(e3), Some(&3));
  437|       |    }
  438|       |
  439|       |    #[test]
  440|       |    fn test_sparse_set_data_iter() {
  441|       |        let mut set = SparseSetData::new();
  442|       |
  443|       |        let e1 = unsafe { Entity::from_raw(5) };
  444|       |        let e2 = unsafe { Entity::from_raw(10) };
  445|       |        let e3 = unsafe { Entity::from_raw(15) };
  446|       |
  447|       |        set.insert(e1, 100);
  448|       |        set.insert(e2, 200);
  449|       |        set.insert(e3, 300);
  450|       |
  451|       |        let sum: i32 = set.iter().map(|(_, &value)| value).sum();
  452|       |        assert_eq!(sum, 600);
  453|       |    }
  454|       |
  455|       |    #[test]
  456|       |    fn test_sparse_set_data_iter_mut() {
  457|       |        let mut set = SparseSetData::new();
  458|       |
  459|       |        let e1 = unsafe { Entity::from_raw(5) };
  460|       |        let e2 = unsafe { Entity::from_raw(10) };
  461|       |
  462|       |        set.insert(e1, 10);
  463|       |        set.insert(e2, 20);
  464|       |
  465|       |        for (_, value) in set.iter_mut() {
  466|       |            *value *= 2;
  467|       |        }
  468|       |
  469|       |        assert_eq!(set.get(e1), Some(&20));
  470|       |        assert_eq!(set.get(e2), Some(&40));
  471|       |    }
  472|       |
  473|       |    // ====================
  474|       |    // Day 3: Surgical Coverage Improvements
  475|       |    // ====================
  476|       |
  477|       |    #[test]
  478|       |    fn test_sparse_set_with_capacity() {
  479|       |        let set = SparseSet::with_capacity(100);
  480|       |        assert_eq!(set.len(), 0);
  481|       |        assert!(set.capacity() >= 100);
  482|       |    }
  483|       |
  484|       |    #[test]
  485|       |    fn test_sparse_set_capacity_and_reserve() {
  486|       |        let mut set = SparseSet::new();
  487|       |        let initial_cap = set.capacity();
  488|       |
  489|       |        set.reserve(50);
  490|       |        assert!(set.capacity() >= initial_cap + 50);
  491|       |    }
  492|       |
  493|       |    #[test]
  494|       |    fn test_sparse_set_insert_existing_entity() {
  495|       |        let mut set = SparseSet::new();
  496|       |        let e1 = unsafe { Entity::from_raw(5) };
  497|       |
  498|       |        let idx1 = set.insert(e1);
  499|       |        let idx2 = set.insert(e1); // Idempotent insert
  500|       |
  501|       |        assert_eq!(idx1, idx2);
  502|       |        assert_eq!(set.len(), 1); // Should not duplicate
  503|       |    }
  504|       |
  505|       |    #[test]
  506|       |    fn test_sparse_set_remove_nonexistent() {
  507|       |        let mut set = SparseSet::new();
  508|       |        let e1 = unsafe { Entity::from_raw(5) };
  509|       |
  510|       |        let removed = set.remove(e1);
  511|       |        assert_eq!(removed, None);
  512|       |    }
  513|       |
  514|       |    #[test]
  515|       |    fn test_sparse_set_large_entity_ids() {
  516|       |        let mut set = SparseSet::new();
  517|       |
  518|       |        // Large entity IDs force sparse array expansion
  519|       |        let e1 = unsafe { Entity::from_raw(1000) };
  520|       |        let e2 = unsafe { Entity::from_raw(5000) };
  521|       |
  522|       |        set.insert(e1);
  523|       |        set.insert(e2);
  524|       |
  525|       |        assert_eq!(set.len(), 2);
  526|       |        assert!(set.contains(e1));
  527|       |        assert!(set.contains(e2));
  528|       |    }
  529|       |
  530|       |    #[test]
  531|       |    fn test_sparse_set_remove_last_element() {
  532|       |        let mut set = SparseSet::new();
  533|       |
  534|       |        let e1 = unsafe { Entity::from_raw(5) };
  535|       |        let e2 = unsafe { Entity::from_raw(10) };
  536|       |
  537|       |        set.insert(e1);
  538|       |        set.insert(e2);
  539|       |
  540|       |        // Remove last element (no swap needed)
  541|       |        let removed = set.remove(e2);
  542|       |        assert_eq!(removed, Some(1));
  543|       |        assert_eq!(set.len(), 1);
  544|       |        assert_eq!(set.get(e1), Some(0));
  545|       |    }
  546|       |
  547|       |    #[test]
  548|       |    fn test_sparse_set_data_with_capacity() {
  549|       |        let set = SparseSetData::<i32>::with_capacity(100);
  550|       |        assert_eq!(set.len(), 0);
  551|       |        assert!(set.is_empty());
  552|       |    }
  553|       |
  554|       |    #[test]
  555|       |    fn test_sparse_set_data_get_mut() {
  556|       |        let mut set = SparseSetData::new();
  557|       |
  558|       |        let e1 = unsafe { Entity::from_raw(5) };
  559|       |        set.insert(e1, 42);
  560|       |
  561|       |        if let Some(value) = set.get_mut(e1) {
  562|       |            *value += 10;
  563|       |        }
  564|       |
  565|       |        assert_eq!(set.get(e1), Some(&52));
  566|       |    }
  567|       |
  568|       |    #[test]
  569|       |    fn test_sparse_set_data_get_mut_nonexistent() {
  570|       |        let mut set = SparseSetData::<i32>::new();
  571|       |        let e1 = unsafe { Entity::from_raw(5) };
  572|       |
  573|       |        assert!(set.get_mut(e1).is_none());
  574|       |    }
  575|       |
  576|       |    #[test]
  577|       |    fn test_sparse_set_data_contains() {
  578|       |        let mut set = SparseSetData::new();
  579|       |
  580|       |        let e1 = unsafe { Entity::from_raw(5) };
  581|       |        let e2 = unsafe { Entity::from_raw(10) };
  582|       |
  583|       |        set.insert(e1, 42);
  584|       |
  585|       |        assert!(set.contains(e1));
  586|       |        assert!(!set.contains(e2));
  587|       |    }
  588|       |
  589|       |    #[test]
  590|       |    fn test_sparse_set_data_clear() {
  591|       |        let mut set = SparseSetData::new();
  592|       |
  593|       |        set.insert(unsafe { Entity::from_raw(1) }, 10);
  594|       |        set.insert(unsafe { Entity::from_raw(2) }, 20);
  595|       |
  596|       |        assert_eq!(set.len(), 2);
  597|       |
  598|       |        set.clear();
  599|       |
  600|       |        assert_eq!(set.len(), 0);
  601|       |        assert!(set.is_empty());
  602|       |    }
  603|       |
  604|       |    #[test]
  605|       |    fn test_sparse_set_data_arrays() {
  606|       |        let mut set = SparseSetData::new();
  607|       |
  608|       |        let e1 = unsafe { Entity::from_raw(5) };
  609|       |        let e2 = unsafe { Entity::from_raw(10) };
  610|       |
  611|       |        set.insert(e1, 100);
  612|       |        set.insert(e2, 200);
  613|       |
  614|       |        assert_eq!(set.entities().len(), 2);
  615|       |        assert_eq!(set.data().len(), 2);
  616|       |
  617|       |        // Mutate via data_mut()
  618|       |        set.data_mut()[0] += 50;
  619|       |        assert_eq!(set.get(e1), Some(&150));
  620|       |    }
  621|       |
  622|       |    #[test]
  623|       |    fn test_sparse_set_data_remove_last() {
  624|       |        let mut set = SparseSetData::new();
  625|       |
  626|       |        let e1 = unsafe { Entity::from_raw(5) };
  627|       |        let e2 = unsafe { Entity::from_raw(10) };
  628|       |
  629|       |        set.insert(e1, 1);
  630|       |        set.insert(e2, 2);
  631|       |
  632|       |        // Remove last element (no swap needed)
  633|       |        let removed = set.remove(e2);
  634|       |        assert_eq!(removed, Some(2));
  635|       |        assert_eq!(set.len(), 1);
  636|       |    }
  637|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\system_param.rs:
    1|       |//! System parameter types for ECS queries.
    2|       |//!
    3|       |//! ## Performance Notes (Week 10)
    4|       |//!
    5|       |//! ### Current Performance (Post SparseSet Integration)
    6|       |//!
    7|       |//! With the SparseSet integration (Week 10 Day 2), entity lookups are now O(1) instead
    8|       |//! of O(log n), providing 12-57× speedup over the old BTreeMap approach. This has
    9|       |//! resulted in:
   10|       |//!
   11|       |//! - **Frame time**: 2.70ms → 1.144ms (2.4× faster)
   12|       |//! - **Movement system**: 1,000µs → 106µs (9.4× faster)
   13|       |//! - **FPS**: 370 → 944 (2.5× improvement)
   14|       |//! - **Headroom**: 93.1% vs 60 FPS budget (16.67ms)
   15|       |//!
   16|       |//! ### Per-Entity Overhead Pattern
   17|       |//!
   18|       |//! Current Query implementations use a per-entity `archetype.get::<T>(entity)` pattern:
   19|       |//!
   20|       |//! ```rust,ignore
   21|       |//! impl Iterator for Query<'w, T> {
   22|       |//!     fn next(&mut self) -> Option<(Entity, &'w T)> {
   23|       |//!         let entity = archetype.entities_vec()[self.entity_idx];
   24|       |//!         let component = archetype.get::<T>(entity)?;
   25|       |//!         // Each get() call:
   26|       |//!         // 1. SparseSet lookup: O(1) - fast!
   27|       |//!         // 2. HashMap lookup: O(1) - fast!
   28|       |//!         // 3. Vec indexing: O(1) - fast!
   29|       |//!         // 4. Box downcast: O(1) - fast!
   30|       |//!         // Total: 4 operations per entity (1,000 entities = 4,000 ops)
   31|       |//!     }
   32|       |//! }
   33|       |//! ```
   34|       |//!
   35|       |//! While each operation is O(1), the repeated overhead adds up for large entity counts.
   36|       |//!
   37|       |//! ### Why Batch Iteration is Difficult
   38|       |//!
   39|       |//! Ideally, we'd batch all operations at the archetype level:
   40|       |//!
   41|       |//! ```rust,ignore
   42|       |//! // Dream API (blocked by borrow checker):
   43|       |//! for (entity, component) in archetype.iter_components_mut::<Position>() {
   44|       |//!     component.x += velocity.x;  // Direct mutable access, no per-entity lookups!
   45|       |//! }
   46|       |//! ```
   47|       |//!
   48|       |//! However, this is **not feasible** with Rust's current borrow checker due to lifetime
   49|       |//! constraints. The issue:
   50|       |//!
   51|       |//! ```rust,ignore
   52|       |//! pub fn iter_components_mut<T>(&mut self) -> impl Iterator<Item = (Entity, &mut T)> {
   53|       |//!     let column = self.components.get_mut(&TypeId::of::<T>())?;
   54|       |//!     self.entities.iter().filter_map(|(idx, &entity)| {
   55|       |//!         column.get_mut(idx)  // ❌ ERROR: captured variable escapes FnMut closure
   56|       |//!         //                           Returns &mut T borrowed from captured column
   57|       |//!     })
   58|       |//! }
   59|       |//! ```
   60|       |//!
   61|       |//! Rust's borrow checker prevents this because:
   62|       |//! 1. The closure captures `column` (a mutable reference)
   63|       |//! 2. The closure tries to return `&mut T` borrowed from `column`
   64|       |//! 3. Rule: **References captured in closures cannot escape the closure scope**
   65|       |//! 4. This prevents dangling references but blocks the optimization
   66|       |//!
   67|       |//! ### Future Optimizations (Week 11-12)
   68|       |//!
   69|       |//! **Week 11: SystemParam DSL**
   70|       |//! - Compile-time borrow splitting with zero runtime cost
   71|       |//! - Eliminate Query2Mut 70% overhead (Action 32 issue)
   72|       |//! - Target: Movement <50µs (2× current performance)
   73|       |//!
   74|       |//! **Week 12: Parallel Execution**
   75|       |//! - Rayon-based parallel system execution
   76|       |//! - Dependency analysis for safe concurrent iteration
   77|       |//! - Target: Physics 813µs → 200-400µs (2-4× faster)
   78|       |//!
   79|       |//! **Week 13+: Type Registry + BlobVec Integration**
   80|       |//! - Runtime type registration system
   81|       |//! - Replace Vec<Box<dyn Any>> with contiguous BlobVec storage
   82|       |//! - This will enable ideal batch iteration (no Box overhead, no downcast)
   83|       |//! - Expected: Additional 5-10× component access speedup
   84|       |
   85|       |use crate::{archetype::ArchetypeId, Component, Entity, World};
   86|       |
   87|       |/// Trait for types that can be system parameters
   88|       |pub trait SystemParam: Sized {
   89|       |    // This will be fleshed out later. For now, it's a marker trait.
   90|       |}
   91|       |
   92|       |// Read-only single-component query
   93|       |pub struct Query<'w, T: Component> {
   94|       |    world: &'w World,
   95|       |    archetype_ids: Vec<ArchetypeId>,
   96|       |    arch_idx: usize,
   97|       |    entity_idx: usize,
   98|       |    _m: std::marker::PhantomData<T>,
   99|       |}
  100|       |
  101|       |impl<'w, T: Component> Query<'w, T> {
  102|      0|    pub fn new(world: &'w World) -> Self {
  103|      0|        let archetype_ids = world
  104|      0|            .archetypes
  105|      0|            .archetypes_with_component(std::any::TypeId::of::<T>())
  106|      0|            .map(|arch| arch.id)
  107|      0|            .collect();
  108|      0|        Self {
  109|      0|            world,
  110|      0|            archetype_ids,
  111|      0|            arch_idx: 0,
  112|      0|            entity_idx: 0,
  113|      0|            _m: Default::default(),
  114|      0|        }
  115|      0|    }
  116|       |}
  117|       |
  118|       |impl<'w, T: Component> Iterator for Query<'w, T> {
  119|       |    type Item = (Entity, &'w T);
  120|      0|    fn next(&mut self) -> Option<Self::Item> {
  121|       |        loop {
  122|      0|            if self.arch_idx >= self.archetype_ids.len() {
  123|      0|                return None;
  124|      0|            }
  125|      0|            let archetype_id = self.archetype_ids[self.arch_idx];
  126|      0|            let archetype = self
  127|      0|                .world
  128|      0|                .archetypes
  129|      0|                .get_archetype(archetype_id)
  130|      0|                .expect("BUG: archetype should exist from archetype_ids");
  131|       |
  132|      0|            if self.entity_idx >= archetype.len() {
  133|      0|                self.arch_idx += 1;
  134|      0|                self.entity_idx = 0;
  135|      0|                continue;
  136|      0|            }
  137|       |
  138|      0|            let entity = archetype.entities_vec()[self.entity_idx];
  139|      0|            self.entity_idx += 1;
  140|       |
  141|       |            // The borrow checker needs help here. Since we are iterating over disjoint archetypes
  142|       |            // and entities, this is safe. We'll use unsafe to extend the lifetime.
  143|      0|            let component = archetype
  144|      0|                .get::<T>(entity)
  145|      0|                .expect("BUG: entity should have component T in archetype");
  146|      0|            let component_ptr = component as *const T;
  147|      0|            return Some((entity, unsafe { &*component_ptr }));
  148|       |        }
  149|      0|    }
  150|       |}
  151|       |
  152|       |// Read-only two-component query
  153|       |pub struct Query2<'w, A: Component, B: Component> {
  154|       |    world: &'w World,
  155|       |    archetype_ids: Vec<ArchetypeId>,
  156|       |    arch_idx: usize,
  157|       |    entity_idx: usize,
  158|       |    _m: std::marker::PhantomData<(A, B)>,
  159|       |}
  160|       |
  161|       |impl<'w, A: Component, B: Component> Query2<'w, A, B> {
  162|      0|    pub fn new(world: &'w World) -> Self {
  163|      0|        let archetype_ids = world
  164|      0|            .archetypes
  165|      0|            .archetypes_with_component(std::any::TypeId::of::<A>())
  166|      0|            .filter(|arch| arch.signature.contains(std::any::TypeId::of::<B>()))
  167|      0|            .map(|arch| arch.id)
  168|      0|            .collect();
  169|       |
  170|      0|        Self {
  171|      0|            world,
  172|      0|            archetype_ids,
  173|      0|            arch_idx: 0,
  174|      0|            entity_idx: 0,
  175|      0|            _m: Default::default(),
  176|      0|        }
  177|      0|    }
  178|       |}
  179|       |
  180|       |impl<'w, A: Component, B: Component> Iterator for Query2<'w, A, B> {
  181|       |    type Item = (Entity, &'w A, &'w B);
  182|      0|    fn next(&mut self) -> Option<Self::Item> {
  183|       |        loop {
  184|      0|            if self.arch_idx >= self.archetype_ids.len() {
  185|      0|                return None;
  186|      0|            }
  187|      0|            let archetype_id = self.archetype_ids[self.arch_idx];
  188|      0|            let archetype = self
  189|      0|                .world
  190|      0|                .archetypes
  191|      0|                .get_archetype(archetype_id)
  192|      0|                .expect("BUG: archetype should exist from archetype_ids");
  193|       |
  194|      0|            if self.entity_idx >= archetype.len() {
  195|      0|                self.arch_idx += 1;
  196|      0|                self.entity_idx = 0;
  197|      0|                continue;
  198|      0|            }
  199|       |
  200|      0|            let entity = archetype.entities_vec()[self.entity_idx];
  201|      0|            self.entity_idx += 1;
  202|       |
  203|       |            // Unsafe is used to satisfy the borrow checker. This is safe because
  204|       |            // we are only reading, and the iterator structure ensures we don't hold
  205|       |            // references that outlive the world.
  206|      0|            let component_a = archetype
  207|      0|                .get::<A>(entity)
  208|      0|                .expect("BUG: entity should have component A in archetype");
  209|      0|            let component_b = archetype
  210|      0|                .get::<B>(entity)
  211|      0|                .expect("BUG: entity should have component B in archetype");
  212|      0|            let ptr_a = component_a as *const A;
  213|      0|            let ptr_b = component_b as *const B;
  214|       |
  215|      0|            return Some((entity, unsafe { &*ptr_a }, unsafe { &*ptr_b }));
  216|       |        }
  217|      0|    }
  218|       |}
  219|       |
  220|       |// Mutable two-component query (for Action 32 writeback optimization)
  221|       |pub struct Query2Mut<'w, A: Component, B: Component> {
  222|       |    world: *mut World,
  223|       |    archetype_ids: Vec<ArchetypeId>,
  224|       |    arch_idx: usize,
  225|       |    entity_idx: usize,
  226|       |    _m: std::marker::PhantomData<(&'w mut A, &'w B)>,
  227|       |}
  228|       |
  229|       |impl<'w, A: Component, B: Component> Query2Mut<'w, A, B> {
  230|      0|    pub fn new(world: &'w mut World) -> Self {
  231|      0|        let archetype_ids = world
  232|      0|            .archetypes
  233|      0|            .archetypes_with_component(std::any::TypeId::of::<A>())
  234|      0|            .filter(|arch| arch.signature.contains(std::any::TypeId::of::<B>()))
  235|      0|            .map(|arch| arch.id)
  236|      0|            .collect();
  237|       |
  238|      0|        Self {
  239|      0|            world,
  240|      0|            archetype_ids,
  241|      0|            arch_idx: 0,
  242|      0|            entity_idx: 0,
  243|      0|            _m: Default::default(),
  244|      0|        }
  245|      0|    }
  246|       |}
  247|       |
  248|       |impl<'w, A: Component, B: Component> Iterator for Query2Mut<'w, A, B> {
  249|       |    type Item = (Entity, &'w mut A, &'w B);
  250|      0|    fn next(&mut self) -> Option<Self::Item> {
  251|       |        loop {
  252|      0|            if self.arch_idx >= self.archetype_ids.len() {
  253|      0|                return None;
  254|      0|            }
  255|      0|            let archetype_id = self.archetype_ids[self.arch_idx];
  256|       |
  257|       |            // SAFETY: We hold *mut World for 'w lifetime. We reconstruct references for each iteration.
  258|       |            // This is safe because:
  259|       |            // 1. The world pointer is valid for 'w
  260|       |            // 2. We only access one entity at a time
  261|       |            // 3. A and B are different types (no aliasing within single entity)
  262|      0|            let world_ref = unsafe { &mut *self.world };
  263|       |
  264|       |            // Get immutable reference to archetype for metadata access
  265|      0|            let archetype = world_ref
  266|      0|                .archetypes
  267|      0|                .get_archetype(archetype_id)
  268|      0|                .expect("BUG: archetype should exist from archetype_ids");
  269|       |
  270|      0|            if self.entity_idx >= archetype.len() {
  271|      0|                self.arch_idx += 1;
  272|      0|                self.entity_idx = 0;
  273|      0|                continue;
  274|      0|            }
  275|       |
  276|      0|            let entity = archetype.entities_vec()[self.entity_idx];
  277|      0|            self.entity_idx += 1;
  278|       |
  279|       |            // SAFETY: Now get the actual component data using raw pointers to avoid borrow conflicts.
  280|       |            // We get component A mutably and B immutably through separate archetype lookups.
  281|       |            // This is safe because:
  282|       |            // 1. A and B are different types (ensured by type system)
  283|       |            // 2. We're returning references that live for 'w
  284|       |            // 3. Iterator ensures sequential access (no overlapping entity borrows)
  285|      0|            let world_ref2 = unsafe { &mut *self.world };
  286|      0|            let archetype_mut = world_ref2
  287|      0|                .archetypes
  288|      0|                .get_archetype_mut(archetype_id)
  289|      0|                .expect("BUG: archetype should exist");
  290|      0|            let component_a = archetype_mut
  291|      0|                .get_mut::<A>(entity)
  292|      0|                .expect("BUG: entity should have component A in archetype");
  293|      0|            let ptr_a = component_a as *mut A;
  294|       |
  295|      0|            let world_ref3 = unsafe { &*self.world };
  296|      0|            let archetype_imm = world_ref3
  297|      0|                .archetypes
  298|      0|                .get_archetype(archetype_id)
  299|      0|                .expect("BUG: archetype should exist");
  300|      0|            let component_b = archetype_imm
  301|      0|                .get::<B>(entity)
  302|      0|                .expect("BUG: entity should have component B in archetype");
  303|      0|            let ptr_b = component_b as *const B;
  304|       |
  305|      0|            return Some((entity, unsafe { &mut *ptr_a }, unsafe { &*ptr_b }));
  306|       |        }
  307|      0|    }
  308|       |}
  309|       |
  310|       |#[cfg(test)]
  311|       |mod tests {
  312|       |    use super::*;
  313|       |
  314|       |    #[derive(Debug, Clone, PartialEq)]
  315|       |    struct Position {
  316|       |        x: f32,
  317|       |        y: f32,
  318|       |    }
  319|       |
  320|       |    #[derive(Debug, Clone, PartialEq)]
  321|       |    struct Velocity {
  322|       |        x: f32,
  323|       |        y: f32,
  324|       |    }
  325|       |
  326|       |    #[derive(Debug, Clone, PartialEq)]
  327|       |    struct Health {
  328|       |        current: i32,
  329|       |        max: i32,
  330|       |    }
  331|       |
  332|       |    // ====================
  333|       |    // Day 1: Query Tests (Single Component)
  334|       |    // ====================
  335|       |
  336|       |    #[test]
  337|       |    fn test_query_single_component_empty() {
  338|       |        let world = World::new();
  339|       |        let query = Query::<Position>::new(&world);
  340|       |        let results: Vec<_> = query.collect();
  341|       |        assert_eq!(results.len(), 0, "Empty world should return no results");
  342|       |    }
  343|       |
  344|       |    #[test]
  345|       |    fn test_query_single_component_one_entity() {
  346|       |        let mut world = World::new();
  347|       |        let entity = world.spawn();
  348|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  349|       |
  350|       |        let query = Query::<Position>::new(&world);
  351|       |        let results: Vec<_> = query.collect();
  352|       |
  353|       |        assert_eq!(results.len(), 1, "Should find one entity with Position");
  354|       |        assert_eq!(results[0].0, entity);
  355|       |        assert_eq!(results[0].1.x, 1.0);
  356|       |        assert_eq!(results[0].1.y, 2.0);
  357|       |    }
  358|       |
  359|       |    #[test]
  360|       |    fn test_query_single_component_multiple_entities() {
  361|       |        let mut world = World::new();
  362|       |        let e1 = world.spawn();
  363|       |        let e2 = world.spawn();
  364|       |        let e3 = world.spawn();
  365|       |
  366|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  367|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  368|       |        world.insert(e3, Position { x: 3.0, y: 3.0 });
  369|       |
  370|       |        let query = Query::<Position>::new(&world);
  371|       |        let results: Vec<_> = query.collect();
  372|       |
  373|       |        assert_eq!(results.len(), 3, "Should find all three entities");
  374|       |
  375|       |        // Verify all entities present (order may vary due to archetype iteration)
  376|       |        let entities: Vec<Entity> = results.iter().map(|(e, _)| *e).collect();
  377|       |        assert!(entities.contains(&e1));
  378|       |        assert!(entities.contains(&e2));
  379|       |        assert!(entities.contains(&e3));
  380|       |    }
  381|       |
  382|       |    #[test]
  383|       |    fn test_query_filters_entities_without_component() {
  384|       |        let mut world = World::new();
  385|       |        let e1 = world.spawn();
  386|       |        let e2 = world.spawn();
  387|       |        let e3 = world.spawn();
  388|       |
  389|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  390|       |        world.insert(e2, Velocity { x: 5.0, y: 5.0 }); // No Position!
  391|       |        world.insert(e3, Position { x: 3.0, y: 3.0 });
  392|       |
  393|       |        let query = Query::<Position>::new(&world);
  394|       |        let results: Vec<_> = query.collect();
  395|       |
  396|       |        assert_eq!(results.len(), 2, "Should only find entities with Position");
  397|       |
  398|       |        let entities: Vec<Entity> = results.iter().map(|(e, _)| *e).collect();
  399|       |        assert!(entities.contains(&e1));
  400|       |        assert!(!entities.contains(&e2), "e2 should not be in results");
  401|       |        assert!(entities.contains(&e3));
  402|       |    }
  403|       |
  404|       |    #[test]
  405|       |    fn test_query_multiple_archetypes() {
  406|       |        let mut world = World::new();
  407|       |
  408|       |        // Archetype 1: Position only
  409|       |        let e1 = world.spawn();
  410|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  411|       |
  412|       |        // Archetype 2: Position + Velocity
  413|       |        let e2 = world.spawn();
  414|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  415|       |        world.insert(e2, Velocity { x: 1.0, y: 1.0 });
  416|       |
  417|       |        // Archetype 3: Position + Health
  418|       |        let e3 = world.spawn();
  419|       |        world.insert(e3, Position { x: 3.0, y: 3.0 });
  420|       |        world.insert(
  421|       |            e3,
  422|       |            Health {
  423|       |                current: 100,
  424|       |                max: 100,
  425|       |            },
  426|       |        );
  427|       |
  428|       |        let query = Query::<Position>::new(&world);
  429|       |        let results: Vec<_> = query.collect();
  430|       |
  431|       |        assert_eq!(
  432|       |            results.len(),
  433|       |            3,
  434|       |            "Should find entities across all archetypes with Position"
  435|       |        );
  436|       |    }
  437|       |
  438|       |    // ====================
  439|       |    // Day 1: Query2 Tests (Two Components)
  440|       |    // ====================
  441|       |
  442|       |    #[test]
  443|       |    fn test_query2_empty_world() {
  444|       |        let world = World::new();
  445|       |        let query = Query2::<Position, Velocity>::new(&world);
  446|       |        let results: Vec<_> = query.collect();
  447|       |        assert_eq!(results.len(), 0, "Empty world should return no results");
  448|       |    }
  449|       |
  450|       |    #[test]
  451|       |    fn test_query2_one_matching_entity() {
  452|       |        let mut world = World::new();
  453|       |        let entity = world.spawn();
  454|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  455|       |        world.insert(entity, Velocity { x: 0.5, y: 0.5 });
  456|       |
  457|       |        let query = Query2::<Position, Velocity>::new(&world);
  458|       |        let results: Vec<_> = query.collect();
  459|       |
  460|       |        assert_eq!(results.len(), 1);
  461|       |        assert_eq!(results[0].0, entity);
  462|       |        assert_eq!(results[0].1.x, 1.0);
  463|       |        assert_eq!(results[0].2.x, 0.5);
  464|       |    }
  465|       |
  466|       |    #[test]
  467|       |    fn test_query2_filters_partial_matches() {
  468|       |        let mut world = World::new();
  469|       |
  470|       |        // Entity with both components
  471|       |        let e1 = world.spawn();
  472|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  473|       |        world.insert(e1, Velocity { x: 0.5, y: 0.5 });
  474|       |
  475|       |        // Entity with Position only
  476|       |        let e2 = world.spawn();
  477|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  478|       |
  479|       |        // Entity with Velocity only
  480|       |        let e3 = world.spawn();
  481|       |        world.insert(e3, Velocity { x: 1.0, y: 1.0 });
  482|       |
  483|       |        let query = Query2::<Position, Velocity>::new(&world);
  484|       |        let results: Vec<_> = query.collect();
  485|       |
  486|       |        assert_eq!(
  487|       |            results.len(),
  488|       |            1,
  489|       |            "Should only find entity with both components"
  490|       |        );
  491|       |        assert_eq!(results[0].0, e1);
  492|       |    }
  493|       |
  494|       |    #[test]
  495|       |    fn test_query2_multiple_matching_entities() {
  496|       |        let mut world = World::new();
  497|       |
  498|       |        let e1 = world.spawn();
  499|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  500|       |        world.insert(e1, Velocity { x: 0.1, y: 0.1 });
  501|       |
  502|       |        let e2 = world.spawn();
  503|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  504|       |        world.insert(e2, Velocity { x: 0.2, y: 0.2 });
  505|       |
  506|       |        let e3 = world.spawn();
  507|       |        world.insert(e3, Position { x: 3.0, y: 3.0 });
  508|       |        world.insert(e3, Velocity { x: 0.3, y: 0.3 });
  509|       |
  510|       |        let query = Query2::<Position, Velocity>::new(&world);
  511|       |        let results: Vec<_> = query.collect();
  512|       |
  513|       |        assert_eq!(results.len(), 3);
  514|       |    }
  515|       |
  516|       |    #[test]
  517|       |    fn test_query2_across_archetypes() {
  518|       |        let mut world = World::new();
  519|       |
  520|       |        // Archetype 1: Position + Velocity
  521|       |        let e1 = world.spawn();
  522|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  523|       |        world.insert(e1, Velocity { x: 0.5, y: 0.5 });
  524|       |
  525|       |        // Archetype 2: Position + Velocity + Health
  526|       |        let e2 = world.spawn();
  527|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  528|       |        world.insert(e2, Velocity { x: 1.0, y: 1.0 });
  529|       |        world.insert(
  530|       |            e2,
  531|       |            Health {
  532|       |                current: 100,
  533|       |                max: 100,
  534|       |            },
  535|       |        );
  536|       |
  537|       |        let query = Query2::<Position, Velocity>::new(&world);
  538|       |        let results: Vec<_> = query.collect();
  539|       |
  540|       |        assert_eq!(results.len(), 2, "Should find entities across archetypes");
  541|       |    }
  542|       |
  543|       |    // ====================
  544|       |    // Day 1: Query2Mut Tests (Mutable Queries)
  545|       |    // ====================
  546|       |
  547|       |    #[test]
  548|       |    fn test_query2mut_empty_world() {
  549|       |        let mut world = World::new();
  550|       |        let query = Query2Mut::<Position, Velocity>::new(&mut world);
  551|       |        let results: Vec<_> = query.collect();
  552|       |        assert_eq!(results.len(), 0);
  553|       |    }
  554|       |
  555|       |    #[test]
  556|       |    fn test_query2mut_mutation() {
  557|       |        let mut world = World::new();
  558|       |        let entity = world.spawn();
  559|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  560|       |        world.insert(entity, Velocity { x: 0.5, y: 0.5 });
  561|       |
  562|       |        {
  563|       |            let query = Query2Mut::<Position, Velocity>::new(&mut world);
  564|       |            for (_e, pos, vel) in query {
  565|       |                pos.x += vel.x;
  566|       |                pos.y += vel.y;
  567|       |            }
  568|       |        }
  569|       |
  570|       |        // Verify mutation
  571|       |        let pos = world.get::<Position>(entity).unwrap();
  572|       |        assert_eq!(pos.x, 1.5);
  573|       |        assert_eq!(pos.y, 2.5);
  574|       |    }
  575|       |
  576|       |    #[test]
  577|       |    fn test_query2mut_multiple_entities() {
  578|       |        let mut world = World::new();
  579|       |
  580|       |        let e1 = world.spawn();
  581|       |        world.insert(e1, Position { x: 0.0, y: 0.0 });
  582|       |        world.insert(e1, Velocity { x: 1.0, y: 1.0 });
  583|       |
  584|       |        let e2 = world.spawn();
  585|       |        world.insert(e2, Position { x: 5.0, y: 5.0 });
  586|       |        world.insert(e2, Velocity { x: 2.0, y: 2.0 });
  587|       |
  588|       |        {
  589|       |            let query = Query2Mut::<Position, Velocity>::new(&mut world);
  590|       |            for (_e, pos, vel) in query {
  591|       |                pos.x += vel.x * 10.0;
  592|       |                pos.y += vel.y * 10.0;
  593|       |            }
  594|       |        }
  595|       |
  596|       |        let pos1 = world.get::<Position>(e1).unwrap();
  597|       |        assert_eq!(pos1.x, 10.0);
  598|       |        assert_eq!(pos1.y, 10.0);
  599|       |
  600|       |        let pos2 = world.get::<Position>(e2).unwrap();
  601|       |        assert_eq!(pos2.x, 25.0);
  602|       |        assert_eq!(pos2.y, 25.0);
  603|       |    }
  604|       |
  605|       |    #[test]
  606|       |    fn test_query2mut_filters_correctly() {
  607|       |        let mut world = World::new();
  608|       |
  609|       |        // Entity with both components
  610|       |        let e1 = world.spawn();
  611|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  612|       |        world.insert(e1, Velocity { x: 1.0, y: 1.0 });
  613|       |
  614|       |        // Entity with Position only (should not be mutated)
  615|       |        let e2 = world.spawn();
  616|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  617|       |
  618|       |        {
  619|       |            let query = Query2Mut::<Position, Velocity>::new(&mut world);
  620|       |            for (_e, pos, vel) in query {
  621|       |                pos.x += vel.x;
  622|       |            }
  623|       |        }
  624|       |
  625|       |        let pos1 = world.get::<Position>(e1).unwrap();
  626|       |        assert_eq!(pos1.x, 2.0, "e1 should be mutated");
  627|       |
  628|       |        let pos2 = world.get::<Position>(e2).unwrap();
  629|       |        assert_eq!(pos2.x, 2.0, "e2 should NOT be mutated");
  630|       |    }
  631|       |
  632|       |    // ====================
  633|       |    // Day 1: Query Component Access Patterns
  634|       |    // ====================
  635|       |
  636|       |    #[test]
  637|       |    fn test_query_read_only_access() {
  638|       |        let mut world = World::new();
  639|       |        let entity = world.spawn();
  640|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  641|       |
  642|       |        let query = Query::<Position>::new(&world);
  643|       |
  644|       |        // Verify we can read data
  645|       |        let results: Vec<_> = query.collect();
  646|       |        assert_eq!(results[0].1.x, 1.0);
  647|       |
  648|       |        // Original data unchanged
  649|       |        let pos = world.get::<Position>(entity).unwrap();
  650|       |        assert_eq!(pos.x, 1.0);
  651|       |    }
  652|       |
  653|       |    #[test]
  654|       |    fn test_query2_read_only_both_components() {
  655|       |        let mut world = World::new();
  656|       |        let entity = world.spawn();
  657|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  658|       |        world.insert(entity, Velocity { x: 0.5, y: 0.5 });
  659|       |
  660|       |        let query = Query2::<Position, Velocity>::new(&world);
  661|       |
  662|       |        for (_e, pos, vel) in query {
  663|       |            // Can read both
  664|       |            let _ = pos.x + vel.x;
  665|       |        }
  666|       |
  667|       |        // Data unchanged
  668|       |        let pos = world.get::<Position>(entity).unwrap();
  669|       |        assert_eq!(pos.x, 1.0);
  670|       |    }
  671|       |
  672|       |    #[test]
  673|       |    fn test_query2mut_mutable_first_immutable_second() {
  674|       |        let mut world = World::new();
  675|       |        let entity = world.spawn();
  676|       |        world.insert(entity, Position { x: 1.0, y: 2.0 });
  677|       |        world.insert(entity, Velocity { x: 0.5, y: 0.5 });
  678|       |
  679|       |        {
  680|       |            let query = Query2Mut::<Position, Velocity>::new(&mut world);
  681|       |            for (_e, pos, vel) in query {
  682|       |                // Can mutate first, read second
  683|       |                pos.x += vel.x;
  684|       |                pos.y += vel.y;
  685|       |            }
  686|       |        }
  687|       |
  688|       |        let pos = world.get::<Position>(entity).unwrap();
  689|       |        assert_eq!(pos.x, 1.5);
  690|       |
  691|       |        // Velocity unchanged (immutable)
  692|       |        let vel = world.get::<Velocity>(entity).unwrap();
  693|       |        assert_eq!(vel.x, 0.5);
  694|       |    }
  695|       |
  696|       |    // ====================
  697|       |    // Day 1: Query Iterator Behavior
  698|       |    // ====================
  699|       |
  700|       |    #[test]
  701|       |    fn test_query_iterator_exhaustion() {
  702|       |        let mut world = World::new();
  703|       |        let e1 = world.spawn();
  704|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  705|       |
  706|       |        let mut query = Query::<Position>::new(&world);
  707|       |
  708|       |        // First iteration
  709|       |        assert!(query.next().is_some());
  710|       |
  711|       |        // Iterator exhausted
  712|       |        assert!(query.next().is_none());
  713|       |        assert!(query.next().is_none());
  714|       |    }
  715|       |
  716|       |    #[test]
  717|       |    fn test_query2_iterator_count() {
  718|       |        let mut world = World::new();
  719|       |
  720|       |        for i in 0..10 {
  721|       |            let e = world.spawn();
  722|       |            world.insert(
  723|       |                e,
  724|       |                Position {
  725|       |                    x: i as f32,
  726|       |                    y: i as f32,
  727|       |                },
  728|       |            );
  729|       |            world.insert(e, Velocity { x: 1.0, y: 1.0 });
  730|       |        }
  731|       |
  732|       |        let query = Query2::<Position, Velocity>::new(&world);
  733|       |        let count = query.count();
  734|       |
  735|       |        assert_eq!(count, 10);
  736|       |    }
  737|       |
  738|       |    #[test]
  739|       |    fn test_query_collect_into_vec() {
  740|       |        let mut world = World::new();
  741|       |
  742|       |        let e1 = world.spawn();
  743|       |        let e2 = world.spawn();
  744|       |        world.insert(e1, Position { x: 1.0, y: 1.0 });
  745|       |        world.insert(e2, Position { x: 2.0, y: 2.0 });
  746|       |
  747|       |        let query = Query::<Position>::new(&world);
  748|       |        let results: Vec<_> = query.collect();
  749|       |
  750|       |        assert_eq!(results.len(), 2);
  751|       |        assert!(results.iter().any(|(e, _)| *e == e1));
  752|       |        assert!(results.iter().any(|(e, _)| *e == e2));
  753|       |    }
  754|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-ecs\src\type_registry.rs:
    1|       |//! Type registry for dynamic component operations.
    2|       |//!
    3|       |//! Provides runtime type information and handlers for type-erased component
    4|       |//! operations (insert, remove, drop). Used by CommandBuffer for deferred operations.
    5|       |
    6|       |use crate::Component;
    7|       |use std::any::{Any, TypeId};
    8|       |use std::collections::HashMap;
    9|       |use std::sync::Arc;
   10|       |
   11|       |/// Handler for inserting type-erased components into World.
   12|       |type InsertHandler =
   13|       |    Arc<dyn Fn(&mut crate::World, crate::Entity, Box<dyn Any + Send + Sync>) + Send + Sync>;
   14|       |
   15|       |/// Handler for removing type-erased components from World.
   16|       |type RemoveHandler = Arc<dyn Fn(&mut crate::World, crate::Entity) + Send + Sync>;
   17|       |
   18|       |/// Registry of component types and their handlers.
   19|       |///
   20|       |/// Allows CommandBuffer to perform type-erased operations (insert/remove)
   21|       |/// without knowing concrete types at runtime.
   22|       |pub struct TypeRegistry {
   23|       |    pub(crate) insert_handlers: HashMap<TypeId, InsertHandler>,
   24|       |    pub(crate) remove_handlers: HashMap<TypeId, RemoveHandler>,
   25|       |    pub(crate) type_names: HashMap<TypeId, &'static str>,
   26|       |}
   27|       |
   28|       |impl TypeRegistry {
   29|       |    /// Create a new empty type registry.
   30|      0|    pub fn new() -> Self {
   31|      0|        Self {
   32|      0|            insert_handlers: HashMap::new(),
   33|      0|            remove_handlers: HashMap::new(),
   34|      0|            type_names: HashMap::new(),
   35|      0|        }
   36|      0|    }
   37|       |
   38|       |    /// Register a component type with insert/remove handlers.
   39|       |    ///
   40|       |    /// This allows CommandBuffer to perform operations on this type via TypeId.
   41|       |    ///
   42|       |    /// # Example
   43|       |    /// ```
   44|       |    /// # use astraweave_ecs::{World, TypeRegistry};
   45|       |    /// # #[derive(Clone, Copy)]
   46|       |    /// # struct Position { x: f32, y: f32 }
   47|       |    /// let mut registry = TypeRegistry::new();
   48|       |    /// registry.register::<Position>();
   49|       |    /// ```
   50|      0|    pub fn register<T: Component>(&mut self) {
   51|      0|        let type_id = TypeId::of::<T>();
   52|      0|        let type_name = std::any::type_name::<T>();
   53|       |
   54|       |        // Insert handler: Downcast Box<dyn Any> → T, then call World::insert
   55|      0|        self.insert_handlers.insert(
   56|      0|            type_id,
   57|      0|            Arc::new(
   58|       |                |world: &mut crate::World,
   59|       |                 entity: crate::Entity,
   60|      0|                 component: Box<dyn Any + Send + Sync>| {
   61|      0|                    if let Ok(component) = component.downcast::<T>() {
   62|      0|                        world.insert(entity, *component);
   63|      0|                    } else {
   64|      0|                        panic!(
   65|      0|                            "TypeRegistry: insert handler called with wrong type (expected {})",
   66|      0|                            std::any::type_name::<T>()
   67|       |                        );
   68|       |                    }
   69|      0|                },
   70|       |            ),
   71|       |        );
   72|       |
   73|       |        // Remove handler: Call World::remove<T>
   74|      0|        self.remove_handlers.insert(
   75|      0|            type_id,
   76|      0|            Arc::new(|world: &mut crate::World, entity: crate::Entity| {
   77|      0|                world.remove::<T>(entity);
   78|      0|            }),
   79|       |        );
   80|       |
   81|      0|        self.type_names.insert(type_id, type_name);
   82|      0|    }
   83|       |
   84|       |    /// Insert a type-erased component using registered handler.
   85|       |    ///
   86|       |    /// # Panics
   87|       |    /// Panics if the type is not registered or if downcast fails.
   88|      0|    pub fn insert_boxed(
   89|      0|        &self,
   90|      0|        world: &mut crate::World,
   91|      0|        entity: crate::Entity,
   92|      0|        type_id: TypeId,
   93|      0|        component: Box<dyn Any + Send + Sync>,
   94|      0|    ) {
   95|      0|        if let Some(handler) = self.insert_handlers.get(&type_id) {
   96|      0|            handler(world, entity, component);
   97|      0|        } else {
   98|      0|            panic!(
   99|      0|                "TypeRegistry: type {:?} not registered (call register::<T>() first)",
  100|      0|                self.type_names.get(&type_id).unwrap_or(&"<unknown>")
  101|       |            );
  102|       |        }
  103|      0|    }
  104|       |
  105|       |    /// Remove a component by TypeId using registered handler.
  106|       |    ///
  107|       |    /// # Panics
  108|       |    /// Panics if the type is not registered.
  109|      0|    pub fn remove_by_type_id(
  110|      0|        &self,
  111|      0|        world: &mut crate::World,
  112|      0|        entity: crate::Entity,
  113|      0|        type_id: TypeId,
  114|      0|    ) {
  115|      0|        if let Some(handler) = self.remove_handlers.get(&type_id) {
  116|      0|            handler(world, entity);
  117|      0|        } else {
  118|      0|            panic!(
  119|      0|                "TypeRegistry: type {:?} not registered (call register::<T>() first)",
  120|      0|                self.type_names.get(&type_id).unwrap_or(&"<unknown>")
  121|       |            );
  122|       |        }
  123|      0|    }
  124|       |
  125|       |    /// Check if a type is registered.
  126|      0|    pub fn is_registered(&self, type_id: TypeId) -> bool {
  127|      0|        self.insert_handlers.contains_key(&type_id)
  128|      0|    }
  129|       |
  130|       |    /// Get the name of a registered type.
  131|      0|    pub fn type_name(&self, type_id: TypeId) -> Option<&'static str> {
  132|      0|        self.type_names.get(&type_id).copied()
  133|      0|    }
  134|       |}
  135|       |
  136|       |impl Default for TypeRegistry {
  137|      0|    fn default() -> Self {
  138|      0|        Self::new()
  139|      0|    }
  140|       |}
  141|       |
  142|       |// ============================================================================
  143|       |// Tests
  144|       |// ============================================================================
  145|       |
  146|       |#[cfg(test)]
  147|       |mod tests {
  148|       |    use super::*;
  149|       |    use crate::World;
  150|       |
  151|       |    #[derive(Clone, Copy, Debug, PartialEq)]
  152|       |    struct Position {
  153|       |        x: f32,
  154|       |        y: f32,
  155|       |    }
  156|       |
  157|       |    #[derive(Clone, Copy, Debug, PartialEq)]
  158|       |    struct Velocity {
  159|       |        x: f32,
  160|       |        y: f32,
  161|       |    }
  162|       |
  163|       |    #[test]
  164|       |    fn test_type_registry_creation() {
  165|       |        let registry = TypeRegistry::new();
  166|       |        assert!(!registry.is_registered(TypeId::of::<Position>()));
  167|       |    }
  168|       |
  169|       |    #[test]
  170|       |    fn test_register_type() {
  171|       |        let mut registry = TypeRegistry::new();
  172|       |        registry.register::<Position>();
  173|       |
  174|       |        assert!(registry.is_registered(TypeId::of::<Position>()));
  175|       |        assert_eq!(
  176|       |            registry.type_name(TypeId::of::<Position>()),
  177|       |            Some("astraweave_ecs::type_registry::tests::Position")
  178|       |        );
  179|       |    }
  180|       |
  181|       |    #[test]
  182|       |    fn test_insert_boxed() {
  183|       |        let mut world = World::new();
  184|       |        let mut registry = TypeRegistry::new();
  185|       |        registry.register::<Position>();
  186|       |
  187|       |        let entity = world.spawn();
  188|       |        let component = Box::new(Position { x: 10.0, y: 20.0 });
  189|       |
  190|       |        registry.insert_boxed(&mut world, entity, TypeId::of::<Position>(), component);
  191|       |
  192|       |        assert_eq!(
  193|       |            world.get::<Position>(entity),
  194|       |            Some(&Position { x: 10.0, y: 20.0 })
  195|       |        );
  196|       |    }
  197|       |
  198|       |    #[test]
  199|       |    fn test_remove_by_type_id() {
  200|       |        let mut world = World::new();
  201|       |        let mut registry = TypeRegistry::new();
  202|       |        registry.register::<Position>();
  203|       |
  204|       |        let entity = world.spawn();
  205|       |        world.insert(entity, Position { x: 10.0, y: 20.0 });
  206|       |
  207|       |        assert!(world.has::<Position>(entity));
  208|       |
  209|       |        registry.remove_by_type_id(&mut world, entity, TypeId::of::<Position>());
  210|       |
  211|       |        assert!(!world.has::<Position>(entity));
  212|       |    }
  213|       |
  214|       |    #[test]
  215|       |    #[should_panic(expected = "type")]
  216|       |    fn test_insert_unregistered_type() {
  217|       |        let mut world = World::new();
  218|       |        let registry = TypeRegistry::new();
  219|       |
  220|       |        let entity = world.spawn();
  221|       |        let component = Box::new(Position { x: 10.0, y: 20.0 });
  222|       |
  223|       |        registry.insert_boxed(&mut world, entity, TypeId::of::<Position>(), component);
  224|       |    }
  225|       |
  226|       |    #[test]
  227|       |    #[should_panic(expected = "type")]
  228|       |    fn test_remove_unregistered_type() {
  229|       |        let mut world = World::new();
  230|       |        let registry = TypeRegistry::new();
  231|       |
  232|       |        let entity = world.spawn();
  233|       |
  234|       |        registry.remove_by_type_id(&mut world, entity, TypeId::of::<Position>());
  235|       |    }
  236|       |
  237|       |    #[test]
  238|       |    fn test_multiple_types() {
  239|       |        let mut registry = TypeRegistry::new();
  240|       |        registry.register::<Position>();
  241|       |        registry.register::<Velocity>();
  242|       |
  243|       |        assert!(registry.is_registered(TypeId::of::<Position>()));
  244|       |        assert!(registry.is_registered(TypeId::of::<Velocity>()));
  245|       |    }
  246|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-net\src\lib.rs:
    1|       |//! # AstraWeave Networking
    2|       |//!
    3|       |//! Snapshot-based networking for multiplayer games with delta compression.
    4|       |//!
    5|       |//! ## Core Concepts
    6|       |//! - **Snapshot**: Complete world state at a point in time
    7|       |//! - **Delta**: Minimal diff between snapshots for bandwidth efficiency
    8|       |//! - **Interest**: Filter entities sent to each client
    9|       |//!
   10|       |//! ## Features
   11|       |//! - Delta compression with `diff_snapshots()` / `apply_delta()`
   12|       |//! - Interest management: `FullInterest`, `RadiusTeamInterest`, `FovInterest`
   13|       |//! - Deterministic replay support
   14|       |//! - Built-in server with `GameServer`
   15|       |//! - **TLS/SSL support** (enable with `tls` feature)
   16|       |
   17|       |#[cfg(feature = "tls")]
   18|       |pub mod tls;
   19|       |
   20|       |use anyhow::Result;
   21|       |use astraweave_core::*;
   22|       |use futures_util::{SinkExt, StreamExt};
   23|       |use serde::{Deserialize, Serialize};
   24|       |use std::collections::{hash_map::DefaultHasher, BTreeMap, BTreeSet};
   25|       |use std::hash::{Hash, Hasher};
   26|       |use std::sync::atomic::{AtomicU64, Ordering};
   27|       |use tokio::sync::{broadcast, Mutex};
   28|       |use tokio::time::{sleep, Duration, Instant};
   29|       |use tokio_tungstenite::tungstenite::Message;
   30|       |
   31|       |const SNAPSHOT_VERSION: u16 = 1;
   32|       |
   33|       |#[derive(Clone, Copy, Serialize, Deserialize, Debug, PartialEq, Eq)]
   34|       |pub struct EntityState {
   35|       |    pub id: u32,
   36|       |    pub pos: IVec2,
   37|       |    pub hp: i32,
   38|       |    pub team: u8,
   39|       |    pub ammo: i32,
   40|       |}
   41|       |
   42|       |#[derive(Clone, Serialize, Deserialize, Debug)]
   43|       |pub struct Snapshot {
   44|       |    pub version: u16,
   45|       |    pub tick: u64,
   46|       |    pub t: f32,
   47|       |    pub seq: u32,
   48|       |    pub world_hash: u64,
   49|       |    pub entities: Vec<EntityState>,
   50|       |}
   51|       |
   52|       |#[derive(Clone, Copy, Serialize, Deserialize, Debug, PartialEq, Eq)]
   53|       |pub struct EntityDeltaMask(u8);
   54|       |
   55|       |impl EntityDeltaMask {
   56|       |    const POS: u8 = 1 << 0;
   57|       |    const HP: u8 = 1 << 1;
   58|       |    const TEAM: u8 = 1 << 2;
   59|       |    const AMMO: u8 = 1 << 3;
   60|       |}
   61|       |
   62|       |#[derive(Clone, Serialize, Deserialize, Debug, PartialEq, Eq)]
   63|       |pub struct EntityDelta {
   64|       |    pub id: u32,
   65|       |    pub mask: u8,
   66|       |    pub pos: Option<IVec2>,
   67|       |    pub hp: Option<i32>,
   68|       |    pub team: Option<u8>,
   69|       |    pub ammo: Option<i32>,
   70|       |}
   71|       |
   72|       |#[derive(Clone, Serialize, Deserialize, Debug, PartialEq, Eq)]
   73|       |pub struct Delta {
   74|       |    pub base_tick: u64,
   75|       |    pub tick: u64,
   76|       |    pub changed: Vec<EntityDelta>,
   77|       |    pub removed: Vec<u32>,
   78|       |    pub head_hash: u64,
   79|       |}
   80|       |
   81|       |pub trait Interest: Send + Sync {
   82|       |    fn include(&self, viewer: &EntityState, e: &EntityState) -> bool;
   83|       |}
   84|       |
   85|       |pub struct FullInterest;
   86|       |impl Interest for FullInterest {
   87|  8.00M|    fn include(&self, _viewer: &EntityState, _e: &EntityState) -> bool {
   88|  8.00M|        true
   89|  8.00M|    }
   90|       |}
   91|       |
   92|       |pub struct RadiusTeamInterest {
   93|       |    pub radius: i32,
   94|       |}
   95|       |impl Interest for RadiusTeamInterest {
   96|     81|    fn include(&self, viewer: &EntityState, e: &EntityState) -> bool {
   97|     81|        if viewer.team == e.team {
   98|     29|            return true;
   99|     52|        }
  100|     52|        let dx = e.pos.x - viewer.pos.x;
  101|     52|        let dy = e.pos.y - viewer.pos.y;
  102|     52|        (dx * dx + dy * dy) <= self.radius * self.radius
  103|     81|    }
  104|       |}
  105|       |
  106|       |pub struct FovInterest {
  107|       |    pub radius: i32,
  108|       |    pub half_angle_deg: f32,
  109|       |    pub facing: IVec2, // approximate facing vector
  110|       |}
  111|       |impl Interest for FovInterest {
  112|      8|    fn include(&self, viewer: &EntityState, e: &EntityState) -> bool {
  113|      8|        if viewer.team == e.team {
  114|      1|            return true;
  115|      7|        }
  116|      7|        let dx = (e.pos.x - viewer.pos.x) as f32;
  117|      7|        let dy = (e.pos.y - viewer.pos.y) as f32;
  118|      7|        let dist2 = dx * dx + dy * dy;
  119|      7|        if dist2 > (self.radius * self.radius) as f32 {
  120|      1|            return false;
  121|      6|        }
  122|      6|        let fx = self.facing.x as f32;
  123|      6|        let fy = self.facing.y as f32;
  124|      6|        let fmag = (fx * fx + fy * fy).sqrt();
  125|      6|        if fmag == 0.0 {
  126|      1|            return true;
  127|      5|        }
  128|      5|        let vmag = (dist2).sqrt();
  129|      5|        if vmag == 0.0 {
  130|      1|            return true;
  131|      4|        }
  132|      4|        let dot = fx * dx + fy * dy;
  133|      4|        let cos_theta = dot / (fmag * vmag);
  134|      4|        let cos_half = (self.half_angle_deg.to_radians()).cos();
  135|      4|        cos_theta >= cos_half
  136|      8|    }
  137|       |}
  138|       |
  139|       |pub struct FovLosInterest {
  140|       |    pub radius: i32,
  141|       |    pub half_angle_deg: f32,
  142|       |    pub facing: IVec2,
  143|       |    pub obstacles: BTreeSet<(i32, i32)>,
  144|       |}
  145|       |
  146|      4|fn has_los(a: IVec2, b: IVec2, obstacles: &BTreeSet<(i32, i32)>) -> bool {
  147|       |    // Bresenham's line algorithm; return false if any obstacle cell intersects
  148|      4|    let (mut x0, mut y0) = (a.x, a.y);
  149|      4|    let (x1, y1) = (b.x, b.y);
  150|      4|    let dx = (x1 - x0).abs();
  151|      4|    let sx = if x0 < x1 { 1 } else { -1 };
                                                   ^0
  152|      4|    let dy = -(y1 - y0).abs();
  153|      4|    let sy = if y0 < y1 { 1 } else { -1 };
                                        ^2         ^2
  154|      4|    let mut err = dx + dy;
  155|       |    loop {
  156|     18|        if !(x0 == a.x && y0 == a.y) {
                                        ^4
  157|       |            // skip the starting cell occupied by viewer
  158|     14|            if obstacles.contains(&(x0, y0)) {
  159|      2|                return false;
  160|     12|            }
  161|      4|        }
  162|     16|        if x0 == x1 && y0 == y1 {
                                     ^2
  163|      2|            break;
  164|     14|        }
  165|     14|        let e2 = 2 * err;
  166|     14|        if e2 >= dy {
  167|     14|            err += dy;
  168|     14|            x0 += sx;
  169|     14|        }
                      ^0
  170|     14|        if e2 <= dx {
  171|      4|            err += dx;
  172|      4|            y0 += sy;
  173|     10|        }
  174|       |    }
  175|      2|    true
  176|      4|}
  177|       |
  178|       |impl Interest for FovLosInterest {
  179|      6|    fn include(&self, viewer: &EntityState, e: &EntityState) -> bool {
  180|      6|        if viewer.team == e.team {
  181|      2|            return true;
  182|      4|        }
  183|      4|        let dx = (e.pos.x - viewer.pos.x) as f32;
  184|      4|        let dy = (e.pos.y - viewer.pos.y) as f32;
  185|      4|        let dist2 = dx * dx + dy * dy;
  186|      4|        if dist2 > (self.radius * self.radius) as f32 {
  187|      0|            return false;
  188|      4|        }
  189|      4|        let fx = self.facing.x as f32;
  190|      4|        let fy = self.facing.y as f32;
  191|      4|        let fmag = (fx * fx + fy * fy).sqrt();
  192|      4|        if fmag == 0.0 {
  193|      1|            return has_los(viewer.pos, e.pos, &self.obstacles);
  194|      3|        }
  195|      3|        let vmag = (dist2).sqrt();
  196|      3|        if vmag == 0.0 {
  197|      0|            return true;
  198|      3|        }
  199|      3|        let dot = fx * dx + fy * dy;
  200|      3|        let cos_theta = dot / (fmag * vmag);
  201|      3|        let cos_half = (self.half_angle_deg.to_radians()).cos();
  202|      3|        cos_theta >= cos_half && has_los(viewer.pos, e.pos, &self.obstacles)
  203|      6|    }
  204|       |}
  205|       |
  206|       |#[derive(Clone, Debug)]
  207|       |pub enum InterestPolicy {
  208|       |    Radius {
  209|       |        radius: i32,
  210|       |    },
  211|       |    Fov {
  212|       |        radius: i32,
  213|       |        half_angle_deg: f32,
  214|       |        facing: IVec2,
  215|       |    },
  216|       |    FovLos {
  217|       |        radius: i32,
  218|       |        half_angle_deg: f32,
  219|       |        facing: IVec2,
  220|       |    },
  221|       |}
  222|       |
  223|  1.68k|fn stable_hash_snapshot(ents: &[EntityState], obstacles: &BTreeSet<(i32, i32)>) -> u64 {
  224|       |    // Canonical ordering
  225|  1.68k|    let mut hasher = DefaultHasher::new();
  226|  6.53k|    for e in ents.iter() {
                           ^1.68k^1.68k
  227|  6.53k|        e.id.hash(&mut hasher);
  228|  6.53k|        e.pos.x.hash(&mut hasher);
  229|  6.53k|        e.pos.y.hash(&mut hasher);
  230|  6.53k|        e.hp.hash(&mut hasher);
  231|  6.53k|        e.team.hash(&mut hasher);
  232|  6.53k|        e.ammo.hash(&mut hasher);
  233|  6.53k|    }
  234|  13.3k|    for o in obstacles.iter() {
                           ^1.68k    ^1.68k
  235|  13.3k|        o.hash(&mut hasher);
  236|  13.3k|    }
  237|  1.68k|    hasher.finish()
  238|  1.68k|}
  239|       |
  240|  8.06k|fn subset_hash(ents: &[EntityState]) -> u64 {
  241|  8.06k|    let mut hasher = DefaultHasher::new();
  242|  8.00M|    for e in ents.iter() {
                           ^8.06k^8.06k
  243|  8.00M|        e.id.hash(&mut hasher);
  244|  8.00M|        e.pos.x.hash(&mut hasher);
  245|  8.00M|        e.pos.y.hash(&mut hasher);
  246|  8.00M|        e.hp.hash(&mut hasher);
  247|  8.00M|        e.team.hash(&mut hasher);
  248|  8.00M|        e.ammo.hash(&mut hasher);
  249|  8.00M|    }
  250|  8.06k|    hasher.finish()
  251|  8.06k|}
  252|       |
  253|       |#[cfg(test)]
  254|       |mod tests;
  255|       |
  256|  1.68k|fn world_to_entities(w: &World) -> Vec<EntityState> {
  257|       |    // Stable by sorting by id
  258|  1.68k|    let mut ids: Vec<u32> = w
  259|  1.68k|        .all_of_team(0)
  260|  1.68k|        .into_iter()
  261|  1.68k|        .chain(w.all_of_team(1))
  262|  1.68k|        .chain(w.all_of_team(2))
  263|  1.68k|        .collect();
  264|  1.68k|    ids.sort_unstable();
  265|  1.68k|    ids.into_iter()
  266|  6.53k|        .filter_map(|id| {
                       ^1.68k
  267|  6.53k|            let pos = w.pos_of(id)?;
                                                ^0
  268|  6.53k|            let hp = w.health(id)?.hp;
                                               ^0
  269|  6.53k|            let team = w.team(id)?.id;
                                               ^0
  270|  6.53k|            let ammo = w.ammo(id)?.rounds;
                                               ^0
  271|  6.53k|            Some(EntityState {
  272|  6.53k|                id,
  273|  6.53k|                pos,
  274|  6.53k|                hp,
  275|  6.53k|                team,
  276|  6.53k|                ammo,
  277|  6.53k|            })
  278|  6.53k|        })
  279|  1.68k|        .collect()
  280|  1.68k|}
  281|       |
  282|  3.21k|fn world_obstacles_btree(w: &World) -> BTreeSet<(i32, i32)> {
  283|  3.21k|    w.obstacles.iter().cloned().collect()
  284|  3.21k|}
  285|       |
  286|  1.68k|pub fn build_snapshot(world: &World, tick: u64, seq: u32) -> Snapshot {
  287|  1.68k|    let entities = world_to_entities(world);
  288|  1.68k|    let obstacles = world_obstacles_btree(world);
  289|  1.68k|    let world_hash = stable_hash_snapshot(&entities, &obstacles);
  290|  1.68k|    Snapshot {
  291|  1.68k|        version: SNAPSHOT_VERSION,
  292|  1.68k|        tick,
  293|  1.68k|        t: world.t,
  294|  1.68k|        seq,
  295|  1.68k|        world_hash,
  296|  1.68k|        entities,
  297|  1.68k|    }
  298|  1.68k|}
  299|       |
  300|  4.03k|pub fn filter_snapshot_for_viewer(
  301|  4.03k|    head: &Snapshot,
  302|  4.03k|    interest: &(impl Interest + ?Sized),
  303|  4.03k|    viewer: &EntityState,
  304|  4.03k|) -> Snapshot {
  305|  4.03k|    let entities: Vec<EntityState> = head
  306|  4.03k|        .entities
  307|  4.03k|        .iter()
  308|  4.03k|        .cloned()
  309|  4.00M|        .filter(|e| interest.include(viewer, e))
                       ^4.03k
  310|  4.03k|        .collect();
  311|  4.03k|    let mut snap = head.clone();
  312|  4.03k|    snap.entities = entities;
  313|  4.03k|    snap.world_hash = subset_hash(&snap.entities);
  314|  4.03k|    snap
  315|  4.03k|}
  316|       |
  317|  4.03k|pub fn diff_snapshots(
  318|  4.03k|    base: &Snapshot,
  319|  4.03k|    head: &Snapshot,
  320|  4.03k|    interest: &impl Interest,
  321|  4.03k|    viewer: &EntityState,
  322|  4.03k|) -> Delta {
  323|  4.03k|    let mut base_map: BTreeMap<u32, &EntityState> = BTreeMap::new();
  324|  4.00M|    for e in &base.entities {
                      ^4.00M
  325|  4.00M|        base_map.insert(e.id, e);
  326|  4.00M|    }
  327|  4.03k|    let mut changed = Vec::new();
  328|  4.03k|    let mut present: BTreeSet<u32> = BTreeSet::new();
  329|  4.00M|    for e in &head.entities {
                      ^4.00M
  330|  4.00M|        if !interest.include(viewer, e) {
  331|      0|            continue;
  332|  4.00M|        }
  333|  4.00M|        present.insert(e.id);
  334|  4.00M|        let mut mask = 0u8;
  335|  4.00M|        let mut pos = None;
  336|  4.00M|        let mut hp = None;
  337|  4.00M|        let mut team = None;
  338|  4.00M|        let mut ammo = None;
  339|  4.00M|        match base_map.get(&e.id) {
  340|  4.00M|            Some(prev) => {
  341|  4.00M|                if prev.pos != e.pos {
  342|     11|                    mask |= EntityDeltaMask::POS;
  343|     11|                    pos = Some(e.pos);
  344|  4.00M|                }
  345|  4.00M|                if prev.hp != e.hp {
  346|   200k|                    mask |= EntityDeltaMask::HP;
  347|   200k|                    hp = Some(e.hp);
  348|  3.80M|                }
  349|  4.00M|                if prev.team != e.team {
  350|      0|                    mask |= EntityDeltaMask::TEAM;
  351|      0|                    team = Some(e.team);
  352|  4.00M|                }
  353|  4.00M|                if prev.ammo != e.ammo {
  354|   200k|                    mask |= EntityDeltaMask::AMMO;
  355|   200k|                    ammo = Some(e.ammo);
  356|  3.80M|                }
  357|       |            }
  358|      3|            None => {
  359|      3|                // treat as full entity update
  360|      3|                mask = EntityDeltaMask::POS
  361|      3|                    | EntityDeltaMask::HP
  362|      3|                    | EntityDeltaMask::TEAM
  363|      3|                    | EntityDeltaMask::AMMO;
  364|      3|                pos = Some(e.pos);
  365|      3|                hp = Some(e.hp);
  366|      3|                team = Some(e.team);
  367|      3|                ammo = Some(e.ammo);
  368|      3|            }
  369|       |        }
  370|  4.00M|        if mask != 0 {
  371|   200k|            changed.push(EntityDelta {
  372|   200k|                id: e.id,
  373|   200k|                mask,
  374|   200k|                pos,
  375|   200k|                hp,
  376|   200k|                team,
  377|   200k|                ammo,
  378|   200k|            });
  379|  3.80M|        }
  380|       |    }
  381|  4.03k|    let removed: Vec<u32> = base_map
  382|  4.03k|        .keys()
  383|  4.00M|        .filter(|id| !present.contains(id))
                       ^4.03k
  384|  4.03k|        .cloned()
  385|  4.03k|        .collect();
  386|  4.03k|    let head_hash = subset_hash(&head.entities);
  387|  4.03k|    Delta {
  388|  4.03k|        base_tick: base.tick,
  389|  4.03k|        tick: head.tick,
  390|  4.03k|        changed,
  391|  4.03k|        removed,
  392|  4.03k|        head_hash,
  393|  4.03k|    }
  394|  4.03k|}
  395|       |
  396|  4.03k|pub fn apply_delta(base: &mut Snapshot, delta: &Delta) {
  397|  4.03k|    if base.tick != delta.base_tick {
  398|      3|        return;
  399|  4.02k|    }
  400|  4.02k|    let mut map: BTreeMap<u32, EntityState> =
  401|  4.00M|        base.entities.iter().cloned().map(|e| (e.id, e)).collect();
                      ^4.02k               ^4.02k   ^4.02k             ^4.02k
  402|   204k|    for d in &delta.changed {
                      ^200k
  403|   200k|        let mut e = map.remove(&d.id).unwrap_or(EntityState {
  404|   200k|            id: d.id,
  405|   200k|            pos: IVec2 { x: 0, y: 0 },
  406|   200k|            hp: 0,
  407|   200k|            team: 0,
  408|   200k|            ammo: 0,
  409|   200k|        });
  410|   200k|        if d.mask & EntityDeltaMask::POS != 0 {
  411|     11|            if let Some(v) = d.pos {
  412|     11|                e.pos = v;
  413|     11|            }
                          ^0
  414|   200k|        }
  415|   200k|        if d.mask & EntityDeltaMask::HP != 0 {
  416|   200k|            if let Some(v) = d.hp {
  417|   200k|                e.hp = v;
  418|   200k|            }
                          ^0
  419|     10|        }
  420|   200k|        if d.mask & EntityDeltaMask::TEAM != 0 {
  421|      2|            if let Some(v) = d.team {
  422|      2|                e.team = v;
  423|      2|            }
                          ^0
  424|   200k|        }
  425|   200k|        if d.mask & EntityDeltaMask::AMMO != 0 {
  426|   200k|            if let Some(v) = d.ammo {
  427|   200k|                e.ammo = v;
  428|   200k|            }
                          ^0
  429|     10|        }
  430|   200k|        map.insert(e.id, e);
  431|       |    }
  432|  4.03k|    for id in &delta.removed {
                      ^4
  433|      4|        map.remove(id);
  434|      4|    }
  435|  4.02k|    base.entities = map.into_values().collect();
  436|  4.02k|    base.tick = delta.tick;
  437|  4.02k|    base.world_hash = delta.head_hash;
  438|  4.03k|}
  439|       |
  440|       |#[derive(Serialize, Deserialize, Debug)]
  441|       |#[serde(tag = "type")]
  442|       |pub enum Msg {
  443|       |    ClientHello {
  444|       |        name: String,
  445|       |        token: Option<String>,
  446|       |        policy: Option<String>,
  447|       |    },
  448|       |    ServerWelcome {
  449|       |        id: u32,
  450|       |    },
  451|       |    ServerSnapshot {
  452|       |        snap: Snapshot,
  453|       |    },
  454|       |    ServerDelta {
  455|       |        delta: Delta,
  456|       |    },
  457|       |    ClientProposePlan {
  458|       |        actor_id: u32,
  459|       |        intent: PlanIntent,
  460|       |    },
  461|       |    ClientInput {
  462|       |        seq: u32,
  463|       |        tick: u64,
  464|       |        actor_id: u32,
  465|       |        intent: PlanIntent,
  466|       |    },
  467|       |    ServerApplyResult {
  468|       |        ok: bool,
  469|       |        err: Option<String>,
  470|       |    },
  471|       |    ServerAck {
  472|       |        seq: u32,
  473|       |        tick_applied: u64,
  474|       |    },
  475|       |}
  476|       |
  477|       |#[derive(Clone, Debug)]
  478|       |pub enum ServerEvent {
  479|       |    Snapshot(Snapshot),
  480|       |    ApplyResult { ok: bool, err: Option<String> },
  481|       |    Ack { seq: u32, tick_applied: u64 },
  482|       |}
  483|       |
  484|       |pub struct GameServer {
  485|       |    pub world: Mutex<World>,
  486|       |    pub player_id: u32,
  487|       |    pub companion_id: u32,
  488|       |    pub enemy_id: u32,
  489|       |    pub tx: broadcast::Sender<ServerEvent>,
  490|       |    pub tick: AtomicU64,
  491|       |    pub replay: Mutex<Vec<ReplayEvent>>,
  492|       |    pub obstacles: std::sync::Arc<Mutex<BTreeSet<(i32, i32)>>>,
  493|       |}
  494|       |
  495|       |impl Default for GameServer {
  496|      1|    fn default() -> Self {
  497|      1|        Self::new()
  498|      1|    }
  499|       |}
  500|       |
  501|       |impl GameServer {
  502|     47|    pub fn new() -> Self {
  503|     47|        let mut w = World::new();
  504|    423|        for y in 1..=8 {
                          ^376
  505|    376|            w.obstacles.insert((6, y));
  506|    376|        }
  507|     47|        let player = w.spawn("P", IVec2 { x: 2, y: 2 }, Team { id: 0 }, 100, 0);
  508|     47|        let comp = w.spawn("C", IVec2 { x: 2, y: 3 }, Team { id: 1 }, 80, 30);
  509|     47|        let enemy = w.spawn("E", IVec2 { x: 12, y: 2 }, Team { id: 2 }, 60, 0);
  510|     47|        let (tx, _) = broadcast::channel(64);
  511|     47|        Self {
  512|     47|            world: Mutex::new(w),
  513|     47|            player_id: player,
  514|     47|            companion_id: comp,
  515|     47|            enemy_id: enemy,
  516|     47|            tx,
  517|     47|            tick: AtomicU64::new(0),
  518|     47|            replay: Mutex::new(Vec::new()),
  519|     47|            obstacles: std::sync::Arc::new(Mutex::new(BTreeSet::new())),
  520|     47|        }
  521|     47|    }
  522|       |
  523|     46|    pub async fn run_ws(self: &std::sync::Arc<Self>, addr: &str) -> Result<()> {
  524|       |        use tokio::net::TcpListener;
  525|     46|        let listener = TcpListener::bind(addr).await?;
                                                                  ^0
  526|     46|        println!("Server on {addr}");
  527|       |        // Fixed-tick loop at ~60 Hz; broadcast snapshots at ~20 Hz and full once per second
  528|     46|        let me = self.clone();
  529|     46|        tokio::spawn(async move {
  530|     46|            let dt = 1.0f32 / 60.0f32;
  531|     46|            let mut last_broadcast = 0u64;
  532|     46|            let mut last_full = 0u64;
  533|     46|            let mut seq: u32 = 0;
  534|     46|            let mut next = Instant::now();
  535|       |            loop {
  536|  1.58k|                let now = Instant::now();
  537|  1.58k|                if now < next {
  538|  1.53k|                    sleep(next - now).await;
  539|     52|                }
  540|  1.53k|                next += Duration::from_micros(16_666);
  541|  1.53k|                let tick = me.tick.fetch_add(1, Ordering::Relaxed) + 1;
  542|       |                {
  543|  1.53k|                    let mut w = me.world.lock().await;
  544|  1.53k|                    w.tick(dt);
  545|       |                    // Build snapshot for this tick and update obstacles cache
  546|  1.53k|                    let snap = build_snapshot(&w, tick, seq);
  547|  1.53k|                    let obs = world_obstacles_btree(&w);
  548|       |                    {
  549|  1.53k|                        let mut o = me.obstacles.lock().await;
  550|  1.53k|                        *o = obs;
  551|       |                    }
  552|  1.53k|                    seq = seq.wrapping_add(1);
  553|  1.53k|                    if tick - last_full >= 60 {
  554|      8|                        let _ = me.tx.send(ServerEvent::Snapshot(snap.clone()));
  555|      8|                        last_full = tick;
  556|  1.52k|                    } else if tick - last_broadcast >= 3 {
  557|    499|                        let _ = me.tx.send(ServerEvent::Snapshot(snap));
  558|    499|                        last_broadcast = tick;
  559|  1.03k|                    }
  560|       |                }
  561|       |            }
  562|       |        });
  563|     46|        while let Ok((stream, _)) = listener.accept().await {
                                    ^0
  564|      0|            let me = self.clone();
  565|      0|            tokio::spawn(async move {
  566|      0|                if let Err(e) = me.handle_conn(stream).await {
  567|      0|                    eprintln!("conn error: {e:?}");
  568|      0|                }
  569|      0|            });
  570|       |        }
  571|      0|        Ok(())
  572|      0|    }
  573|       |
  574|      0|    async fn handle_conn(self: std::sync::Arc<Self>, stream: tokio::net::TcpStream) -> Result<()> {
  575|      0|        let ws = tokio_tungstenite::accept_async(stream).await?;
  576|      0|        let (mut tx, mut rx) = ws.split();
  577|      0|        let mut rx_bcast = self.tx.subscribe();
  578|       |
  579|       |        // send welcome (id will be updated after ClientHello)
  580|      0|        tx.send(Message::Text(
  581|      0|            serde_json::to_string(&Msg::ServerWelcome { id: 1 })?.into(),
  582|       |        ))
  583|      0|        .await?;
  584|       |
  585|       |        // spawn a task to push snapshots
  586|      0|        let viewer_id = std::sync::Arc::new(Mutex::new(self.player_id)); // updated on ClientHello
  587|      0|        let policy = std::sync::Arc::new(Mutex::new(InterestPolicy::Radius { radius: 6 }));
  588|      0|        let writer_viewer = viewer_id.clone();
  589|      0|        let writer_policy = policy.clone();
  590|      0|        let obstacles_ref = self.obstacles.clone();
  591|      0|        tokio::spawn(async move {
  592|      0|            let mut last_sent: Option<Snapshot> = None;
  593|      0|            while let Ok(evt) = rx_bcast.recv().await {
  594|      0|                match evt {
  595|      0|                    ServerEvent::Snapshot(snap) => {
  596|       |                        // Choose viewer state
  597|      0|                        let vid = { *writer_viewer.lock().await };
  598|      0|                        if let Some(viewer) = snap.entities.iter().find(|e| e.id == vid).cloned() {
  599|       |                            // Build interest based on current policy
  600|      0|                            let interest_obj: Box<dyn Interest> = {
  601|      0|                                let pol = writer_policy.lock().await.clone();
  602|      0|                                match pol {
  603|      0|                                    InterestPolicy::Radius { radius } => {
  604|      0|                                        Box::new(RadiusTeamInterest { radius }) as Box<dyn Interest>
  605|       |                                    }
  606|       |                                    InterestPolicy::Fov {
  607|      0|                                        radius,
  608|      0|                                        half_angle_deg,
  609|      0|                                        facing,
  610|      0|                                    } => Box::new(FovInterest {
  611|      0|                                        radius,
  612|      0|                                        half_angle_deg,
  613|      0|                                        facing,
  614|      0|                                    })
  615|      0|                                        as Box<dyn Interest>,
  616|       |                                    InterestPolicy::FovLos {
  617|      0|                                        radius,
  618|      0|                                        half_angle_deg,
  619|      0|                                        facing,
  620|       |                                    } => {
  621|      0|                                        let obs = obstacles_ref.lock().await.clone();
  622|      0|                                        Box::new(FovLosInterest {
  623|      0|                                            radius,
  624|      0|                                            half_angle_deg,
  625|      0|                                            facing,
  626|      0|                                            obstacles: obs,
  627|      0|                                        })
  628|      0|                                            as Box<dyn Interest>
  629|       |                                    }
  630|       |                                }
  631|       |                            };
  632|       |                            // Filter the snapshot to the viewer's interest
  633|      0|                            let filtered =
  634|      0|                                filter_snapshot_for_viewer(&snap, &*interest_obj, &viewer);
  635|      0|                            if let Some(base) = &last_sent {
  636|      0|                                let delta = diff_snapshots(base, &filtered, &FullInterest, &viewer);
  637|      0|                                if delta.changed.is_empty() && delta.removed.is_empty() {
  638|      0|                                    continue;
  639|      0|                                }
  640|      0|                                let msg = Msg::ServerDelta { delta };
  641|      0|                                let _ = tx
  642|      0|                                    .send(Message::Text(
  643|      0|                                        serde_json::to_string(&msg).unwrap().into(),
  644|      0|                                    ))
  645|      0|                                    .await;
  646|       |                            } else {
  647|      0|                                let msg = Msg::ServerSnapshot {
  648|      0|                                    snap: filtered.clone(),
  649|      0|                                };
  650|      0|                                let _ = tx
  651|      0|                                    .send(Message::Text(
  652|      0|                                        serde_json::to_string(&msg).unwrap().into(),
  653|      0|                                    ))
  654|      0|                                    .await;
  655|       |                            }
  656|      0|                            last_sent = Some(filtered);
  657|       |                        } else {
  658|       |                            // viewer not in snapshot; send full snapshot
  659|      0|                            let msg = Msg::ServerSnapshot { snap: snap.clone() };
  660|      0|                            let _ = tx
  661|      0|                                .send(Message::Text(serde_json::to_string(&msg).unwrap().into()))
  662|      0|                                .await;
  663|      0|                            last_sent = Some(snap);
  664|       |                        }
  665|       |                    }
  666|      0|                    ServerEvent::ApplyResult { ok, err } => {
  667|      0|                        let _ = tx
  668|      0|                            .send(Message::Text(
  669|      0|                                serde_json::to_string(&Msg::ServerApplyResult { ok, err })
  670|      0|                                    .unwrap()
  671|      0|                                    .into(),
  672|      0|                            ))
  673|      0|                            .await;
  674|       |                    }
  675|      0|                    ServerEvent::Ack { seq, tick_applied } => {
  676|      0|                        let _ = tx
  677|      0|                            .send(Message::Text(
  678|      0|                                serde_json::to_string(&Msg::ServerAck { seq, tick_applied })
  679|      0|                                    .unwrap()
  680|      0|                                    .into(),
  681|      0|                            ))
  682|      0|                            .await;
  683|       |                    }
  684|       |                }
  685|       |            }
  686|      0|        });
  687|       |
  688|      0|        while let Some(msg) = rx.next().await {
  689|      0|            let msg = msg?;
  690|      0|            if msg.is_text() {
  691|      0|                let text = msg.into_text()?;
  692|      0|                let m: Msg = serde_json::from_str(&text)?;
  693|      0|                match m {
  694|       |                    Msg::ClientHello {
  695|      0|                        name,
  696|      0|                        token,
  697|      0|                        policy: pol,
  698|       |                    } => {
  699|      0|                        println!("Hello from {name}");
  700|      0|                        if let Some(tok) = token {
  701|      0|                            if tok != "dev" {
  702|      0|                                println!("unauthenticated or unknown token: {}", tok);
  703|      0|                            }
  704|      0|                        }
  705|       |                        // Map name to viewer id
  706|      0|                        let mapped = match name.as_str() {
  707|      0|                            "player" | "player1" => self.player_id,
  708|      0|                            "comp" | "companion" => self.companion_id,
  709|      0|                            "enemy" => self.enemy_id,
  710|      0|                            _ => self.player_id,
  711|       |                        };
  712|       |                        {
  713|      0|                            let mut v = viewer_id.lock().await;
  714|      0|                            *v = mapped;
  715|       |                        }
  716|      0|                        if let Some(kind) = pol.as_deref() {
  717|      0|                            let mut p = policy.lock().await;
  718|      0|                            *p = match kind {
  719|      0|                                "radius" => InterestPolicy::Radius { radius: 6 },
  720|      0|                                "fov" => InterestPolicy::Fov {
  721|      0|                                    radius: 6,
  722|      0|                                    half_angle_deg: 60.0,
  723|      0|                                    facing: IVec2 { x: 1, y: 0 },
  724|      0|                                },
  725|      0|                                "fovlos" => InterestPolicy::FovLos {
  726|      0|                                    radius: 6,
  727|      0|                                    half_angle_deg: 60.0,
  728|      0|                                    facing: IVec2 { x: 1, y: 0 },
  729|      0|                                },
  730|      0|                                _ => InterestPolicy::Radius { radius: 6 },
  731|       |                            };
  732|      0|                        }
  733|       |                        // send immediate full snapshot via broadcast
  734|      0|                        let w = self.world.lock().await;
  735|      0|                        let snap = build_snapshot(&w, self.tick.load(Ordering::Relaxed), 0);
  736|      0|                        let _ = self.tx.send(ServerEvent::Snapshot(snap));
  737|       |                    }
  738|      0|                    Msg::ClientProposePlan { actor_id, intent } => {
  739|      0|                        let mut w = self.world.lock().await;
  740|      0|                        let mut log = |s: String| println!("{}", s);
  741|      0|                        let vcfg = ValidateCfg {
  742|      0|                            world_bounds: (0, 0, 19, 9),
  743|      0|                        };
  744|      0|                        let res = validate_and_execute(&mut w, actor_id, &intent, &vcfg, &mut log);
  745|      0|                        let ok = res.is_ok();
  746|      0|                        let err = res.err().map(|e| e.to_string());
  747|       |                        // Capture snapshot + append replay
  748|      0|                        let tick = self.tick.load(Ordering::Relaxed);
  749|      0|                        let snap = build_snapshot(&w, tick, 0);
  750|       |                        {
  751|      0|                            let mut rec = self.replay.lock().await;
  752|      0|                            rec.push(ReplayEvent {
  753|      0|                                tick,
  754|      0|                                seq: 0,
  755|      0|                                actor_id,
  756|      0|                                intent: intent.clone(),
  757|      0|                                world_hash: snap.world_hash,
  758|      0|                            });
  759|       |                        }
  760|       |                        // Broadcast snapshot; per-connection task will produce deltas
  761|      0|                        let _ = self.tx.send(ServerEvent::Snapshot(snap));
  762|      0|                        let _ = self.tx.send(ServerEvent::ApplyResult { ok, err });
  763|       |                    }
  764|       |                    Msg::ClientInput {
  765|      0|                        actor_id,
  766|      0|                        intent,
  767|      0|                        seq,
  768|       |                        ..
  769|       |                    } => {
  770|      0|                        let mut w = self.world.lock().await;
  771|      0|                        let mut log = |s: String| println!("{}", s);
  772|      0|                        let vcfg = ValidateCfg {
  773|      0|                            world_bounds: (0, 0, 19, 9),
  774|      0|                        };
  775|      0|                        let res = validate_and_execute(&mut w, actor_id, &intent, &vcfg, &mut log);
  776|      0|                        let ok = res.is_ok();
  777|      0|                        let err = res.err().map(|e| e.to_string());
  778|       |                        // Capture snapshot + append replay
  779|      0|                        let tick = self.tick.load(Ordering::Relaxed);
  780|      0|                        let snap = build_snapshot(&w, tick, 0);
  781|       |                        {
  782|      0|                            let mut rec = self.replay.lock().await;
  783|      0|                            rec.push(ReplayEvent {
  784|      0|                                tick,
  785|      0|                                seq: 0,
  786|      0|                                actor_id,
  787|      0|                                intent: intent.clone(),
  788|      0|                                world_hash: snap.world_hash,
  789|      0|                            });
  790|       |                        }
  791|       |                        // Broadcast snapshot; per-connection task will produce deltas
  792|      0|                        let _ = self.tx.send(ServerEvent::Snapshot(snap));
  793|      0|                        let _ = self.tx.send(ServerEvent::ApplyResult { ok, err });
  794|       |                        // Ack this input to help client reconcile prediction history
  795|      0|                        let _ = self.tx.send(ServerEvent::Ack {
  796|      0|                            seq,
  797|      0|                            tick_applied: tick,
  798|      0|                        });
  799|       |                    }
  800|       |                    Msg::ServerWelcome { .. }
  801|       |                    | Msg::ServerSnapshot { .. }
  802|       |                    | Msg::ServerDelta { .. }
  803|       |                    | Msg::ServerApplyResult { .. }
  804|      0|                    | Msg::ServerAck { .. } => {
  805|      0|                        // ignore from clients
  806|      0|                    }
  807|       |                }
  808|      0|            } else if msg.is_close() {
  809|      0|                break;
  810|      0|            }
  811|       |        }
  812|      0|        Ok(())
  813|      0|    }
  814|       |}
  815|       |
  816|       |#[derive(Clone, Debug, Serialize, Deserialize)]
  817|       |pub struct ReplayEvent {
  818|       |    pub tick: u64,
  819|       |    pub seq: u32,
  820|       |    pub actor_id: u32,
  821|       |    pub intent: PlanIntent,
  822|       |    pub world_hash: u64,
  823|       |}
  824|       |
  825|       |/// Replays a sequence of inputs against a fresh world state provided by caller, stepping deterministically at 60 Hz.
  826|      2|pub fn replay_from(mut world: World, events: &[ReplayEvent]) -> Result<u64> {
  827|      2|    let dt = 1.0f32 / 60.0f32;
  828|      2|    let mut current_tick: u64 = 0;
  829|       |    // Sort by (tick, seq)
  830|      2|    let mut evs = events.to_vec();
  831|      4|    evs.sort_by_key(|e| (e.tick, e.seq));
                  ^2  ^2
  832|      6|    for e in evs {
                      ^4
  833|     24|        while current_tick < e.tick {
  834|     20|            world.tick(dt);
  835|     20|            current_tick += 1;
  836|     20|        }
  837|      8|        let mut log = |s: String| {
                          ^4
  838|      8|            let _ = s;
  839|      8|        };
  840|      4|        let vcfg = ValidateCfg {
  841|      4|            world_bounds: (0, 0, 19, 9),
  842|      4|        };
  843|      4|        let _ = validate_and_execute(&mut world, e.actor_id, &e.intent, &vcfg, &mut log);
  844|       |    }
  845|      2|    let snap = build_snapshot(&world, current_tick, 0);
  846|      2|    Ok(snap.world_hash)
  847|      2|}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-net\src\tests.rs:
    1|       |#![cfg(test)]
    2|       |
    3|       |use crate::Interest;
    4|       |use crate::{
    5|       |    apply_delta, build_snapshot, diff_snapshots, filter_snapshot_for_viewer, FullInterest,
    6|       |};
    7|       |use astraweave_core::{IVec2, Team, World};
    8|       |
    9|      6|fn make_world() -> World {
   10|      6|    let mut w = World::new();
   11|      6|    w.obstacles.insert((1, 1));
   12|      6|    let _p = w.spawn("P", IVec2 { x: 2, y: 2 }, Team { id: 0 }, 100, 10);
   13|      6|    let _c = w.spawn("C", IVec2 { x: 3, y: 2 }, Team { id: 1 }, 80, 5);
   14|      6|    let _e = w.spawn("E", IVec2 { x: 5, y: 2 }, Team { id: 2 }, 60, 0);
   15|      6|    w
   16|      6|}
   17|       |
   18|       |#[test]
   19|      1|fn snapshot_hash_stable() {
   20|      1|    let w1 = make_world();
   21|      1|    let s1 = build_snapshot(&w1, 1, 0);
   22|      1|    let w2 = make_world();
   23|      1|    let s2 = build_snapshot(&w2, 1, 0);
   24|      1|    assert_eq!(s1.world_hash, s2.world_hash);
   25|      1|}
   26|       |
   27|       |#[test]
   28|      1|fn delta_roundtrip() {
   29|      1|    let mut w = make_world();
   30|      1|    let a = build_snapshot(&w, 1, 0);
   31|       |    // mutate world
   32|      1|    if let Some(p) = w.pose_mut(1) {
   33|      1|        p.pos.x += 1;
   34|      1|    }
                  ^0
   35|      1|    if let Some(h) = w.health_mut(2) {
   36|      1|        h.hp -= 5;
   37|      1|    }
                  ^0
   38|      1|    if let Some(a) = w.ammo_mut(3) {
   39|      1|        a.rounds += 2;
   40|      1|    }
                  ^0
   41|      1|    let b = build_snapshot(&w, 2, 1);
   42|      1|    let viewer = a.entities.first().cloned().unwrap();
   43|      1|    let d = diff_snapshots(&a, &b, &FullInterest, &viewer);
   44|      1|    let mut x = a.clone();
   45|      1|    apply_delta(&mut x, &d);
   46|      1|    assert_eq!(x.tick, b.tick);
   47|      1|    assert_eq!(x.entities.len(), b.entities.len());
   48|       |    // Compare maps
   49|      3|    let map_x: std::collections::BTreeMap<_, _> = x.entities.iter().map(|e| (e.id, e)).collect();
                      ^1     ^1                                 ^1                ^1                 ^1
   50|      3|    let map_b: std::collections::BTreeMap<_, _> = b.entities.iter().map(|e| (e.id, e)).collect();
                      ^1     ^1                                 ^1                ^1                 ^1
   51|      3|    for (id, ex) in map_x.iter() {
                                  ^1    ^1
   52|      3|        let eb = map_b.get(id).unwrap();
   53|      3|        assert_eq!(ex, eb);
   54|       |    }
   55|      1|}
   56|       |
   57|       |#[test]
   58|      1|fn delta_removal_on_interest_change() {
   59|       |    use crate::RadiusTeamInterest;
   60|      1|    let mut w = make_world();
   61|      1|    let a = build_snapshot(&w, 1, 0);
   62|       |    // viewer = team 0 entity
   63|      1|    let viewer = a.entities.iter().find(|e| e.team == 0).cloned().unwrap();
   64|       |    // Identify an enemy and move it far away so it drops out of interest
   65|      3|    let enemy_id = a.entities.iter().find(|e| e.team == 2).unwrap().id;
                      ^1         ^1                ^1                    ^1
   66|      1|    if let Some(p) = w.pose_mut(enemy_id) {
   67|      1|        p.pos = IVec2 { x: 50, y: 50 };
   68|      1|    }
                  ^0
   69|      1|    let b = build_snapshot(&w, 2, 1);
   70|      1|    let policy = RadiusTeamInterest { radius: 5 };
   71|      1|    let base_f = filter_snapshot_for_viewer(&a, &policy, &viewer);
   72|      1|    let head_f = filter_snapshot_for_viewer(&b, &policy, &viewer);
   73|      1|    let d = diff_snapshots(&base_f, &head_f, &FullInterest, &viewer);
   74|      1|    assert!(
   75|      1|        d.removed.contains(&enemy_id),
   76|      0|        "enemy should be removed when it leaves interest"
   77|       |    );
   78|      1|    let mut x = base_f.clone();
   79|      1|    apply_delta(&mut x, &d);
   80|      1|    assert_eq!(x.tick, head_f.tick);
   81|      1|    assert_eq!(x.entities.len(), head_f.entities.len());
   82|      2|    assert!(x.entities.iter().all(|e| e.id != enemy_id));
                  ^1      ^1                ^1
   83|      1|}
   84|       |
   85|       |#[test]
   86|      1|fn interest_filter_basic() {
   87|       |    use crate::{EntityState, RadiusTeamInterest};
   88|      1|    let viewer = EntityState {
   89|      1|        id: 1,
   90|      1|        pos: IVec2 { x: 0, y: 0 },
   91|      1|        hp: 100,
   92|      1|        team: 0,
   93|      1|        ammo: 0,
   94|      1|    };
   95|      1|    let ally = EntityState {
   96|      1|        id: 2,
   97|      1|        pos: IVec2 { x: 100, y: 100 },
   98|      1|        hp: 100,
   99|      1|        team: 0,
  100|      1|        ammo: 0,
  101|      1|    };
  102|      1|    let near_enemy = EntityState {
  103|      1|        id: 3,
  104|      1|        pos: IVec2 { x: 2, y: 2 },
  105|      1|        hp: 100,
  106|      1|        team: 1,
  107|      1|        ammo: 0,
  108|      1|    };
  109|      1|    let far_enemy = EntityState {
  110|      1|        id: 4,
  111|      1|        pos: IVec2 { x: 20, y: 20 },
  112|      1|        hp: 100,
  113|      1|        team: 1,
  114|      1|        ammo: 0,
  115|      1|    };
  116|      1|    let policy = RadiusTeamInterest { radius: 5 };
  117|      1|    assert!(policy.include(&viewer, &ally), "allies always included");
                                                          ^0
  118|      1|    assert!(policy.include(&viewer, &near_enemy), "near enemy included");
                                                                ^0
  119|      1|    assert!(!policy.include(&viewer, &far_enemy), "far enemy excluded");
                                                                ^0
  120|      1|}
  121|       |
  122|       |#[test]
  123|      1|fn replay_determinism() {
  124|       |    use crate::{replay_from, ReplayEvent};
  125|       |    use astraweave_core::{ActionStep, PlanIntent};
  126|       |    // Build two identical worlds
  127|      1|    let mut w1 = World::new();
  128|      1|    let p1 = w1.spawn("P", IVec2 { x: 2, y: 2 }, Team { id: 0 }, 100, 0);
  129|      1|    let c1 = w1.spawn("C", IVec2 { x: 3, y: 2 }, Team { id: 1 }, 80, 10);
  130|      1|    let _e1 = w1.spawn("E", IVec2 { x: 7, y: 2 }, Team { id: 2 }, 60, 0);
  131|       |
  132|      1|    let mut w2 = World::new();
  133|      1|    let _p2 = w2.spawn("P", IVec2 { x: 2, y: 2 }, Team { id: 0 }, 100, 0);
  134|      1|    let _c2 = w2.spawn("C", IVec2 { x: 3, y: 2 }, Team { id: 1 }, 80, 10);
  135|      1|    let _e2 = w2.spawn("E", IVec2 { x: 7, y: 2 }, Team { id: 2 }, 60, 0);
  136|       |
  137|      1|    let evs = vec![
  138|      1|        ReplayEvent {
  139|      1|            tick: 5,
  140|      1|            seq: 0,
  141|      1|            actor_id: c1,
  142|      1|            intent: PlanIntent {
  143|      1|                plan_id: "mv".into(),
  144|      1|                steps: vec![ActionStep::MoveTo {
  145|      1|                    x: 4,
  146|      1|                    y: 2,
  147|      1|                    speed: None,
  148|      1|                }],
  149|      1|            },
  150|      1|            world_hash: 0,
  151|      1|        },
  152|      1|        ReplayEvent {
  153|      1|            tick: 10,
  154|      1|            seq: 0,
  155|      1|            actor_id: p1,
  156|      1|            intent: PlanIntent {
  157|      1|                plan_id: "mv".into(),
  158|      1|                steps: vec![ActionStep::MoveTo {
  159|      1|                    x: 3,
  160|      1|                    y: 2,
  161|      1|                    speed: None,
  162|      1|                }],
  163|      1|            },
  164|      1|            world_hash: 0,
  165|      1|        },
  166|       |    ];
  167|      1|    let h1 = replay_from(w1, &evs).unwrap();
  168|      1|    let h2 = replay_from(w2, &evs).unwrap();
  169|      1|    assert_eq!(h1, h2, "replay should be deterministic and consistent");
                                     ^0
  170|      1|}
  171|       |
  172|       |#[test]
  173|      1|fn multi_client_consistency_filtered_hash() {
  174|       |    use crate::{subset_hash, RadiusTeamInterest};
  175|       |    // Setup world and two viewers
  176|      1|    let mut w = make_world();
  177|      1|    let snap0 = build_snapshot(&w, 0, 0);
  178|      1|    let viewer_a = snap0
  179|      1|        .entities
  180|      1|        .iter()
  181|      1|        .find(|e| e.team == 0)
  182|      1|        .cloned()
  183|      1|        .unwrap();
  184|      1|    let viewer_b = snap0
  185|      1|        .entities
  186|      1|        .iter()
  187|      2|        .find(|e| e.team == 1)
                       ^1
  188|      1|        .cloned()
  189|      1|        .unwrap();
  190|      1|    let policy = RadiusTeamInterest { radius: 6 };
  191|       |
  192|       |    // Each client keeps its own filtered base and hash history
  193|      1|    let mut a = filter_snapshot_for_viewer(&snap0, &policy, &viewer_a);
  194|      1|    let mut b = filter_snapshot_for_viewer(&snap0, &policy, &viewer_b);
  195|      1|    let mut a_hashes = vec![a.world_hash];
  196|      1|    let mut b_hashes = vec![b.world_hash];
  197|       |
  198|       |    // Advance world a few ticks and broadcast filtered snapshots; apply deltas on each client
  199|     11|    for tick in 1..=10u64 {
                      ^10
  200|       |        // simple world change: move team 2 enemy to the right each tick
  201|     10|        if let Some(enemy) = w.all_of_team(2).first().cloned() {
  202|     10|            if let Some(p) = w.pose_mut(enemy) {
  203|     10|                p.pos.x += 1;
  204|     10|            }
                          ^0
  205|      0|        }
  206|     10|        let snap = build_snapshot(&w, tick, tick as u32);
  207|     10|        let head_a = filter_snapshot_for_viewer(&snap, &policy, &viewer_a);
  208|     10|        let head_b = filter_snapshot_for_viewer(&snap, &policy, &viewer_b);
  209|     10|        let d_a = diff_snapshots(&a, &head_a, &FullInterest, &viewer_a);
  210|     10|        let d_b = diff_snapshots(&b, &head_b, &FullInterest, &viewer_b);
  211|     10|        apply_delta(&mut a, &d_a);
  212|     10|        apply_delta(&mut b, &d_b);
  213|     10|        a_hashes.push(a.world_hash);
  214|     10|        b_hashes.push(b.world_hash);
  215|       |    }
  216|       |
  217|       |    // We don't expect a_hashes == b_hashes because views differ, but they should each be consistent
  218|      1|    assert_eq!(a.world_hash, subset_hash(&a.entities));
  219|      1|    assert_eq!(b.world_hash, subset_hash(&b.entities));
  220|      1|}
  221|       |
  222|       |#[test]
  223|      1|fn fov_los_interest_blocks_through_wall() {
  224|       |    use crate::{EntityState, FovLosInterest};
  225|       |    // Viewer at (0,0) facing +X with 45deg half-angle and radius 10
  226|      1|    let viewer = EntityState {
  227|      1|        id: 1,
  228|      1|        pos: IVec2 { x: 0, y: 0 },
  229|      1|        hp: 100,
  230|      1|        team: 0,
  231|      1|        ammo: 0,
  232|      1|    };
  233|      1|    let enemy_visible = EntityState {
  234|      1|        id: 2,
  235|      1|        pos: IVec2 { x: 5, y: 0 },
  236|      1|        hp: 100,
  237|      1|        team: 1,
  238|      1|        ammo: 0,
  239|      1|    };
  240|      1|    let enemy_blocked = EntityState {
  241|      1|        id: 3,
  242|      1|        pos: IVec2 { x: 5, y: 2 },
  243|      1|        hp: 100,
  244|      1|        team: 1,
  245|      1|        ammo: 0,
  246|      1|    };
  247|      1|    let mut obstacles = std::collections::BTreeSet::new();
  248|       |    // Wall at x=3 for y in [1..3]
  249|      1|    obstacles.insert((3, 1));
  250|      1|    obstacles.insert((3, 2));
  251|      1|    let policy = FovLosInterest {
  252|      1|        radius: 10,
  253|      1|        half_angle_deg: 45.0,
  254|      1|        facing: IVec2 { x: 1, y: 0 },
  255|      1|        obstacles,
  256|      1|    };
  257|      1|    assert!(
  258|      1|        policy.include(&viewer, &enemy_visible),
  259|      0|        "enemy directly ahead with LOS should be included"
  260|       |    );
  261|      1|    assert!(
  262|      1|        !policy.include(&viewer, &enemy_blocked),
  263|      0|        "enemy behind wall should be excluded by LOS"
  264|       |    );
  265|      1|}
  266|       |
  267|       |// ============================================================================
  268|       |// Additional Coverage Tests
  269|       |// ============================================================================
  270|       |
  271|       |#[test]
  272|      1|fn test_entity_state_equality() {
  273|       |    use crate::EntityState;
  274|      1|    let e1 = EntityState {
  275|      1|        id: 1,
  276|      1|        pos: IVec2 { x: 5, y: 10 },
  277|      1|        hp: 100,
  278|      1|        team: 0,
  279|      1|        ammo: 30,
  280|      1|    };
  281|      1|    let e2 = EntityState {
  282|      1|        id: 1,
  283|      1|        pos: IVec2 { x: 5, y: 10 },
  284|      1|        hp: 100,
  285|      1|        team: 0,
  286|      1|        ammo: 30,
  287|      1|    };
  288|      1|    let e3 = EntityState {
  289|      1|        id: 1,
  290|      1|        pos: IVec2 { x: 6, y: 10 },
  291|      1|        hp: 100,
  292|      1|        team: 0,
  293|      1|        ammo: 30,
  294|      1|    };
  295|      1|    assert_eq!(e1, e2);
  296|      1|    assert_ne!(e1, e3);
  297|      1|}
  298|       |
  299|       |#[test]
  300|      1|fn test_entity_state_clone() {
  301|       |    use crate::EntityState;
  302|      1|    let e1 = EntityState {
  303|      1|        id: 1,
  304|      1|        pos: IVec2 { x: 5, y: 10 },
  305|      1|        hp: 100,
  306|      1|        team: 0,
  307|      1|        ammo: 30,
  308|      1|    };
  309|      1|    let e2 = e1.clone();
  310|      1|    assert_eq!(e1.id, e2.id);
  311|      1|    assert_eq!(e1.pos, e2.pos);
  312|      1|}
  313|       |
  314|       |#[test]
  315|      1|fn test_entity_delta_mask_flags() {
  316|       |    use crate::EntityDeltaMask;
  317|      1|    assert_eq!(EntityDeltaMask::POS, 1);
  318|      1|    assert_eq!(EntityDeltaMask::HP, 2);
  319|      1|    assert_eq!(EntityDeltaMask::TEAM, 4);
  320|      1|    assert_eq!(EntityDeltaMask::AMMO, 8);
  321|      1|}
  322|       |
  323|       |#[test]
  324|      1|fn test_entity_delta_equality() {
  325|       |    use crate::EntityDelta;
  326|      1|    let d1 = EntityDelta {
  327|      1|        id: 1,
  328|      1|        mask: 3, // POS | HP
  329|      1|        pos: Some(IVec2 { x: 5, y: 5 }),
  330|      1|        hp: Some(80),
  331|      1|        team: None,
  332|      1|        ammo: None,
  333|      1|    };
  334|      1|    let d2 = d1.clone();
  335|      1|    assert_eq!(d1, d2);
  336|      1|}
  337|       |
  338|       |#[test]
  339|      1|fn test_delta_equality() {
  340|       |    use crate::Delta;
  341|      1|    let d1 = Delta {
  342|      1|        base_tick: 0,
  343|      1|        tick: 1,
  344|      1|        changed: vec![],
  345|      1|        removed: vec![],
  346|      1|        head_hash: 12345,
  347|      1|    };
  348|      1|    let d2 = d1.clone();
  349|      1|    assert_eq!(d1.base_tick, d2.base_tick);
  350|      1|    assert_eq!(d1.tick, d2.tick);
  351|      1|    assert_eq!(d1.head_hash, d2.head_hash);
  352|      1|}
  353|       |
  354|       |#[test]
  355|      1|fn test_snapshot_clone() {
  356|      1|    let w = make_world();
  357|      1|    let s1 = build_snapshot(&w, 1, 0);
  358|      1|    let s2 = s1.clone();
  359|      1|    assert_eq!(s1.tick, s2.tick);
  360|      1|    assert_eq!(s1.world_hash, s2.world_hash);
  361|      1|    assert_eq!(s1.entities.len(), s2.entities.len());
  362|      1|}
  363|       |
  364|       |#[test]
  365|      1|fn test_full_interest_includes_all() {
  366|       |    use crate::{EntityState, FullInterest};
  367|      1|    let viewer = EntityState {
  368|      1|        id: 1,
  369|      1|        pos: IVec2 { x: 0, y: 0 },
  370|      1|        hp: 100,
  371|      1|        team: 0,
  372|      1|        ammo: 0,
  373|      1|    };
  374|      1|    let far_entity = EntityState {
  375|      1|        id: 2,
  376|      1|        pos: IVec2 { x: 1000, y: 1000 },
  377|      1|        hp: 100,
  378|      1|        team: 2,
  379|      1|        ammo: 0,
  380|      1|    };
  381|      1|    let policy = FullInterest;
  382|      1|    assert!(policy.include(&viewer, &far_entity));
  383|      1|}
  384|       |
  385|       |#[test]
  386|      1|fn test_radius_interest_same_team_always_included() {
  387|       |    use crate::{EntityState, RadiusTeamInterest};
  388|      1|    let viewer = EntityState {
  389|      1|        id: 1,
  390|      1|        pos: IVec2 { x: 0, y: 0 },
  391|      1|        hp: 100,
  392|      1|        team: 0,
  393|      1|        ammo: 0,
  394|      1|    };
  395|      1|    let far_ally = EntityState {
  396|      1|        id: 2,
  397|      1|        pos: IVec2 { x: 1000, y: 1000 },
  398|      1|        hp: 100,
  399|      1|        team: 0, // Same team
  400|      1|        ammo: 0,
  401|      1|    };
  402|      1|    let policy = RadiusTeamInterest { radius: 5 };
  403|      1|    assert!(policy.include(&viewer, &far_ally)); // Same team always included
  404|      1|}
  405|       |
  406|       |#[test]
  407|      1|fn test_fov_interest_basic() {
  408|       |    use crate::{EntityState, FovInterest};
  409|      1|    let viewer = EntityState {
  410|      1|        id: 1,
  411|      1|        pos: IVec2 { x: 0, y: 0 },
  412|      1|        hp: 100,
  413|      1|        team: 0,
  414|      1|        ammo: 0,
  415|      1|    };
  416|       |    // Enemy directly in front
  417|      1|    let enemy_ahead = EntityState {
  418|      1|        id: 2,
  419|      1|        pos: IVec2 { x: 5, y: 0 },
  420|      1|        hp: 100,
  421|      1|        team: 1,
  422|      1|        ammo: 0,
  423|      1|    };
  424|       |    // Enemy behind
  425|      1|    let enemy_behind = EntityState {
  426|      1|        id: 3,
  427|      1|        pos: IVec2 { x: -5, y: 0 },
  428|      1|        hp: 100,
  429|      1|        team: 1,
  430|      1|        ammo: 0,
  431|      1|    };
  432|      1|    let policy = FovInterest {
  433|      1|        radius: 10,
  434|      1|        half_angle_deg: 45.0,
  435|      1|        facing: IVec2 { x: 1, y: 0 },
  436|      1|    };
  437|      1|    assert!(policy.include(&viewer, &enemy_ahead));
  438|      1|    assert!(!policy.include(&viewer, &enemy_behind));
  439|      1|}
  440|       |
  441|       |#[test]
  442|      1|fn test_fov_interest_same_position() {
  443|       |    use crate::{EntityState, FovInterest};
  444|      1|    let viewer = EntityState {
  445|      1|        id: 1,
  446|      1|        pos: IVec2 { x: 5, y: 5 },
  447|      1|        hp: 100,
  448|      1|        team: 0,
  449|      1|        ammo: 0,
  450|      1|    };
  451|       |    // Entity at same position
  452|      1|    let same_pos = EntityState {
  453|      1|        id: 2,
  454|      1|        pos: IVec2 { x: 5, y: 5 },
  455|      1|        hp: 100,
  456|      1|        team: 1,
  457|      1|        ammo: 0,
  458|      1|    };
  459|      1|    let policy = FovInterest {
  460|      1|        radius: 10,
  461|      1|        half_angle_deg: 45.0,
  462|      1|        facing: IVec2 { x: 1, y: 0 },
  463|      1|    };
  464|      1|    assert!(policy.include(&viewer, &same_pos)); // Same position should be included
  465|      1|}
  466|       |
  467|       |#[test]
  468|      1|fn test_fov_interest_zero_facing() {
  469|       |    use crate::{EntityState, FovInterest};
  470|      1|    let viewer = EntityState {
  471|      1|        id: 1,
  472|      1|        pos: IVec2 { x: 0, y: 0 },
  473|      1|        hp: 100,
  474|      1|        team: 0,
  475|      1|        ammo: 0,
  476|      1|    };
  477|      1|    let enemy = EntityState {
  478|      1|        id: 2,
  479|      1|        pos: IVec2 { x: 5, y: 5 },
  480|      1|        hp: 100,
  481|      1|        team: 1,
  482|      1|        ammo: 0,
  483|      1|    };
  484|      1|    let policy = FovInterest {
  485|      1|        radius: 10,
  486|      1|        half_angle_deg: 45.0,
  487|      1|        facing: IVec2 { x: 0, y: 0 }, // Zero facing
  488|      1|    };
  489|      1|    assert!(policy.include(&viewer, &enemy)); // Should include when facing is zero
  490|      1|}
  491|       |
  492|       |#[test]
  493|      1|fn test_fov_interest_out_of_range() {
  494|       |    use crate::{EntityState, FovInterest};
  495|      1|    let viewer = EntityState {
  496|      1|        id: 1,
  497|      1|        pos: IVec2 { x: 0, y: 0 },
  498|      1|        hp: 100,
  499|      1|        team: 0,
  500|      1|        ammo: 0,
  501|      1|    };
  502|      1|    let far_enemy = EntityState {
  503|      1|        id: 2,
  504|      1|        pos: IVec2 { x: 100, y: 0 },
  505|      1|        hp: 100,
  506|      1|        team: 1,
  507|      1|        ammo: 0,
  508|      1|    };
  509|      1|    let policy = FovInterest {
  510|      1|        radius: 10,
  511|      1|        half_angle_deg: 90.0,
  512|      1|        facing: IVec2 { x: 1, y: 0 },
  513|      1|    };
  514|      1|    assert!(!policy.include(&viewer, &far_enemy)); // Out of range
  515|      1|}
  516|       |
  517|       |#[test]
  518|      1|fn test_fov_los_interest_same_team() {
  519|       |    use crate::{EntityState, FovLosInterest};
  520|      1|    let viewer = EntityState {
  521|      1|        id: 1,
  522|      1|        pos: IVec2 { x: 0, y: 0 },
  523|      1|        hp: 100,
  524|      1|        team: 0,
  525|      1|        ammo: 0,
  526|      1|    };
  527|      1|    let ally = EntityState {
  528|      1|        id: 2,
  529|      1|        pos: IVec2 { x: 50, y: 50 },
  530|      1|        hp: 100,
  531|      1|        team: 0, // Same team
  532|      1|        ammo: 0,
  533|      1|    };
  534|      1|    let policy = FovLosInterest {
  535|      1|        radius: 10,
  536|      1|        half_angle_deg: 45.0,
  537|      1|        facing: IVec2 { x: 1, y: 0 },
  538|      1|        obstacles: std::collections::BTreeSet::new(),
  539|      1|    };
  540|      1|    assert!(policy.include(&viewer, &ally)); // Same team always included
  541|      1|}
  542|       |
  543|       |#[test]
  544|      1|fn test_fov_los_interest_zero_facing() {
  545|       |    use crate::{EntityState, FovLosInterest};
  546|      1|    let viewer = EntityState {
  547|      1|        id: 1,
  548|      1|        pos: IVec2 { x: 0, y: 0 },
  549|      1|        hp: 100,
  550|      1|        team: 0,
  551|      1|        ammo: 0,
  552|      1|    };
  553|      1|    let enemy = EntityState {
  554|      1|        id: 2,
  555|      1|        pos: IVec2 { x: 3, y: 3 },
  556|      1|        hp: 100,
  557|      1|        team: 1,
  558|      1|        ammo: 0,
  559|      1|    };
  560|      1|    let policy = FovLosInterest {
  561|      1|        radius: 10,
  562|      1|        half_angle_deg: 45.0,
  563|      1|        facing: IVec2 { x: 0, y: 0 }, // Zero facing
  564|      1|        obstacles: std::collections::BTreeSet::new(),
  565|      1|    };
  566|      1|    assert!(policy.include(&viewer, &enemy)); // Should use LOS only when facing is zero
  567|      1|}
  568|       |
  569|       |#[test]
  570|      1|fn test_interest_policy_variants() {
  571|       |    use crate::InterestPolicy;
  572|      1|    let policy1 = InterestPolicy::Radius { radius: 10 };
  573|      1|    let policy2 = InterestPolicy::Fov {
  574|      1|        radius: 10,
  575|      1|        half_angle_deg: 45.0,
  576|      1|        facing: IVec2 { x: 1, y: 0 },
  577|      1|    };
  578|      1|    let policy3 = InterestPolicy::FovLos {
  579|      1|        radius: 10,
  580|      1|        half_angle_deg: 45.0,
  581|      1|        facing: IVec2 { x: 1, y: 0 },
  582|      1|    };
  583|       |    // Just test they can be created and cloned
  584|      1|    let _p1 = policy1.clone();
  585|      1|    let _p2 = policy2.clone();
  586|      1|    let _p3 = policy3.clone();
  587|      1|}
  588|       |
  589|       |#[test]
  590|      1|fn test_apply_delta_mismatched_tick() {
  591|       |    use crate::{Delta, Snapshot};
  592|      1|    let mut snap = Snapshot {
  593|      1|        version: 1,
  594|      1|        tick: 5,
  595|      1|        t: 0.5,
  596|      1|        seq: 0,
  597|      1|        world_hash: 0,
  598|      1|        entities: vec![],
  599|      1|    };
  600|      1|    let delta = Delta {
  601|      1|        base_tick: 10, // Mismatched
  602|      1|        tick: 11,
  603|      1|        changed: vec![],
  604|      1|        removed: vec![],
  605|      1|        head_hash: 0,
  606|      1|    };
  607|      1|    apply_delta(&mut snap, &delta);
  608|       |    // Delta should not be applied due to tick mismatch
  609|      1|    assert_eq!(snap.tick, 5);
  610|      1|}
  611|       |
  612|       |#[test]
  613|      1|fn test_apply_delta_creates_new_entity() {
  614|       |    use crate::{Delta, EntityDelta, EntityDeltaMask, EntityState, Snapshot};
  615|      1|    let mut snap = Snapshot {
  616|      1|        version: 1,
  617|      1|        tick: 1,
  618|      1|        t: 0.0,
  619|      1|        seq: 0,
  620|      1|        world_hash: 0,
  621|      1|        entities: vec![],
  622|      1|    };
  623|      1|    let delta = Delta {
  624|      1|        base_tick: 1,
  625|      1|        tick: 2,
  626|      1|        changed: vec![EntityDelta {
  627|      1|            id: 100,
  628|      1|            mask: EntityDeltaMask::POS | EntityDeltaMask::HP | EntityDeltaMask::TEAM | EntityDeltaMask::AMMO,
  629|      1|            pos: Some(IVec2 { x: 10, y: 20 }),
  630|      1|            hp: Some(75),
  631|      1|            team: Some(1),
  632|      1|            ammo: Some(25),
  633|      1|        }],
  634|      1|        removed: vec![],
  635|      1|        head_hash: 12345,
  636|      1|    };
  637|      1|    apply_delta(&mut snap, &delta);
  638|      1|    assert_eq!(snap.tick, 2);
  639|      1|    assert_eq!(snap.entities.len(), 1);
  640|      1|    let entity = &snap.entities[0];
  641|      1|    assert_eq!(entity.id, 100);
  642|      1|    assert_eq!(entity.pos.x, 10);
  643|      1|    assert_eq!(entity.hp, 75);
  644|      1|}
  645|       |
  646|       |#[test]
  647|      1|fn test_diff_snapshots_new_entity() {
  648|       |    use crate::{EntityState, Snapshot};
  649|      1|    let base = Snapshot {
  650|      1|        version: 1,
  651|      1|        tick: 1,
  652|      1|        t: 0.0,
  653|      1|        seq: 0,
  654|      1|        world_hash: 0,
  655|      1|        entities: vec![],
  656|      1|    };
  657|      1|    let head = Snapshot {
  658|      1|        version: 1,
  659|      1|        tick: 2,
  660|      1|        t: 0.0,
  661|      1|        seq: 1,
  662|      1|        world_hash: 0,
  663|      1|        entities: vec![EntityState {
  664|      1|            id: 1,
  665|      1|            pos: IVec2 { x: 5, y: 5 },
  666|      1|            hp: 100,
  667|      1|            team: 0,
  668|      1|            ammo: 10,
  669|      1|        }],
  670|      1|    };
  671|      1|    let viewer = EntityState {
  672|      1|        id: 0,
  673|      1|        pos: IVec2 { x: 0, y: 0 },
  674|      1|        hp: 100,
  675|      1|        team: 0,
  676|      1|        ammo: 0,
  677|      1|    };
  678|      1|    let delta = diff_snapshots(&base, &head, &FullInterest, &viewer);
  679|      1|    assert_eq!(delta.changed.len(), 1);
  680|      1|    assert!(delta.removed.is_empty());
  681|      1|    let change = &delta.changed[0];
  682|      1|    assert_eq!(change.id, 1);
  683|       |    // All fields should be set for a new entity
  684|      1|    assert!(change.pos.is_some());
  685|      1|    assert!(change.hp.is_some());
  686|      1|    assert!(change.team.is_some());
  687|      1|    assert!(change.ammo.is_some());
  688|      1|}
  689|       |
  690|       |#[test]
  691|      1|fn test_diff_snapshots_no_change() {
  692|       |    use crate::EntityState;
  693|      1|    let state = EntityState {
  694|      1|        id: 1,
  695|      1|        pos: IVec2 { x: 5, y: 5 },
  696|      1|        hp: 100,
  697|      1|        team: 0,
  698|      1|        ammo: 10,
  699|      1|    };
  700|      1|    let snap = crate::Snapshot {
  701|      1|        version: 1,
  702|      1|        tick: 1,
  703|      1|        t: 0.0,
  704|      1|        seq: 0,
  705|      1|        world_hash: 0,
  706|      1|        entities: vec![state.clone()],
  707|      1|    };
  708|      1|    let viewer = state.clone();
  709|      1|    let delta = diff_snapshots(&snap, &snap, &FullInterest, &viewer);
  710|      1|    assert!(delta.changed.is_empty());
  711|      1|    assert!(delta.removed.is_empty());
  712|      1|}
  713|       |
  714|       |#[test]
  715|      1|fn test_msg_serialization() {
  716|       |    use crate::Msg;
  717|      1|    let msg = Msg::ClientHello {
  718|      1|        name: "test".to_string(),
  719|      1|        token: Some("dev".to_string()),
  720|      1|        policy: Some("radius".to_string()),
  721|      1|    };
  722|      1|    let json = serde_json::to_string(&msg).unwrap();
  723|      1|    let decoded: Msg = serde_json::from_str(&json).unwrap();
  724|      1|    match decoded {
  725|      1|        Msg::ClientHello { name, token, policy } => {
  726|      1|            assert_eq!(name, "test");
  727|      1|            assert_eq!(token, Some("dev".to_string()));
  728|      1|            assert_eq!(policy, Some("radius".to_string()));
  729|       |        }
  730|      0|        _ => panic!("Wrong variant"),
  731|       |    }
  732|      1|}
  733|       |
  734|       |#[test]
  735|      1|fn test_msg_welcome_serialization() {
  736|       |    use crate::Msg;
  737|      1|    let msg = Msg::ServerWelcome { id: 42 };
  738|      1|    let json = serde_json::to_string(&msg).unwrap();
  739|      1|    let decoded: Msg = serde_json::from_str(&json).unwrap();
  740|      1|    match decoded {
  741|      1|        Msg::ServerWelcome { id } => assert_eq!(id, 42),
  742|      0|        _ => panic!("Wrong variant"),
  743|       |    }
  744|      1|}
  745|       |
  746|       |#[test]
  747|      1|fn test_msg_apply_result_serialization() {
  748|       |    use crate::Msg;
  749|      1|    let msg = Msg::ServerApplyResult {
  750|      1|        ok: false,
  751|      1|        err: Some("Out of bounds".to_string()),
  752|      1|    };
  753|      1|    let json = serde_json::to_string(&msg).unwrap();
  754|      1|    let decoded: Msg = serde_json::from_str(&json).unwrap();
  755|      1|    match decoded {
  756|      1|        Msg::ServerApplyResult { ok, err } => {
  757|      1|            assert!(!ok);
  758|      1|            assert_eq!(err, Some("Out of bounds".to_string()));
  759|       |        }
  760|      0|        _ => panic!("Wrong variant"),
  761|       |    }
  762|      1|}
  763|       |
  764|       |#[test]
  765|      1|fn test_msg_ack_serialization() {
  766|       |    use crate::Msg;
  767|      1|    let msg = Msg::ServerAck {
  768|      1|        seq: 5,
  769|      1|        tick_applied: 100,
  770|      1|    };
  771|      1|    let json = serde_json::to_string(&msg).unwrap();
  772|      1|    let decoded: Msg = serde_json::from_str(&json).unwrap();
  773|      1|    match decoded {
  774|      1|        Msg::ServerAck { seq, tick_applied } => {
  775|      1|            assert_eq!(seq, 5);
  776|      1|            assert_eq!(tick_applied, 100);
  777|       |        }
  778|      0|        _ => panic!("Wrong variant"),
  779|       |    }
  780|      1|}
  781|       |
  782|       |#[test]
  783|      1|fn test_replay_event_serialization() {
  784|       |    use crate::ReplayEvent;
  785|       |    use astraweave_core::{ActionStep, PlanIntent};
  786|      1|    let event = ReplayEvent {
  787|      1|        tick: 50,
  788|      1|        seq: 1,
  789|      1|        actor_id: 5,
  790|      1|        intent: PlanIntent {
  791|      1|            plan_id: "test".to_string(),
  792|      1|            steps: vec![ActionStep::Scan { radius: 10.0 }],
  793|      1|        },
  794|      1|        world_hash: 12345,
  795|      1|    };
  796|      1|    let json = serde_json::to_string(&event).unwrap();
  797|      1|    let decoded: ReplayEvent = serde_json::from_str(&json).unwrap();
  798|      1|    assert_eq!(decoded.tick, 50);
  799|      1|    assert_eq!(decoded.seq, 1);
  800|      1|    assert_eq!(decoded.actor_id, 5);
  801|      1|    assert_eq!(decoded.world_hash, 12345);
  802|      1|}
  803|       |
  804|       |#[test]
  805|      1|fn test_game_server_default() {
  806|       |    use crate::GameServer;
  807|      1|    let server = GameServer::default();
  808|      1|    assert!(server.player_id > 0);
  809|      1|    assert!(server.companion_id > 0);
  810|      1|    assert!(server.enemy_id > 0);
  811|      1|}
  812|       |
  813|       |#[test]
  814|      1|fn test_server_event_clone() {
  815|       |    use crate::{ServerEvent, Snapshot};
  816|      1|    let event = ServerEvent::Snapshot(Snapshot {
  817|      1|        version: 1,
  818|      1|        tick: 1,
  819|      1|        t: 0.0,
  820|      1|        seq: 0,
  821|      1|        world_hash: 0,
  822|      1|        entities: vec![],
  823|      1|    });
  824|      1|    let _cloned = event.clone();
  825|       |
  826|      1|    let result = ServerEvent::ApplyResult {
  827|      1|        ok: true,
  828|      1|        err: None,
  829|      1|    };
  830|      1|    let _cloned_result = result.clone();
  831|       |
  832|      1|    let ack = ServerEvent::Ack {
  833|      1|        seq: 1,
  834|      1|        tick_applied: 10,
  835|      1|    };
  836|      1|    let _cloned_ack = ack.clone();
  837|      1|}