# Feature development workflow

---

## Workflow Steps

### [x] Step: Requirements

Your job is to generate a Product Requirements Document based on the feature description,

First, analyze the provided feature definition and determine unclear aspects. For unclear aspects: - Make informed guesses based on context and industry standards - Only mark with [NEEDS CLARIFICATION: specific question] if: - The choice significantly impacts feature scope or user experience - Multiple reasonable interpretations exist with different implications - No reasonable default exists - Prioritize clarifications by impact: scope > security/privacy > user experience > technical details

Ask up to 5 most priority clarifications to the user. Then, create the document following this template:

```
# Feature Specification: [FEATURE NAME]


## User Stories*


### User Story 1 - [Brief Title]

**Acceptance Scenarios**:

1. **Given** [initial state], **When** [action], **Then** [expected outcome]
2. **Given** [initial state], **When** [action], **Then** [expected outcome]

---

## Requirements*

## Success Criteria*

```

Save the PRD into `c:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\.zencoder\chats\8d391d61-ea96-4b7e-8595-9406b2e34960/requirements.md`.

### [x] Step: Technical Specification

Based on the PRD in `c:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\.zencoder\chats\8d391d61-ea96-4b7e-8595-9406b2e34960/requirements.md`, create a detailed technical specification to be used by a coding agent to implement the feature. Follow this template:

```
# Technical Specification: [FEATURE]

## Technical Context
Language/Version, primary dependencies, etc

## Technical Implementation Brief

Summarize key technical decisions for implementing the feature. Make sure they take into account the existing code as much as possible.

## Source Code Structure

## Contracts

Define addition or changes in data models, DB schemas, APIs, code interfaces etc

## Delivery Phases

Define several incremental deliverables for the feature. Each should be a minimal viable product testable end-to-end.

## Verification Strategy

Define how the coding agent can verify each deliverable it creates. Provide instructions for the agent to perform the verification using available tools (lint/test commands, bash commands) and create helper scripts and tools for more complex result verification.
The verification for each deliverable should be executable by a coding agent using built-in capabilities (lint and test commands from the project, bash commands), pre-generated helper scripts or MCP servers. Research and add to the spec:

- MCP servers that should be installed to help the agent with the verification

- helper scripts that need to be generated in the first phases of the plan to verify complex scenarios that can't be covered by the tests in the project's test framework(s)

- any sample input artifact(s) that are required for verification. Note if these artifacts can be a) generated by the agent; b) discovered by the agent on line; c) must be provided by the user.
```

Save the spec to `c:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\.zencoder\chats\8d391d61-ea96-4b7e-8595-9406b2e34960/spec.md`.

### [x] Step: Implementation Plan

Based on the technical spec in `c:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\.zencoder\chats\8d391d61-ea96-4b7e-8595-9406b2e34960/spec.md`, create a detailed task plan and update `c:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\.zencoder\chats\8d391d61-ea96-4b7e-8595-9406b2e34960/plan.md`. Each task should have task definition, references to contracts to be used/implemented, deliverable definition and verification instructions.

Format each task as

```
### [ ] Step: <task_name>
Task instructions
```

---

## Implementation Tasks

---

## PHASE 1: CRITICAL PATH (Weeks 1-4) - Foundation

### [ ] Task 1.1.1: Investigate & Fix wgpu/egui/winit API Migration

**Priority**: P0 (CRITICAL - Blocks all work)  
**Estimated Effort**: 2-3 days

**Objective**: Fix compilation errors blocking editor build due to API changes in wgpu 25.0.2, egui 0.32, winit 0.30.

**Tasks**:
1. Run `cargo build -p aw_editor` and capture all compilation errors
2. Research API migration guides:
   - wgpu 24.x â†’ 25.0.2 changelog
   - egui 0.31 â†’ 0.32 changelog  
   - winit 0.29 â†’ 0.30 changelog
3. Fix errors in priority order:
   - `viewport/widget.rs` - wgpu surface API changes (SurfaceConfiguration, present modes)
   - `gizmo/rendering.rs` - egui-wgpu RenderPass integration
   - `brdf_preview.rs` - shader compilation (WGSL syntax changes if any)
4. Address deprecation warnings (aim for 0 warnings)

**Contracts**: None (fixes existing code)

**Deliverable**: Editor compiles with `cargo build -p aw_editor --release` returning exit code 0, 0 errors, 0 warnings.

**Verification**:
```bash
cd c:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine
cargo clean -p aw_editor
cargo build -p aw_editor --release
# Expected: "Finished release [optimized] target(s)"
# Exit code: 0
```

---

### [ ] Task 1.1.2: Create Smoke Test Checklist Script

**Priority**: P0 (CRITICAL)  
**Estimated Effort**: 1 day

**Objective**: Create automated smoke test checklist to verify editor functionality after compilation fix.

**Tasks**:
1. Create `tools/aw_editor/smoke_test.md` with 30 test cases:
   - Editor Launch (3 tests)
   - Scene Editing (7 tests)  
   - Undo/Redo (3 tests)
   - Scene Save/Load (3 tests)
   - Play-in-Editor (4 tests)
   - Asset Browser (4 tests)
   - Panel Docking (3 tests)
   - Viewport (3 tests)
2. Document expected behavior for each test case
3. Add manual verification checkbox format

**Contracts**: None (documentation only)

**Deliverable**: `tools/aw_editor/smoke_test.md` with 30 manual test cases.

**Verification**: File exists and contains all 30 tests from spec.md lines 926-973.

---

### [ ] Task 1.1.3: Run Smoke Test & Fix Regressions

**Priority**: P0 (CRITICAL)  
**Estimated Effort**: 2-3 days

**Objective**: Execute smoke test checklist and fix any broken functionality.

**Tasks**:
1. Launch editor: `cargo run -p aw_editor --release`
2. Execute all 30 smoke test cases manually
3. Document failures in `tools/aw_editor/smoke_test_results.md`
4. Fix critical failures (P0: editor crash, scene corruption)
5. Fix high-priority failures (P1: broken gizmos, missing panels)
6. Defer low-priority issues to backlog

**Contracts**: None (fixes existing code)

**Deliverable**: Smoke test passes 30/30 tests. Editor functional for basic workflows.

**Verification**:
```bash
# Manual verification - Run through smoke_test.md checklist
# Expected: All 30 tests pass âœ“
```

---

### [ ] Task 1.2.1: Add egui_dock Dependency & Create PanelType Enum

**Priority**: P1-A (High)  
**Estimated Effort**: 0.5 days

**Objective**: Prepare for panel docking system integration.

**Tasks**:
1. Verify `egui_dock` is in workspace dependencies (Cargo.toml root)
2. Create `tools/aw_editor/src/panel_type.rs`:
   ```rust
   #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
   pub enum PanelType {
       Hierarchy,
       Inspector,
       AssetBrowser,
       Viewport,
       Console,
       Profiler,
       BuildManager,
       SceneStats,
       Transform,
       Performance,
       Charts,
       AdvancedWidgets,
       Graph,
       Animation,
       ThemeManager,
       World,
   }
   
   impl PanelType {
       pub fn title(&self) -> &'static str {
           match self {
               Self::Hierarchy => "Hierarchy",
               Self::Inspector => "Inspector",
               // ... etc
           }
       }
   }
   ```
3. Add `mod panel_type;` to `main.rs`
4. Add `pub use panel_type::PanelType;` to `main.rs`

**Contracts**: `PanelType` enum with 16 variants matching existing panels.

**Deliverable**: `panel_type.rs` file with enum definition.

**Verification**:
```bash
cargo build -p aw_editor
# Expected: Compiles without errors
```

---

### [ ] Task 1.2.2: Refactor EditorApp to Use egui_dock::DockArea

**Priority**: P1-A (High)  
**Estimated Effort**: 2 days

**Objective**: Replace fixed panel layout with flexible docking system.

**Tasks**:
1. Add to `EditorApp` struct in `main.rs`:
   ```rust
   dock_state: egui_dock::DockState<PanelType>,
   ```
2. In `EditorApp::default()`, create initial layout:
   ```rust
   let mut dock_state = egui_dock::DockState::new(vec![PanelType::Viewport]);
   let [left, right] = dock_state.main_surface_mut().split_left(
       egui_dock::NodeIndex::root(), 
       0.2, 
       vec![PanelType::Hierarchy, PanelType::AssetBrowser]
   );
   // ... continue building layout
   ```
3. Create `TabViewer` implementation (see spec.md lines 549-569)
4. Replace `egui::SidePanel` calls in `EditorApp::update()` with:
   ```rust
   egui::CentralPanel::default().show(ctx, |ui| {
       egui_dock::DockArea::new(&mut self.dock_state)
           .show(ctx, &mut TabViewer { app: self });
   });
   ```

**Contracts**: 
- `DockState<PanelType>` field in EditorApp
- `TabViewer` struct implementing `egui_dock::TabViewer`

**Deliverable**: Editor launches with dockable panels. Can drag tabs to reposition.

**Verification**:
```bash
cargo run -p aw_editor --release
# Manual test:
# 1. Drag "Hierarchy" tab to center â†’ splits viewport
# 2. Drag "Inspector" tab to bottom â†’ creates bottom dock
# Expected: Panels dock smoothly, no crashes
```

---

### [ ] Task 1.2.3: Implement Layout Persistence (Save/Load)

**Priority**: P1-A (High)  
**Estimated Effort**: 1.5 days

**Objective**: Save and restore panel layouts across sessions.

**Tasks**:
1. Extend `editor_preferences.rs` with DockLayout contract (spec.md lines 216-229):
   ```rust
   #[derive(Serialize, Deserialize)]
   pub struct EditorPreferences {
       pub layout: DockLayout,
       // ... existing fields
   }
   
   #[derive(Serialize, Deserialize)]
   pub struct DockLayout {
       pub tree: String, // JSON-encoded DockState
   }
   ```
2. Implement `save_layout()` method:
   ```rust
   fn save_layout(&self) -> Result<()> {
       let tree_json = serde_json::to_string(&self.dock_state)?;
       let prefs = EditorPreferences {
           layout: DockLayout { tree: tree_json },
           // ... other fields
       };
       prefs.save()?;
       Ok(())
   }
   ```
3. Implement `load_layout()` method (called in `EditorApp::default()`)
4. Save layout on:
   - Editor exit (in `eframe::App::on_exit()`)
   - File â†’ Save Layout (Ctrl+S)
5. Add "Window" menu:
   - Reset Layout to Default
   - Save Layout As...
   - Load Layout...

**Contracts**: 
- `EditorPreferences` extended with `DockLayout` field
- Layout saved to `.config/aw_editor/editor_layout.ron`

**Deliverable**: Panel layouts persist across sessions.

**Verification**:
```bash
cargo run -p aw_editor --release
# Manual test:
# 1. Drag panels to custom layout
# 2. File â†’ Save Layout
# 3. Close editor
# 4. Relaunch editor
# Expected: Layout restored exactly as saved
```

---

### [ ] Task 1.3.1: Add Orthographic Camera Modes

**Priority**: P1-A (High)  
**Estimated Effort**: 1 day

**Objective**: Support orthographic projections (Top/Front/Side views) in viewport.

**Tasks**:
1. Add to `viewport/camera.rs`:
   ```rust
   #[derive(Clone, Copy, Debug, PartialEq)]
   pub enum CameraMode {
       Perspective,
       Top,    // Ortho looking down -Y
       Front,  // Ortho looking down -Z  
       Side,   // Ortho looking down -X
   }
   
   pub struct ViewportCamera {
       pub mode: CameraMode,
       // ... existing fields
   }
   
   impl ViewportCamera {
       pub fn projection_matrix(&self) -> Mat4 {
           match self.mode {
               CameraMode::Perspective => self.perspective_matrix(),
               _ => self.orthographic_matrix(),
           }
       }
   }
   ```
2. Implement orthographic projection matrix generation
3. Add camera mode dropdown to `viewport/toolbar.rs` (spec.md lines 400-408)

**Contracts**: `CameraMode` enum in `viewport/camera.rs`

**Deliverable**: Viewport supports 4 camera modes (Perspective, Top, Front, Side).

**Verification**:
```bash
cargo run -p aw_editor --release
# Manual test:
# 1. Click camera mode dropdown
# 2. Select "Top (Ortho)"
# Expected: Viewport shows orthographic top-down view
```

---

### [ ] Task 1.3.2: Implement Debug Draw Modes

**Priority**: P1-A (High)  
**Estimated Effort**: 2 days

**Objective**: Add wireframe, collider, and navmesh visualization modes.

**Tasks**:
1. Add to `viewport/widget.rs`:
   ```rust
   pub struct DebugDrawOptions {
       pub wireframe: bool,
       pub show_colliders: bool,
       pub show_navmesh: bool,
   }
   ```
2. Wireframe mode:
   - Modify `viewport/renderer.rs` to create wireframe render pipeline
   - Set `primitive.polygon_mode = wgpu::PolygonMode::Line`
3. Collider mode:
   - Use existing `physics_renderer::PhysicsDebugRenderer`
   - Render collider wireframes in green
4. NavMesh mode:
   - Query `astraweave-nav::NavMesh`
   - Render triangles as wireframe overlay
5. Add toggle buttons to viewport toolbar (spec.md lines 410-412)

**Contracts**: `DebugDrawOptions` struct in `viewport/widget.rs`

**Deliverable**: 3 debug draw modes functional (wireframe, colliders, navmesh).

**Verification**:
```bash
cargo run -p aw_editor --release
# Manual test:
# 1. Toggle wireframe â†’ see mesh edges only
# 2. Toggle colliders â†’ see green boxes/spheres
# 3. Toggle navmesh â†’ see navigation mesh overlay
```

---

### [ ] Task 1.3.3: Add Grid Snapping Configuration

**Priority**: P1-A (High)  
**Estimated Effort**: 0.5 days

**Objective**: Make grid size configurable (0.1, 0.25, 0.5, 1.0, 2.0, 5.0 units).

**Tasks**:
1. Add to `gizmo/snapping.rs`:
   ```rust
   pub struct SnappingConfig {
       pub enabled: bool,
       pub grid_size: f32, // Units
   }
   ```
2. Add grid size dropdown to viewport toolbar
3. Modify gizmo transform operations to snap to grid when enabled:
   ```rust
   if snapping_config.enabled {
       position = (position / grid_size).round() * grid_size;
   }
   ```
4. Update grid renderer to match selected grid size

**Contracts**: `SnappingConfig::grid_size` field

**Deliverable**: Grid size configurable via dropdown, gizmos snap accordingly.

**Verification**:
```bash
cargo run -p aw_editor --release
# Manual test:
# 1. Set grid size to 1.0
# 2. Press G, move entity
# Expected: Entity snaps to integer coordinates (0, 1, 2, ...)
```

---

### [ ] Task 1.3.4: Implement Camera Bookmarks (F1-F12)

**Priority**: P1-A (High)  
**Estimated Effort**: 1 day

**Objective**: Save/restore camera positions with F1-F12 hotkeys.

**Tasks**:
1. Extend `editor_preferences.rs` with camera bookmark contract (spec.md lines 236-243):
   ```rust
   #[derive(Serialize, Deserialize)]
   pub struct ViewportSettings {
       pub camera_bookmarks: [Option<CameraBookmark>; 12],
       // ... other fields
   }
   
   #[derive(Serialize, Deserialize, Clone)]
   pub struct CameraBookmark {
       pub position: glam::Vec3,
       pub rotation: glam::Quat,
   }
   ```
2. Detect F1-F12 keypresses in `viewport/widget.rs`:
   ```rust
   if ctx.input(|i| i.key_pressed(egui::Key::F3)) {
       self.save_camera_bookmark(2); // F3 = index 2
       self.show_toast("ðŸ“· Saved F3");
   }
   ```
3. Detect Shift+F1-F12 to restore bookmarks
4. Show toast notification on save/restore

**Contracts**: `ViewportSettings::camera_bookmarks` field

**Deliverable**: F1-F12 saves camera pose, Shift+F1-F12 restores.

**Verification**:
```bash
cargo run -p aw_editor --release
# Manual test:
# 1. Move camera to position A
# 2. Press F3 â†’ toast shows "ðŸ“· Saved F3"
# 3. Move camera to position B
# 4. Press Shift+F3 â†’ camera returns to position A
```

---

### [ ] Task 1.4.1: Create Project Settings Panel

**Priority**: P1-A (High)  
**Estimated Effort**: 2 days

**Objective**: Create UI for physics layers, input mappings, and tags.

**Tasks**:
1. Create `tools/aw_editor/src/panels/project_settings_panel.rs`
2. Implement contract from spec.md lines 355-388:
   ```rust
   #[derive(Clone, Serialize, Deserialize)]
   pub struct ProjectSettings {
       pub physics: PhysicsSettings,
       pub input: InputSettings,
       pub tags: TagsSettings,
   }
   
   #[derive(Clone, Serialize, Deserialize)]
   pub struct PhysicsSettings {
       pub layers: [String; 32],
       pub collision_matrix: [[bool; 32]; 32],
   }
   
   // ... other structs
   ```
3. Implement UI with 3 tabs:
   - **Physics**: 32 text fields for layer names, 32Ã—32 collision matrix checkboxes
   - **Input**: Table with action name + key binding columns
   - **Tags**: List with Add/Remove/Rename buttons
4. Load/save to `project_settings.ron` in project root
5. Add "Project Settings" to Edit menu

**Contracts**: 
- `ProjectSettings` struct with physics/input/tags fields
- Saved to `project_settings.ron`

**Deliverable**: Project Settings panel accessible from Edit menu.

**Verification**:
```bash
cargo run -p aw_editor --release
# Manual test:
# 1. Edit â†’ Project Settings
# 2. Physics tab â†’ rename layer 0 to "Player"
# 3. Click Save
# Expected: project_settings.ron created with layer[0] = "Player"
```

---

### [ ] Task 1.4.2: Implement Hot-Reload for Project Settings

**Priority**: P1-A (High)  
**Estimated Effort**: 1 day

**Objective**: Apply project settings changes without editor restart.

**Tasks**:
1. Add event channel between editor and runtime:
   ```rust
   enum SettingsEvent {
       PhysicsLayersUpdated([String; 32]),
       InputMappingsUpdated(HashMap<String, KeyCode>),
       TagsUpdated(Vec<String>),
   }
   ```
2. When user clicks "Apply" in Project Settings:
   - Send event to runtime via channel
   - Runtime updates physics layers immediately
3. Test that Play-in-Editor uses updated settings without restart

**Contracts**: `SettingsEvent` enum for editor â†’ runtime communication

**Deliverable**: Settings changes apply instantly during Play-in-Editor.

**Verification**:
```bash
cargo run -p aw_editor --release
# Manual test:
# 1. Project Settings â†’ Input â†’ Add "Jump" = Space
# 2. Click Apply
# 3. Press F5 (Play-in-Editor)
# 4. Press Space
# Expected: Jump action triggers without restarting editor
```

---

## PHASE 2: HIGH-VALUE FEATURES (Weeks 5-8) - Material Editor & Asset Pipeline

### [ ] Task 2.1.1: Create Material Graph Data Structures

**Priority**: P1-B (High)  
**Estimated Effort**: 2 days

**Objective**: Implement core data model for material node graphs.

**Tasks**:
1. Create `tools/aw_editor/src/material/mod.rs`
2. Create `tools/aw_editor/src/material/graph.rs` with contract from spec.md lines 247-302:
   ```rust
   #[derive(Clone, Serialize, Deserialize)]
   pub struct MaterialGraph {
       pub nodes: Vec<MaterialNode>,
       pub edges: Vec<MaterialEdge>,
       pub output_node: NodeId,
   }
   
   #[derive(Clone, Serialize, Deserialize)]
   pub struct MaterialNode {
       pub id: NodeId,
       pub node_type: MaterialNodeType,
       pub position: (f32, f32),
   }
   
   #[derive(Clone, Serialize, Deserialize)]
   pub enum MaterialNodeType {
       TextureSample { texture_path: String, uv_channel: u8 },
       ColorConstant { color: [f32; 4] },
       FloatConstant { value: f32 },
       Vec3Constant { value: [f32; 3] },
       Add, Multiply, Lerp, Clamp,
       PbrOutput {
           base_color: Option<InputSlot>,
           metallic: Option<InputSlot>,
           roughness: Option<InputSlot>,
           normal: Option<InputSlot>,
           emissive: Option<InputSlot>,
       },
   }
   ```
3. Add unit tests for graph creation/serialization

**Contracts**: `MaterialGraph`, `MaterialNode`, `MaterialNodeType` structs

**Deliverable**: Material graph data model complete with tests.

**Verification**:
```bash
cargo test -p aw_editor --lib material::graph
# Expected: All tests pass
```

---

### [ ] Task 2.1.2: Integrate egui_graphs for Node Editor UI

**Priority**: P1-B (High)  
**Estimated Effort**: 3 days

**Objective**: Create visual node graph editor using egui_graphs.

**Tasks**:
1. Create `tools/aw_editor/src/panels/material_editor_panel.rs`
2. Integrate `egui_graphs::GraphEditor`:
   ```rust
   pub struct MaterialEditorPanel {
       graph: MaterialGraph,
       graph_editor: egui_graphs::GraphEditor<MaterialNode>,
   }
   
   impl Panel for MaterialEditorPanel {
       fn show(&mut self, ui: &mut egui::Ui) {
           self.graph_editor.show(ui, &mut self.graph);
       }
   }
   ```
3. Implement node creation via right-click context menu:
   - Show node type list (Texture, Color, Math, PBR)
   - Create node at mouse position
4. Implement wire connections:
   - Drag from output pin â†’ input pin
   - Validate data types (float, vec3, texture)
   - Show error if types incompatible

**Contracts**: `MaterialEditorPanel` implementing `Panel` trait

**Deliverable**: Material editor panel with visual node graph.

**Verification**:
```bash
cargo run -p aw_editor --release
# Manual test:
# 1. Window â†’ Material Editor
# 2. Right-click â†’ Add Node â†’ Color Constant
# 3. Right-click â†’ Add Node â†’ PBR Output
# 4. Drag wire from Color output to PBR base_color input
# Expected: Wire connects, no crash
```

---

### [ ] Task 2.1.3: Implement Material Graph Compiler (WGSL Generation)

**Priority**: P1-B (High)  
**Estimated Effort**: 4 days

**Objective**: Compile MaterialGraph to WGSL fragment shader code.

**Tasks**:
1. Create `tools/aw_editor/src/material/compiler.rs` with contract from spec.md lines 433-474
2. Implement validation:
   ```rust
   fn validate(graph: &MaterialGraph) -> Result<(), CompileError> {
       // Check for cycles (DFS)
       // Check type compatibility  
       // Check output node exists
   }
   ```
3. Implement topological sort:
   ```rust
   fn topological_sort(graph: &MaterialGraph) -> Result<Vec<NodeId>, CompileError> {
       // Kahn's algorithm or DFS-based sort
   }
   ```
4. Implement WGSL code generation:
   ```rust
   fn generate_node_code(node: &MaterialNode) -> Result<String, CompileError> {
       match node.node_type {
           MaterialNodeType::ColorConstant { color } => {
               Ok(format!("let color_{} = vec4<f32>({}, {}, {}, {});", node.id, ...))
           }
           // ... other node types
       }
   }
   ```
5. Add unit tests for:
   - Simple graph (ColorConstant â†’ PbrOutput)
   - Complex graph (10+ nodes)
   - Invalid graphs (cycle, type mismatch)

**Contracts**: 
- `MaterialCompiler::compile()` function
- `CompileError` enum

**Deliverable**: Material compiler generates valid WGSL code from graphs.

**Verification**:
```bash
cargo test -p aw_editor --lib material::compiler
# Expected: All tests pass (spec.md lines 842-891)

# Also test manually:
cargo run -p aw_editor --release
# 1. Create simple material: ColorConstant(red) â†’ PbrOutput.base_color
# 2. Click "Compile"
# 3. Check console for WGSL output
# Expected: Valid WGSL shader code
```

---

### [ ] Task 2.1.4: Integrate PBR Preview with Material Graph

**Priority**: P1-B (High)  
**Estimated Effort**: 2 days

**Objective**: Show real-time PBR preview of compiled materials.

**Tasks**:
1. Enhance `brdf_preview.rs`:
   ```rust
   impl BrdfPreviewWidget {
       pub fn set_material_graph(&mut self, graph: &MaterialGraph) -> Result<()> {
           let wgsl = MaterialCompiler::compile(graph)?;
           self.compile_shader(&wgsl)?;
           self.update_preview();
           Ok(())
       }
   }
   ```
2. Add HDR environment rotation:
   - Detect mouse drag on preview sphere
   - Rotate environment map
3. Integrate into MaterialEditorPanel:
   - Show preview sphere in right panel
   - Update preview on graph changes (debounced to 500ms)

**Contracts**: `BrdfPreviewWidget::set_material_graph()` method

**Deliverable**: Material editor shows live PBR preview.

**Verification**:
```bash
cargo run -p aw_editor --release
# Manual test:
# 1. Material Editor â†’ Create TextureSample("albedo.png") â†’ PbrOutput
# 2. Click Compile
# Expected: Preview sphere shows textured surface within 500ms
```

---

### [ ] Task 2.1.5: Implement Material Asset Save/Load

**Priority**: P1-B (High)  
**Estimated Effort**: 1.5 days

**Objective**: Save materials as `.mat.ron` files, load in asset browser.

**Tasks**:
1. Implement material serialization:
   ```rust
   impl MaterialGraph {
       pub fn save(&self, path: &Path) -> Result<()> {
           let ron = ron::to_string(self)?;
           fs::write(path, ron)?;
           Ok(())
       }
       
       pub fn load(path: &Path) -> Result<Self> {
           let ron = fs::read_to_string(path)?;
           let graph = ron::from_str(&ron)?;
           Ok(graph)
       }
   }
   ```
2. Add "Save Material" button to MaterialEditorPanel
3. Add `.mat.ron` file type to AssetBrowser
4. Implement drag-drop from asset browser to entity:
   - Detect drop on entity in viewport
   - Apply material to entity's renderer component

**Contracts**: Material files saved as `.mat.ron` in RON format

**Deliverable**: Materials save/load, draggable from asset browser.

**Verification**:
```bash
cargo run -p aw_editor --release
# Manual test:
# 1. Create material â†’ Save as "metal.mat.ron"
# 2. Asset Browser â†’ see "metal.mat.ron"
# 3. Drag to entity in viewport
# Expected: Entity's material updates
```

---

### [ ] Task 2.2.1: Create Asset Import Job Queue System

**Priority**: P1-A (High)  
**Estimated Effort**: 3 days

**Objective**: Implement async asset import pipeline with progress tracking.

**Tasks**:
1. Create `tools/aw_editor/src/asset_pipeline/mod.rs`
2. Create `tools/aw_editor/src/asset_pipeline/import_job.rs` with contract from spec.md lines 305-351:
   ```rust
   #[async_trait::async_trait]
   pub trait AssetImporter: Send + Sync {
       fn extensions(&self) -> &[&str];
       async fn import(
           &self,
           source_path: &Path,
           asset_db: &mut AssetDatabase,
           progress: mpsc::Sender<ImportProgress>,
       ) -> Result<PathBuf>;
   }
   
   pub struct AssetImportQueue {
       jobs: Vec<ImportJob>,
       importers: Vec<Box<dyn AssetImporter>>,
       progress_tx: mpsc::Sender<ImportProgress>,
   }
   ```
3. Implement 3 importers:
   - `GltfImporter` (uses `astraweave-render` GLTF loader)
   - `TextureImporter` (PNG/JPG â†’ DDS with mipmaps)
   - `FbxImporter` (converts to GLTF via external tool)
4. Create `panels/asset_import_panel.rs` to show import queue UI

**Contracts**: 
- `AssetImporter` trait
- `AssetImportQueue` struct
- `ImportProgress` event type

**Deliverable**: Asset import system functional with 3 importers.

**Verification**:
```bash
cargo run -p aw_editor --release
# Manual test (once drag-drop implemented in next task):
# 1. Drag test.gltf to asset browser
# 2. Asset Import panel shows progress bar 0% â†’ 100%
# Expected: Asset imported successfully
```

---

### [ ] Task 2.2.2: Implement Drag-Drop Asset Import

**Priority**: P1-A (High)  
**Estimated Effort**: 2 days

**Objective**: Enable drag-drop of files to asset browser for import.

**Tasks**:
1. Modify `panels/asset_browser.rs` to handle file drops:
   ```rust
   impl AssetBrowser {
       fn show(&mut self, ui: &mut egui::Ui) {
           // Detect file drop
           ui.input(|i| {
               for file in &i.raw.dropped_files {
                   if let Some(path) = &file.path {
                       self.enqueue_import(path);
                   }
               }
           });
       }
   }
   ```
2. Enqueue import job when file dropped
3. Show progress bar in asset browser
4. Update asset list when import completes

**Contracts**: None (extends existing AssetBrowser)

**Deliverable**: Drag-drop files to asset browser triggers import.

**Verification**:
```bash
cargo run -p aw_editor --release
# Manual test:
# 1. Drag texture.png from file explorer to asset browser
# Expected: Progress bar appears, texture imports to assets/textures/
```

---

### [ ] Task 2.2.3: Add Asset Organization (Folders, Search, Tags)

**Priority**: P1-A (High)  
**Estimated Effort**: 3 days

**Objective**: Enable folder hierarchy, fuzzy search, and tagging in asset browser.

**Tasks**:
1. Replace flat asset list with tree view:
   ```rust
   egui::ScrollArea::vertical().show(ui, |ui| {
       self.render_folder_tree(ui, &self.root_folder);
   });
   ```
2. Implement drag-drop between folders:
   - Detect drop on folder node
   - Move file on disk to new folder
   - Update AssetDatabase paths
3. Add fuzzy search bar:
   ```rust
   ui.text_edit_singleline(&mut self.search_query);
   let filtered = self.assets.iter().filter(|a| {
       fuzzy_match(&a.name, &self.search_query)
   });
   ```
4. Add tagging system:
   - Right-click asset â†’ Add Tag
   - Tags stored in `.meta` file next to asset
   - Filter by tag

**Contracts**: None (extends AssetBrowser UI)

**Deliverable**: Asset browser has folders, search, and tags.

**Verification**:
```bash
cargo run -p aw_editor --release
# Manual test:
# 1. Asset Browser â†’ Right-click â†’ New Folder "Characters"
# 2. Drag hero.gltf to Characters folder
# 3. Search "hero" â†’ finds hero.gltf
# 4. Right-click hero.gltf â†’ Add Tag "Player"
# Expected: All features work smoothly
```

---

## PHASE 3: PRODUCTIVITY MULTIPLIERS (Weeks 9-12) - Visual Scripting & Profiling

### [ ] Task 3.1.1: Add Behavior Graph UX Enhancements

**Priority**: P1-C (Medium)  
**Estimated Effort**: 2 days

**Objective**: Improve behavior graph editor usability with search, minimap, zoom/pan.

**Tasks**:
1. Add search palette to `behavior_graph::BehaviorGraphEditorUi`:
   ```rust
   // Press Space â†’ show search dialog
   if ui.input_mut(|i| i.consume_key(egui::Modifiers::NONE, egui::Key::Space)) {
       self.show_search_palette = true;
   }
   
   if self.show_search_palette {
       egui::Window::new("Add Node").show(ctx, |ui| {
           ui.text_edit_singleline(&mut self.search_query);
           for node_type in Self::filter_nodes(&self.search_query) {
               if ui.button(node_type.name()).clicked() {
                   self.add_node(node_type);
               }
           }
       });
   }
   ```
2. Add minimap:
   - Render small overview in corner
   - Highlight visible region
3. Add zoom/pan:
   - Mouse wheel = zoom
   - Middle mouse drag = pan

**Contracts**: None (extends existing BehaviorGraphEditorUi)

**Deliverable**: Behavior graph editor has search, minimap, zoom/pan.

**Verification**:
```bash
cargo run -p aw_editor --release
# Manual test:
# 1. Open behavior graph
# 2. Press Space â†’ type "Move" â†’ MoveNode appears
# 3. Mouse wheel â†’ graph zooms in/out
# Expected: All UX features work
```

---

### [ ] Task 3.1.2: Implement Live Debugging for Behavior Graphs

**Priority**: P1-C (Medium)  
**Estimated Effort**: 3 days

**Objective**: Highlight active nodes during Play-in-Editor, show breakpoints.

**Tasks**:
1. Add runtime â†’ editor communication channel:
   ```rust
   pub enum RuntimeEvent {
       NodeExecuting { entity: Entity, node_id: NodeId },
       BreakpointHit { entity: Entity, node_id: NodeId },
   }
   ```
2. In `EditorRuntime`, send events when nodes execute
3. In `BehaviorGraphEditorUi`, highlight active nodes:
   ```rust
   if self.active_nodes.contains(&node.id) {
       node.draw_with_highlight(ui, Color::GREEN);
   }
   ```
4. Add breakpoint system:
   - Right-click node â†’ Add Breakpoint
   - Breakpoints shown as red dot on node
   - Simulation pauses when breakpoint hit

**Contracts**: `RuntimeEvent` enum for runtime â†’ editor communication

**Deliverable**: Behavior graphs show live execution during Play-in-Editor.

**Verification**:
```bash
cargo run -p aw_editor --release
# Manual test:
# 1. Open behavior graph for AI entity
# 2. Right-click MoveNode â†’ Add Breakpoint
# 3. Press F5 (Play-in-Editor)
# Expected: Simulation pauses when MoveNode executes, node highlighted
```

---

### [ ] Task 3.2.1: Enhance Build Manager with Platform Targets

**Priority**: P1-D (Medium)  
**Estimated Effort**: 2 days

**Objective**: Add multi-platform build configuration UI.

**Tasks**:
1. Modify `panels/build_manager.rs`:
   ```rust
   pub struct BuildConfig {
       pub target: PlatformTarget,
       pub optimization: OptimizationLevel,
       pub features: Vec<String>,
   }
   
   pub enum PlatformTarget {
       WindowsX64,
       LinuxX64,
       MacOSArm64,
       WasmWeb,
   }
   
   pub enum OptimizationLevel {
       Debug,
       Release,
       ReleaseLTO,
   }
   ```
2. Add UI dropdowns for target, optimization, features
3. Build button executes:
   ```bash
   cargo build --release --target x86_64-pc-windows-msvc --features profiling,git-integration
   ```
4. Stream output to console panel in real-time

**Contracts**: `BuildConfig` struct with target/optimization/features

**Deliverable**: Build Manager supports multi-platform builds.

**Verification**:
```bash
cargo run -p aw_editor --release
# Manual test:
# 1. Build Manager â†’ Select "Windows Release+LTO"
# 2. Click Build
# Expected: Console shows "cargo build --release --target ... --features lto"
```

---

### [ ] Task 3.2.2: Integrate Tracy Profiler

**Priority**: P1-D (Medium)  
**Estimated Effort**: 3 days

**Objective**: Add Tracy profiler integration with in-editor flamegraph.

**Tasks**:
1. Add `tracy-client` dependency to `Cargo.toml` (behind "profiling" feature)
2. Create `tools/aw_editor/src/profiling/client.rs`:
   ```rust
   pub struct TracyClient {
       client: tracy_client::Client,
   }
   
   impl TracyClient {
       pub fn capture_frame(&mut self) -> FrameData {
           // Collect frame profiling data
       }
   }
   ```
3. Modify `panels/profiler_panel.rs` to render flamegraph:
   ```rust
   egui::plot::Plot::new("flamegraph").show(ui, |plot_ui| {
       // Render bars for each profiling zone
   });
   ```
4. Collect data during Play-in-Editor

**Contracts**: 
- `TracyClient` wrapper around `tracy_client`
- `FrameData` struct with profiling zones

**Deliverable**: Profiler panel shows Tracy flamegraph.

**Verification**:
```bash
cargo run -p aw_editor --release --features profiling
# Manual test:
# 1. Press F5 (Play-in-Editor)
# 2. Profiler panel â†’ Enable Tracy
# Expected: Flamegraph shows ECS/AI/Physics/Rendering zones
```

---

### [ ] Task 3.2.3: Add Performance Budget Warnings

**Priority**: P1-D (Medium)  
**Estimated Effort**: 1 day

**Objective**: Show red/yellow/green indicators when systems exceed 60 FPS budget.

**Tasks**:
1. Define budgets in `profiler_panel.rs`:
   ```rust
   const BUDGETS: &[(&#str, f32)] = &[
       ("ECS", 2.0),      // 2ms
       ("AI", 3.0),       // 3ms
       ("Physics", 3.0),  // 3ms
       ("Rendering", 8.0), // 8ms
   ];
   ```
2. Calculate budget % for each system:
   ```rust
   let usage_pct = (actual_time / budget) * 100.0;
   let color = if usage_pct < 80.0 { GREEN }
               else if usage_pct < 100.0 { YELLOW }
               else { RED };
   ```
3. Render budget bars with color coding

**Contracts**: Performance budget constants

**Deliverable**: Profiler shows budget bars (green/yellow/red).

**Verification**:
```bash
cargo run -p aw_editor --release --features profiling
# Manual test:
# 1. Play-in-Editor with 1000 entities
# 2. Profiler panel â†’ Check budget bars
# Expected: Rendering bar green (<8ms), Physics bar green (<3ms)
```

---

### [ ] Task 3.3.1: Implement Scene Gizmos (Lights, Cameras, Audio)

**Priority**: P1-D (Medium)  
**Estimated Effort**: 4 days

**Objective**: Visualize non-mesh entities with gizmos (lights, cameras, audio sources).

**Tasks**:
1. Create `tools/aw_editor/src/scene_gizmos/mod.rs`
2. Create `scene_gizmos/light_gizmo.rs`:
   ```rust
   pub fn render_point_light(
       ui: &mut egui::Ui,
       position: Vec3,
       range: f32,
       color: Color,
   ) {
       // Render yellow sphere with radius = range
   }
   
   pub fn render_directional_light(
       ui: &mut egui::Ui,
       position: Vec3,
       direction: Vec3,
   ) {
       // Render yellow arrow pointing in direction
   }
   ```
3. Create `scene_gizmos/camera_gizmo.rs`:
   ```rust
   pub fn render_camera_frustum(
       ui: &mut egui::Ui,
       camera: &Camera,
   ) {
       // Render wireframe pyramid showing frustum
   }
   ```
4. Create `scene_gizmos/audio_gizmo.rs`:
   ```rust
   pub fn render_audio_source(
       ui: &mut egui::Ui,
       position: Vec3,
       max_distance: f32,
   ) {
       // Render blue sphere with radius = max_distance
   }
   ```
5. Integrate into `viewport/renderer.rs`:
   - Query entities with Light/Camera/AudioSource components
   - Render corresponding gizmos
   - Make gizmos selectable (click â†’ selects entity)
6. Scale gizmos with camera distance (always same screen size)

**Contracts**: Gizmo rendering functions in `scene_gizmos/` modules

**Deliverable**: Lights, cameras, and audio sources visible as gizmos in viewport.

**Verification**:
```bash
cargo run -p aw_editor --release
# Manual test:
# 1. Add point light to scene
# Expected: Yellow sphere appears at light position
# 2. Click sphere â†’ light entity selected in hierarchy
# 3. Move camera far away â†’ sphere stays same screen size
```

---

## PHASE 4: POLISH & DEFERRED FEATURES (Weeks 13-16+) - OPTIONAL

### [ ] Task 4.1: Animation Timeline (Optional - P2)

**Priority**: P2 (Deferred)  
**Estimated Effort**: 3 weeks

**Objective**: Create keyframe timeline editor for animations.

**Tasks**:
1. Create `panels/timeline_panel.rs`
2. Implement horizontal timeline UI (tracks, keyframes, scrubber)
3. Curve editor for easing (Bezier handles)
4. Animation clip blending
5. Export to `.anim.ron` format

**Note**: Defer unless Phases 1-3 complete ahead of schedule.

---

### [ ] Task 4.2: Particle System Editor (Optional - P2)

**Priority**: P2 (Deferred)  
**Estimated Effort**: 2 weeks

**Objective**: Create particle system editor with GPU preview.

**Tasks**:
1. Integrate `astraweave-render/gpu_particles.rs`
2. Property inspector (rate, lifetime, forces, color gradient)
3. Real-time GPU preview in viewport
4. Save to `.particle.ron` format

**Note**: Defer unless Phases 1-3 complete ahead of schedule.

---

### [ ] Task 4.3: Version Control Integration (Optional - P2)

**Priority**: P2 (Deferred)  
**Estimated Effort**: 2 weeks

**Objective**: Add Git integration with status indicators and diff viewer.

**Tasks**:
1. Add `git2` dependency (behind "git-integration" feature)
2. Show modified/untracked icons in asset browser
3. Diff viewer for `.scene.ron` files
4. Commit dialog

**Note**: Defer unless Phases 1-3 complete ahead of schedule.

---

## Verification & Quality Assurance

### [ ] Task QA-1: Create Automated Test Suite

**Estimated Effort**: Ongoing (1 day per phase)

**Tasks**:
1. Add unit tests for each module (target 80%+ coverage)
2. Add integration tests (spec.md lines 895-922)
3. Run tests after each task:
   ```bash
   cargo test -p aw_editor --all-features
   ```

---

### [ ] Task QA-2: Create Verification Helper Scripts

**Estimated Effort**: 1 day

**Tasks**:
1. Create `tools/aw_editor/verify.sh` (spec.md lines 1016-1041)
2. Create smoke test checklist markdown
3. Run verification script after each phase

---

### [ ] Task QA-3: Generate Test Assets

**Estimated Effort**: 0.5 days

**Tasks**:
1. Generate `assets/textures/test_albedo.png` (512Ã—512 gradient)
2. Generate `assets/meshes/test_cube.gltf` (simple cube)
3. Create `tests/stress_test_1000.scene.ron` (1000 entities)
4. Create `tests/materials/*.mat.ron` (5 test materials)

---

## End of Implementation Plan
