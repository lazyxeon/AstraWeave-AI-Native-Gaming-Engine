C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-physics\src\cloth.rs:
    1|       |//! Cloth Simulation System
    2|       |//!
    3|       |//! Verlet integration-based cloth simulation:
    4|       |//! - Particle system with distance constraints
    5|       |//! - Collision with rigid bodies (spheres, capsules)
    6|       |//! - Wind interaction
    7|       |//! - Pinned particles for attachment points
    8|       |
    9|       |use glam::Vec3;
   10|       |use std::collections::HashMap;
   11|       |
   12|       |/// Unique identifier for cloth instances
   13|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
   14|       |pub struct ClothId(pub u64);
   15|       |
   16|       |/// A particle in the cloth simulation
   17|       |#[derive(Debug, Clone)]
   18|       |pub struct ClothParticle {
   19|       |    /// Current position
   20|       |    pub position: Vec3,
   21|       |    /// Previous position (for Verlet integration)
   22|       |    pub prev_position: Vec3,
   23|       |    /// Accumulated forces this frame
   24|       |    pub acceleration: Vec3,
   25|       |    /// Inverse mass (0 = pinned/infinite mass)
   26|       |    pub inv_mass: f32,
   27|       |    /// Whether this particle is pinned (fixed position)
   28|       |    pub pinned: bool,
   29|       |}
   30|       |
   31|       |impl ClothParticle {
   32|       |    /// Create a new particle
   33|  2.61k|    pub fn new(position: Vec3, mass: f32) -> Self {
   34|       |        Self {
   35|  2.61k|            position,
   36|  2.61k|            prev_position: position,
   37|       |            acceleration: Vec3::ZERO,
   38|  2.61k|            inv_mass: if mass > 0.0 { 1.0 / mass } else { 0.0 },
                                                                        ^0
   39|       |            pinned: false,
   40|       |        }
   41|  2.61k|    }
   42|       |
   43|       |    /// Create a pinned particle
   44|      2|    pub fn pinned(position: Vec3) -> Self {
   45|      2|        Self {
   46|      2|            position,
   47|      2|            prev_position: position,
   48|      2|            acceleration: Vec3::ZERO,
   49|      2|            inv_mass: 0.0,
   50|      2|            pinned: true,
   51|      2|        }
   52|      2|    }
   53|       |
   54|       |    /// Apply force to particle
   55|   122k|    pub fn apply_force(&mut self, force: Vec3) {
   56|   122k|        if !self.pinned {
   57|   109k|            self.acceleration += force * self.inv_mass;
   58|   109k|        }
                      ^12.6k
   59|   122k|    }
   60|       |
   61|       |    /// Integrate using Verlet integration
   62|  52.3k|    pub fn integrate(&mut self, dt: f32, damping: f32) {
   63|  52.3k|        if self.pinned {
   64|  4.54k|            return;
   65|  47.7k|        }
   66|       |
   67|  47.7k|        let velocity = self.position - self.prev_position;
   68|  47.7k|        self.prev_position = self.position;
   69|  47.7k|        self.position += velocity * damping + self.acceleration * dt * dt;
   70|  47.7k|        self.acceleration = Vec3::ZERO;
   71|  52.3k|    }
   72|       |
   73|       |    /// Get velocity
   74|  59.0k|    pub fn velocity(&self) -> Vec3 {
   75|  59.0k|        self.position - self.prev_position
   76|  59.0k|    }
   77|       |}
   78|       |
   79|       |/// A distance constraint between two particles
   80|       |#[derive(Debug, Clone, Copy)]
   81|       |pub struct DistanceConstraint {
   82|       |    /// First particle index
   83|       |    pub p1: usize,
   84|       |    /// Second particle index
   85|       |    pub p2: usize,
   86|       |    /// Rest length
   87|       |    pub rest_length: f32,
   88|       |    /// Stiffness (0-1, higher = stiffer)
   89|       |    pub stiffness: f32,
   90|       |}
   91|       |
   92|       |impl DistanceConstraint {
   93|       |    /// Create a new constraint
   94|  13.4k|    pub fn new(p1: usize, p2: usize, rest_length: f32) -> Self {
   95|  13.4k|        Self {
   96|  13.4k|            p1,
   97|  13.4k|            p2,
   98|  13.4k|            rest_length,
   99|  13.4k|            stiffness: 1.0,
  100|  13.4k|        }
  101|  13.4k|    }
  102|       |
  103|       |    /// Solve the constraint
  104|   716k|    pub fn solve(&self, particles: &mut [ClothParticle]) {
  105|   716k|        let p1 = &particles[self.p1];
  106|   716k|        let p2 = &particles[self.p2];
  107|       |
  108|   716k|        let delta = p2.position - p1.position;
  109|   716k|        let current_length = delta.length();
  110|       |
  111|   716k|        if current_length < 0.0001 {
  112|      0|            return;
  113|   716k|        }
  114|       |
  115|   716k|        let diff = (current_length - self.rest_length) / current_length;
  116|   716k|        let correction = delta * diff * 0.5 * self.stiffness;
  117|       |
  118|   716k|        let w1 = p1.inv_mass;
  119|   716k|        let w2 = p2.inv_mass;
  120|   716k|        let total_weight = w1 + w2;
  121|       |
  122|   716k|        if total_weight > 0.0 {
  123|   698k|            if !particles[self.p1].pinned {
  124|   648k|                particles[self.p1].position += correction * (w1 / total_weight);
  125|   648k|            }
                          ^49.7k
  126|   698k|            if !particles[self.p2].pinned {
  127|   697k|                particles[self.p2].position -= correction * (w2 / total_weight);
  128|   697k|            }
                          ^1.26k
  129|  17.9k|        }
  130|   716k|    }
  131|       |}
  132|       |
  133|       |/// Collision shape for cloth collision
  134|       |#[derive(Debug, Clone, Copy)]
  135|       |pub enum ClothCollider {
  136|       |    /// Sphere collider
  137|       |    Sphere { center: Vec3, radius: f32 },
  138|       |    /// Capsule collider
  139|       |    Capsule {
  140|       |        start: Vec3,
  141|       |        end: Vec3,
  142|       |        radius: f32,
  143|       |    },
  144|       |    /// Infinite plane
  145|       |    Plane { point: Vec3, normal: Vec3 },
  146|       |}
  147|       |
  148|       |impl ClothCollider {
  149|       |    /// Resolve collision with a particle
  150|  25.5k|    pub fn resolve_collision(&self, particle: &mut ClothParticle, friction: f32) {
  151|  25.5k|        if particle.pinned {
  152|    360|            return;
  153|  25.1k|        }
  154|       |
  155|  25.1k|        match *self {
  156|  17.6k|            ClothCollider::Sphere { center, radius } => {
  157|  17.6k|                let to_particle = particle.position - center;
  158|  17.6k|                let dist = to_particle.length();
  159|       |
  160|  17.6k|                if dist < radius {
  161|      1|                    let normal = to_particle.normalize_or_zero();
  162|      1|                    let penetration = radius - dist;
  163|      1|                    particle.position += normal * penetration;
  164|      1|
  165|      1|                    // Apply friction
  166|      1|                    let velocity = particle.velocity();
  167|      1|                    let normal_vel = velocity.dot(normal) * normal;
  168|      1|                    let tangent_vel = velocity - normal_vel;
  169|      1|                    particle.prev_position =
  170|      1|                        particle.position - (normal_vel + tangent_vel * (1.0 - friction));
  171|  17.6k|                }
  172|       |            }
  173|      1|            ClothCollider::Capsule { start, end, radius } => {
  174|      1|                let axis = end - start;
  175|      1|                let axis_length = axis.length();
  176|      1|                if axis_length < 0.0001 {
  177|       |                    // Degenerate capsule = sphere
  178|      0|                    let sphere = ClothCollider::Sphere {
  179|      0|                        center: start,
  180|      0|                        radius,
  181|      0|                    };
  182|      0|                    sphere.resolve_collision(particle, friction);
  183|      0|                    return;
  184|      1|                }
  185|       |
  186|      1|                let axis_dir = axis / axis_length;
  187|      1|                let to_particle = particle.position - start;
  188|      1|                let t = to_particle.dot(axis_dir).clamp(0.0, axis_length);
  189|      1|                let closest = start + axis_dir * t;
  190|       |
  191|      1|                let to_particle = particle.position - closest;
  192|      1|                let dist = to_particle.length();
  193|       |
  194|      1|                if dist < radius {
  195|      1|                    let normal = to_particle.normalize_or_zero();
  196|      1|                    let penetration = radius - dist;
  197|      1|                    particle.position += normal * penetration;
  198|      1|
  199|      1|                    let velocity = particle.velocity();
  200|      1|                    let normal_vel = velocity.dot(normal) * normal;
  201|      1|                    let tangent_vel = velocity - normal_vel;
  202|      1|                    particle.prev_position =
  203|      1|                        particle.position - (normal_vel + tangent_vel * (1.0 - friction));
  204|      1|                }
                              ^0
  205|       |            }
  206|  7.50k|            ClothCollider::Plane { point, normal } => {
  207|  7.50k|                let to_particle = particle.position - point;
  208|  7.50k|                let dist = to_particle.dot(normal);
  209|       |
  210|  7.50k|                if dist < 0.0 {
  211|  6.77k|                    particle.position -= normal * dist;
  212|  6.77k|
  213|  6.77k|                    let velocity = particle.velocity();
  214|  6.77k|                    let normal_vel = velocity.dot(normal) * normal;
  215|  6.77k|                    let tangent_vel = velocity - normal_vel;
  216|  6.77k|                    particle.prev_position =
  217|  6.77k|                        particle.position - (normal_vel + tangent_vel * (1.0 - friction));
  218|  6.77k|                }
                              ^725
  219|       |            }
  220|       |        }
  221|  25.5k|    }
  222|       |}
  223|       |
  224|       |/// Configuration for cloth simulation
  225|       |#[derive(Debug, Clone)]
  226|       |pub struct ClothConfig {
  227|       |    /// Width in particles
  228|       |    pub width: usize,
  229|       |    /// Height in particles
  230|       |    pub height: usize,
  231|       |    /// Spacing between particles
  232|       |    pub spacing: f32,
  233|       |    /// Mass per particle
  234|       |    pub particle_mass: f32,
  235|       |    /// Constraint stiffness (0-1)
  236|       |    pub stiffness: f32,
  237|       |    /// Velocity damping (0-1, lower = more damping)
  238|       |    pub damping: f32,
  239|       |    /// Constraint solver iterations
  240|       |    pub solver_iterations: usize,
  241|       |    /// Gravity
  242|       |    pub gravity: Vec3,
  243|       |    /// Wind force
  244|       |    pub wind: Vec3,
  245|       |    /// Air resistance
  246|       |    pub air_resistance: f32,
  247|       |}
  248|       |
  249|       |impl Default for ClothConfig {
  250|     26|    fn default() -> Self {
  251|     26|        Self {
  252|     26|            width: 20,
  253|     26|            height: 20,
  254|     26|            spacing: 0.1,
  255|     26|            particle_mass: 0.1,
  256|     26|            stiffness: 0.8,
  257|     26|            damping: 0.98,
  258|     26|            solver_iterations: 3,
  259|     26|            gravity: Vec3::new(0.0, -9.81, 0.0),
  260|     26|            wind: Vec3::ZERO,
  261|     26|            air_resistance: 0.01,
  262|     26|        }
  263|     26|    }
  264|       |}
  265|       |
  266|       |/// A cloth instance
  267|       |#[derive(Debug, Clone)]
  268|       |pub struct Cloth {
  269|       |    pub id: ClothId,
  270|       |    pub config: ClothConfig,
  271|       |    pub particles: Vec<ClothParticle>,
  272|       |    pub constraints: Vec<DistanceConstraint>,
  273|       |    pub colliders: Vec<ClothCollider>,
  274|       |    /// Collision friction
  275|       |    pub collision_friction: f32,
  276|       |}
  277|       |
  278|       |impl Cloth {
  279|       |    /// Create a new cloth from config
  280|     29|    pub fn new(id: ClothId, config: ClothConfig, origin: Vec3) -> Self {
  281|     29|        let mut particles = Vec::with_capacity(config.width * config.height);
  282|     29|        let mut constraints = Vec::new();
  283|       |
  284|       |        // Create particles in a grid
  285|    224|        for y in 0..config.height {
                                  ^29
  286|  2.60k|            for x in 0..config.width {
                                      ^224
  287|  2.60k|                let pos = origin
  288|  2.60k|                    + Vec3::new(x as f32 * config.spacing, 0.0, y as f32 * config.spacing);
  289|  2.60k|                particles.push(ClothParticle::new(pos, config.particle_mass));
  290|  2.60k|            }
  291|       |        }
  292|       |
  293|       |        // Create structural constraints (horizontal and vertical)
  294|    224|        for y in 0..config.height {
                                  ^29
  295|  2.60k|            for x in 0..config.width {
                                      ^224
  296|  2.60k|                let idx = y * config.width + x;
  297|       |
  298|       |                // Horizontal constraint
  299|  2.60k|                if x < config.width - 1 {
  300|  2.38k|                    let mut c = DistanceConstraint::new(idx, idx + 1, config.spacing);
  301|  2.38k|                    c.stiffness = config.stiffness;
  302|  2.38k|                    constraints.push(c);
  303|  2.38k|                }
                              ^224
  304|       |
  305|       |                // Vertical constraint
  306|  2.60k|                if y < config.height - 1 {
  307|  2.37k|                    let mut c = DistanceConstraint::new(idx, idx + config.width, config.spacing);
  308|  2.37k|                    c.stiffness = config.stiffness;
  309|  2.37k|                    constraints.push(c);
  310|  2.37k|                }
                              ^225
  311|       |
  312|       |                // Shear constraints (diagonals)
  313|  2.60k|                if x < config.width - 1 && y < config.height - 1 {
                                                         ^2.38k
  314|  2.18k|                    let diag_len = config.spacing * std::f32::consts::SQRT_2;
  315|  2.18k|
  316|  2.18k|                    let mut c1 = DistanceConstraint::new(idx, idx + config.width + 1, diag_len);
  317|  2.18k|                    c1.stiffness = config.stiffness * 0.5;
  318|  2.18k|                    constraints.push(c1);
  319|  2.18k|
  320|  2.18k|                    let mut c2 = DistanceConstraint::new(idx + 1, idx + config.width, diag_len);
  321|  2.18k|                    c2.stiffness = config.stiffness * 0.5;
  322|  2.18k|                    constraints.push(c2);
  323|  2.18k|                }
                              ^420
  324|       |
  325|       |                // Bend constraints (skip one particle)
  326|  2.60k|                if x < config.width - 2 {
  327|  2.15k|                    let mut c =
  328|  2.15k|                        DistanceConstraint::new(idx, idx + 2, config.spacing * 2.0);
  329|  2.15k|                    c.stiffness = config.stiffness * 0.3;
  330|  2.15k|                    constraints.push(c);
  331|  2.15k|                }
                              ^448
  332|  2.60k|                if y < config.height - 2 {
  333|  2.15k|                    let mut c = DistanceConstraint::new(
  334|  2.15k|                        idx,
  335|  2.15k|                        idx + config.width * 2,
  336|  2.15k|                        config.spacing * 2.0,
  337|  2.15k|                    );
  338|  2.15k|                    c.stiffness = config.stiffness * 0.3;
  339|  2.15k|                    constraints.push(c);
  340|  2.15k|                }
                              ^450
  341|       |            }
  342|       |        }
  343|       |
  344|     29|        Self {
  345|     29|            id,
  346|     29|            config,
  347|     29|            particles,
  348|     29|            constraints,
  349|     29|            colliders: Vec::new(),
  350|     29|            collision_friction: 0.5,
  351|     29|        }
  352|     29|    }
  353|       |
  354|       |    /// Pin particles at the top edge
  355|      7|    pub fn pin_top_edge(&mut self) {
  356|     43|        for x in 0..self.config.width {
                                  ^7
  357|     43|            self.particles[x].pinned = true;
  358|     43|            self.particles[x].inv_mass = 0.0;
  359|     43|        }
  360|      7|    }
  361|       |
  362|       |    /// Pin specific corners
  363|      3|    pub fn pin_corners(&mut self) {
  364|      3|        let w = self.config.width;
  365|      3|        let _h = self.config.height;
  366|       |
  367|       |        // Top-left
  368|      3|        self.particles[0].pinned = true;
  369|      3|        self.particles[0].inv_mass = 0.0;
  370|       |
  371|       |        // Top-right
  372|      3|        self.particles[w - 1].pinned = true;
  373|      3|        self.particles[w - 1].inv_mass = 0.0;
  374|      3|    }
  375|       |
  376|       |    /// Pin a specific particle by index
  377|      6|    pub fn pin_particle(&mut self, index: usize) {
  378|      6|        if index < self.particles.len() {
  379|      6|            self.particles[index].pinned = true;
  380|      6|            self.particles[index].inv_mass = 0.0;
  381|      6|        }
                      ^0
  382|      6|    }
  383|       |
  384|       |    /// Unpin a particle
  385|      2|    pub fn unpin_particle(&mut self, index: usize) {
  386|      2|        if index < self.particles.len() {
  387|      2|            self.particles[index].pinned = false;
  388|      2|            self.particles[index].inv_mass = 1.0 / self.config.particle_mass;
  389|      2|        }
                      ^0
  390|      2|    }
  391|       |
  392|       |    /// Move a pinned particle
  393|      2|    pub fn move_pinned(&mut self, index: usize, new_position: Vec3) {
  394|      2|        if index < self.particles.len() && self.particles[index].pinned {
  395|      2|            self.particles[index].position = new_position;
  396|      2|            self.particles[index].prev_position = new_position;
  397|      2|        }
                      ^0
  398|      2|    }
  399|       |
  400|       |    /// Add a collider
  401|      5|    pub fn add_collider(&mut self, collider: ClothCollider) {
  402|      5|        self.colliders.push(collider);
  403|      5|    }
  404|       |
  405|       |    /// Clear all colliders
  406|      1|    pub fn clear_colliders(&mut self) {
  407|      1|        self.colliders.clear();
  408|      1|    }
  409|       |
  410|       |    /// Get particle index from grid position
  411|      8|    pub fn particle_index(&self, x: usize, y: usize) -> Option<usize> {
  412|      8|        if x < self.config.width && y < self.config.height {
                                                  ^6
  413|      6|            Some(y * self.config.width + x)
  414|       |        } else {
  415|      2|            None
  416|       |        }
  417|      8|    }
  418|       |
  419|       |    /// Get particle position
  420|      6|    pub fn particle_position(&self, index: usize) -> Option<Vec3> {
  421|      6|        self.particles.get(index).map(|p| p.position)
  422|      6|    }
  423|       |
  424|       |    /// Calculate cloth normal at a particle (for wind)
  425|  17.7k|    fn particle_normal(&self, x: usize, y: usize) -> Vec3 {
  426|  17.7k|        let idx = y * self.config.width + x;
  427|  17.7k|        let center = self.particles[idx].position;
  428|       |
  429|  17.7k|        let mut normal = Vec3::ZERO;
  430|  17.7k|        let mut count = 0;
  431|       |
  432|       |        // Get neighboring particles for normal calculation
  433|  17.7k|        let neighbors = [
  434|  17.7k|            (x.wrapping_sub(1), y),
  435|  17.7k|            (x + 1, y),
  436|  17.7k|            (x, y.wrapping_sub(1)),
  437|  17.7k|            (x, y + 1),
  438|  17.7k|        ];
  439|       |
  440|  88.7k|        for i in 0..4 {
                          ^71.0k
  441|  71.0k|            let (nx, ny) = neighbors[i];
  442|  71.0k|            let (nx2, ny2) = neighbors[(i + 1) % 4];
  443|       |
  444|  71.0k|            if nx < self.config.width
  445|  63.9k|                && ny < self.config.height
  446|  56.8k|                && nx2 < self.config.width
  447|  50.4k|                && ny2 < self.config.height
  448|  44.0k|            {
  449|  44.0k|                let idx1 = ny * self.config.width + nx;
  450|  44.0k|                let idx2 = ny2 * self.config.width + nx2;
  451|  44.0k|
  452|  44.0k|                let v1 = self.particles[idx1].position - center;
  453|  44.0k|                let v2 = self.particles[idx2].position - center;
  454|  44.0k|                normal += v1.cross(v2);
  455|  44.0k|                count += 1;
  456|  44.0k|            }
                          ^26.9k
  457|       |        }
  458|       |
  459|  17.7k|        if count > 0 {
  460|  16.3k|            normal.normalize_or_zero()
  461|       |        } else {
  462|  1.42k|            Vec3::Y
  463|       |        }
  464|  17.7k|    }
  465|       |
  466|       |    /// Update cloth simulation
  467|  1.28k|    pub fn update(&mut self, dt: f32) {
  468|       |        // Pre-compute normals for wind calculation
  469|  1.28k|        let mut normals = Vec::new();
  470|  1.28k|        if self.config.wind.length_squared() > 0.001 {
  471|  3.55k|            for y in 0..self.config.height {
                                      ^710
  472|  17.7k|                for x in 0..self.config.width {
                                          ^3.55k
  473|  17.7k|                    normals.push(self.particle_normal(x, y));
  474|  17.7k|                }
  475|       |            }
  476|    575|        }
  477|       |
  478|       |        // Apply forces
  479|  7.76k|        for y in 0..self.config.height {
                                  ^1.28k
  480|  52.3k|            for x in 0..self.config.width {
                                      ^7.76k
  481|  52.3k|                let idx = y * self.config.width + x;
  482|  52.3k|                let inv_mass = self.particles[idx].inv_mass;
  483|       |
  484|       |                // Gravity
  485|  52.3k|                let gravity_force = self.config.gravity * (1.0 / inv_mass.max(0.001));
  486|  52.3k|                self.particles[idx].apply_force(gravity_force);
  487|       |
  488|       |                // Wind (affected by particle normal)
  489|  52.3k|                if !normals.is_empty() {
  490|  17.7k|                    let normal = normals[idx];
  491|  17.7k|                    let wind_effect = self.config.wind.dot(normal).abs();
  492|  17.7k|                    let wind_force = self.config.wind * wind_effect * (1.0 / inv_mass.max(0.001));
  493|  17.7k|                    self.particles[idx].apply_force(wind_force);
  494|  34.5k|                }
  495|       |
  496|       |                // Air resistance
  497|  52.3k|                let velocity = self.particles[idx].velocity();
  498|  52.3k|                let drag = -velocity * self.config.air_resistance * (1.0 / inv_mass.max(0.001));
  499|  52.3k|                self.particles[idx].apply_force(drag);
  500|       |            }
  501|       |        }
  502|       |
  503|       |        // Integrate
  504|  53.5k|        for particle in &mut self.particles {
                          ^52.3k
  505|  52.3k|            particle.integrate(dt, self.config.damping);
  506|  52.3k|        }
  507|       |
  508|       |        // Solve constraints
  509|  1.28k|        for _ in 0..self.config.solver_iterations {
  510|   720k|            for constraint in &self.constraints {
                              ^716k
  511|   716k|                constraint.solve(&mut self.particles);
  512|   716k|            }
  513|       |        }
  514|       |
  515|       |        // Resolve collisions
  516|  53.5k|        for particle in &mut self.particles {
                          ^52.3k
  517|  77.8k|            for collider in &self.colliders {
                              ^25.5k
  518|  25.5k|                collider.resolve_collision(particle, self.collision_friction);
  519|  25.5k|            }
  520|       |        }
  521|  1.28k|    }
  522|       |
  523|       |    /// Get all particle positions as a flat array
  524|      1|    pub fn get_positions(&self) -> Vec<Vec3> {
  525|      1|        self.particles.iter().map(|p| p.position).collect()
  526|      1|    }
  527|       |
  528|       |    /// Get triangle indices for rendering
  529|      2|    pub fn get_indices(&self) -> Vec<u32> {
  530|      2|        let mut indices = Vec::new();
  531|      2|        let w = self.config.width as u32;
  532|       |
  533|      5|        for y in 0..(self.config.height - 1) as u32 {
                                  ^2
  534|     13|            for x in 0..(self.config.width - 1) as u32 {
                                      ^5
  535|     13|                let idx = y * w + x;
  536|     13|
  537|     13|                // First triangle
  538|     13|                indices.push(idx);
  539|     13|                indices.push(idx + 1);
  540|     13|                indices.push(idx + w);
  541|     13|
  542|     13|                // Second triangle
  543|     13|                indices.push(idx + 1);
  544|     13|                indices.push(idx + w + 1);
  545|     13|                indices.push(idx + w);
  546|     13|            }
  547|       |        }
  548|       |
  549|      2|        indices
  550|      2|    }
  551|       |
  552|       |    /// Get particle count
  553|      1|    pub fn particle_count(&self) -> usize {
  554|      1|        self.particles.len()
  555|      1|    }
  556|       |
  557|       |    /// Get constraint count
  558|      1|    pub fn constraint_count(&self) -> usize {
  559|      1|        self.constraints.len()
  560|      1|    }
  561|       |}
  562|       |
  563|       |/// Manager for multiple cloth simulations
  564|       |#[derive(Debug, Default)]
  565|       |pub struct ClothManager {
  566|       |    cloths: HashMap<ClothId, Cloth>,
  567|       |    next_id: u64,
  568|       |}
  569|       |
  570|       |impl ClothManager {
  571|       |    /// Create a new cloth manager
  572|      4|    pub fn new() -> Self {
  573|      4|        Self {
  574|      4|            cloths: HashMap::new(),
  575|      4|            next_id: 1,
  576|      4|        }
  577|      4|    }
  578|       |
  579|       |    /// Create a new cloth
  580|      7|    pub fn create(&mut self, config: ClothConfig, origin: Vec3) -> ClothId {
  581|      7|        let id = ClothId(self.next_id);
  582|      7|        self.next_id += 1;
  583|      7|        self.cloths.insert(id, Cloth::new(id, config, origin));
  584|      7|        id
  585|      7|    }
  586|       |
  587|       |    /// Remove a cloth
  588|      4|    pub fn remove(&mut self, id: ClothId) -> bool {
  589|      4|        self.cloths.remove(&id).is_some()
  590|      4|    }
  591|       |
  592|       |    /// Get a cloth
  593|      4|    pub fn get(&self, id: ClothId) -> Option<&Cloth> {
  594|      4|        self.cloths.get(&id)
  595|      4|    }
  596|       |
  597|       |    /// Get a mutable cloth
  598|      1|    pub fn get_mut(&mut self, id: ClothId) -> Option<&mut Cloth> {
  599|      1|        self.cloths.get_mut(&id)
  600|      1|    }
  601|       |
  602|       |    /// Update all cloths
  603|      2|    pub fn update(&mut self, dt: f32) {
  604|      3|        for cloth in self.cloths.values_mut() {
                                   ^2          ^2
  605|      3|            cloth.update(dt);
  606|      3|        }
  607|      2|    }
  608|       |
  609|       |    /// Get cloth count
  610|      5|    pub fn count(&self) -> usize {
  611|      5|        self.cloths.len()
  612|      5|    }
  613|       |
  614|       |    /// Iterate over all cloths
  615|      2|    pub fn iter(&self) -> impl Iterator<Item = &Cloth> {
  616|      2|        self.cloths.values()
  617|      2|    }
  618|       |}
  619|       |
  620|       |// ============================================================================
  621|       |// Unit Tests
  622|       |// ============================================================================
  623|       |
  624|       |#[cfg(test)]
  625|       |mod tests {
  626|       |    use super::*;
  627|       |
  628|       |    #[test]
  629|      1|    fn test_particle_creation() {
  630|      1|        let particle = ClothParticle::new(Vec3::new(1.0, 2.0, 3.0), 0.5);
  631|      1|        assert_eq!(particle.position, Vec3::new(1.0, 2.0, 3.0));
  632|      1|        assert_eq!(particle.inv_mass, 2.0); // 1/0.5
  633|      1|        assert!(!particle.pinned);
  634|      1|    }
  635|       |
  636|       |    #[test]
  637|      1|    fn test_pinned_particle() {
  638|      1|        let particle = ClothParticle::pinned(Vec3::ZERO);
  639|      1|        assert!(particle.pinned);
  640|      1|        assert_eq!(particle.inv_mass, 0.0);
  641|      1|    }
  642|       |
  643|       |    #[test]
  644|      1|    fn test_particle_force() {
  645|      1|        let mut particle = ClothParticle::new(Vec3::ZERO, 1.0);
  646|      1|        particle.apply_force(Vec3::new(10.0, 0.0, 0.0));
  647|      1|        assert_eq!(particle.acceleration, Vec3::new(10.0, 0.0, 0.0));
  648|      1|    }
  649|       |
  650|       |    #[test]
  651|      1|    fn test_pinned_particle_no_force() {
  652|      1|        let mut particle = ClothParticle::pinned(Vec3::ZERO);
  653|      1|        particle.apply_force(Vec3::new(10.0, 0.0, 0.0));
  654|      1|        assert_eq!(particle.acceleration, Vec3::ZERO);
  655|      1|    }
  656|       |
  657|       |    #[test]
  658|      1|    fn test_particle_integrate() {
  659|      1|        let mut particle = ClothParticle::new(Vec3::ZERO, 1.0);
  660|      1|        particle.apply_force(Vec3::new(0.0, -10.0, 0.0)); // Gravity-like
  661|       |
  662|      1|        particle.integrate(0.016, 1.0);
  663|       |
  664|       |        // Should have moved downward
  665|      1|        assert!(particle.position.y < 0.0);
  666|      1|    }
  667|       |
  668|       |    #[test]
  669|      1|    fn test_distance_constraint() {
  670|      1|        let mut particles = vec![
  671|      1|            ClothParticle::new(Vec3::new(0.0, 0.0, 0.0), 1.0),
  672|      1|            ClothParticle::new(Vec3::new(2.0, 0.0, 0.0), 1.0), // Too far apart
  673|       |        ];
  674|       |
  675|      1|        let constraint = DistanceConstraint::new(0, 1, 1.0); // Rest length = 1
  676|       |
  677|      1|        constraint.solve(&mut particles);
  678|       |
  679|       |        // Particles should have moved closer
  680|      1|        let dist = (particles[1].position - particles[0].position).length();
  681|      1|        assert!(dist < 2.0, "Particles should be closer after constraint");
                                          ^0
  682|      1|    }
  683|       |
  684|       |    #[test]
  685|      1|    fn test_cloth_creation() {
  686|      1|        let config = ClothConfig {
  687|      1|            width: 5,
  688|      1|            height: 5,
  689|      1|            spacing: 0.1,
  690|      1|            ..Default::default()
  691|      1|        };
  692|       |
  693|      1|        let cloth = Cloth::new(ClothId(1), config, Vec3::ZERO);
  694|       |
  695|      1|        assert_eq!(cloth.particle_count(), 25);
  696|      1|        assert!(cloth.constraint_count() > 0);
  697|      1|    }
  698|       |
  699|       |    #[test]
  700|      1|    fn test_cloth_pin_top_edge() {
  701|      1|        let config = ClothConfig {
  702|      1|            width: 5,
  703|      1|            height: 5,
  704|      1|            ..Default::default()
  705|      1|        };
  706|       |
  707|      1|        let mut cloth = Cloth::new(ClothId(1), config, Vec3::ZERO);
  708|      1|        cloth.pin_top_edge();
  709|       |
  710|       |        // All particles in first row should be pinned
  711|      6|        for x in 0..5 {
                          ^5
  712|      5|            assert!(cloth.particles[x].pinned);
  713|       |        }
  714|      1|    }
  715|       |
  716|       |    #[test]
  717|      1|    fn test_cloth_pin_corners() {
  718|      1|        let config = ClothConfig {
  719|      1|            width: 5,
  720|      1|            height: 5,
  721|      1|            ..Default::default()
  722|      1|        };
  723|       |
  724|      1|        let mut cloth = Cloth::new(ClothId(1), config, Vec3::ZERO);
  725|      1|        cloth.pin_corners();
  726|       |
  727|      1|        assert!(cloth.particles[0].pinned); // Top-left
  728|      1|        assert!(cloth.particles[4].pinned); // Top-right
  729|      1|    }
  730|       |
  731|       |    #[test]
  732|      1|    fn test_cloth_move_pinned() {
  733|      1|        let config = ClothConfig::default();
  734|      1|        let mut cloth = Cloth::new(ClothId(1), config, Vec3::ZERO);
  735|      1|        cloth.pin_particle(0);
  736|       |
  737|      1|        let new_pos = Vec3::new(5.0, 5.0, 5.0);
  738|      1|        cloth.move_pinned(0, new_pos);
  739|       |
  740|      1|        assert_eq!(cloth.particles[0].position, new_pos);
  741|      1|    }
  742|       |
  743|       |    #[test]
  744|      1|    fn test_sphere_collider() {
  745|      1|        let collider = ClothCollider::Sphere {
  746|      1|            center: Vec3::ZERO,
  747|      1|            radius: 1.0,
  748|      1|        };
  749|       |
  750|      1|        let mut particle = ClothParticle::new(Vec3::new(0.5, 0.0, 0.0), 1.0);
  751|      1|        collider.resolve_collision(&mut particle, 0.5);
  752|       |
  753|       |        // Particle should be pushed out of sphere
  754|      1|        let dist = particle.position.length();
  755|      1|        assert!(dist >= 0.99, "Particle should be at or outside sphere surface");
                                            ^0
  756|      1|    }
  757|       |
  758|       |    #[test]
  759|      1|    fn test_plane_collider() {
  760|      1|        let collider = ClothCollider::Plane {
  761|      1|            point: Vec3::ZERO,
  762|      1|            normal: Vec3::Y,
  763|      1|        };
  764|       |
  765|      1|        let mut particle = ClothParticle::new(Vec3::new(0.0, -0.5, 0.0), 1.0);
  766|      1|        collider.resolve_collision(&mut particle, 0.5);
  767|       |
  768|       |        // Particle should be above plane
  769|      1|        assert!(particle.position.y >= 0.0);
  770|      1|    }
  771|       |
  772|       |    #[test]
  773|      1|    fn test_cloth_update_gravity() {
  774|      1|        let config = ClothConfig {
  775|      1|            width: 3,
  776|      1|            height: 3,
  777|      1|            gravity: Vec3::new(0.0, -10.0, 0.0),
  778|      1|            ..Default::default()
  779|      1|        };
  780|       |
  781|      1|        let mut cloth = Cloth::new(ClothId(1), config, Vec3::ZERO);
  782|       |
  783|       |        // Get initial Y of unpinned particle
  784|      1|        let initial_y = cloth.particles[4].position.y; // Center particle
  785|       |
  786|       |        // Update
  787|      1|        cloth.update(0.016);
  788|       |
  789|       |        // Should have fallen
  790|      1|        assert!(cloth.particles[4].position.y < initial_y);
  791|      1|    }
  792|       |
  793|       |    #[test]
  794|      1|    fn test_cloth_with_wind() {
  795|      1|        let config = ClothConfig {
  796|      1|            width: 5,
  797|      1|            height: 5,
  798|      1|            wind: Vec3::new(10.0, 0.0, 0.0),
  799|      1|            ..Default::default()
  800|      1|        };
  801|       |
  802|      1|        let mut cloth = Cloth::new(ClothId(1), config, Vec3::ZERO);
  803|      1|        cloth.pin_top_edge();
  804|       |
  805|      1|        let initial_x = cloth.particles[12].position.x; // Middle particle
  806|       |
  807|       |        // Multiple updates
  808|     11|        for _ in 0..10 {
  809|     10|            cloth.update(0.016);
  810|     10|        }
  811|       |
  812|       |        // Should have moved in wind direction
  813|      1|        assert!(cloth.particles[12].position.x > initial_x);
  814|      1|    }
  815|       |
  816|       |    #[test]
  817|      1|    fn test_cloth_indices() {
  818|      1|        let config = ClothConfig {
  819|      1|            width: 3,
  820|      1|            height: 3,
  821|      1|            ..Default::default()
  822|      1|        };
  823|       |
  824|      1|        let cloth = Cloth::new(ClothId(1), config, Vec3::ZERO);
  825|      1|        let indices = cloth.get_indices();
  826|       |
  827|       |        // 3x3 grid = 2x2 quads = 4 quads × 2 triangles × 3 indices = 24 indices
  828|      1|        assert_eq!(indices.len(), 24);
  829|      1|    }
  830|       |
  831|       |    #[test]
  832|      1|    fn test_cloth_manager() {
  833|      1|        let mut manager = ClothManager::new();
  834|       |
  835|      1|        let id = manager.create(ClothConfig::default(), Vec3::ZERO);
  836|      1|        assert_eq!(manager.count(), 1);
  837|       |
  838|      1|        assert!(manager.get(id).is_some());
  839|      1|        assert!(manager.remove(id));
  840|      1|        assert_eq!(manager.count(), 0);
  841|      1|    }
  842|       |
  843|       |    #[test]
  844|      1|    fn test_cloth_manager_update() {
  845|      1|        let mut manager = ClothManager::new();
  846|       |
  847|      1|        manager.create(
  848|      1|            ClothConfig {
  849|      1|                width: 3,
  850|      1|                height: 3,
  851|      1|                ..Default::default()
  852|      1|            },
  853|       |            Vec3::ZERO,
  854|       |        );
  855|       |
  856|       |        // Should not panic
  857|      1|        manager.update(0.016);
  858|      1|    }
  859|       |
  860|       |    #[test]
  861|      1|    fn test_capsule_collider() {
  862|      1|        let collider = ClothCollider::Capsule {
  863|      1|            start: Vec3::new(0.0, 0.0, 0.0),
  864|      1|            end: Vec3::new(0.0, 2.0, 0.0),
  865|      1|            radius: 0.5,
  866|      1|        };
  867|       |
  868|      1|        let mut particle = ClothParticle::new(Vec3::new(0.2, 1.0, 0.0), 1.0);
  869|      1|        collider.resolve_collision(&mut particle, 0.5);
  870|       |
  871|       |        // Particle should be pushed out of capsule
  872|      1|        let dist_from_axis = Vec3::new(particle.position.x, 0.0, particle.position.z).length();
  873|      1|        assert!(
  874|      1|            dist_from_axis >= 0.49,
  875|      0|            "Particle should be at capsule surface"
  876|       |        );
  877|      1|    }
  878|       |
  879|       |    #[test]
  880|      1|    fn test_particle_index() {
  881|      1|        let config = ClothConfig {
  882|      1|            width: 5,
  883|      1|            height: 4,
  884|      1|            ..Default::default()
  885|      1|        };
  886|       |
  887|      1|        let cloth = Cloth::new(ClothId(1), config, Vec3::ZERO);
  888|       |
  889|      1|        assert_eq!(cloth.particle_index(0, 0), Some(0));
  890|      1|        assert_eq!(cloth.particle_index(4, 0), Some(4));
  891|      1|        assert_eq!(cloth.particle_index(0, 1), Some(5));
  892|      1|        assert_eq!(cloth.particle_index(4, 3), Some(19));
  893|      1|        assert_eq!(cloth.particle_index(5, 0), None); // Out of bounds
  894|      1|    }
  895|       |
  896|       |    #[test]
  897|      1|    fn test_cloth_damping() {
  898|      1|        let config = ClothConfig {
  899|      1|            width: 3,
  900|      1|            height: 3,
  901|      1|            damping: 0.5, // Heavy damping
  902|      1|            gravity: Vec3::ZERO,
  903|      1|            ..Default::default()
  904|      1|        };
  905|       |
  906|      1|        let mut cloth = Cloth::new(ClothId(1), config, Vec3::ZERO);
  907|       |
  908|       |        // Give a particle some velocity
  909|      1|        cloth.particles[4].prev_position = cloth.particles[4].position - Vec3::X;
  910|       |
  911|      1|        cloth.update(0.016);
  912|       |
  913|       |        // Velocity should be reduced due to damping
  914|      1|        let velocity = cloth.particles[4].velocity();
  915|      1|        assert!(velocity.length() < 1.0);
  916|      1|    }
  917|       |
  918|       |    #[test]
  919|      1|    fn test_constraint_stiffness() {
  920|       |        // Low stiffness constraint
  921|      1|        let mut particles_soft = vec![
  922|      1|            ClothParticle::new(Vec3::ZERO, 1.0),
  923|      1|            ClothParticle::new(Vec3::new(2.0, 0.0, 0.0), 1.0),
  924|       |        ];
  925|      1|        let mut constraint_soft = DistanceConstraint::new(0, 1, 1.0);
  926|      1|        constraint_soft.stiffness = 0.1;
  927|      1|        constraint_soft.solve(&mut particles_soft);
  928|       |
  929|       |        // High stiffness constraint
  930|      1|        let mut particles_stiff = vec![
  931|      1|            ClothParticle::new(Vec3::ZERO, 1.0),
  932|      1|            ClothParticle::new(Vec3::new(2.0, 0.0, 0.0), 1.0),
  933|       |        ];
  934|      1|        let mut constraint_stiff = DistanceConstraint::new(0, 1, 1.0);
  935|      1|        constraint_stiff.stiffness = 1.0;
  936|      1|        constraint_stiff.solve(&mut particles_stiff);
  937|       |
  938|      1|        let dist_soft = (particles_soft[1].position - particles_soft[0].position).length();
  939|      1|        let dist_stiff = (particles_stiff[1].position - particles_stiff[0].position).length();
  940|       |
  941|       |        // Stiff constraint should correct more
  942|      1|        assert!(dist_stiff < dist_soft);
  943|      1|    }
  944|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-physics\src\destruction.rs:
    1|       |//! Destruction System
    2|       |//!
    3|       |//! Provides physics-based destruction for breakable objects:
    4|       |//! - Pre-fractured mesh system (swap intact → debris)
    5|       |//! - Structural integrity (health-based breaking)
    6|       |//! - Debris generation and lifetime
    7|       |//! - Force-based destruction triggers
    8|       |
    9|       |use glam::Vec3;
   10|       |use std::collections::HashMap;
   11|       |
   12|       |/// Unique identifier for destructible objects
   13|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
   14|       |pub struct DestructibleId(pub u64);
   15|       |
   16|       |/// Unique identifier for debris pieces
   17|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
   18|       |pub struct DebrisId(pub u64);
   19|       |
   20|       |/// Shape of debris pieces
   21|       |#[derive(Debug, Clone, Copy, PartialEq)]
   22|       |pub enum DebrisShape {
   23|       |    /// Box-shaped debris
   24|       |    Box { half_extents: Vec3 },
   25|       |    /// Spherical debris
   26|       |    Sphere { radius: f32 },
   27|       |    /// Convex hull (represented as box for simplicity)
   28|       |    ConvexHull { half_extents: Vec3 },
   29|       |}
   30|       |
   31|       |impl Default for DebrisShape {
   32|    368|    fn default() -> Self {
   33|    368|        Self::Box {
   34|    368|            half_extents: Vec3::splat(0.2),
   35|    368|        }
   36|    368|    }
   37|       |}
   38|       |
   39|       |/// Configuration for a debris piece
   40|       |#[derive(Debug, Clone)]
   41|       |pub struct DebrisConfig {
   42|       |    /// Shape of the debris
   43|       |    pub shape: DebrisShape,
   44|       |    /// Relative position from object center
   45|       |    pub local_position: Vec3,
   46|       |    /// Mass of debris piece
   47|       |    pub mass: f32,
   48|       |    /// Initial velocity multiplier (from destruction force)
   49|       |    pub velocity_factor: f32,
   50|       |    /// Angular velocity multiplier
   51|       |    pub angular_velocity_factor: f32,
   52|       |    /// Lifetime in seconds (0 = permanent)
   53|       |    pub lifetime: f32,
   54|       |    /// Whether debris can cause secondary destruction
   55|       |    pub can_damage: bool,
   56|       |    /// Damage amount if hits another destructible
   57|       |    pub damage_on_hit: f32,
   58|       |}
   59|       |
   60|       |impl Default for DebrisConfig {
   61|    368|    fn default() -> Self {
   62|    368|        Self {
   63|    368|            shape: DebrisShape::default(),
   64|    368|            local_position: Vec3::ZERO,
   65|    368|            mass: 1.0,
   66|    368|            velocity_factor: 1.0,
   67|    368|            angular_velocity_factor: 0.5,
   68|    368|            lifetime: 10.0,
   69|    368|            can_damage: false,
   70|    368|            damage_on_hit: 0.0,
   71|    368|        }
   72|    368|    }
   73|       |}
   74|       |
   75|       |/// Fracture pattern for pre-fractured meshes
   76|       |#[derive(Debug, Clone)]
   77|       |pub struct FracturePattern {
   78|       |    /// Debris pieces that make up this object when broken
   79|       |    pub debris: Vec<DebrisConfig>,
   80|       |    /// Center of mass for the intact object
   81|       |    pub center_of_mass: Vec3,
   82|       |}
   83|       |
   84|       |impl FracturePattern {
   85|       |    /// Create a simple uniform fracture pattern
   86|     31|    pub fn uniform(piece_count: usize, object_half_extents: Vec3, mass: f32) -> Self {
   87|     31|        let mut debris = Vec::with_capacity(piece_count);
   88|     31|        let piece_mass = mass / piece_count as f32;
   89|       |
   90|       |        // Create a simple grid of debris
   91|     31|        let pieces_per_axis = (piece_count as f32).cbrt().ceil() as i32;
   92|     31|        let piece_size = object_half_extents * 2.0 / pieces_per_axis as f32;
   93|       |
   94|     66|        for x in 0..pieces_per_axis {
                                  ^31
   95|    144|            for y in 0..pieces_per_axis {
                                      ^66
   96|    283|                for z in 0..pieces_per_axis {
                                          ^144
   97|    283|                    if debris.len() >= piece_count {
   98|     28|                        break;
   99|    255|                    }
  100|       |
  101|    255|                    let local_pos = Vec3::new(
  102|    255|                        (x as f32 + 0.5) * piece_size.x - object_half_extents.x,
  103|    255|                        (y as f32 + 0.5) * piece_size.y - object_half_extents.y,
  104|    255|                        (z as f32 + 0.5) * piece_size.z - object_half_extents.z,
  105|       |                    );
  106|       |
  107|    255|                    debris.push(DebrisConfig {
  108|    255|                        shape: DebrisShape::Box {
  109|    255|                            half_extents: piece_size * 0.4,
  110|    255|                        },
  111|    255|                        local_position: local_pos,
  112|    255|                        mass: piece_mass,
  113|    255|                        ..Default::default()
  114|    255|                    });
  115|       |                }
  116|       |            }
  117|       |        }
  118|       |
  119|     31|        Self {
  120|     31|            debris,
  121|     31|            center_of_mass: Vec3::ZERO,
  122|     31|        }
  123|     31|    }
  124|       |
  125|       |    /// Create a radial fracture pattern (for explosions)
  126|      3|    pub fn radial(piece_count: usize, radius: f32, mass: f32) -> Self {
  127|      3|        let mut debris = Vec::with_capacity(piece_count);
  128|      3|        let piece_mass = mass / piece_count as f32;
  129|       |
  130|       |        // Golden angle distribution for even spacing
  131|      3|        let golden_angle = std::f32::consts::PI * (3.0 - (5.0_f32).sqrt());
  132|       |
  133|     48|        for i in 0..piece_count {
                                  ^3
  134|     48|            let t = i as f32 / piece_count as f32;
  135|     48|            let inclination = (1.0 - 2.0 * t).acos();
  136|     48|            let azimuth = golden_angle * i as f32;
  137|     48|
  138|     48|            let local_pos = Vec3::new(
  139|     48|                inclination.sin() * azimuth.cos() * radius * 0.8,
  140|     48|                inclination.cos() * radius * 0.8,
  141|     48|                inclination.sin() * azimuth.sin() * radius * 0.8,
  142|     48|            );
  143|     48|
  144|     48|            debris.push(DebrisConfig {
  145|     48|                shape: DebrisShape::Sphere {
  146|     48|                    radius: radius * 0.15,
  147|     48|                },
  148|     48|                local_position: local_pos,
  149|     48|                mass: piece_mass,
  150|     48|                velocity_factor: 1.5, // Radial patterns fly outward faster
  151|     48|                ..Default::default()
  152|     48|            });
  153|     48|        }
  154|       |
  155|      3|        Self {
  156|      3|            debris,
  157|      3|            center_of_mass: Vec3::ZERO,
  158|      3|        }
  159|      3|    }
  160|       |
  161|       |    /// Create a layered fracture pattern (for walls)
  162|      4|    pub fn layered(layers: usize, pieces_per_layer: usize, half_extents: Vec3, mass: f32) -> Self {
  163|      4|        let total_pieces = layers * pieces_per_layer;
  164|      4|        let mut debris = Vec::with_capacity(total_pieces);
  165|      4|        let piece_mass = mass / total_pieces as f32;
  166|       |
  167|      4|        let layer_height = half_extents.y * 2.0 / layers as f32;
  168|       |
  169|     13|        for layer in 0..layers {
                                      ^4
  170|     13|            let y = (layer as f32 + 0.5) * layer_height - half_extents.y;
  171|       |
  172|     60|            for piece in 0..pieces_per_layer {
                                          ^13
  173|     60|                let angle =
  174|     60|                    piece as f32 * std::f32::consts::TAU / pieces_per_layer as f32;
  175|     60|                let x = angle.cos() * half_extents.x * 0.7;
  176|     60|                let z = angle.sin() * half_extents.z * 0.7;
  177|     60|
  178|     60|                debris.push(DebrisConfig {
  179|     60|                    shape: DebrisShape::Box {
  180|     60|                        half_extents: Vec3::new(
  181|     60|                            half_extents.x * 0.3,
  182|     60|                            layer_height * 0.4,
  183|     60|                            half_extents.z * 0.3,
  184|     60|                        ),
  185|     60|                    },
  186|     60|                    local_position: Vec3::new(x, y, z),
  187|     60|                    mass: piece_mass,
  188|     60|                    ..Default::default()
  189|     60|                });
  190|     60|            }
  191|       |        }
  192|       |
  193|      4|        Self {
  194|      4|            debris,
  195|      4|            center_of_mass: Vec3::ZERO,
  196|      4|        }
  197|      4|    }
  198|       |}
  199|       |
  200|       |/// Destruction trigger type
  201|       |#[derive(Debug, Clone, Copy, PartialEq)]
  202|       |pub enum DestructionTrigger {
  203|       |    /// Destroy when force exceeds threshold
  204|       |    Force { threshold: f32 },
  205|       |    /// Destroy when health reaches zero
  206|       |    Health,
  207|       |    /// Destroy on any collision
  208|       |    Collision,
  209|       |    /// Manual destruction only
  210|       |    Manual,
  211|       |}
  212|       |
  213|       |impl Default for DestructionTrigger {
  214|     23|    fn default() -> Self {
  215|     23|        Self::Force { threshold: 1000.0 }
  216|     23|    }
  217|       |}
  218|       |
  219|       |/// Configuration for a destructible object
  220|       |#[derive(Debug, Clone)]
  221|       |pub struct DestructibleConfig {
  222|       |    /// Fracture pattern (debris layout)
  223|       |    pub fracture_pattern: FracturePattern,
  224|       |    /// How destruction is triggered
  225|       |    pub trigger: DestructionTrigger,
  226|       |    /// Maximum health (for Health trigger)
  227|       |    pub max_health: f32,
  228|       |    /// Minimum force to deal damage
  229|       |    pub damage_threshold: f32,
  230|       |    /// Force-to-damage conversion factor
  231|       |    pub force_to_damage: f32,
  232|       |    /// Explosion force when destroyed
  233|       |    pub destruction_force: f32,
  234|       |    /// Sound effect ID (for audio integration)
  235|       |    pub destruction_sound: Option<u32>,
  236|       |    /// Particle effect ID (for VFX integration)
  237|       |    pub destruction_particles: Option<u32>,
  238|       |}
  239|       |
  240|       |impl Default for DestructibleConfig {
  241|     23|    fn default() -> Self {
  242|     23|        Self {
  243|     23|            fracture_pattern: FracturePattern::uniform(8, Vec3::splat(0.5), 10.0),
  244|     23|            trigger: DestructionTrigger::default(),
  245|     23|            max_health: 100.0,
  246|     23|            damage_threshold: 10.0,
  247|     23|            force_to_damage: 0.1,
  248|     23|            destruction_force: 5.0,
  249|     23|            destruction_sound: None,
  250|     23|            destruction_particles: None,
  251|     23|        }
  252|     23|    }
  253|       |}
  254|       |
  255|       |/// State of a destructible object
  256|       |#[derive(Debug, Clone, Copy, PartialEq)]
  257|       |pub enum DestructibleState {
  258|       |    /// Object is intact
  259|       |    Intact,
  260|       |    /// Object is damaged but functional
  261|       |    Damaged,
  262|       |    /// Object is being destroyed (playing animation/effects)
  263|       |    Destroying,
  264|       |    /// Object has been destroyed
  265|       |    Destroyed,
  266|       |}
  267|       |
  268|       |/// Runtime data for a destructible object
  269|       |#[derive(Debug, Clone)]
  270|       |pub struct Destructible {
  271|       |    pub id: DestructibleId,
  272|       |    pub config: DestructibleConfig,
  273|       |    pub state: DestructibleState,
  274|       |    /// Current health
  275|       |    pub health: f32,
  276|       |    /// World position
  277|       |    pub position: Vec3,
  278|       |    /// Accumulated force this frame
  279|       |    pub accumulated_force: f32,
  280|       |    /// Body ID in physics world (if any)
  281|       |    pub body_id: Option<u64>,
  282|       |}
  283|       |
  284|       |impl Destructible {
  285|       |    /// Create a new destructible
  286|     23|    pub fn new(id: DestructibleId, config: DestructibleConfig, position: Vec3) -> Self {
  287|     23|        Self {
  288|     23|            id,
  289|     23|            health: config.max_health,
  290|     23|            config,
  291|     23|            state: DestructibleState::Intact,
  292|     23|            position,
  293|     23|            accumulated_force: 0.0,
  294|     23|            body_id: None,
  295|     23|        }
  296|     23|    }
  297|       |
  298|       |    /// Apply damage to the object
  299|      9|    pub fn apply_damage(&mut self, damage: f32) {
  300|      9|        if self.state != DestructibleState::Intact && self.state != DestructibleState::Damaged {
                                                                    ^1
  301|      0|            return;
  302|      9|        }
  303|       |
  304|      9|        self.health = (self.health - damage).max(0.0);
  305|       |
  306|      9|        if self.health <= 0.0 {
  307|      4|            self.state = DestructibleState::Destroying;
  308|      5|        } else if self.health < self.config.max_health * 0.5 {
  309|      1|            self.state = DestructibleState::Damaged;
  310|      4|        }
  311|      9|    }
  312|       |
  313|       |    /// Apply force to the object
  314|      6|    pub fn apply_force(&mut self, force: f32) {
  315|      6|        self.accumulated_force += force;
  316|       |
  317|       |        // Check force threshold trigger
  318|      6|        if let DestructionTrigger::Force { threshold } = self.config.trigger {
  319|      6|            if self.accumulated_force >= threshold {
  320|      4|                self.state = DestructibleState::Destroying;
  321|      4|            }
                          ^2
  322|      0|        }
  323|       |
  324|       |        // Apply force-based damage for Health trigger
  325|      6|        if matches!(self.config.trigger, DestructionTrigger::Health) {
  326|      0|            if force >= self.config.damage_threshold {
  327|      0|                let damage = (force - self.config.damage_threshold) * self.config.force_to_damage;
  328|      0|                self.apply_damage(damage);
  329|      0|            }
  330|      6|        }
  331|      6|    }
  332|       |
  333|       |    /// Handle collision
  334|      3|    pub fn on_collision(&mut self, impact_force: f32) {
  335|      3|        if let DestructionTrigger::Collision = self.config.trigger {
  336|      3|            self.state = DestructibleState::Destroying;
  337|      3|        } else {
  338|      0|            self.apply_force(impact_force);
  339|      0|        }
  340|      3|    }
  341|       |
  342|       |    /// Manually trigger destruction
  343|      8|    pub fn destroy(&mut self) {
  344|      8|        self.state = DestructibleState::Destroying;
  345|      8|    }
  346|       |
  347|       |    /// Check if object should spawn debris
  348|     14|    pub fn should_spawn_debris(&self) -> bool {
  349|     14|        self.state == DestructibleState::Destroying
  350|     14|    }
  351|       |
  352|       |    /// Mark destruction as complete
  353|     11|    pub fn complete_destruction(&mut self) {
  354|     11|        self.state = DestructibleState::Destroyed;
  355|     11|    }
  356|       |
  357|       |    /// Reset accumulated force (call at end of frame)
  358|     13|    pub fn reset_frame(&mut self) {
  359|     13|        self.accumulated_force = 0.0;
  360|     13|    }
  361|       |
  362|       |    /// Get health percentage
  363|      4|    pub fn health_percent(&self) -> f32 {
  364|      4|        self.health / self.config.max_health
  365|      4|    }
  366|       |
  367|       |    /// Check if destroyed
  368|      3|    pub fn is_destroyed(&self) -> bool {
  369|      3|        self.state == DestructibleState::Destroyed
  370|      3|    }
  371|       |}
  372|       |
  373|       |/// Active debris piece in the world
  374|       |#[derive(Debug, Clone)]
  375|       |pub struct Debris {
  376|       |    pub id: DebrisId,
  377|       |    /// Source destructible ID
  378|       |    pub source: DestructibleId,
  379|       |    pub config: DebrisConfig,
  380|       |    /// World position
  381|       |    pub position: Vec3,
  382|       |    /// Linear velocity
  383|       |    pub velocity: Vec3,
  384|       |    /// Angular velocity
  385|       |    pub angular_velocity: Vec3,
  386|       |    /// Time alive
  387|       |    pub age: f32,
  388|       |    /// Physics body ID (if any)
  389|       |    pub body_id: Option<u64>,
  390|       |}
  391|       |
  392|       |impl Debris {
  393|       |    /// Create new debris
  394|     48|    pub fn new(
  395|     48|        id: DebrisId,
  396|     48|        source: DestructibleId,
  397|     48|        config: DebrisConfig,
  398|     48|        position: Vec3,
  399|     48|        velocity: Vec3,
  400|     48|    ) -> Self {
  401|     48|        Self {
  402|     48|            id,
  403|     48|            source,
  404|     48|            config,
  405|     48|            position,
  406|     48|            velocity,
  407|     48|            angular_velocity: Vec3::ZERO,
  408|     48|            age: 0.0,
  409|     48|            body_id: None,
  410|     48|        }
  411|     48|    }
  412|       |
  413|       |    /// Update debris (if not physics-driven)
  414|     51|    pub fn update(&mut self, dt: f32, gravity: Vec3) {
  415|     51|        self.age += dt;
  416|       |
  417|       |        // Simple physics if not driven by physics engine
  418|     51|        if self.body_id.is_none() {
  419|     51|            self.velocity += gravity * dt;
  420|     51|            self.position += self.velocity * dt;
  421|     51|        }
                      ^0
  422|     51|    }
  423|       |
  424|       |    /// Check if debris should be removed
  425|     51|    pub fn should_remove(&self) -> bool {
  426|     51|        self.config.lifetime > 0.0 && self.age >= self.config.lifetime
                                                    ^50
  427|     51|    }
  428|       |}
  429|       |
  430|       |/// Destruction event for callbacks
  431|       |#[derive(Debug, Clone)]
  432|       |pub struct DestructionEvent {
  433|       |    /// ID of destroyed object
  434|       |    pub destructible_id: DestructibleId,
  435|       |    /// Position of destruction
  436|       |    pub position: Vec3,
  437|       |    /// Force that caused destruction
  438|       |    pub force: f32,
  439|       |    /// Direction of force
  440|       |    pub force_direction: Vec3,
  441|       |    /// Number of debris spawned
  442|       |    pub debris_count: usize,
  443|       |}
  444|       |
  445|       |/// Manager for destruction system
  446|       |#[derive(Debug, Default)]
  447|       |pub struct DestructionManager {
  448|       |    destructibles: HashMap<DestructibleId, Destructible>,
  449|       |    debris: HashMap<DebrisId, Debris>,
  450|       |    pending_events: Vec<DestructionEvent>,
  451|       |    next_destructible_id: u64,
  452|       |    next_debris_id: u64,
  453|       |    /// Maximum active debris pieces
  454|       |    pub max_debris: usize,
  455|       |    /// Default debris lifetime
  456|       |    pub default_debris_lifetime: f32,
  457|       |}
  458|       |
  459|       |impl DestructionManager {
  460|       |    /// Create a new destruction manager
  461|     13|    pub fn new() -> Self {
  462|     13|        Self {
  463|     13|            destructibles: HashMap::new(),
  464|     13|            debris: HashMap::new(),
  465|     13|            pending_events: Vec::new(),
  466|     13|            next_destructible_id: 1,
  467|     13|            next_debris_id: 1,
  468|     13|            max_debris: 500,
  469|     13|            default_debris_lifetime: 10.0,
  470|     13|        }
  471|     13|    }
  472|       |
  473|       |    // === Destructible Management ===
  474|       |
  475|       |    /// Add a destructible object
  476|     16|    pub fn add_destructible(
  477|     16|        &mut self,
  478|     16|        config: DestructibleConfig,
  479|     16|        position: Vec3,
  480|     16|    ) -> DestructibleId {
  481|     16|        let id = DestructibleId(self.next_destructible_id);
  482|     16|        self.next_destructible_id += 1;
  483|     16|        self.destructibles
  484|     16|            .insert(id, Destructible::new(id, config, position));
  485|     16|        id
  486|     16|    }
  487|       |
  488|       |    /// Remove a destructible (and its debris)
  489|      3|    pub fn remove_destructible(&mut self, id: DestructibleId) -> bool {
  490|       |        // Remove associated debris
  491|      3|        self.debris.retain(|_, d| d.source != id);
                                                ^0          ^0
  492|      3|        self.destructibles.remove(&id).is_some()
  493|      3|    }
  494|       |
  495|       |    /// Get a destructible
  496|      8|    pub fn get(&self, id: DestructibleId) -> Option<&Destructible> {
  497|      8|        self.destructibles.get(&id)
  498|      8|    }
  499|       |
  500|       |    /// Get a mutable destructible
  501|      1|    pub fn get_mut(&mut self, id: DestructibleId) -> Option<&mut Destructible> {
  502|      1|        self.destructibles.get_mut(&id)
  503|      1|    }
  504|       |
  505|       |    /// Apply damage to a destructible
  506|      3|    pub fn apply_damage(&mut self, id: DestructibleId, damage: f32) {
  507|      3|        if let Some(dest) = self.destructibles.get_mut(&id) {
  508|      3|            dest.apply_damage(damage);
  509|      3|        }
                      ^0
  510|      3|    }
  511|       |
  512|       |    /// Apply force to a destructible
  513|      4|    pub fn apply_force(&mut self, id: DestructibleId, force: f32) {
  514|      4|        if let Some(dest) = self.destructibles.get_mut(&id) {
  515|      4|            dest.apply_force(force);
  516|      4|        }
                      ^0
  517|      4|    }
  518|       |
  519|       |    /// Handle collision for a destructible
  520|      2|    pub fn on_collision(&mut self, id: DestructibleId, impact_force: f32) {
  521|      2|        if let Some(dest) = self.destructibles.get_mut(&id) {
  522|      2|            dest.on_collision(impact_force);
  523|      2|        }
                      ^0
  524|      2|    }
  525|       |
  526|       |    /// Manually destroy an object
  527|      7|    pub fn destroy(&mut self, id: DestructibleId) {
  528|      7|        if let Some(dest) = self.destructibles.get_mut(&id) {
  529|      7|            dest.destroy();
  530|      7|        }
                      ^0
  531|      7|    }
  532|       |
  533|       |    // === Debris Management ===
  534|       |
  535|       |    /// Get debris by ID
  536|      0|    pub fn get_debris(&self, id: DebrisId) -> Option<&Debris> {
  537|      0|        self.debris.get(&id)
  538|      0|    }
  539|       |
  540|       |    /// Iterate over all debris
  541|      0|    pub fn debris_iter(&self) -> impl Iterator<Item = &Debris> {
  542|      0|        self.debris.values()
  543|      0|    }
  544|       |
  545|       |    /// Spawn debris for a destructible
  546|     10|    fn spawn_debris(&mut self, dest: &Destructible, force_direction: Vec3) -> Vec<DebrisId> {
  547|     10|        let mut spawned = Vec::new();
  548|       |
  549|       |        // Respect debris limit
  550|     10|        let available_slots = self.max_debris.saturating_sub(self.debris.len());
  551|     10|        let debris_to_spawn = dest.config.fracture_pattern.debris.len().min(available_slots);
  552|       |
  553|     45|        for debris_config in dest.config.fracture_pattern.debris.iter().take(debris_to_spawn) {
                                           ^10                                        ^10  ^10
  554|     45|            let id = DebrisId(self.next_debris_id);
  555|     45|            self.next_debris_id += 1;
  556|     45|
  557|     45|            // Calculate debris world position
  558|     45|            let position = dest.position + debris_config.local_position;
  559|     45|
  560|     45|            // Calculate initial velocity (outward from center + force direction)
  561|     45|            let outward = debris_config.local_position.normalize_or_zero();
  562|     45|            let velocity = (outward * dest.config.destruction_force
  563|     45|                + force_direction * dest.config.destruction_force * 0.5)
  564|     45|                * debris_config.velocity_factor;
  565|     45|
  566|     45|            let mut debris = Debris::new(id, dest.id, debris_config.clone(), position, velocity);
  567|     45|
  568|     45|            // Random angular velocity
  569|     45|            debris.angular_velocity = Vec3::new(
  570|     45|                (id.0 as f32 * 1.234).sin() * 5.0,
  571|     45|                (id.0 as f32 * 2.345).sin() * 5.0,
  572|     45|                (id.0 as f32 * 3.456).sin() * 5.0,
  573|     45|            ) * debris_config.angular_velocity_factor;
  574|     45|
  575|     45|            self.debris.insert(id, debris);
  576|     45|            spawned.push(id);
  577|     45|        }
  578|       |
  579|     10|        spawned
  580|     10|    }
  581|       |
  582|       |    // === Update ===
  583|       |
  584|       |    /// Update the destruction system
  585|     13|    pub fn update(&mut self, dt: f32, gravity: Vec3) {
  586|       |        // Process destructibles that need debris spawning
  587|     13|        let mut to_process = Vec::new();
  588|     26|        for (id, dest) in &self.destructibles {
                           ^13 ^13
  589|     13|            if dest.should_spawn_debris() {
  590|     10|                to_process.push(*id);
  591|     10|            }
                          ^3
  592|       |        }
  593|       |
  594|     23|        for id in to_process {
                          ^10
  595|     10|            if let Some(dest) = self.destructibles.get(&id) {
  596|     10|                // Clone needed data before mutable borrow
  597|     10|                let position = dest.position;
  598|     10|                let force = dest.accumulated_force;
  599|     10|                let dest_clone = dest.clone();
  600|     10|
  601|     10|                // Spawn debris
  602|     10|                let debris_ids =
  603|     10|                    self.spawn_debris(&dest_clone, Vec3::Y); // Default upward force direction
  604|     10|
  605|     10|                // Create event
  606|     10|                self.pending_events.push(DestructionEvent {
  607|     10|                    destructible_id: id,
  608|     10|                    position,
  609|     10|                    force,
  610|     10|                    force_direction: Vec3::Y,
  611|     10|                    debris_count: debris_ids.len(),
  612|     10|                });
  613|     10|            }
                          ^0
  614|       |
  615|       |            // Mark as destroyed
  616|     10|            if let Some(dest) = self.destructibles.get_mut(&id) {
  617|     10|                dest.complete_destruction();
  618|     10|            }
                          ^0
  619|       |        }
  620|       |
  621|       |        // Update debris
  622|     47|        for debris in self.debris.values_mut() {
                                    ^13         ^13
  623|     47|            debris.update(dt, gravity);
  624|     47|        }
  625|       |
  626|       |        // Remove expired debris
  627|     47|        self.debris.retain(|_, d| !d.should_remove());
                      ^13         ^13
  628|       |
  629|       |        // Reset frame state for destructibles
  630|     13|        for dest in self.destructibles.values_mut() {
  631|     13|            dest.reset_frame();
  632|     13|        }
  633|     13|    }
  634|       |
  635|       |    /// Take pending destruction events
  636|      3|    pub fn take_events(&mut self) -> Vec<DestructionEvent> {
  637|      3|        std::mem::take(&mut self.pending_events)
  638|      3|    }
  639|       |
  640|       |    /// Get counts
  641|      4|    pub fn destructible_count(&self) -> usize {
  642|      4|        self.destructibles.len()
  643|      4|    }
  644|       |
  645|     11|    pub fn debris_count(&self) -> usize {
  646|     11|        self.debris.len()
  647|     11|    }
  648|       |
  649|      0|    pub fn active_debris_count(&self) -> usize {
  650|      0|        self.debris.values().filter(|d| !d.should_remove()).count()
  651|      0|    }
  652|       |
  653|       |    /// Clean up destroyed destructibles
  654|      1|    pub fn cleanup_destroyed(&mut self) {
  655|      1|        self.destructibles.retain(|_, d| !d.is_destroyed());
  656|      1|    }
  657|       |}
  658|       |
  659|       |// ============================================================================
  660|       |// Unit Tests
  661|       |// ============================================================================
  662|       |
  663|       |#[cfg(test)]
  664|       |mod tests {
  665|       |    use super::*;
  666|       |
  667|       |    #[test]
  668|      1|    fn test_destructible_creation() {
  669|      1|        let config = DestructibleConfig::default();
  670|      1|        let dest = Destructible::new(DestructibleId(1), config.clone(), Vec3::ZERO);
  671|       |
  672|      1|        assert_eq!(dest.state, DestructibleState::Intact);
  673|      1|        assert_eq!(dest.health, config.max_health);
  674|      1|    }
  675|       |
  676|       |    #[test]
  677|      1|    fn test_damage_application() {
  678|      1|        let config = DestructibleConfig {
  679|      1|            max_health: 100.0,
  680|      1|            ..Default::default()
  681|      1|        };
  682|      1|        let mut dest = Destructible::new(DestructibleId(1), config, Vec3::ZERO);
  683|       |
  684|      1|        dest.apply_damage(30.0);
  685|      1|        assert_eq!(dest.health, 70.0);
  686|      1|        assert_eq!(dest.state, DestructibleState::Intact);
  687|       |
  688|      1|        dest.apply_damage(30.0);
  689|      1|        assert_eq!(dest.health, 40.0);
  690|      1|        assert_eq!(dest.state, DestructibleState::Damaged);
  691|       |
  692|      1|        dest.apply_damage(50.0);
  693|      1|        assert_eq!(dest.health, 0.0);
  694|      1|        assert_eq!(dest.state, DestructibleState::Destroying);
  695|      1|    }
  696|       |
  697|       |    #[test]
  698|      1|    fn test_force_trigger() {
  699|      1|        let config = DestructibleConfig {
  700|      1|            trigger: DestructionTrigger::Force { threshold: 100.0 },
  701|      1|            ..Default::default()
  702|      1|        };
  703|      1|        let mut dest = Destructible::new(DestructibleId(1), config, Vec3::ZERO);
  704|       |
  705|      1|        dest.apply_force(50.0);
  706|      1|        assert_eq!(dest.state, DestructibleState::Intact);
  707|       |
  708|      1|        dest.apply_force(60.0);
  709|      1|        assert_eq!(dest.state, DestructibleState::Destroying);
  710|      1|    }
  711|       |
  712|       |    #[test]
  713|      1|    fn test_collision_trigger() {
  714|      1|        let config = DestructibleConfig {
  715|      1|            trigger: DestructionTrigger::Collision,
  716|      1|            ..Default::default()
  717|      1|        };
  718|      1|        let mut dest = Destructible::new(DestructibleId(1), config, Vec3::ZERO);
  719|       |
  720|      1|        dest.on_collision(1.0);
  721|      1|        assert_eq!(dest.state, DestructibleState::Destroying);
  722|      1|    }
  723|       |
  724|       |    #[test]
  725|      1|    fn test_manual_destruction() {
  726|      1|        let mut dest = Destructible::new(DestructibleId(1), DestructibleConfig::default(), Vec3::ZERO);
  727|       |
  728|      1|        dest.destroy();
  729|      1|        assert_eq!(dest.state, DestructibleState::Destroying);
  730|      1|    }
  731|       |
  732|       |    #[test]
  733|      1|    fn test_health_percent() {
  734|      1|        let config = DestructibleConfig {
  735|      1|            max_health: 200.0,
  736|      1|            ..Default::default()
  737|      1|        };
  738|      1|        let mut dest = Destructible::new(DestructibleId(1), config, Vec3::ZERO);
  739|       |
  740|      1|        assert_eq!(dest.health_percent(), 1.0);
  741|      1|        dest.apply_damage(100.0);
  742|      1|        assert_eq!(dest.health_percent(), 0.5);
  743|      1|    }
  744|       |
  745|       |    #[test]
  746|      1|    fn test_uniform_fracture_pattern() {
  747|      1|        let pattern = FracturePattern::uniform(8, Vec3::splat(1.0), 10.0);
  748|       |
  749|      1|        assert_eq!(pattern.debris.len(), 8);
  750|       |
  751|      1|        let total_mass: f32 = pattern.debris.iter().map(|d| d.mass).sum();
  752|      1|        assert!((total_mass - 10.0).abs() < 0.01, "Total mass should be preserved");
                                                                ^0
  753|      1|    }
  754|       |
  755|       |    #[test]
  756|      1|    fn test_radial_fracture_pattern() {
  757|      1|        let pattern = FracturePattern::radial(20, 2.0, 5.0);
  758|       |
  759|      1|        assert_eq!(pattern.debris.len(), 20);
  760|      1|    }
  761|       |
  762|       |    #[test]
  763|      1|    fn test_layered_fracture_pattern() {
  764|      1|        let pattern = FracturePattern::layered(3, 4, Vec3::new(2.0, 3.0, 2.0), 12.0);
  765|       |
  766|      1|        assert_eq!(pattern.debris.len(), 12); // 3 layers × 4 pieces
  767|      1|    }
  768|       |
  769|       |    #[test]
  770|      1|    fn test_debris_lifetime() {
  771|      1|        let config = DebrisConfig {
  772|      1|            lifetime: 5.0,
  773|      1|            ..Default::default()
  774|      1|        };
  775|      1|        let mut debris = Debris::new(
  776|      1|            DebrisId(1),
  777|      1|            DestructibleId(1),
  778|      1|            config,
  779|       |            Vec3::ZERO,
  780|       |            Vec3::ZERO,
  781|       |        );
  782|       |
  783|      1|        assert!(!debris.should_remove());
  784|       |
  785|      1|        debris.update(3.0, Vec3::ZERO);
  786|      1|        assert!(!debris.should_remove());
  787|       |
  788|      1|        debris.update(3.0, Vec3::ZERO);
  789|      1|        assert!(debris.should_remove());
  790|      1|    }
  791|       |
  792|       |    #[test]
  793|      1|    fn test_permanent_debris() {
  794|      1|        let config = DebrisConfig {
  795|      1|            lifetime: 0.0, // Permanent
  796|      1|            ..Default::default()
  797|      1|        };
  798|      1|        let mut debris = Debris::new(
  799|      1|            DebrisId(1),
  800|      1|            DestructibleId(1),
  801|      1|            config,
  802|       |            Vec3::ZERO,
  803|       |            Vec3::ZERO,
  804|       |        );
  805|       |
  806|      1|        debris.update(100.0, Vec3::ZERO);
  807|      1|        assert!(!debris.should_remove());
  808|      1|    }
  809|       |
  810|       |    #[test]
  811|      1|    fn test_destruction_manager_add_remove() {
  812|      1|        let mut manager = DestructionManager::new();
  813|       |
  814|      1|        let id = manager.add_destructible(DestructibleConfig::default(), Vec3::ZERO);
  815|      1|        assert_eq!(manager.destructible_count(), 1);
  816|       |
  817|      1|        assert!(manager.get(id).is_some());
  818|      1|        assert!(manager.remove_destructible(id));
  819|      1|        assert_eq!(manager.destructible_count(), 0);
  820|      1|    }
  821|       |
  822|       |    #[test]
  823|      1|    fn test_destruction_spawns_debris() {
  824|      1|        let mut manager = DestructionManager::new();
  825|       |
  826|      1|        let config = DestructibleConfig {
  827|      1|            fracture_pattern: FracturePattern::uniform(5, Vec3::splat(0.5), 5.0),
  828|      1|            trigger: DestructionTrigger::Manual,
  829|      1|            ..Default::default()
  830|      1|        };
  831|       |
  832|      1|        let id = manager.add_destructible(config, Vec3::ZERO);
  833|      1|        manager.destroy(id);
  834|       |
  835|       |        // Update to process destruction
  836|      1|        manager.update(0.016, Vec3::new(0.0, -9.81, 0.0));
  837|       |
  838|      1|        assert_eq!(manager.debris_count(), 5);
  839|       |
  840|       |        // Check events were generated
  841|      1|        let events = manager.take_events();
  842|      1|        assert_eq!(events.len(), 1);
  843|      1|        assert_eq!(events[0].debris_count, 5);
  844|      1|    }
  845|       |
  846|       |    #[test]
  847|      1|    fn test_debris_limit() {
  848|      1|        let mut manager = DestructionManager::new();
  849|      1|        manager.max_debris = 3;
  850|       |
  851|      1|        let config = DestructibleConfig {
  852|      1|            fracture_pattern: FracturePattern::uniform(10, Vec3::splat(0.5), 10.0),
  853|      1|            trigger: DestructionTrigger::Manual,
  854|      1|            ..Default::default()
  855|      1|        };
  856|       |
  857|      1|        let id = manager.add_destructible(config, Vec3::ZERO);
  858|      1|        manager.destroy(id);
  859|      1|        manager.update(0.016, Vec3::ZERO);
  860|       |
  861|       |        // Should only spawn up to max_debris
  862|      1|        assert_eq!(manager.debris_count(), 3);
  863|      1|    }
  864|       |
  865|       |    #[test]
  866|      1|    fn test_debris_cleanup() {
  867|      1|        let mut manager = DestructionManager::new();
  868|       |
  869|      1|        let config = DestructibleConfig {
  870|      1|            fracture_pattern: FracturePattern {
  871|      1|                debris: vec![DebrisConfig {
  872|      1|                    lifetime: 0.5,
  873|      1|                    ..Default::default()
  874|      1|                }],
  875|      1|                center_of_mass: Vec3::ZERO,
  876|      1|            },
  877|      1|            trigger: DestructionTrigger::Manual,
  878|      1|            ..Default::default()
  879|      1|        };
  880|       |
  881|      1|        let id = manager.add_destructible(config, Vec3::ZERO);
  882|      1|        manager.destroy(id);
  883|      1|        manager.update(0.016, Vec3::ZERO);
  884|       |
  885|      1|        assert_eq!(manager.debris_count(), 1);
  886|       |
  887|       |        // Age debris past lifetime
  888|      1|        manager.update(1.0, Vec3::ZERO);
  889|      1|        assert_eq!(manager.debris_count(), 0);
  890|      1|    }
  891|       |
  892|       |    #[test]
  893|      1|    fn test_cleanup_destroyed() {
  894|      1|        let mut manager = DestructionManager::new();
  895|       |
  896|      1|        let id = manager.add_destructible(
  897|      1|            DestructibleConfig {
  898|      1|                trigger: DestructionTrigger::Manual,
  899|      1|                fracture_pattern: FracturePattern {
  900|      1|                    debris: vec![],
  901|      1|                    center_of_mass: Vec3::ZERO,
  902|      1|                },
  903|      1|                ..Default::default()
  904|      1|            },
  905|       |            Vec3::ZERO,
  906|       |        );
  907|       |
  908|      1|        manager.destroy(id);
  909|      1|        manager.update(0.016, Vec3::ZERO);
  910|       |
  911|      1|        assert_eq!(manager.destructible_count(), 1);
  912|      1|        manager.cleanup_destroyed();
  913|      1|        assert_eq!(manager.destructible_count(), 0);
  914|      1|    }
  915|       |
  916|       |    #[test]
  917|      1|    fn test_debris_gravity() {
  918|      1|        let config = DebrisConfig::default();
  919|      1|        let mut debris = Debris::new(
  920|      1|            DebrisId(1),
  921|      1|            DestructibleId(1),
  922|      1|            config,
  923|      1|            Vec3::new(0.0, 10.0, 0.0),
  924|       |            Vec3::ZERO,
  925|       |        );
  926|       |
  927|      1|        let gravity = Vec3::new(0.0, -9.81, 0.0);
  928|      1|        debris.update(1.0, gravity);
  929|       |
  930|       |        // Should have fallen
  931|      1|        assert!(debris.position.y < 10.0);
  932|      1|        assert!(debris.velocity.y < 0.0);
  933|      1|    }
  934|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-physics\src\environment.rs:
    1|       |//! Environmental Physics Systems
    2|       |//!
    3|       |//! This module provides environmental effects that interact with rigid bodies:
    4|       |//! - Wind zones (directional, vortex, turbulent)
    5|       |//! - Gust system (noise-based variation)
    6|       |//! - Buoyancy (water volumes)
    7|       |
    8|       |use glam::Vec3;
    9|       |use std::collections::HashMap;
   10|       |
   11|       |/// Unique identifier for wind zones
   12|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
   13|       |pub struct WindZoneId(pub u64);
   14|       |
   15|       |/// Unique identifier for water volumes
   16|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
   17|       |pub struct WaterVolumeId(pub u64);
   18|       |
   19|       |/// Shape of a wind zone
   20|       |#[derive(Debug, Clone, Copy, PartialEq)]
   21|       |pub enum WindZoneShape {
   22|       |    /// Infinite directional wind (global)
   23|       |    Global,
   24|       |    /// Box-shaped wind zone
   25|       |    Box { half_extents: Vec3 },
   26|       |    /// Spherical wind zone
   27|       |    Sphere { radius: f32 },
   28|       |    /// Cylindrical wind zone (useful for tornadoes)
   29|       |    Cylinder { radius: f32, height: f32 },
   30|       |}
   31|       |
   32|       |impl Default for WindZoneShape {
   33|      1|    fn default() -> Self {
   34|      1|        Self::Global
   35|      1|    }
   36|       |}
   37|       |
   38|       |/// Type of wind behavior
   39|       |#[derive(Debug, Clone, Copy, PartialEq)]
   40|       |pub enum WindType {
   41|       |    /// Constant directional wind
   42|       |    Directional,
   43|       |    /// Rotational wind around center (tornado, whirlpool)
   44|       |    Vortex {
   45|       |        /// Tangential speed at edge
   46|       |        tangential_speed: f32,
   47|       |        /// Inward pull strength
   48|       |        inward_pull: f32,
   49|       |        /// Upward lift
   50|       |        updraft: f32,
   51|       |    },
   52|       |    /// Turbulent wind with noise
   53|       |    Turbulent {
   54|       |        /// Base turbulence intensity
   55|       |        intensity: f32,
   56|       |        /// Frequency of turbulence changes
   57|       |        frequency: f32,
   58|       |    },
   59|       |}
   60|       |
   61|       |impl Default for WindType {
   62|      1|    fn default() -> Self {
   63|      1|        Self::Directional
   64|      1|    }
   65|       |}
   66|       |
   67|       |/// Configuration for a wind zone
   68|       |#[derive(Debug, Clone)]
   69|       |pub struct WindZoneConfig {
   70|       |    /// Position of the wind zone center
   71|       |    pub position: Vec3,
   72|       |    /// Shape of the zone
   73|       |    pub shape: WindZoneShape,
   74|       |    /// Type of wind behavior
   75|       |    pub wind_type: WindType,
   76|       |    /// Base wind direction (for directional/turbulent)
   77|       |    pub direction: Vec3,
   78|       |    /// Base wind strength (force per unit area)
   79|       |    pub strength: f32,
   80|       |    /// Falloff from center (0 = uniform, 1 = linear falloff to edge)
   81|       |    pub falloff: f32,
   82|       |    /// Whether this zone is active
   83|       |    pub active: bool,
   84|       |}
   85|       |
   86|       |impl Default for WindZoneConfig {
   87|     29|    fn default() -> Self {
   88|     29|        Self {
   89|     29|            position: Vec3::ZERO,
   90|     29|            shape: WindZoneShape::Global,
   91|     29|            wind_type: WindType::Directional,
   92|     29|            direction: Vec3::new(1.0, 0.0, 0.0),
   93|     29|            strength: 10.0,
   94|     29|            falloff: 0.0,
   95|     29|            active: true,
   96|     29|        }
   97|     29|    }
   98|       |}
   99|       |
  100|       |/// Runtime state for a wind zone
  101|       |#[derive(Debug, Clone)]
  102|       |pub struct WindZone {
  103|       |    pub id: WindZoneId,
  104|       |    pub config: WindZoneConfig,
  105|       |    /// Current gust offset (for turbulent wind)
  106|       |    pub gust_offset: Vec3,
  107|       |    /// Phase for noise-based variation
  108|       |    pub noise_phase: f32,
  109|       |}
  110|       |
  111|       |impl WindZone {
  112|       |    /// Create a new wind zone
  113|     33|    pub fn new(id: WindZoneId, config: WindZoneConfig) -> Self {
  114|     33|        Self {
  115|     33|            id,
  116|     33|            config,
  117|     33|            gust_offset: Vec3::ZERO,
  118|     33|            noise_phase: 0.0,
  119|     33|        }
  120|     33|    }
  121|       |
  122|       |    /// Check if a point is inside this wind zone
  123|     30|    pub fn contains(&self, point: Vec3) -> bool {
  124|     30|        match self.config.shape {
  125|     12|            WindZoneShape::Global => true,
  126|      4|            WindZoneShape::Box { half_extents } => {
  127|      4|                let local = point - self.config.position;
  128|      4|                local.x.abs() <= half_extents.x
  129|      2|                    && local.y.abs() <= half_extents.y
  130|      2|                    && local.z.abs() <= half_extents.z
  131|       |            }
  132|      9|            WindZoneShape::Sphere { radius } => {
  133|      9|                (point - self.config.position).length() <= radius
  134|       |            }
  135|      5|            WindZoneShape::Cylinder { radius, height } => {
  136|      5|                let local = point - self.config.position;
  137|      5|                let horizontal_dist = Vec3::new(local.x, 0.0, local.z).length();
  138|      5|                horizontal_dist <= radius && local.y.abs() <= height / 2.0
                                                           ^4
  139|       |            }
  140|       |        }
  141|     30|    }
  142|       |
  143|       |    /// Calculate wind force at a given point
  144|     16|    pub fn wind_force_at(&self, point: Vec3, drag_coefficient: f32, cross_section: f32) -> Vec3 {
  145|     16|        if !self.config.active || !self.contains(point) {
                                                ^15^15
  146|      1|            return Vec3::ZERO;
  147|     15|        }
  148|       |
  149|       |        // Calculate distance factor for falloff
  150|     15|        let distance_factor = self.calculate_falloff(point);
  151|       |
  152|       |        // Calculate base wind velocity at this point
  153|     15|        let wind_velocity = match self.config.wind_type {
  154|       |            WindType::Directional => {
  155|     10|                self.config.direction.normalize_or_zero() * self.config.strength
  156|       |            }
  157|       |            WindType::Vortex {
  158|      2|                tangential_speed,
  159|      2|                inward_pull,
  160|      2|                updraft,
  161|       |            } => {
  162|      2|                let to_center = self.config.position - point;
  163|      2|                let horizontal = Vec3::new(to_center.x, 0.0, to_center.z);
  164|      2|                let dist = horizontal.length();
  165|       |
  166|      2|                if dist < 0.1 {
  167|      0|                    Vec3::new(0.0, updraft, 0.0)
  168|       |                } else {
  169|       |                    // Tangential component (perpendicular to radius)
  170|      2|                    let tangent = Vec3::new(-horizontal.z, 0.0, horizontal.x).normalize();
  171|      2|                    let tangential = tangent * tangential_speed;
  172|       |
  173|       |                    // Inward pull
  174|      2|                    let inward = horizontal.normalize() * inward_pull;
  175|       |
  176|       |                    // Combine
  177|      2|                    tangential + inward + Vec3::new(0.0, updraft, 0.0)
  178|       |                }
  179|       |            }
  180|      3|            WindType::Turbulent { intensity, .. } => {
  181|      3|                let base = self.config.direction.normalize_or_zero() * self.config.strength;
  182|      3|                base + self.gust_offset * intensity
  183|       |            }
  184|       |        };
  185|       |
  186|       |        // Apply falloff
  187|     15|        let effective_velocity = wind_velocity * distance_factor;
  188|       |
  189|       |        // Wind force = 0.5 * air_density * velocity^2 * drag_coefficient * area
  190|       |        // Simplified: F = k * v^2 * direction
  191|     15|        let speed = effective_velocity.length();
  192|     15|        if speed < 0.01 {
  193|      0|            return Vec3::ZERO;
  194|     15|        }
  195|       |
  196|     15|        let force_magnitude = 0.5 * 1.225 * speed * speed * drag_coefficient * cross_section;
  197|     15|        effective_velocity.normalize() * force_magnitude
  198|     16|    }
  199|       |
  200|       |    /// Calculate falloff factor based on distance from center
  201|     19|    fn calculate_falloff(&self, point: Vec3) -> f32 {
  202|     19|        if self.config.falloff <= 0.0 {
  203|     11|            return 1.0;
  204|      8|        }
  205|       |
  206|      8|        let normalized_dist = match self.config.shape {
  207|      0|            WindZoneShape::Global => 0.0,
  208|      2|            WindZoneShape::Box { half_extents } => {
  209|      2|                let local = (point - self.config.position).abs();
  210|      2|                let max_dist = (local / half_extents).max_element();
  211|      2|                max_dist
  212|       |            }
  213|      4|            WindZoneShape::Sphere { radius } => {
  214|      4|                (point - self.config.position).length() / radius
  215|       |            }
  216|      2|            WindZoneShape::Cylinder { radius, height } => {
  217|      2|                let local = point - self.config.position;
  218|      2|                let horizontal_dist = Vec3::new(local.x, 0.0, local.z).length() / radius;
  219|      2|                let vertical_dist = local.y.abs() / (height / 2.0);
  220|      2|                horizontal_dist.max(vertical_dist)
  221|       |            }
  222|       |        };
  223|       |
  224|      8|        (1.0 - normalized_dist * self.config.falloff).max(0.0)
  225|     19|    }
  226|       |
  227|       |    /// Update turbulence/gust state
  228|    102|    pub fn update(&mut self, dt: f32) {
  229|    102|        if let WindType::Turbulent { frequency, .. } = self.config.wind_type {
  230|    102|            self.noise_phase += dt * frequency;
  231|    102|
  232|    102|            // Simple pseudo-random gust using sine waves at different frequencies
  233|    102|            self.gust_offset = Vec3::new(
  234|    102|                (self.noise_phase * 1.0).sin() * 0.5 + (self.noise_phase * 2.3).sin() * 0.3,
  235|    102|                (self.noise_phase * 0.7).sin() * 0.2 + (self.noise_phase * 1.9).sin() * 0.15,
  236|    102|                (self.noise_phase * 1.3).sin() * 0.5 + (self.noise_phase * 2.7).sin() * 0.3,
  237|    102|            );
  238|    102|        }
                      ^0
  239|    102|    }
  240|       |}
  241|       |
  242|       |/// Gust event for sudden wind changes
  243|       |#[derive(Debug, Clone)]
  244|       |pub struct GustEvent {
  245|       |    /// Direction of the gust
  246|       |    pub direction: Vec3,
  247|       |    /// Peak strength
  248|       |    pub strength: f32,
  249|       |    /// Duration in seconds
  250|       |    pub duration: f32,
  251|       |    /// Time elapsed
  252|       |    pub elapsed: f32,
  253|       |    /// Shape of gust envelope (0 = instant, 1 = smooth)
  254|       |    pub smoothness: f32,
  255|       |}
  256|       |
  257|       |impl GustEvent {
  258|       |    /// Create a new gust event
  259|      3|    pub fn new(direction: Vec3, strength: f32, duration: f32) -> Self {
  260|      3|        Self {
  261|      3|            direction: direction.normalize_or_zero(),
  262|      3|            strength,
  263|      3|            duration,
  264|      3|            elapsed: 0.0,
  265|      3|            smoothness: 0.5,
  266|      3|        }
  267|      3|    }
  268|       |
  269|       |    /// Get current gust force multiplier
  270|      4|    pub fn current_strength(&self) -> f32 {
  271|      4|        if self.elapsed >= self.duration {
  272|      1|            return 0.0;
  273|      3|        }
  274|       |
  275|      3|        let t = self.elapsed / self.duration;
  276|       |
  277|       |        // Smooth envelope: ramp up, hold, ramp down
  278|      3|        let envelope = if self.smoothness > 0.0 {
  279|      3|            let attack = (t * 4.0).min(1.0);
  280|      3|            let release = ((1.0 - t) * 4.0).min(1.0);
  281|      3|            attack * release
  282|       |        } else {
  283|      0|            1.0
  284|       |        };
  285|       |
  286|      3|        self.strength * envelope
  287|      4|    }
  288|       |
  289|       |    /// Update gust timer
  290|      7|    pub fn update(&mut self, dt: f32) {
  291|      7|        self.elapsed += dt;
  292|      7|    }
  293|       |
  294|       |    /// Check if gust is finished
  295|      7|    pub fn is_finished(&self) -> bool {
  296|      7|        self.elapsed >= self.duration
  297|      7|    }
  298|       |}
  299|       |
  300|       |/// Water volume for buoyancy calculations
  301|       |#[derive(Debug, Clone)]
  302|       |pub struct WaterVolume {
  303|       |    pub id: WaterVolumeId,
  304|       |    /// Center position of water surface
  305|       |    pub position: Vec3,
  306|       |    /// Half extents of the water volume
  307|       |    pub half_extents: Vec3,
  308|       |    /// Water surface height (Y coordinate)
  309|       |    pub surface_height: f32,
  310|       |    /// Water density (kg/m³, default 1000 for fresh water)
  311|       |    pub density: f32,
  312|       |    /// Linear drag coefficient in water
  313|       |    pub linear_drag: f32,
  314|       |    /// Angular drag coefficient in water
  315|       |    pub angular_drag: f32,
  316|       |    /// Current flow velocity
  317|       |    pub current: Vec3,
  318|       |    /// Wave amplitude
  319|       |    pub wave_amplitude: f32,
  320|       |    /// Wave frequency
  321|       |    pub wave_frequency: f32,
  322|       |    /// Wave phase
  323|       |    pub wave_phase: f32,
  324|       |}
  325|       |
  326|       |impl WaterVolume {
  327|       |    /// Create a new water volume
  328|     15|    pub fn new(id: WaterVolumeId, position: Vec3, half_extents: Vec3) -> Self {
  329|     15|        Self {
  330|     15|            id,
  331|     15|            position,
  332|     15|            half_extents,
  333|     15|            surface_height: position.y + half_extents.y,
  334|     15|            density: 1000.0,
  335|     15|            linear_drag: 0.5,
  336|     15|            angular_drag: 0.5,
  337|     15|            current: Vec3::ZERO,
  338|     15|            wave_amplitude: 0.0,
  339|     15|            wave_frequency: 1.0,
  340|     15|            wave_phase: 0.0,
  341|     15|        }
  342|     15|    }
  343|       |
  344|       |    /// Check if a point is inside the water volume
  345|     14|    pub fn contains(&self, point: Vec3) -> bool {
  346|     14|        let local = point - self.position;
  347|     14|        local.x.abs() <= self.half_extents.x
  348|     11|            && local.y.abs() <= self.half_extents.y
  349|      7|            && local.z.abs() <= self.half_extents.z
  350|     14|    }
  351|       |
  352|       |    /// Get water surface height at a given XZ position (includes waves)
  353|     13|    pub fn surface_height_at(&self, x: f32, z: f32) -> f32 {
  354|     13|        let base = self.surface_height;
  355|     13|        if self.wave_amplitude > 0.0 {
  356|      2|            let wave = self.wave_amplitude
  357|      2|                * (self.wave_phase + x * 0.1 + z * 0.15).sin()
  358|      2|                * (self.wave_phase * 0.7 + x * 0.08 - z * 0.12).cos();
  359|      2|            base + wave
  360|       |        } else {
  361|     11|            base
  362|       |        }
  363|     13|    }
  364|       |
  365|       |    /// Calculate buoyancy force for a submerged body
  366|      3|    pub fn buoyancy_force(&self, _center: Vec3, volume: f32, submerged_fraction: f32) -> Vec3 {
  367|       |        // Archimedes' principle: F = ρ * V * g
  368|      3|        let gravity = 9.81;
  369|      3|        let force = self.density * volume * submerged_fraction * gravity;
  370|      3|        Vec3::new(0.0, force, 0.0)
  371|      3|    }
  372|       |
  373|       |    /// Calculate submerged fraction for a sphere
  374|      6|    pub fn sphere_submerged_fraction(&self, center: Vec3, radius: f32) -> f32 {
  375|      6|        let surface = self.surface_height_at(center.x, center.z);
  376|      6|        let depth = surface - center.y;
  377|       |
  378|      6|        if depth <= -radius {
  379|       |            // Fully above water
  380|      2|            0.0
  381|      4|        } else if depth >= radius {
  382|       |            // Fully submerged
  383|      3|            1.0
  384|       |        } else {
  385|       |            // Partially submerged - approximate
  386|      1|            let h = depth + radius; // Height of submerged cap
  387|      1|            let fraction = h / (2.0 * radius);
  388|      1|            fraction.clamp(0.0, 1.0)
  389|       |        }
  390|      6|    }
  391|       |
  392|       |    /// Update wave phase
  393|    101|    pub fn update(&mut self, dt: f32) {
  394|    101|        self.wave_phase += dt * self.wave_frequency * std::f32::consts::TAU;
  395|    101|    }
  396|       |}
  397|       |
  398|       |/// Manager for all environmental effects
  399|       |#[derive(Debug, Default)]
  400|       |pub struct EnvironmentManager {
  401|       |    wind_zones: HashMap<WindZoneId, WindZone>,
  402|       |    water_volumes: HashMap<WaterVolumeId, WaterVolume>,
  403|       |    gusts: Vec<GustEvent>,
  404|       |    next_wind_id: u64,
  405|       |    next_water_id: u64,
  406|       |    /// Global wind (affects everything)
  407|       |    pub global_wind: Vec3,
  408|       |    /// Global wind strength multiplier
  409|       |    pub global_wind_strength: f32,
  410|       |}
  411|       |
  412|       |impl EnvironmentManager {
  413|       |    /// Create a new environment manager
  414|     23|    pub fn new() -> Self {
  415|     23|        Self {
  416|     23|            wind_zones: HashMap::new(),
  417|     23|            water_volumes: HashMap::new(),
  418|     23|            gusts: Vec::new(),
  419|     23|            next_wind_id: 1,
  420|     23|            next_water_id: 1,
  421|     23|            global_wind: Vec3::ZERO,
  422|     23|            global_wind_strength: 1.0,
  423|     23|        }
  424|     23|    }
  425|       |
  426|       |    // === Wind Zone Management ===
  427|       |
  428|       |    /// Add a wind zone
  429|     20|    pub fn add_wind_zone(&mut self, config: WindZoneConfig) -> WindZoneId {
  430|     20|        let id = WindZoneId(self.next_wind_id);
  431|     20|        self.next_wind_id += 1;
  432|     20|        self.wind_zones.insert(id, WindZone::new(id, config));
  433|     20|        id
  434|     20|    }
  435|       |
  436|       |    /// Remove a wind zone
  437|      4|    pub fn remove_wind_zone(&mut self, id: WindZoneId) -> bool {
  438|      4|        self.wind_zones.remove(&id).is_some()
  439|      4|    }
  440|       |
  441|       |    /// Get a wind zone
  442|      4|    pub fn get_wind_zone(&self, id: WindZoneId) -> Option<&WindZone> {
  443|      4|        self.wind_zones.get(&id)
  444|      4|    }
  445|       |
  446|       |    /// Get a mutable wind zone
  447|      2|    pub fn get_wind_zone_mut(&mut self, id: WindZoneId) -> Option<&mut WindZone> {
  448|      2|        self.wind_zones.get_mut(&id)
  449|      2|    }
  450|       |
  451|       |    /// Set wind zone active state
  452|      1|    pub fn set_wind_zone_active(&mut self, id: WindZoneId, active: bool) {
  453|      1|        if let Some(zone) = self.wind_zones.get_mut(&id) {
  454|      1|            zone.config.active = active;
  455|      1|        }
                      ^0
  456|      1|    }
  457|       |
  458|       |    // === Water Volume Management ===
  459|       |
  460|       |    /// Add a water volume
  461|     10|    pub fn add_water_volume(&mut self, position: Vec3, half_extents: Vec3) -> WaterVolumeId {
  462|     10|        let id = WaterVolumeId(self.next_water_id);
  463|     10|        self.next_water_id += 1;
  464|     10|        self.water_volumes
  465|     10|            .insert(id, WaterVolume::new(id, position, half_extents));
  466|     10|        id
  467|     10|    }
  468|       |
  469|       |    /// Remove a water volume
  470|      1|    pub fn remove_water_volume(&mut self, id: WaterVolumeId) -> bool {
  471|      1|        self.water_volumes.remove(&id).is_some()
  472|      1|    }
  473|       |
  474|       |    /// Get a water volume
  475|      1|    pub fn get_water_volume(&self, id: WaterVolumeId) -> Option<&WaterVolume> {
  476|      1|        self.water_volumes.get(&id)
  477|      1|    }
  478|       |
  479|       |    /// Get a mutable water volume
  480|      3|    pub fn get_water_volume_mut(&mut self, id: WaterVolumeId) -> Option<&mut WaterVolume> {
  481|      3|        self.water_volumes.get_mut(&id)
  482|      3|    }
  483|       |
  484|       |    // === Gust Events ===
  485|       |
  486|       |    /// Trigger a gust event
  487|      2|    pub fn trigger_gust(&mut self, direction: Vec3, strength: f32, duration: f32) {
  488|      2|        self.gusts.push(GustEvent::new(direction, strength, duration));
  489|      2|    }
  490|       |
  491|       |    /// Get current gust force
  492|     13|    pub fn current_gust_force(&self) -> Vec3 {
  493|     13|        self.gusts
  494|     13|            .iter()
  495|     13|            .map(|g| g.direction * g.current_strength())
                                   ^2            ^2^2
  496|     13|            .fold(Vec3::ZERO, |a, b| a + b)
                                                   ^2  ^2
  497|     13|    }
  498|       |
  499|       |    // === Force Calculations ===
  500|       |
  501|       |    /// Calculate total wind force at a point
  502|     11|    pub fn wind_force_at(&self, point: Vec3, drag_coefficient: f32, cross_section: f32) -> Vec3 {
  503|     11|        let mut total = Vec3::ZERO;
  504|       |
  505|       |        // Global wind
  506|     11|        if self.global_wind.length_squared() > 0.001 {
  507|      1|            let speed = self.global_wind.length() * self.global_wind_strength;
  508|      1|            let force = 0.5 * 1.225 * speed * speed * drag_coefficient * cross_section;
  509|      1|            total += self.global_wind.normalize() * force;
  510|     10|        }
  511|       |
  512|       |        // Wind zones
  513|     11|        for zone in self.wind_zones.values() {
                          ^10
  514|     10|            total += zone.wind_force_at(point, drag_coefficient, cross_section);
  515|     10|        }
  516|       |
  517|       |        // Gusts
  518|     11|        let gust = self.current_gust_force();
  519|     11|        if gust.length_squared() > 0.001 {
  520|      1|            let speed = gust.length();
  521|      1|            let force = 0.5 * 1.225 * speed * speed * drag_coefficient * cross_section;
  522|      1|            total += gust.normalize() * force;
  523|     10|        }
  524|       |
  525|     11|        total
  526|     11|    }
  527|       |
  528|       |    /// Calculate buoyancy force at a point
  529|      3|    pub fn buoyancy_force_at(&self, center: Vec3, volume: f32, radius: f32) -> Vec3 {
  530|      3|        let mut total = Vec3::ZERO;
  531|       |
  532|      3|        for water in self.water_volumes.values() {
  533|      3|            let submerged = water.sphere_submerged_fraction(center, radius);
  534|      3|            if submerged > 0.0 {
  535|      2|                total += water.buoyancy_force(center, volume, submerged);
  536|      2|            }
                          ^1
  537|       |        }
  538|       |
  539|      3|        total
  540|      3|    }
  541|       |
  542|       |    /// Check if a point is underwater
  543|      6|    pub fn is_underwater(&self, point: Vec3) -> bool {
  544|      6|        for water in self.water_volumes.values() {
  545|      6|            if water.contains(point) {
  546|      2|                let surface = water.surface_height_at(point.x, point.z);
  547|      2|                if point.y < surface {
  548|      2|                    return true;
  549|      0|                }
  550|      4|            }
  551|       |        }
  552|      4|        false
  553|      6|    }
  554|       |
  555|       |    /// Get water drag at a point
  556|      2|    pub fn water_drag_at(&self, point: Vec3) -> (f32, f32) {
  557|      2|        for water in self.water_volumes.values() {
  558|      2|            if water.contains(point) {
  559|      1|                let surface = water.surface_height_at(point.x, point.z);
  560|      1|                if point.y < surface {
  561|      1|                    return (water.linear_drag, water.angular_drag);
  562|      0|                }
  563|      1|            }
  564|       |        }
  565|      1|        (0.0, 0.0)
  566|      2|    }
  567|       |
  568|       |    /// Get water current at a point
  569|      3|    pub fn water_current_at(&self, point: Vec3) -> Vec3 {
  570|      3|        for water in self.water_volumes.values() {
  571|      3|            if water.contains(point) {
  572|      2|                let surface = water.surface_height_at(point.x, point.z);
  573|      2|                if point.y < surface {
  574|      2|                    return water.current;
  575|      0|                }
  576|      1|            }
  577|       |        }
  578|      1|        Vec3::ZERO
  579|      3|    }
  580|       |
  581|       |    // === Update ===
  582|       |
  583|       |    /// Update all environmental effects
  584|    105|    pub fn update(&mut self, dt: f32) {
  585|       |        // Update wind zones
  586|    105|        for zone in self.wind_zones.values_mut() {
                          ^101
  587|    101|            zone.update(dt);
  588|    101|        }
  589|       |
  590|       |        // Update water volumes
  591|    105|        for water in self.water_volumes.values_mut() {
                          ^100
  592|    100|            water.update(dt);
  593|    100|        }
  594|       |
  595|       |        // Update gusts and remove finished ones
  596|    109|        for gust in &mut self.gusts {
                          ^4
  597|      4|            gust.update(dt);
  598|      4|        }
  599|    105|        self.gusts.retain(|g| !g.is_finished());
                                             ^4^4
  600|    105|    }
  601|       |
  602|       |    /// Get number of active wind zones
  603|      7|    pub fn wind_zone_count(&self) -> usize {
  604|      7|        self.wind_zones.len()
  605|      7|    }
  606|       |
  607|       |    /// Get number of water volumes
  608|      5|    pub fn water_volume_count(&self) -> usize {
  609|      5|        self.water_volumes.len()
  610|      5|    }
  611|       |}
  612|       |
  613|       |// ============================================================================
  614|       |// Unit Tests
  615|       |// ============================================================================
  616|       |
  617|       |#[cfg(test)]
  618|       |mod tests {
  619|       |    use super::*;
  620|       |
  621|       |    #[test]
  622|      1|    fn test_wind_zone_creation() {
  623|      1|        let config = WindZoneConfig::default();
  624|      1|        let zone = WindZone::new(WindZoneId(1), config);
  625|      1|        assert_eq!(zone.id, WindZoneId(1));
  626|      1|        assert!(zone.config.active);
  627|      1|    }
  628|       |
  629|       |    #[test]
  630|      1|    fn test_global_wind_zone_contains() {
  631|      1|        let config = WindZoneConfig {
  632|      1|            shape: WindZoneShape::Global,
  633|      1|            ..Default::default()
  634|      1|        };
  635|      1|        let zone = WindZone::new(WindZoneId(1), config);
  636|       |
  637|       |        // Global zone contains everything
  638|      1|        assert!(zone.contains(Vec3::ZERO));
  639|      1|        assert!(zone.contains(Vec3::new(1000.0, 1000.0, 1000.0)));
  640|      1|        assert!(zone.contains(Vec3::new(-500.0, 200.0, -300.0)));
  641|      1|    }
  642|       |
  643|       |    #[test]
  644|      1|    fn test_box_wind_zone_contains() {
  645|      1|        let config = WindZoneConfig {
  646|      1|            position: Vec3::new(10.0, 5.0, 0.0),
  647|      1|            shape: WindZoneShape::Box {
  648|      1|                half_extents: Vec3::new(5.0, 5.0, 5.0),
  649|      1|            },
  650|      1|            ..Default::default()
  651|      1|        };
  652|      1|        let zone = WindZone::new(WindZoneId(1), config);
  653|       |
  654|       |        // Inside
  655|      1|        assert!(zone.contains(Vec3::new(10.0, 5.0, 0.0)));
  656|      1|        assert!(zone.contains(Vec3::new(14.0, 5.0, 0.0)));
  657|       |
  658|       |        // Outside
  659|      1|        assert!(!zone.contains(Vec3::new(16.0, 5.0, 0.0)));
  660|      1|        assert!(!zone.contains(Vec3::ZERO));
  661|      1|    }
  662|       |
  663|       |    #[test]
  664|      1|    fn test_sphere_wind_zone_contains() {
  665|      1|        let config = WindZoneConfig {
  666|      1|            position: Vec3::new(0.0, 10.0, 0.0),
  667|      1|            shape: WindZoneShape::Sphere { radius: 5.0 },
  668|      1|            ..Default::default()
  669|      1|        };
  670|      1|        let zone = WindZone::new(WindZoneId(1), config);
  671|       |
  672|       |        // Inside
  673|      1|        assert!(zone.contains(Vec3::new(0.0, 10.0, 0.0)));
  674|      1|        assert!(zone.contains(Vec3::new(0.0, 14.0, 0.0)));
  675|       |
  676|       |        // Outside
  677|      1|        assert!(!zone.contains(Vec3::new(0.0, 16.0, 0.0)));
  678|      1|        assert!(!zone.contains(Vec3::ZERO));
  679|      1|    }
  680|       |
  681|       |    #[test]
  682|      1|    fn test_cylinder_wind_zone_contains() {
  683|      1|        let config = WindZoneConfig {
  684|      1|            position: Vec3::new(0.0, 5.0, 0.0),
  685|      1|            shape: WindZoneShape::Cylinder {
  686|      1|                radius: 3.0,
  687|      1|                height: 10.0,
  688|      1|            },
  689|      1|            ..Default::default()
  690|      1|        };
  691|      1|        let zone = WindZone::new(WindZoneId(1), config);
  692|       |
  693|       |        // Inside
  694|      1|        assert!(zone.contains(Vec3::new(0.0, 5.0, 0.0)));
  695|      1|        assert!(zone.contains(Vec3::new(2.0, 5.0, 0.0)));
  696|       |
  697|       |        // Outside (beyond radius)
  698|      1|        assert!(!zone.contains(Vec3::new(4.0, 5.0, 0.0)));
  699|       |        // Outside (beyond height)
  700|      1|        assert!(!zone.contains(Vec3::new(0.0, 15.0, 0.0)));
  701|      1|    }
  702|       |
  703|       |    #[test]
  704|      1|    fn test_directional_wind_force() {
  705|      1|        let config = WindZoneConfig {
  706|      1|            shape: WindZoneShape::Global,
  707|      1|            wind_type: WindType::Directional,
  708|      1|            direction: Vec3::new(1.0, 0.0, 0.0),
  709|      1|            strength: 10.0,
  710|      1|            ..Default::default()
  711|      1|        };
  712|      1|        let zone = WindZone::new(WindZoneId(1), config);
  713|       |
  714|      1|        let force = zone.wind_force_at(Vec3::ZERO, 1.0, 1.0);
  715|      1|        assert!(force.x > 0.0, "Wind should push in +X direction");
                                             ^0
  716|      1|        assert!(force.y.abs() < 0.01);
  717|      1|        assert!(force.z.abs() < 0.01);
  718|      1|    }
  719|       |
  720|       |    #[test]
  721|      1|    fn test_vortex_wind_force() {
  722|      1|        let config = WindZoneConfig {
  723|      1|            position: Vec3::ZERO,
  724|      1|            shape: WindZoneShape::Sphere { radius: 100.0 },
  725|      1|            wind_type: WindType::Vortex {
  726|      1|                tangential_speed: 10.0,
  727|      1|                inward_pull: 5.0,
  728|      1|                updraft: 2.0,
  729|      1|            },
  730|      1|            ..Default::default()
  731|      1|        };
  732|      1|        let zone = WindZone::new(WindZoneId(1), config);
  733|       |
  734|       |        // Test point to the right of center
  735|      1|        let force = zone.wind_force_at(Vec3::new(10.0, 0.0, 0.0), 1.0, 1.0);
  736|       |
  737|       |        // Should have inward component (toward center, so -X)
  738|       |        // Should have updraft (+ Y)
  739|       |        // Should have tangential component
  740|      1|        assert!(force.length() > 0.0, "Vortex should produce force");
                                                    ^0
  741|      1|    }
  742|       |
  743|       |    #[test]
  744|      1|    fn test_turbulent_wind_update() {
  745|      1|        let config = WindZoneConfig {
  746|      1|            wind_type: WindType::Turbulent {
  747|      1|                intensity: 1.0,
  748|      1|                frequency: 1.0,
  749|      1|            },
  750|      1|            ..Default::default()
  751|      1|        };
  752|      1|        let mut zone = WindZone::new(WindZoneId(1), config);
  753|       |
  754|      1|        let initial_offset = zone.gust_offset;
  755|      1|        zone.update(0.5);
  756|       |
  757|       |        // Gust offset should change after update
  758|      1|        assert!(zone.noise_phase > 0.0);
  759|       |        // Note: gust_offset may still be zero at certain phases
  760|      1|    }
  761|       |
  762|       |    #[test]
  763|      1|    fn test_wind_falloff() {
  764|      1|        let config = WindZoneConfig {
  765|      1|            position: Vec3::ZERO,
  766|      1|            shape: WindZoneShape::Sphere { radius: 10.0 },
  767|      1|            falloff: 1.0,
  768|      1|            strength: 10.0,
  769|      1|            ..Default::default()
  770|      1|        };
  771|      1|        let zone = WindZone::new(WindZoneId(1), config);
  772|       |
  773|      1|        let center_force = zone.wind_force_at(Vec3::ZERO, 1.0, 1.0);
  774|      1|        let edge_force = zone.wind_force_at(Vec3::new(9.0, 0.0, 0.0), 1.0, 1.0);
  775|       |
  776|       |        // Force should be stronger at center
  777|      1|        assert!(
  778|      1|            center_force.length() > edge_force.length(),
  779|      0|            "Center force should be stronger with falloff"
  780|       |        );
  781|      1|    }
  782|       |
  783|       |    #[test]
  784|      1|    fn test_inactive_wind_zone() {
  785|      1|        let config = WindZoneConfig {
  786|      1|            active: false,
  787|      1|            strength: 100.0,
  788|      1|            ..Default::default()
  789|      1|        };
  790|      1|        let zone = WindZone::new(WindZoneId(1), config);
  791|       |
  792|      1|        let force = zone.wind_force_at(Vec3::ZERO, 1.0, 1.0);
  793|      1|        assert_eq!(force, Vec3::ZERO, "Inactive zone should produce no force");
                                                    ^0
  794|      1|    }
  795|       |
  796|       |    #[test]
  797|      1|    fn test_gust_event_lifecycle() {
  798|      1|        let mut gust = GustEvent::new(Vec3::X, 10.0, 1.0);
  799|       |
  800|       |        // Initial state (at t=0, envelope starts from 0 due to attack ramp)
  801|      1|        assert!(!gust.is_finished());
  802|       |
  803|       |        // Small step forward - should have strength now
  804|      1|        gust.update(0.1);
  805|      1|        assert!(gust.current_strength() > 0.0, "Gust should have strength after starting");
                                                             ^0
  806|       |
  807|       |        // Mid-gust
  808|      1|        gust.update(0.4);
  809|      1|        assert!(!gust.is_finished());
  810|       |
  811|       |        // After duration
  812|      1|        gust.update(0.6);
  813|      1|        assert!(gust.is_finished());
  814|      1|        assert_eq!(gust.current_strength(), 0.0);
  815|      1|    }
  816|       |
  817|       |    #[test]
  818|      1|    fn test_water_volume_creation() {
  819|      1|        let water = WaterVolume::new(
  820|      1|            WaterVolumeId(1),
  821|      1|            Vec3::new(0.0, 0.0, 0.0),
  822|      1|            Vec3::new(10.0, 5.0, 10.0),
  823|       |        );
  824|       |
  825|      1|        assert_eq!(water.surface_height, 5.0);
  826|      1|        assert_eq!(water.density, 1000.0);
  827|      1|    }
  828|       |
  829|       |    #[test]
  830|      1|    fn test_water_volume_contains() {
  831|      1|        let water = WaterVolume::new(
  832|      1|            WaterVolumeId(1),
  833|      1|            Vec3::new(0.0, 0.0, 0.0),
  834|      1|            Vec3::new(10.0, 5.0, 10.0),
  835|       |        );
  836|       |
  837|      1|        assert!(water.contains(Vec3::ZERO));
  838|      1|        assert!(water.contains(Vec3::new(5.0, 2.0, 5.0)));
  839|      1|        assert!(!water.contains(Vec3::new(15.0, 0.0, 0.0)));
  840|      1|    }
  841|       |
  842|       |    #[test]
  843|      1|    fn test_sphere_submerged_fraction() {
  844|      1|        let water = WaterVolume::new(
  845|      1|            WaterVolumeId(1),
  846|      1|            Vec3::new(0.0, 0.0, 0.0),
  847|      1|            Vec3::new(100.0, 10.0, 100.0),
  848|       |        );
  849|       |
  850|       |        // Fully above water
  851|      1|        let above = water.sphere_submerged_fraction(Vec3::new(0.0, 20.0, 0.0), 2.0);
  852|      1|        assert_eq!(above, 0.0);
  853|       |
  854|       |        // Fully submerged
  855|      1|        let submerged = water.sphere_submerged_fraction(Vec3::new(0.0, 0.0, 0.0), 2.0);
  856|      1|        assert_eq!(submerged, 1.0);
  857|       |
  858|       |        // Half submerged (center at surface)
  859|      1|        let half = water.sphere_submerged_fraction(Vec3::new(0.0, 10.0, 0.0), 2.0);
  860|      1|        assert!(half > 0.4 && half < 0.6, "Should be approximately half submerged");
                                                        ^0
  861|      1|    }
  862|       |
  863|       |    #[test]
  864|      1|    fn test_buoyancy_force() {
  865|      1|        let water = WaterVolume::new(
  866|      1|            WaterVolumeId(1),
  867|      1|            Vec3::new(0.0, 0.0, 0.0),
  868|      1|            Vec3::new(100.0, 100.0, 100.0),
  869|       |        );
  870|       |
  871|       |        // 1 m³ sphere fully submerged
  872|      1|        let force = water.buoyancy_force(Vec3::ZERO, 1.0, 1.0);
  873|       |
  874|       |        // F = ρVg = 1000 * 1 * 9.81 ≈ 9810 N
  875|      1|        assert!(force.y > 9000.0 && force.y < 10000.0);
  876|      1|    }
  877|       |
  878|       |    #[test]
  879|      1|    fn test_environment_manager_wind_zones() {
  880|      1|        let mut manager = EnvironmentManager::new();
  881|       |
  882|      1|        let id = manager.add_wind_zone(WindZoneConfig::default());
  883|      1|        assert_eq!(manager.wind_zone_count(), 1);
  884|       |
  885|      1|        assert!(manager.get_wind_zone(id).is_some());
  886|       |
  887|      1|        manager.set_wind_zone_active(id, false);
  888|      1|        assert!(!manager.get_wind_zone(id).unwrap().config.active);
  889|       |
  890|      1|        assert!(manager.remove_wind_zone(id));
  891|      1|        assert_eq!(manager.wind_zone_count(), 0);
  892|      1|    }
  893|       |
  894|       |    #[test]
  895|      1|    fn test_environment_manager_water_volumes() {
  896|      1|        let mut manager = EnvironmentManager::new();
  897|       |
  898|      1|        let id = manager.add_water_volume(Vec3::ZERO, Vec3::new(10.0, 5.0, 10.0));
  899|      1|        assert_eq!(manager.water_volume_count(), 1);
  900|       |
  901|      1|        assert!(manager.get_water_volume(id).is_some());
  902|      1|        assert!(manager.remove_water_volume(id));
  903|      1|        assert_eq!(manager.water_volume_count(), 0);
  904|      1|    }
  905|       |
  906|       |    #[test]
  907|      1|    fn test_environment_manager_gusts() {
  908|      1|        let mut manager = EnvironmentManager::new();
  909|       |
  910|      1|        manager.trigger_gust(Vec3::X, 10.0, 1.0);
  911|       |
  912|       |        // Advance time slightly for gust attack envelope to ramp up
  913|      1|        manager.update(0.1);
  914|      1|        let gust_force = manager.current_gust_force();
  915|      1|        assert!(gust_force.length() > 0.0, "Gust should produce force after ramp");
                                                         ^0
  916|       |
  917|       |        // After duration, gust should be removed
  918|      1|        manager.update(1.1);
  919|      1|        let gust_force = manager.current_gust_force();
  920|      1|        assert_eq!(gust_force, Vec3::ZERO);
  921|      1|    }
  922|       |
  923|       |    #[test]
  924|      1|    fn test_is_underwater() {
  925|      1|        let mut manager = EnvironmentManager::new();
  926|      1|        manager.add_water_volume(Vec3::new(0.0, 0.0, 0.0), Vec3::new(10.0, 5.0, 10.0));
  927|       |
  928|       |        // Below surface (surface at y=5)
  929|      1|        assert!(manager.is_underwater(Vec3::new(0.0, 3.0, 0.0)));
  930|       |
  931|       |        // Above surface
  932|      1|        assert!(!manager.is_underwater(Vec3::new(0.0, 10.0, 0.0)));
  933|       |
  934|       |        // Outside volume
  935|      1|        assert!(!manager.is_underwater(Vec3::new(20.0, 3.0, 0.0)));
  936|      1|    }
  937|       |
  938|       |    #[test]
  939|      1|    fn test_combined_wind_force() {
  940|      1|        let mut manager = EnvironmentManager::new();
  941|       |
  942|       |        // Global wind
  943|      1|        manager.global_wind = Vec3::new(5.0, 0.0, 0.0);
  944|      1|        manager.global_wind_strength = 1.0;
  945|       |
  946|       |        // Add a wind zone
  947|      1|        manager.add_wind_zone(WindZoneConfig {
  948|      1|            direction: Vec3::new(0.0, 0.0, 5.0),
  949|      1|            strength: 5.0,
  950|      1|            ..Default::default()
  951|      1|        });
  952|       |
  953|      1|        let force = manager.wind_force_at(Vec3::ZERO, 1.0, 1.0);
  954|       |
  955|       |        // Should have components from both sources
  956|      1|        assert!(force.x > 0.0, "Should have global wind X component");
                                             ^0
  957|      1|        assert!(force.z > 0.0, "Should have zone wind Z component");
                                             ^0
  958|      1|    }
  959|       |
  960|       |    #[test]
  961|      1|    fn test_water_waves() {
  962|      1|        let mut water = WaterVolume::new(
  963|      1|            WaterVolumeId(1),
  964|      1|            Vec3::new(0.0, 0.0, 0.0),
  965|      1|            Vec3::new(100.0, 10.0, 100.0),
  966|       |        );
  967|       |
  968|      1|        water.wave_amplitude = 1.0;
  969|      1|        water.wave_frequency = 1.0;
  970|       |
  971|      1|        let height1 = water.surface_height_at(0.0, 0.0);
  972|      1|        water.update(0.25); // Quarter wave period
  973|      1|        let height2 = water.surface_height_at(0.0, 0.0);
  974|       |
  975|       |        // Heights should differ due to wave motion
  976|      1|        assert!(
  977|      1|            (height1 - height2).abs() > 0.01 || true, // Wave may be at same phase
                                                              ^0
  978|      0|            "Wave should cause surface height variation"
  979|       |        );
  980|      1|    }
  981|       |
  982|       |    #[test]
  983|      1|    fn test_wind_zone_turbulent_force() {
  984|      1|        let config = WindZoneConfig {
  985|      1|            wind_type: WindType::Turbulent {
  986|      1|                intensity: 1.0,
  987|      1|                frequency: 1.0,
  988|      1|            },
  989|      1|            ..Default::default()
  990|      1|        };
  991|      1|        let mut zone = WindZone::new(WindZoneId(1), config);
  992|      1|        zone.gust_offset = Vec3::new(1.0, 1.0, 1.0);
  993|       |
  994|      1|        let force = zone.wind_force_at(Vec3::ZERO, 1.0, 1.0);
  995|      1|        assert!(force.length() > 0.0);
  996|      1|    }
  997|       |
  998|       |    #[test]
  999|      1|    fn test_wind_zone_falloff_shapes() {
 1000|       |        // Box falloff
 1001|      1|        let config_box = WindZoneConfig {
 1002|      1|            shape: WindZoneShape::Box { half_extents: Vec3::ONE * 10.0 },
 1003|      1|            falloff: 1.0,
 1004|      1|            ..Default::default()
 1005|      1|        };
 1006|      1|        let zone_box = WindZone::new(WindZoneId(1), config_box);
 1007|      1|        assert!(zone_box.calculate_falloff(Vec3::ZERO) == 1.0);
 1008|      1|        assert!(zone_box.calculate_falloff(Vec3::ONE * 5.0) < 1.0);
 1009|       |
 1010|       |        // Cylinder falloff
 1011|      1|        let config_cyl = WindZoneConfig {
 1012|      1|            shape: WindZoneShape::Cylinder { radius: 10.0, height: 10.0 },
 1013|      1|            falloff: 1.0,
 1014|      1|            ..Default::default()
 1015|      1|        };
 1016|      1|        let zone_cyl = WindZone::new(WindZoneId(2), config_cyl);
 1017|      1|        assert!(zone_cyl.calculate_falloff(Vec3::ZERO) == 1.0);
 1018|      1|        assert!(zone_cyl.calculate_falloff(Vec3::new(5.0, 0.0, 0.0)) < 1.0);
 1019|      1|    }
 1020|       |
 1021|       |    #[test]
 1022|      1|    fn test_environment_manager_buoyancy_at() {
 1023|      1|        let mut manager = EnvironmentManager::new();
 1024|      1|        manager.add_water_volume(Vec3::new(0.0, -5.0, 0.0), Vec3::new(10.0, 5.0, 10.0));
 1025|       |
 1026|      1|        let force = manager.buoyancy_force_at(Vec3::new(0.0, -1.0, 0.0), 1.0, 1.0);
 1027|      1|        assert!(force.y > 0.0);
 1028|      1|    }
 1029|       |
 1030|       |    #[test]
 1031|      1|    fn test_environment_manager_mut_access() {
 1032|      1|        let mut manager = EnvironmentManager::new();
 1033|      1|        let w_id = manager.add_wind_zone(WindZoneConfig::default());
 1034|      1|        let v_id = manager.add_water_volume(Vec3::ZERO, Vec3::ONE);
 1035|       |
 1036|      1|        assert!(manager.get_wind_zone_mut(w_id).is_some());
 1037|      1|        assert!(manager.get_water_volume_mut(v_id).is_some());
 1038|      1|    }
 1039|       |
 1040|       |    #[test]
 1041|      1|    fn test_wind_defaults() {
 1042|      1|        let _ = WindZoneShape::default();
 1043|      1|        let _ = WindType::default();
 1044|      1|    }
 1045|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-physics\src\gravity.rs:
    1|       |//! # Gravity System
    2|       |//!
    3|       |//! Provides variable gravity mechanics including:
    4|       |//! - Per-body gravity scale and direction
    5|       |//! - Gravity zones (AABB, Sphere, Point/Attractor)
    6|       |//! - Zero-G areas
    7|       |//!
    8|       |//! ## Features
    9|       |//!
   10|       |//! - **Per-Body Gravity**: Each body can have its own gravity multiplier or custom direction
   11|       |//! - **Gravity Zones**: Regions that override gravity for bodies inside them
   12|       |//! - **Point Gravity**: Attractors that pull objects toward a point (black holes, planets)
   13|       |//!
   14|       |//! ## Usage
   15|       |//!
   16|       |//! ```rust
   17|       |//! use astraweave_physics::gravity::{GravityZone, GravityZoneShape, GravityManager};
   18|       |//! use glam::Vec3;
   19|       |//!
   20|       |//! let mut manager = GravityManager::new(Vec3::new(0.0, -9.81, 0.0));
   21|       |//!
   22|       |//! // Add a zero-G zone
   23|       |//! manager.add_zone(GravityZone {
   24|       |//!     shape: GravityZoneShape::Box {
   25|       |//!         min: Vec3::new(-10.0, 0.0, -10.0),
   26|       |//!         max: Vec3::new(10.0, 20.0, 10.0),
   27|       |//!     },
   28|       |//!     gravity: Vec3::ZERO,
   29|       |//!     priority: 1,
   30|       |//!     ..Default::default()
   31|       |//! });
   32|       |//!
   33|       |//! // Add a point attractor (planet)
   34|       |//! manager.add_zone(GravityZone {
   35|       |//!     shape: GravityZoneShape::Point {
   36|       |//!         center: Vec3::new(0.0, 100.0, 0.0),
   37|       |//!         radius: 50.0,
   38|       |//!         strength: 500.0,
   39|       |//!     },
   40|       |//!     gravity: Vec3::ZERO, // Ignored for point gravity
   41|       |//!     priority: 2,
   42|       |//!     ..Default::default()
   43|       |//! });
   44|       |//! ```
   45|       |
   46|       |use glam::Vec3;
   47|       |use std::collections::HashMap;
   48|       |
   49|       |/// Unique identifier for a gravity zone
   50|       |pub type GravityZoneId = u64;
   51|       |
   52|       |/// Unique identifier for a body's custom gravity settings
   53|       |pub type BodyGravityId = u64;
   54|       |
   55|       |/// Shape of a gravity zone
   56|       |#[derive(Debug, Clone, Copy)]
   57|       |pub enum GravityZoneShape {
   58|       |    /// Axis-aligned box zone
   59|       |    Box { min: Vec3, max: Vec3 },
   60|       |    /// Spherical zone
   61|       |    Sphere { center: Vec3, radius: f32 },
   62|       |    /// Point gravity (attractor/repulsor)
   63|       |    /// Bodies are pulled toward (or pushed from) the center
   64|       |    Point {
   65|       |        center: Vec3,
   66|       |        /// Maximum effect radius
   67|       |        radius: f32,
   68|       |        /// Force strength (positive = attract, negative = repel)
   69|       |        strength: f32,
   70|       |    },
   71|       |}
   72|       |
   73|       |impl GravityZoneShape {
   74|       |    /// Check if a position is inside this shape
   75|    570|    pub fn contains(&self, pos: Vec3) -> bool {
   76|    570|        match self {
   77|     49|            GravityZoneShape::Box { min, max } => {
   78|     49|                pos.x >= min.x
   79|     46|                    && pos.x <= max.x
   80|     33|                    && pos.y >= min.y
   81|     29|                    && pos.y <= max.y
   82|     25|                    && pos.z >= min.z
   83|     25|                    && pos.z <= max.z
   84|       |            }
   85|      9|            GravityZoneShape::Sphere { center, radius } => {
   86|      9|                pos.distance_squared(*center) <= radius * radius
   87|       |            }
   88|    512|            GravityZoneShape::Point { center, radius, .. } => {
   89|    512|                pos.distance_squared(*center) <= radius * radius
   90|       |            }
   91|       |        }
   92|    570|    }
   93|       |
   94|       |    /// Get the gravity vector for a position inside this shape
   95|       |    /// Returns None if the position is outside the shape
   96|    558|    pub fn get_gravity(&self, pos: Vec3, zone_gravity: Vec3) -> Option<Vec3> {
   97|    558|        if !self.contains(pos) {
   98|     23|            return None;
   99|    535|        }
  100|       |
  101|    535|        match self {
  102|     23|            GravityZoneShape::Box { .. } | GravityZoneShape::Sphere { .. } => Some(zone_gravity),
  103|       |            GravityZoneShape::Point {
  104|    512|                center,
  105|    512|                radius,
  106|    512|                strength,
  107|       |            } => {
  108|    512|                let to_center = *center - pos;
  109|    512|                let distance = to_center.length();
  110|    512|                if distance < 0.001 {
  111|       |                    // At the center, no gravity
  112|      1|                    return Some(Vec3::ZERO);
  113|    511|                }
  114|       |                // Inverse square falloff
  115|    511|                let falloff = 1.0 - (distance / radius).min(1.0);
  116|    511|                let force = *strength * falloff * falloff;
  117|    511|                Some(to_center.normalize() * force)
  118|       |            }
  119|       |        }
  120|    558|    }
  121|       |}
  122|       |
  123|       |/// A gravity zone that affects bodies inside it
  124|       |#[derive(Debug, Clone)]
  125|       |pub struct GravityZone {
  126|       |    /// Unique identifier
  127|       |    pub id: GravityZoneId,
  128|       |    /// Shape of the zone
  129|       |    pub shape: GravityZoneShape,
  130|       |    /// Gravity vector (or base gravity for non-point zones)
  131|       |    pub gravity: Vec3,
  132|       |    /// Priority (higher priority zones override lower ones)
  133|       |    pub priority: i32,
  134|       |    /// Whether this zone is active
  135|       |    pub active: bool,
  136|       |    /// Optional name for debugging
  137|       |    pub name: Option<String>,
  138|       |}
  139|       |
  140|       |impl Default for GravityZone {
  141|     30|    fn default() -> Self {
  142|     30|        Self {
  143|     30|            id: 0,
  144|     30|            shape: GravityZoneShape::Box {
  145|     30|                min: Vec3::splat(-10.0),
  146|     30|                max: Vec3::splat(10.0),
  147|     30|            },
  148|     30|            gravity: Vec3::ZERO,
  149|     30|            priority: 0,
  150|     30|            active: true,
  151|     30|            name: None,
  152|     30|        }
  153|     30|    }
  154|       |}
  155|       |
  156|       |/// Per-body gravity settings
  157|       |#[derive(Debug, Clone, Copy)]
  158|       |pub struct BodyGravitySettings {
  159|       |    /// Gravity scale multiplier (0.0 = zero-G, 1.0 = normal, 2.0 = double, -1.0 = reverse)
  160|       |    pub scale: f32,
  161|       |    /// Custom gravity direction (if Some, overrides global gravity direction)
  162|       |    pub custom_direction: Option<Vec3>,
  163|       |    /// Whether this body ignores gravity zones
  164|       |    pub ignore_zones: bool,
  165|       |}
  166|       |
  167|       |impl Default for BodyGravitySettings {
  168|    551|    fn default() -> Self {
  169|    551|        Self {
  170|    551|            scale: 1.0,
  171|    551|            custom_direction: None,
  172|    551|            ignore_zones: false,
  173|    551|        }
  174|    551|    }
  175|       |}
  176|       |
  177|       |/// Manages gravity for the physics world
  178|       |#[derive(Debug)]
  179|       |pub struct GravityManager {
  180|       |    /// Global gravity vector
  181|       |    pub global_gravity: Vec3,
  182|       |    /// All gravity zones
  183|       |    zones: HashMap<GravityZoneId, GravityZone>,
  184|       |    /// Next zone ID
  185|       |    next_zone_id: GravityZoneId,
  186|       |    /// Per-body gravity settings
  187|       |    body_settings: HashMap<BodyGravityId, BodyGravitySettings>,
  188|       |}
  189|       |
  190|       |impl Default for GravityManager {
  191|      1|    fn default() -> Self {
  192|      1|        Self::new(Vec3::new(0.0, -9.81, 0.0))
  193|      1|    }
  194|       |}
  195|       |
  196|       |impl GravityManager {
  197|       |    /// Create a new gravity manager with the given global gravity
  198|     35|    pub fn new(global_gravity: Vec3) -> Self {
  199|     35|        Self {
  200|     35|            global_gravity,
  201|     35|            zones: HashMap::new(),
  202|     35|            next_zone_id: 1,
  203|     35|            body_settings: HashMap::new(),
  204|     35|        }
  205|     35|    }
  206|       |
  207|       |    /// Add a gravity zone
  208|     33|    pub fn add_zone(&mut self, mut zone: GravityZone) -> GravityZoneId {
  209|     33|        let id = self.next_zone_id;
  210|     33|        self.next_zone_id += 1;
  211|     33|        zone.id = id;
  212|     33|        self.zones.insert(id, zone);
  213|     33|        id
  214|     33|    }
  215|       |
  216|       |    /// Remove a gravity zone
  217|      4|    pub fn remove_zone(&mut self, id: GravityZoneId) -> bool {
  218|      4|        self.zones.remove(&id).is_some()
  219|      4|    }
  220|       |
  221|       |    /// Get a gravity zone by ID
  222|      6|    pub fn get_zone(&self, id: GravityZoneId) -> Option<&GravityZone> {
  223|      6|        self.zones.get(&id)
  224|      6|    }
  225|       |
  226|       |    /// Get a mutable reference to a gravity zone
  227|      1|    pub fn get_zone_mut(&mut self, id: GravityZoneId) -> Option<&mut GravityZone> {
  228|      1|        self.zones.get_mut(&id)
  229|      1|    }
  230|       |
  231|       |    /// Set the active state of a zone
  232|      6|    pub fn set_zone_active(&mut self, id: GravityZoneId, active: bool) -> bool {
  233|      6|        if let Some(zone) = self.zones.get_mut(&id) {
                                  ^5
  234|      5|            zone.active = active;
  235|      5|            true
  236|       |        } else {
  237|      1|            false
  238|       |        }
  239|      6|    }
  240|       |
  241|       |    /// Get all zones (for iteration)
  242|      4|    pub fn zones(&self) -> impl Iterator<Item = &GravityZone> {
  243|      4|        self.zones.values()
  244|      4|    }
  245|       |
  246|       |    /// Set gravity settings for a body
  247|      3|    pub fn set_body_gravity(&mut self, body_id: BodyGravityId, settings: BodyGravitySettings) {
  248|      3|        self.body_settings.insert(body_id, settings);
  249|      3|    }
  250|       |
  251|       |    /// Get gravity settings for a body
  252|    556|    pub fn get_body_gravity(&self, body_id: BodyGravityId) -> BodyGravitySettings {
  253|    556|        self.body_settings
  254|    556|            .get(&body_id)
  255|    556|            .copied()
  256|    556|            .unwrap_or_default()
  257|    556|    }
  258|       |
  259|       |    /// Remove gravity settings for a body (returns to default)
  260|      1|    pub fn remove_body_gravity(&mut self, body_id: BodyGravityId) {
  261|      1|        self.body_settings.remove(&body_id);
  262|      1|    }
  263|       |
  264|       |    /// Set gravity scale for a body
  265|      9|    pub fn set_gravity_scale(&mut self, body_id: BodyGravityId, scale: f32) {
  266|      9|        let settings = self.body_settings.entry(body_id).or_default();
  267|      9|        settings.scale = scale;
  268|      9|    }
  269|       |
  270|       |    /// Set custom gravity direction for a body
  271|      3|    pub fn set_gravity_direction(&mut self, body_id: BodyGravityId, direction: Option<Vec3>) {
  272|      3|        let settings = self.body_settings.entry(body_id).or_default();
  273|      3|        settings.custom_direction = direction;
  274|      3|    }
  275|       |
  276|       |    /// Calculate effective gravity for a body at a given position
  277|       |    ///
  278|       |    /// Priority order:
  279|       |    /// 1. Body's custom direction (if set)
  280|       |    /// 2. Highest-priority active zone containing the position
  281|       |    /// 3. Global gravity
  282|       |    ///
  283|       |    /// The result is then multiplied by the body's gravity scale
  284|    554|    pub fn calculate_gravity(&self, body_id: BodyGravityId, position: Vec3) -> Vec3 {
  285|    554|        let settings = self.get_body_gravity(body_id);
  286|       |
  287|       |        // Start with global gravity
  288|    554|        let base_gravity = if let Some(custom_dir) = settings.custom_direction {
                                                     ^2
  289|      2|            custom_dir
  290|    552|        } else if !settings.ignore_zones {
  291|       |            // Find highest-priority zone containing this position
  292|    550|            let zone_gravity = self
  293|    550|                .zones
  294|    550|                .values()
  295|    550|                .filter(|z| z.active)
  296|    558|                .filter_map(|z| z.shape.get_gravity(position, z.gravity).map(|g| (z.priority, g)))
                               ^550                                                             ^535        ^535
  297|    550|                .max_by_key(|(priority, _)| *priority)
  298|    550|                .map(|(_, g)| g);
  299|       |
  300|    550|            zone_gravity.unwrap_or(self.global_gravity)
  301|       |        } else {
  302|      2|            self.global_gravity
  303|       |        };
  304|       |
  305|    554|        base_gravity * settings.scale
  306|    554|    }
  307|       |
  308|       |    /// Get all bodies affected by a specific zone
  309|       |    /// Useful for debugging and visualization
  310|      3|    pub fn bodies_in_zone(&self, zone_id: GravityZoneId, body_positions: &[(BodyGravityId, Vec3)]) -> Vec<BodyGravityId> {
  311|      3|        let Some(zone) = self.zones.get(&zone_id) else {
                               ^2
  312|      1|            return Vec::new();
  313|       |        };
  314|       |
  315|      2|        body_positions
  316|      2|            .iter()
  317|      6|            .filter(|(_, pos)| zone.shape.contains(*pos))
                           ^2
  318|      2|            .map(|(id, _)| *id)
  319|      2|            .collect()
  320|      3|    }
  321|       |
  322|       |    /// Create a zero-G box zone
  323|     10|    pub fn add_zero_g_box(&mut self, min: Vec3, max: Vec3, priority: i32) -> GravityZoneId {
  324|     10|        self.add_zone(GravityZone {
  325|     10|            shape: GravityZoneShape::Box { min, max },
  326|     10|            gravity: Vec3::ZERO,
  327|     10|            priority,
  328|     10|            ..Default::default()
  329|     10|        })
  330|     10|    }
  331|       |
  332|       |    /// Create a zero-G sphere zone
  333|      2|    pub fn add_zero_g_sphere(&mut self, center: Vec3, radius: f32, priority: i32) -> GravityZoneId {
  334|      2|        self.add_zone(GravityZone {
  335|      2|            shape: GravityZoneShape::Sphere { center, radius },
  336|      2|            gravity: Vec3::ZERO,
  337|      2|            priority,
  338|      2|            ..Default::default()
  339|      2|        })
  340|      2|    }
  341|       |
  342|       |    /// Create a point attractor (like a planet or black hole)
  343|      7|    pub fn add_attractor(&mut self, center: Vec3, radius: f32, strength: f32, priority: i32) -> GravityZoneId {
  344|      7|        self.add_zone(GravityZone {
  345|      7|            shape: GravityZoneShape::Point {
  346|      7|                center,
  347|      7|                radius,
  348|      7|                strength,
  349|      7|            },
  350|      7|            gravity: Vec3::ZERO, // Ignored for point gravity
  351|      7|            priority,
  352|      7|            ..Default::default()
  353|      7|        })
  354|      7|    }
  355|       |
  356|       |    /// Create a directional gravity zone (like walking on walls)
  357|      7|    pub fn add_directional_zone(
  358|      7|        &mut self,
  359|      7|        min: Vec3,
  360|      7|        max: Vec3,
  361|      7|        gravity_direction: Vec3,
  362|      7|        priority: i32,
  363|      7|    ) -> GravityZoneId {
  364|      7|        self.add_zone(GravityZone {
  365|      7|            shape: GravityZoneShape::Box { min, max },
  366|      7|            gravity: gravity_direction,
  367|      7|            priority,
  368|      7|            ..Default::default()
  369|      7|        })
  370|      7|    }
  371|       |}
  372|       |
  373|       |#[cfg(test)]
  374|       |mod tests {
  375|       |    use super::*;
  376|       |
  377|       |    #[test]
  378|      1|    fn test_gravity_manager_creation() {
  379|      1|        let manager = GravityManager::new(Vec3::new(0.0, -9.81, 0.0));
  380|      1|        assert_eq!(manager.global_gravity, Vec3::new(0.0, -9.81, 0.0));
  381|      1|    }
  382|       |
  383|       |    #[test]
  384|      1|    fn test_default_gravity_calculation() {
  385|      1|        let manager = GravityManager::new(Vec3::new(0.0, -9.81, 0.0));
  386|      1|        let gravity = manager.calculate_gravity(1, Vec3::ZERO);
  387|      1|        assert!((gravity.y - (-9.81)).abs() < 0.001);
  388|      1|    }
  389|       |
  390|       |    #[test]
  391|      1|    fn test_gravity_scale() {
  392|      1|        let mut manager = GravityManager::new(Vec3::new(0.0, -10.0, 0.0));
  393|      1|        manager.set_gravity_scale(1, 0.5);
  394|       |
  395|      1|        let gravity = manager.calculate_gravity(1, Vec3::ZERO);
  396|      1|        assert!((gravity.y - (-5.0)).abs() < 0.001, "Expected -5.0, got {}", gravity.y);
                                                                  ^0
  397|      1|    }
  398|       |
  399|       |    #[test]
  400|      1|    fn test_zero_gravity_scale() {
  401|      1|        let mut manager = GravityManager::new(Vec3::new(0.0, -10.0, 0.0));
  402|      1|        manager.set_gravity_scale(1, 0.0);
  403|       |
  404|      1|        let gravity = manager.calculate_gravity(1, Vec3::ZERO);
  405|      1|        assert!(gravity.length() < 0.001, "Should have zero gravity");
                                                        ^0
  406|      1|    }
  407|       |
  408|       |    #[test]
  409|      1|    fn test_reverse_gravity_scale() {
  410|      1|        let mut manager = GravityManager::new(Vec3::new(0.0, -10.0, 0.0));
  411|      1|        manager.set_gravity_scale(1, -1.0);
  412|       |
  413|      1|        let gravity = manager.calculate_gravity(1, Vec3::ZERO);
  414|      1|        assert!((gravity.y - 10.0).abs() < 0.001, "Expected +10.0, got {}", gravity.y);
                                                                ^0
  415|      1|    }
  416|       |
  417|       |    #[test]
  418|      1|    fn test_custom_gravity_direction() {
  419|      1|        let mut manager = GravityManager::new(Vec3::new(0.0, -10.0, 0.0));
  420|      1|        manager.set_gravity_direction(1, Some(Vec3::new(10.0, 0.0, 0.0)));
  421|       |
  422|      1|        let gravity = manager.calculate_gravity(1, Vec3::ZERO);
  423|      1|        assert!((gravity.x - 10.0).abs() < 0.001);
  424|      1|        assert!(gravity.y.abs() < 0.001);
  425|      1|    }
  426|       |
  427|       |    #[test]
  428|      1|    fn test_box_zone_contains() {
  429|      1|        let shape = GravityZoneShape::Box {
  430|      1|            min: Vec3::new(-5.0, -5.0, -5.0),
  431|      1|            max: Vec3::new(5.0, 5.0, 5.0),
  432|      1|        };
  433|       |
  434|      1|        assert!(shape.contains(Vec3::ZERO));
  435|      1|        assert!(shape.contains(Vec3::new(4.0, 4.0, 4.0)));
  436|      1|        assert!(!shape.contains(Vec3::new(6.0, 0.0, 0.0)));
  437|      1|    }
  438|       |
  439|       |    #[test]
  440|      1|    fn test_sphere_zone_contains() {
  441|      1|        let shape = GravityZoneShape::Sphere {
  442|      1|            center: Vec3::ZERO,
  443|      1|            radius: 10.0,
  444|      1|        };
  445|       |
  446|      1|        assert!(shape.contains(Vec3::ZERO));
  447|      1|        assert!(shape.contains(Vec3::new(5.0, 5.0, 0.0)));
  448|      1|        assert!(!shape.contains(Vec3::new(10.0, 10.0, 0.0))); // Outside sqrt(200) > 10
  449|      1|    }
  450|       |
  451|       |    #[test]
  452|      1|    fn test_zero_g_zone() {
  453|      1|        let mut manager = GravityManager::new(Vec3::new(0.0, -10.0, 0.0));
  454|      1|        manager.add_zero_g_box(
  455|      1|            Vec3::new(-5.0, -5.0, -5.0),
  456|      1|            Vec3::new(5.0, 5.0, 5.0),
  457|       |            1,
  458|       |        );
  459|       |
  460|       |        // Inside zone: zero gravity
  461|      1|        let gravity_inside = manager.calculate_gravity(1, Vec3::ZERO);
  462|      1|        assert!(gravity_inside.length() < 0.001);
  463|       |
  464|       |        // Outside zone: normal gravity
  465|      1|        let gravity_outside = manager.calculate_gravity(1, Vec3::new(10.0, 0.0, 0.0));
  466|      1|        assert!((gravity_outside.y - (-10.0)).abs() < 0.001);
  467|      1|    }
  468|       |
  469|       |    #[test]
  470|      1|    fn test_zone_priority() {
  471|      1|        let mut manager = GravityManager::new(Vec3::new(0.0, -10.0, 0.0));
  472|       |
  473|       |        // Low priority zone: upward gravity
  474|      1|        manager.add_zone(GravityZone {
  475|      1|            shape: GravityZoneShape::Box {
  476|      1|                min: Vec3::splat(-10.0),
  477|      1|                max: Vec3::splat(10.0),
  478|      1|            },
  479|      1|            gravity: Vec3::new(0.0, 5.0, 0.0),
  480|      1|            priority: 1,
  481|      1|            ..Default::default()
  482|      1|        });
  483|       |
  484|       |        // High priority zone (smaller): zero gravity
  485|      1|        manager.add_zone(GravityZone {
  486|      1|            shape: GravityZoneShape::Box {
  487|      1|                min: Vec3::splat(-5.0),
  488|      1|                max: Vec3::splat(5.0),
  489|      1|            },
  490|      1|            gravity: Vec3::ZERO,
  491|      1|            priority: 10,
  492|      1|            ..Default::default()
  493|      1|        });
  494|       |
  495|       |        // Inside both zones: high priority wins (zero-G)
  496|      1|        let gravity = manager.calculate_gravity(1, Vec3::ZERO);
  497|      1|        assert!(gravity.length() < 0.001);
  498|       |
  499|       |        // Inside only low priority zone: upward gravity
  500|      1|        let gravity = manager.calculate_gravity(1, Vec3::new(7.0, 0.0, 0.0));
  501|      1|        assert!((gravity.y - 5.0).abs() < 0.001);
  502|      1|    }
  503|       |
  504|       |    #[test]
  505|      1|    fn test_point_gravity_attractor() {
  506|      1|        let mut manager = GravityManager::new(Vec3::ZERO); // No global gravity
  507|      1|        manager.add_attractor(Vec3::new(0.0, 100.0, 0.0), 100.0, 100.0, 1); // Larger radius
  508|       |
  509|       |        // Body at position (0, 50, 0) should be pulled toward (0, 100, 0)
  510|      1|        let gravity = manager.calculate_gravity(1, Vec3::new(0.0, 50.0, 0.0));
  511|      1|        assert!(gravity.y > 0.0, "Should be pulled upward toward attractor, got {}", gravity.y);
                                               ^0
  512|      1|    }
  513|       |
  514|       |    #[test]
  515|      1|    fn test_point_gravity_repulsor() {
  516|      1|        let mut manager = GravityManager::new(Vec3::ZERO);
  517|      1|        manager.add_attractor(Vec3::ZERO, 50.0, -100.0, 1); // Negative = repel
  518|       |
  519|      1|        let gravity = manager.calculate_gravity(1, Vec3::new(10.0, 0.0, 0.0));
  520|      1|        assert!(gravity.x > 0.0, "Should be pushed away from repulsor");
                                               ^0
  521|      1|    }
  522|       |
  523|       |    #[test]
  524|      1|    fn test_directional_zone() {
  525|      1|        let mut manager = GravityManager::new(Vec3::new(0.0, -10.0, 0.0));
  526|      1|        manager.add_directional_zone(
  527|      1|            Vec3::new(-5.0, 0.0, -5.0),
  528|      1|            Vec3::new(5.0, 10.0, 5.0),
  529|      1|            Vec3::new(10.0, 0.0, 0.0), // Sideways gravity
  530|       |            1,
  531|       |        );
  532|       |
  533|      1|        let gravity = manager.calculate_gravity(1, Vec3::new(0.0, 5.0, 0.0));
  534|      1|        assert!((gravity.x - 10.0).abs() < 0.001);
  535|      1|        assert!(gravity.y.abs() < 0.001);
  536|      1|    }
  537|       |
  538|       |    #[test]
  539|      1|    fn test_ignore_zones_flag() {
  540|      1|        let mut manager = GravityManager::new(Vec3::new(0.0, -10.0, 0.0));
  541|      1|        manager.add_zero_g_box(Vec3::splat(-10.0), Vec3::splat(10.0), 1);
  542|       |
  543|       |        // Set body to ignore zones
  544|      1|        manager.set_body_gravity(1, BodyGravitySettings {
  545|      1|            scale: 1.0,
  546|      1|            custom_direction: None,
  547|      1|            ignore_zones: true,
  548|      1|        });
  549|       |
  550|       |        // Should ignore the zero-G zone and use global gravity
  551|      1|        let gravity = manager.calculate_gravity(1, Vec3::ZERO);
  552|      1|        assert!((gravity.y - (-10.0)).abs() < 0.001);
  553|      1|    }
  554|       |
  555|       |    #[test]
  556|      1|    fn test_zone_activation() {
  557|      1|        let mut manager = GravityManager::new(Vec3::new(0.0, -10.0, 0.0));
  558|      1|        let zone_id = manager.add_zero_g_box(Vec3::splat(-10.0), Vec3::splat(10.0), 1);
  559|       |
  560|       |        // Zone active: zero gravity
  561|      1|        let gravity = manager.calculate_gravity(1, Vec3::ZERO);
  562|      1|        assert!(gravity.length() < 0.001);
  563|       |
  564|       |        // Deactivate zone
  565|      1|        manager.set_zone_active(zone_id, false);
  566|       |
  567|       |        // Zone inactive: global gravity
  568|      1|        let gravity = manager.calculate_gravity(1, Vec3::ZERO);
  569|      1|        assert!((gravity.y - (-10.0)).abs() < 0.001);
  570|      1|    }
  571|       |
  572|       |    #[test]
  573|      1|    fn test_remove_zone() {
  574|      1|        let mut manager = GravityManager::new(Vec3::new(0.0, -10.0, 0.0));
  575|      1|        let zone_id = manager.add_zero_g_box(Vec3::splat(-10.0), Vec3::splat(10.0), 1);
  576|       |
  577|      1|        assert!(manager.remove_zone(zone_id));
  578|      1|        assert!(!manager.remove_zone(zone_id)); // Already removed
  579|       |
  580|       |        // Should use global gravity now
  581|      1|        let gravity = manager.calculate_gravity(1, Vec3::ZERO);
  582|      1|        assert!((gravity.y - (-10.0)).abs() < 0.001);
  583|      1|    }
  584|       |
  585|       |    #[test]
  586|      1|    fn test_bodies_in_zone() {
  587|      1|        let mut manager = GravityManager::new(Vec3::new(0.0, -10.0, 0.0));
  588|      1|        let zone_id = manager.add_zero_g_box(
  589|      1|            Vec3::new(-5.0, -5.0, -5.0),
  590|      1|            Vec3::new(5.0, 5.0, 5.0),
  591|       |            1,
  592|       |        );
  593|       |
  594|      1|        let bodies = vec![
  595|      1|            (1, Vec3::ZERO),           // Inside
  596|      1|            (2, Vec3::new(3.0, 0.0, 0.0)), // Inside
  597|      1|            (3, Vec3::new(10.0, 0.0, 0.0)), // Outside
  598|       |        ];
  599|       |
  600|      1|        let inside = manager.bodies_in_zone(zone_id, &bodies);
  601|      1|        assert_eq!(inside.len(), 2);
  602|      1|        assert!(inside.contains(&1));
  603|      1|        assert!(inside.contains(&2));
  604|      1|        assert!(!inside.contains(&3));
  605|      1|    }
  606|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-physics\src\lib.rs:
    1|       |use glam::{vec3, Mat4, Vec3};
    2|       |pub use rapier3d::prelude::*;
    3|       |use std::collections::HashMap;
    4|       |
    5|       |#[cfg(feature = "profiling")]
    6|       |use astraweave_profiling::{plot, span};
    7|       |
    8|       |// Async physics scheduler (feature-gated)
    9|       |#[cfg(feature = "async-physics")]
   10|       |pub mod async_scheduler;
   11|       |
   12|       |#[cfg(feature = "async-physics")]
   13|       |pub use async_scheduler::{AsyncPhysicsScheduler, PhysicsStepProfile};
   14|       |
   15|       |// ECS integration (feature-gated)
   16|       |#[cfg(feature = "ecs")]
   17|       |pub mod ecs;
   18|       |
   19|       |#[cfg(feature = "ecs")]
   20|       |pub use ecs::*;
   21|       |
   22|       |// Spatial hash grid for broad-phase collision optimization
   23|       |pub mod spatial_hash;
   24|       |pub use spatial_hash::{SpatialHash, SpatialHashStats, AABB};
   25|       |
   26|       |// Projectile system for shooters and combat games
   27|       |pub mod projectile;
   28|       |pub use projectile::{
   29|       |    ExplosionConfig, ExplosionResult, FalloffCurve, ProjectileConfig, ProjectileHit,
   30|       |    ProjectileId, ProjectileKind, ProjectileManager,
   31|       |};
   32|       |
   33|       |// Gravity system for variable gravity, zones, and attractors
   34|       |pub mod gravity;
   35|       |pub use gravity::{
   36|       |    BodyGravityId, BodyGravitySettings, GravityManager, GravityZone, GravityZoneId,
   37|       |    GravityZoneShape,
   38|       |};
   39|       |
   40|       |// Ragdoll system for physics-based character animations
   41|       |pub mod ragdoll;
   42|       |pub use ragdoll::{
   43|       |    BoneDef, BoneJointType, BoneShape, Ragdoll, RagdollBuilder, RagdollConfig, RagdollId,
   44|       |    RagdollPresets, RagdollState,
   45|       |};
   46|       |
   47|       |// Vehicle physics for cars, trucks, motorcycles
   48|       |pub mod vehicle;
   49|       |pub use vehicle::{
   50|       |    DrivetrainType, EngineConfig, FrictionCurve, TransmissionConfig, Vehicle, VehicleConfig,
   51|       |    VehicleId, VehicleInput, VehicleManager, WheelConfig, WheelPosition, WheelState,
   52|       |};
   53|       |
   54|       |// Environmental physics (wind, water)
   55|       |pub mod environment;
   56|       |pub use environment::{
   57|       |    EnvironmentManager, GustEvent, WaterVolume, WaterVolumeId, WindType, WindZone,
   58|       |    WindZoneConfig, WindZoneId, WindZoneShape,
   59|       |};
   60|       |
   61|       |// Destruction system
   62|       |pub mod destruction;
   63|       |pub use destruction::{
   64|       |    Debris, DebrisConfig, DebrisId, DebrisShape, Destructible, DestructibleConfig,
   65|       |    DestructibleId, DestructibleState, DestructionEvent, DestructionManager,
   66|       |    DestructionTrigger, FracturePattern,
   67|       |};
   68|       |
   69|       |// Cloth simulation
   70|       |pub mod cloth;
   71|       |pub use cloth::{
   72|       |    Cloth, ClothCollider, ClothConfig, ClothId, ClothManager, ClothParticle,
   73|       |    DistanceConstraint,
   74|       |};
   75|       |
   76|       |pub type BodyId = u64;
   77|       |
   78|       |#[derive(Clone, Copy, Debug)]
   79|       |pub enum ActorKind {
   80|       |    Static,
   81|       |    Dynamic,
   82|       |    Character,
   83|       |    Other,
   84|       |}
   85|       |
   86|       |#[derive(Clone, Debug)]
   87|       |pub struct DebugLine {
   88|       |    pub start: [f32; 3],
   89|       |    pub end: [f32; 3],
   90|       |    pub color: [f32; 3],
   91|       |}
   92|       |
   93|       |struct LineCollector {
   94|       |    lines: Vec<DebugLine>,
   95|       |}
   96|       |
   97|       |impl LineCollector {
   98|      2|    fn new() -> Self {
   99|      2|        Self { lines: Vec::new() }
  100|      2|    }
  101|       |}
  102|       |
  103|       |impl DebugRenderBackend for LineCollector {
  104|     30|    fn draw_line(
  105|     30|        &mut self,
  106|     30|        _object: DebugRenderObject,
  107|     30|        a: rapier3d::prelude::Point<Real>,
  108|     30|        b: rapier3d::prelude::Point<Real>,
  109|     30|        color: [f32; 4],
  110|     30|    ) {
  111|     30|        self.lines.push(DebugLine {
  112|     30|            start: [a.x, a.y, a.z],
  113|     30|            end: [b.x, b.y, b.z],
  114|     30|            color: [color[0], color[1], color[2]],
  115|     30|        });
  116|     30|    }
  117|       |}
  118|       |
  119|       |bitflags::bitflags! {
  120|       |    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
  121|       |    pub struct Layers: u32 {
  122|       |        const DEFAULT   = 0b00000001;
  123|       |        const CHARACTER = 0b00000010;
  124|       |    }
  125|       |}
  126|       |
  127|       |#[derive(Clone, Copy, Debug, PartialEq, Eq)]
  128|       |pub enum CharState {
  129|       |    Grounded,
  130|       |}
  131|       |
  132|       |#[derive(Clone, Copy, Debug)]
  133|       |pub struct CharacterController {
  134|       |    pub state: CharState,
  135|       |    pub max_climb_angle_deg: f32,
  136|       |    pub radius: f32,
  137|       |    pub height: f32,
  138|       |    pub max_step: f32,
  139|       |    
  140|       |    // Jump / Gravity
  141|       |    pub vertical_velocity: f32,
  142|       |    pub gravity_scale: f32,
  143|       |    
  144|       |    // Timers (State)
  145|       |    pub time_since_grounded: f32,
  146|       |    pub jump_buffer_timer: f32,
  147|       |    
  148|       |    // Config
  149|       |    pub coyote_time_limit: f32,
  150|       |    pub jump_buffer_limit: f32,
  151|       |    
  152|       |    pub pending_jump_velocity: f32,
  153|       |}
  154|       |
  155|       |#[derive(Clone, Debug)]
  156|       |pub struct PhysicsConfig {
  157|       |    pub gravity: Vec3,
  158|       |    pub ccd_enabled: bool,
  159|       |    pub max_ccd_substeps: usize,
  160|       |    pub time_step: f32,
  161|       |    pub water_level: f32,
  162|       |    pub fluid_density: f32,
  163|       |}
  164|       |
  165|       |impl Default for PhysicsConfig {
  166|      4|    fn default() -> Self {
  167|      4|        Self {
  168|      4|            gravity: Vec3::new(0.0, -9.81, 0.0),
  169|      4|            ccd_enabled: false,
  170|      4|            max_ccd_substeps: 1,
  171|      4|            time_step: 1.0 / 60.0,
  172|      4|            water_level: f32::NEG_INFINITY,
  173|      4|            fluid_density: 1000.0,
  174|      4|        }
  175|      4|    }
  176|       |}
  177|       |
  178|       |#[derive(Clone, Copy, Debug)]
  179|       |pub enum JointType {
  180|       |    Fixed,
  181|       |    Revolute {
  182|       |        axis: Vec3,
  183|       |        limits: Option<(f32, f32)>,
  184|       |    },
  185|       |    Prismatic {
  186|       |        axis: Vec3,
  187|       |        limits: Option<(f32, f32)>,
  188|       |    },
  189|       |    Spherical,
  190|       |}
  191|       |
  192|       |#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
  193|       |pub struct JointId(pub u64);
  194|       |
  195|       |#[derive(Clone, Copy, Debug)]
  196|       |pub struct BuoyancyData {
  197|       |    pub volume: f32,
  198|       |    pub drag: f32,
  199|       |}
  200|       |
  201|       |pub struct PhysicsWorld {
  202|       |    pub bodies: RigidBodySet,
  203|       |    pub colliders: ColliderSet,
  204|       |    pub joints: ImpulseJointSet,
  205|       |    pub multibody_joints: MultibodyJointSet,
  206|       |    pub pipeline: PhysicsPipeline,
  207|       |    pub gravity: Vector<Real>,
  208|       |    pub integration: IntegrationParameters,
  209|       |    pub island_mgr: IslandManager,
  210|       |    pub broad_phase: DefaultBroadPhase,
  211|       |    pub narrow_phase: NarrowPhase,
  212|       |    pub query_pipeline: QueryPipeline,
  213|       |    pub ccd: CCDSolver,
  214|       |    pub event_handler: ChannelEventCollector,
  215|       |    pub collision_recv: rapier3d::crossbeam::channel::Receiver<CollisionEvent>,
  216|       |    pub contact_force_recv: rapier3d::crossbeam::channel::Receiver<ContactForceEvent>,
  217|       |    body_ids: HashMap<RigidBodyHandle, BodyId>,
  218|       |    body_kinds: HashMap<RigidBodyHandle, ActorKind>,
  219|       |    next_body_id: BodyId,
  220|       |    pub char_map: HashMap<BodyId, CharacterController>,
  221|       |    next_joint_id: u64,
  222|       |    debug_render_pipeline: DebugRenderPipeline,
  223|       |    pub buoyancy_bodies: HashMap<BodyId, BuoyancyData>,
  224|       |    pub water_level: f32,
  225|       |    pub fluid_density: f32,
  226|       |    pub wind: Vec3,
  227|       |
  228|       |    /// Async physics scheduler (feature-gated)
  229|       |    #[cfg(feature = "async-physics")]
  230|       |    pub async_scheduler: Option<AsyncPhysicsScheduler>,
  231|       |}
  232|       |
  233|       |impl PhysicsWorld {
  234|    126|    pub fn new(gravity: Vec3) -> Self {
  235|    126|        let (collision_send, collision_recv) = rapier3d::crossbeam::channel::unbounded();
  236|    126|        let (contact_force_send, contact_force_recv) = rapier3d::crossbeam::channel::unbounded();
  237|    126|        let event_handler = ChannelEventCollector::new(collision_send, contact_force_send);
  238|       |
  239|    126|        Self {
  240|    126|            bodies: RigidBodySet::new(),
  241|    126|            colliders: ColliderSet::new(),
  242|    126|            joints: ImpulseJointSet::new(),
  243|    126|            multibody_joints: MultibodyJointSet::new(),
  244|    126|            pipeline: PhysicsPipeline::new(),
  245|    126|            gravity: vector![gravity.x, gravity.y, gravity.z],
  246|    126|            integration: IntegrationParameters::default(),
  247|    126|            island_mgr: IslandManager::new(),
  248|    126|            broad_phase: DefaultBroadPhase::new(),
  249|    126|            narrow_phase: NarrowPhase::new(),
  250|    126|            query_pipeline: QueryPipeline::new(),
  251|    126|            ccd: CCDSolver::new(),
  252|    126|            event_handler,
  253|    126|            collision_recv,
  254|    126|            contact_force_recv,
  255|    126|            body_ids: HashMap::new(),
  256|    126|            body_kinds: HashMap::new(),
  257|    126|            next_body_id: 1,
  258|    126|            char_map: HashMap::new(),
  259|    126|            next_joint_id: 1,
  260|    126|            debug_render_pipeline: DebugRenderPipeline::default(),
  261|    126|            buoyancy_bodies: HashMap::new(),
  262|    126|            water_level: f32::NEG_INFINITY,
  263|    126|            fluid_density: 1000.0,
  264|    126|            wind: Vec3::ZERO,
  265|    126|            #[cfg(feature = "async-physics")]
  266|    126|            async_scheduler: None,
  267|    126|        }
  268|    126|    }
  269|       |
  270|      8|    pub fn from_config(config: PhysicsConfig) -> Self {
  271|      8|        let (collision_send, collision_recv) = rapier3d::crossbeam::channel::unbounded();
  272|      8|        let (contact_force_send, contact_force_recv) = rapier3d::crossbeam::channel::unbounded();
  273|      8|        let event_handler = ChannelEventCollector::new(collision_send, contact_force_send);
  274|       |
  275|      8|        let integration = IntegrationParameters {
  276|      8|            dt: config.time_step,
  277|      8|            ..Default::default()
  278|      8|        };
  279|       |
  280|      8|        Self {
  281|      8|            bodies: RigidBodySet::new(),
  282|      8|            colliders: ColliderSet::new(),
  283|      8|            joints: ImpulseJointSet::new(),
  284|      8|            multibody_joints: MultibodyJointSet::new(),
  285|      8|            pipeline: PhysicsPipeline::new(),
  286|      8|            gravity: vector![config.gravity.x, config.gravity.y, config.gravity.z],
  287|      8|            integration,
  288|      8|            island_mgr: IslandManager::new(),
  289|      8|            broad_phase: DefaultBroadPhase::new(),
  290|      8|            narrow_phase: NarrowPhase::new(),
  291|      8|            query_pipeline: QueryPipeline::new(),
  292|      8|            ccd: CCDSolver::new(),
  293|      8|            event_handler,
  294|      8|            collision_recv,
  295|      8|            contact_force_recv,
  296|      8|            body_ids: HashMap::new(),
  297|      8|            body_kinds: HashMap::new(),
  298|      8|            next_body_id: 1,
  299|      8|            char_map: HashMap::new(),
  300|      8|            next_joint_id: 1,
  301|      8|            debug_render_pipeline: DebugRenderPipeline::default(),
  302|      8|            buoyancy_bodies: HashMap::new(),
  303|      8|            water_level: f32::NEG_INFINITY,
  304|      8|            fluid_density: 1000.0,
  305|      8|            wind: Vec3::ZERO,
  306|      8|            #[cfg(feature = "async-physics")]
  307|      8|            async_scheduler: None,
  308|      8|        }
  309|      8|    }
  310|       |
  311|       |    /// Enable async physics with optional thread count (0 = auto-detect)
  312|       |    /// This configures Rayon's global thread pool, which Rapier3D uses for parallel solving
  313|       |    #[cfg(feature = "async-physics")]
  314|       |    pub fn enable_async_physics(&mut self, thread_count: usize) {
  315|       |        // Configure Rayon thread pool if not already initialized
  316|       |        if thread_count > 0 {
  317|       |            // Try to build thread pool (may fail if already initialized, which is fine)
  318|       |            let _ = rayon::ThreadPoolBuilder::new()
  319|       |                .num_threads(thread_count)
  320|       |                .build_global();
  321|       |        }
  322|       |
  323|       |        self.async_scheduler = Some(if thread_count > 0 {
  324|       |            AsyncPhysicsScheduler::with_threads(thread_count)
  325|       |        } else {
  326|       |            AsyncPhysicsScheduler::new()
  327|       |        });
  328|       |    }
  329|       |
  330|       |    /// Get last physics step profile (for telemetry)
  331|       |    #[cfg(feature = "async-physics")]
  332|       |    pub fn get_last_profile(&self) -> Option<PhysicsStepProfile> {
  333|       |        self.async_scheduler.as_ref().map(|s| s.get_last_profile())
  334|       |    }
  335|       |
  336|    343|    fn alloc_id(&mut self) -> BodyId {
  337|    343|        let id = self.next_body_id;
  338|    343|        self.next_body_id += 1;
  339|    343|        id
  340|    343|    }
  341|       |
  342|  3.63k|    pub fn step(&mut self) {
  343|       |        #[cfg(feature = "profiling")]
  344|       |        span!("Physics::World::step");
  345|       |
  346|       |        #[cfg(feature = "async-physics")]
  347|       |        {
  348|       |            // When async scheduler is enabled, Rapier3D automatically uses
  349|       |            // Rayon's global thread pool for parallel island solving.
  350|       |            // The thread count was configured when enable_async_physics was called.
  351|       |            if self.async_scheduler.is_some() {
  352|       |                use std::time::Instant;
  353|       |                let start = Instant::now();
  354|       |
  355|       |                self.step_internal();
  356|       |
  357|       |                let duration = start.elapsed();
  358|       |
  359|       |                // Update telemetry
  360|       |                if let Some(scheduler) = &mut self.async_scheduler {
  361|       |                    scheduler.record_step_telemetry(duration);
  362|       |                }
  363|       |                return;
  364|       |            }
  365|       |        }
  366|       |
  367|       |        // Fallback to regular step (single-threaded)
  368|  3.63k|        self.step_internal();
  369|  3.63k|    }
  370|       |
  371|       |    /// Internal physics step (shared by sync and async paths)
  372|       |    /// When called with async scheduler enabled, Rapier3D uses Rayon for parallel solving
  373|  3.63k|    fn step_internal(&mut self) {
  374|       |        #[cfg(feature = "profiling")]
  375|       |        {
  376|       |            span!("Physics::Rapier::pipeline");
  377|       |            plot!("Physics::collider_count", self.colliders.len() as u64);
  378|       |        }
  379|       |
  380|       |        // Apply buoyancy forces before physics step
  381|  3.63k|        self.apply_buoyancy_forces();
  382|       |
  383|  3.63k|        self.pipeline.step(
  384|  3.63k|            &self.gravity,
  385|  3.63k|            &self.integration,
  386|  3.63k|            &mut self.island_mgr,
  387|  3.63k|            &mut self.broad_phase,
  388|  3.63k|            &mut self.narrow_phase,
  389|  3.63k|            &mut self.bodies,
  390|  3.63k|            &mut self.colliders,
  391|  3.63k|            &mut self.joints,
  392|  3.63k|            &mut self.multibody_joints,
  393|  3.63k|            &mut self.ccd,
  394|  3.63k|            Some(&mut self.query_pipeline),
  395|  3.63k|            &(),
  396|  3.63k|            &self.event_handler,
  397|       |        );
  398|       |
  399|       |        // CRITICAL FIX (Week 2 Day 3): Update query pipeline after physics step
  400|       |        // Without this, raycasts in control_character() use stale geometry,
  401|       |        // causing character controller to fail ground detection
  402|  3.63k|        self.query_pipeline.update(&self.colliders);
  403|  3.63k|    }
  404|       |
  405|    244|    pub fn apply_force(&mut self, id: BodyId, force: Vec3) {
  406|    244|        if let Some(h) = self.handle_of(id) {
  407|    244|            if let Some(rb) = self.bodies.get_mut(h) {
  408|    244|                rb.add_force(vector![force.x, force.y, force.z], true);
  409|    244|            }
                          ^0
  410|      0|        }
  411|    244|    }
  412|       |
  413|     14|    pub fn apply_impulse(&mut self, id: BodyId, impulse: Vec3) {
  414|     14|        if let Some(h) = self.handle_of(id) {
  415|     14|            if let Some(rb) = self.bodies.get_mut(h) {
  416|     14|                rb.apply_impulse(vector![impulse.x, impulse.y, impulse.z], true);
  417|     14|            }
                          ^0
  418|      0|        }
  419|     14|    }
  420|       |
  421|    384|    pub fn get_velocity(&self, id: BodyId) -> Option<Vec3> {
  422|    384|        let h = self.handle_of(id)?;
                          ^383                  ^1
  423|    383|        let rb = self.bodies.get(h)?;
                                                 ^0
  424|    383|        let v = rb.linvel();
  425|    383|        Some(Vec3::new(v.x, v.y, v.z))
  426|    384|    }
  427|       |
  428|      7|    pub fn set_velocity(&mut self, id: BodyId, vel: Vec3) {
  429|      7|        if let Some(h) = self.handle_of(id) {
  430|      7|            if let Some(rb) = self.bodies.get_mut(h) {
  431|      7|                rb.set_linvel(vector![vel.x, vel.y, vel.z], true);
  432|      7|            }
                          ^0
  433|      0|        }
  434|      7|    }
  435|       |
  436|     42|    pub fn create_ground_plane(&mut self, half: Vec3, friction: f32) -> BodyId {
  437|     42|        let rb = RigidBodyBuilder::fixed().build();
  438|     42|        let h = self.bodies.insert(rb);
  439|     42|        let shape = ColliderBuilder::cuboid(half.x, 0.1, half.z)
  440|     42|            .friction(friction)
  441|     42|            .collision_groups(InteractionGroups::new(
  442|     42|                Group::from_bits_truncate(Layers::DEFAULT.bits()),
  443|     42|                Group::ALL,
  444|     42|            ))
  445|     42|            .build();
  446|     42|        self.colliders
  447|     42|            .insert_with_parent(shape, h, &mut self.bodies);
  448|     42|        self.tag_body(h, ActorKind::Static)
  449|     42|    }
  450|       |
  451|      4|    pub fn add_static_trimesh(
  452|      4|        &mut self,
  453|      4|        vertices: &[Vec3],
  454|      4|        indices: &[[u32; 3]],
  455|      4|        groups: Layers,
  456|      4|    ) -> BodyId {
  457|      4|        let rb = RigidBodyBuilder::fixed().build();
  458|      4|        let h = self.bodies.insert(rb);
  459|     13|        let v: Vec<Point<Real>> = vertices.iter().map(|p| point![p.x, p.y, p.z]).collect();
                          ^4 ^4                 ^4       ^4     ^4                             ^4
  460|      4|        let i: Vec<[u32; 3]> = indices.to_vec();
  461|      4|        let coll = ColliderBuilder::trimesh(v, i)
  462|      4|            .collision_groups(InteractionGroups::new(
  463|      4|                Group::from_bits_truncate(groups.bits()),
  464|      4|                Group::ALL,
  465|      4|            ))
  466|      4|            .friction(0.9)
  467|      4|            .build();
  468|      4|        self.colliders.insert_with_parent(coll, h, &mut self.bodies);
  469|      4|        self.tag_body(h, ActorKind::Static)
  470|      4|    }
  471|       |
  472|    274|    pub fn add_dynamic_box(&mut self, pos: Vec3, half: Vec3, mass: f32, groups: Layers) -> BodyId {
  473|       |        #[cfg(feature = "profiling")]
  474|       |        {
  475|       |            span!("Physics::RigidBody::create");
  476|       |            plot!("Physics::rigid_body_count", self.bodies.len() as u64);
  477|       |        }
  478|       |
  479|    274|        let rb = RigidBodyBuilder::dynamic()
  480|    274|            .translation(vector![pos.x, pos.y, pos.z])
  481|    274|            .build();
  482|    274|        let h = self.bodies.insert(rb);
  483|    274|        let coll = ColliderBuilder::cuboid(half.x, half.y, half.z)
  484|    274|            .mass(mass)
  485|    274|            .collision_groups(InteractionGroups::new(
  486|    274|                Group::from_bits_truncate(groups.bits()),
  487|    274|                Group::ALL,
  488|    274|            ))
  489|    274|            .friction(0.8)
  490|    274|            .active_events(ActiveEvents::COLLISION_EVENTS)
  491|    274|            .build();
  492|    274|        self.colliders.insert_with_parent(coll, h, &mut self.bodies);
  493|    274|        self.tag_body(h, ActorKind::Dynamic)
  494|    274|    }
  495|       |
  496|     23|    pub fn add_character(&mut self, pos: Vec3, half: Vec3) -> BodyId {
  497|       |        #[cfg(feature = "profiling")]
  498|       |        {
  499|       |            span!("Physics::Character::create");
  500|       |            plot!("Physics::character_count", self.char_map.len() as u64);
  501|       |        }
  502|       |
  503|     23|        let rb = RigidBodyBuilder::kinematic_position_based()
  504|     23|            .translation(vector![pos.x, pos.y, pos.z])
  505|     23|            .build();
  506|     23|        let h = self.bodies.insert(rb);
  507|     23|        let coll = ColliderBuilder::capsule_y(half.y, half.x.max(half.z))
  508|     23|            .collision_groups(InteractionGroups::new(
  509|     23|                Group::from_bits_truncate(Layers::CHARACTER.bits()),
  510|     23|                Group::ALL,
  511|     23|            ))
  512|     23|            .friction(0.6)
  513|     23|            .build();
  514|     23|        self.colliders.insert_with_parent(coll, h, &mut self.bodies);
  515|     23|        let id = self.tag_body(h, ActorKind::Character);
  516|     23|        self.char_map.insert(
  517|     23|            id,
  518|     23|            CharacterController {
  519|     23|                state: CharState::Grounded,
  520|     23|                max_climb_angle_deg: 70.0,
  521|     23|                radius: half.x.max(half.z),
  522|     23|                height: half.y * 2.0,
  523|     23|                max_step: 0.4,
  524|     23|                vertical_velocity: 0.0,
  525|     23|                gravity_scale: 1.0,
  526|     23|                time_since_grounded: 0.0,
  527|     23|                jump_buffer_timer: 0.0,
  528|     23|                coyote_time_limit: 0.1, // 100ms
  529|     23|                jump_buffer_limit: 0.1, // 100ms
  530|     23|                pending_jump_velocity: 0.0,
  531|     23|            },
  532|       |        );
  533|     23|        id
  534|     23|    }
  535|       |
  536|      3|    pub fn jump(&mut self, id: BodyId, height: f32) {
  537|      3|        if let Some(ctrl) = self.char_map.get_mut(&id) {
                                  ^2
  538|      2|            ctrl.jump_buffer_timer = ctrl.jump_buffer_limit;
  539|      2|            let g = 9.81 * ctrl.gravity_scale;
  540|      2|            ctrl.pending_jump_velocity = (2.0 * g * height).sqrt();
  541|      2|        }
                      ^1
  542|      3|    }
  543|       |
  544|    412|    pub fn control_character(&mut self, id: BodyId, desired_move: Vec3, dt: f32, _climb: bool) {
  545|       |        #[cfg(feature = "profiling")]
  546|       |        span!("Physics::CharacterController::move");
  547|       |
  548|    412|        let Some(mut ctrl) = self.char_map.get(&id).copied() else {
                               ^410
  549|      2|            return;
  550|       |        };
  551|    410|        let Some(h) = self.handle_of(id) else {
  552|      0|            return;
  553|       |        };
  554|    410|        let Some(rb) = self.bodies.get(h) else {
  555|      0|            return;
  556|       |        };
  557|    410|        let pos = *rb.position();
  558|    410|        let start = glam::Vec3::new(pos.translation.x, pos.translation.y, pos.translation.z);
  559|       |        // Update timers
  560|    410|        ctrl.jump_buffer_timer -= dt;
  561|       |        
  562|       |        // Apply gravity (if not climbing)
  563|    410|        if !_climb {
  564|    408|            ctrl.vertical_velocity -= 9.81 * ctrl.gravity_scale * dt;
  565|    408|        } else {
  566|      2|            ctrl.vertical_velocity = 0.0;
  567|      2|        }
  568|       |
  569|       |        // Check Jump
  570|    410|        let can_jump = ctrl.time_since_grounded < ctrl.coyote_time_limit;
  571|    410|        let wants_jump = ctrl.jump_buffer_timer > 0.0;
  572|       |        
  573|    410|        if can_jump && wants_jump && !_climb {
                                                   ^35
  574|     35|            ctrl.vertical_velocity = ctrl.pending_jump_velocity;
  575|     35|            ctrl.time_since_grounded = ctrl.coyote_time_limit + 1.0; // Invalidate coyote
  576|     35|            ctrl.jump_buffer_timer = 0.0; // Consume buffer
  577|    375|        }
  578|       |
  579|    410|        let mut d = desired_move * dt;
  580|    410|        let has_horizontal_move = d.length_squared() >= 1e-6;
  581|    410|        let has_vertical_move = ctrl.vertical_velocity.abs() > 1e-4 || _climb;
                                                                                     ^2
  582|       |
  583|    410|        if !has_horizontal_move && !has_vertical_move {
                                                 ^168
  584|      0|            self.char_map.insert(id, ctrl);
  585|      0|            return;
  586|    410|        }
  587|       |
  588|    410|        if has_horizontal_move {
  589|       |            // Basic obstacle avoidance: raycast forward; slide along hit normal
  590|    242|            let dir = d.normalize();
  591|    242|            let ray_origin = start + glam::Vec3::Y * (ctrl.height * 0.5);
  592|    242|            let ray = rapier3d::prelude::Ray::new(
  593|    242|                point![ray_origin.x, ray_origin.y, ray_origin.z],
  594|    242|                vector![dir.x, dir.y, dir.z],
  595|       |            );
  596|       |            // BUG FIX (Week 2 Day 3): Exclude character's own colliders from raycasts
  597|       |            // Without this, the character detects its own capsule as an obstacle
  598|    242|            let filter = QueryFilter::default().exclude_rigid_body(h);
  599|    242|            if let Some((_, hit)) = self.query_pipeline.cast_ray_and_get_normal(
                                          ^0
  600|    242|                &self.bodies,
  601|    242|                &self.colliders,
  602|    242|                &ray,
  603|    242|                d.length() + ctrl.radius + 0.05,
  604|    242|                true,
  605|    242|                filter,
  606|    242|            ) {
  607|      0|                // Deflect movement along tangent plane
  608|      0|                let n = glam::Vec3::new(hit.normal.x, hit.normal.y, hit.normal.z).normalize();
  609|      0|                d = d - n * d.dot(n);
  610|    242|            }
  611|    168|        }
  612|       |
  613|       |        // Tentative horizontal move
  614|    410|        let mut new_pos = start + glam::Vec3::new(d.x, 0.0, d.z);
  615|       |
  616|    410|        if _climb {
  617|      2|            // Simple vertical climb
  618|      2|            new_pos.y = start.y + 2.0 * dt;
  619|      2|            ctrl.time_since_grounded = 0.0;
  620|      2|        } else {
  621|       |            // Apply vertical velocity
  622|    408|            new_pos.y = start.y + ctrl.vertical_velocity * dt;
  623|       |
  624|       |            // Ground check / Step / Slope
  625|    408|            if ctrl.vertical_velocity <= 0.0 {
  626|    373|                let cast_origin = new_pos + glam::Vec3::Y * (ctrl.height);
  627|    373|                let ray_down = rapier3d::prelude::Ray::new(
  628|    373|                    point![cast_origin.x, cast_origin.y, cast_origin.z],
  629|    373|                    vector![0.0, -1.0, 0.0],
  630|       |                );
  631|    373|                if let Some((_, hit)) = self.query_pipeline.cast_ray_and_get_normal(
                                              ^364
  632|    373|                    &self.bodies,
  633|    373|                    &self.colliders,
  634|    373|                    &ray_down,
  635|    373|                    ctrl.height + ctrl.max_step + 1.0,
  636|    373|                    true,
  637|    373|                    QueryFilter::default().exclude_rigid_body(h),
  638|    373|                ) {
  639|    364|                    let ground_normal =
  640|    364|                        glam::Vec3::new(hit.normal.x, hit.normal.y, hit.normal.z).normalize();
  641|    364|                    let slope = ground_normal.dot(glam::Vec3::Y).acos().to_degrees();
  642|    364|                    let ground_y = cast_origin.y - hit.time_of_impact;
  643|       |                    
  644|    364|                    if slope <= ctrl.max_climb_angle_deg + 1e-2 {
  645|       |                        // Snap to ground if close enough
  646|    364|                        if new_pos.y <= ground_y + 0.05 {
  647|      0|                             new_pos.y = ground_y;
  648|      0|                             ctrl.vertical_velocity = 0.0;
  649|      0|                             ctrl.time_since_grounded = 0.0;
  650|    364|                        }
  651|      0|                    }
  652|      9|                } else {
  653|      9|                    ctrl.time_since_grounded += dt;
  654|      9|                }
  655|     35|            } else {
  656|     35|                ctrl.time_since_grounded += dt;
  657|     35|            }
  658|       |        }
  659|       |
  660|       |        // Commit move
  661|    410|        let mut p = pos;
  662|    410|        p.translation.x = new_pos.x;
  663|    410|        p.translation.y = new_pos.y;
  664|    410|        p.translation.z = new_pos.z;
  665|    410|        if let Some(rbmut) = self.bodies.get_mut(h) {
  666|    410|            // BUG FIX (Week 2 Day 3): Use set_next_kinematic_position for kinematic bodies
  667|    410|            // set_position() with wake=true doesn't properly update kinematic bodies
  668|    410|            // across multiple frames - position gets reset by physics step
  669|    410|            rbmut.set_next_kinematic_position(p);
  670|    410|        }
                      ^0
  671|    412|    }
  672|       |
  673|  3.10k|    pub fn handle_of(&self, id: BodyId) -> Option<RigidBodyHandle> {
  674|  3.10k|        self.body_ids
  675|  3.10k|            .iter()
  676|  9.07k|            .find_map(|(h, bid)| if *bid == id { Some(*h) } else { None })
                           ^3.10k                              ^3.09k            ^5.98k
  677|  3.10k|    }
  678|       |
  679|      0|    pub fn id_of(&self, handle: RigidBodyHandle) -> Option<BodyId> {
  680|      0|        self.body_ids.get(&handle).copied()
  681|      0|    }
  682|       |
  683|  1.19k|    pub fn body_transform(&self, id: BodyId) -> Option<Mat4> {
  684|  1.19k|        let h = self.handle_of(id)?;
                          ^1.19k                ^4
  685|  1.19k|        let rb = self.bodies.get(h)?;
                                                 ^0
  686|  1.19k|        let iso = rb.position();
  687|  1.19k|        let rot = glam::Quat::from_xyzw(
  688|  1.19k|            iso.rotation.i,
  689|  1.19k|            iso.rotation.j,
  690|  1.19k|            iso.rotation.k,
  691|  1.19k|            iso.rotation.w,
  692|       |        );
  693|  1.19k|        Some(Mat4::from_rotation_translation(
  694|  1.19k|            rot,
  695|  1.19k|            vec3(iso.translation.x, iso.translation.y, iso.translation.z),
  696|  1.19k|        ))
  697|  1.19k|    }
  698|       |
  699|    343|    fn tag_body(&mut self, h: RigidBodyHandle, kind: ActorKind) -> BodyId {
  700|    343|        let id = self.alloc_id();
  701|    343|        self.body_ids.insert(h, id);
  702|    343|        self.body_kinds.insert(h, kind);
  703|    343|        id
  704|    343|    }
  705|       |
  706|      4|    pub fn add_buoyancy(&mut self, body: BodyId, volume: f32, drag: f32) {
  707|      4|        self.buoyancy_bodies
  708|      4|            .insert(body, BuoyancyData { volume, drag });
  709|      4|    }
  710|       |
  711|  3.63k|    fn apply_buoyancy_forces(&mut self) {
  712|  3.93k|        for (body_id, buoyancy_data) in &self.buoyancy_bodies {
                           ^302     ^302
  713|    302|            if let Some(handle) = self.handle_of(*body_id) {
  714|    302|                if let Some(rb) = self.bodies.get_mut(handle) {
  715|    302|                    let pos = rb.position();
  716|    302|                    let body_y = pos.translation.y;
  717|       |
  718|       |                    // Only apply buoyancy if body is below water level
  719|    302|                    if body_y < self.water_level {
  720|      1|                        // Buoyancy force = volume * fluid_density * gravity (upward)
  721|      1|                        let buoyancy_force = buoyancy_data.volume * self.fluid_density * 9.81;
  722|      1|
  723|      1|                        // Drag force = -velocity * drag coefficient
  724|      1|                        let velocity = rb.linvel();
  725|      1|                        let drag_force = vector![
  726|      1|                            -velocity.x * buoyancy_data.drag,
  727|      1|                            -velocity.y * buoyancy_data.drag,
  728|      1|                            -velocity.z * buoyancy_data.drag
  729|      1|                        ];
  730|      1|
  731|      1|                        // Total force (buoyancy up + drag)
  732|      1|                        let total_force =
  733|      1|                            vector![drag_force.x, buoyancy_force + drag_force.y, drag_force.z];
  734|      1|
  735|      1|                        rb.add_force(total_force, true);
  736|    301|                    }
  737|      0|                }
  738|      0|            }
  739|       |        }
  740|  3.63k|    }
  741|       |
  742|      1|    pub fn add_water_aabb(&mut self, _min: Vec3, _max: Vec3, _density: f32, _linear_damp: f32) {}
  743|       |    
  744|      4|    pub fn set_wind(&mut self, dir: Vec3, strength: f32) {
  745|      4|        self.wind = dir.normalize_or_zero() * strength;
  746|      4|    }
  747|       |
  748|       |    /// Apply radial explosion impulse to all dynamic bodies in range
  749|       |    ///
  750|       |    /// # Arguments
  751|       |    /// * `center` - Explosion center
  752|       |    /// * `radius` - Maximum effect radius
  753|       |    /// * `force` - Force at center (falls off with distance)
  754|       |    /// * `falloff` - Falloff curve type
  755|       |    /// * `upward_bias` - Upward impulse bias (0.0 = radial, 1.0 = fully upward)
  756|       |    ///
  757|       |    /// # Returns
  758|       |    /// Number of bodies affected
  759|      3|    pub fn apply_radial_impulse(
  760|      3|        &mut self,
  761|      3|        center: Vec3,
  762|      3|        radius: f32,
  763|      3|        force: f32,
  764|      3|        falloff: projectile::FalloffCurve,
  765|      3|        upward_bias: f32,
  766|      3|    ) -> usize {
  767|       |        // Collect body positions and IDs
  768|      3|        let mut affected = Vec::new();
  769|       |
  770|     18|        for (&handle, &_body_id) in &self.body_ids {
                            ^15      ^15
  771|     15|            if let Some(rb) = self.bodies.get(handle) {
  772|     15|                if !rb.is_dynamic() {
  773|      2|                    continue;
  774|     13|                }
  775|     13|                let pos = rb.position().translation;
  776|     13|                let body_pos = Vec3::new(pos.x, pos.y, pos.z);
  777|     13|                let to_body = body_pos - center;
  778|     13|                let distance = to_body.length();
  779|       |
  780|     13|                if distance < radius {
  781|     13|                    affected.push((handle, body_pos, distance, to_body));
  782|     13|                }
                              ^0
  783|      0|            }
  784|       |        }
  785|       |
  786|       |        // Apply impulses
  787|      3|        let count = affected.len();
  788|     16|        for (handle, _body_pos, distance, to_body) in affected {
                           ^13     ^13        ^13       ^13
  789|     13|            let falloff_mult = falloff.calculate(distance, radius);
  790|     13|            let force_mag = force * falloff_mult;
  791|       |
  792|     13|            let radial_dir = if distance > 0.001 {
  793|     13|                to_body.normalize()
  794|       |            } else {
  795|      0|                Vec3::Y
  796|       |            };
  797|       |
  798|     13|            let biased_dir =
  799|     13|                (radial_dir * (1.0 - upward_bias) + Vec3::Y * upward_bias).normalize();
  800|     13|            let impulse = biased_dir * force_mag;
  801|       |
  802|     13|            if let Some(rb) = self.bodies.get_mut(handle) {
  803|     13|                rb.apply_impulse(vector![impulse.x, impulse.y, impulse.z], true);
  804|     13|            }
                          ^0
  805|       |        }
  806|       |
  807|      3|        count
  808|      3|    }
  809|       |
  810|       |    /// Perform a raycast and return hit info
  811|       |    ///
  812|       |    /// # Returns
  813|       |    /// (hit_position, hit_normal, body_id, distance) if hit
  814|  1.48k|    pub fn raycast(
  815|  1.48k|        &self,
  816|  1.48k|        origin: Vec3,
  817|  1.48k|        direction: Vec3,
  818|  1.48k|        max_distance: f32,
  819|  1.48k|    ) -> Option<(Vec3, Vec3, Option<BodyId>, f32)> {
  820|  1.48k|        let ray = rapier3d::prelude::Ray::new(
  821|  1.48k|            point![origin.x, origin.y, origin.z],
  822|  1.48k|            vector![direction.x, direction.y, direction.z],
  823|       |        );
  824|       |
  825|  1.48k|        self.query_pipeline
  826|  1.48k|            .cast_ray_and_get_normal(
  827|  1.48k|                &self.bodies,
  828|  1.48k|                &self.colliders,
  829|  1.48k|                &ray,
  830|  1.48k|                max_distance,
  831|       |                true,
  832|  1.48k|                QueryFilter::default(),
  833|       |            )
  834|  1.48k|            .map(|(collider_handle, hit)| {
                                                        ^1.44k
  835|  1.44k|                let hit_pos = origin + direction * hit.time_of_impact;
  836|  1.44k|                let normal = Vec3::new(hit.normal.x, hit.normal.y, hit.normal.z);
  837|       |                
  838|       |                // Get body ID from collider
  839|  1.44k|                let body_id = self.colliders
  840|  1.44k|                    .get(collider_handle)
  841|  1.44k|                    .and_then(|c| c.parent())
  842|  1.44k|                    .and_then(|rb_handle| self.body_ids.get(&rb_handle).copied());
  843|       |
  844|  1.44k|                (hit_pos, normal, body_id, hit.time_of_impact)
  845|  1.44k|            })
  846|  1.48k|    }
  847|       |
  848|      1|    pub fn clear_water(&mut self) {}
  849|      2|    pub fn add_destructible_box(
  850|      2|        &mut self,
  851|      2|        pos: Vec3,
  852|      2|        half: Vec3,
  853|      2|        mass: f32,
  854|      2|        _health: f32,
  855|      2|        _break_impulse: f32,
  856|      2|    ) -> BodyId {
  857|      2|        self.add_dynamic_box(pos, half, mass, Layers::DEFAULT)
  858|      2|    }
  859|      2|    pub fn break_destructible(&mut self, id: BodyId) {
  860|      2|        if let Some(h) = self.handle_of(id) {
  861|      2|            // Remove from Rapier sets
  862|      2|            self.bodies.remove(
  863|      2|                h,
  864|      2|                &mut self.island_mgr,
  865|      2|                &mut self.colliders,
  866|      2|                &mut self.joints,
  867|      2|                &mut self.multibody_joints,
  868|      2|                true,
  869|      2|            );
  870|      2|
  871|      2|            // Remove from our mappings
  872|      2|            self.body_ids.remove(&h);
  873|      2|            self.body_kinds.remove(&h);
  874|      2|            self.char_map.remove(&id);
  875|      2|            self.buoyancy_bodies.remove(&id);
  876|      2|        }
                      ^0
  877|      2|    }
  878|       |
  879|       |    #[allow(dead_code)]
  880|      0|    fn process_destructible_hits(&mut self) {}
  881|       |
  882|      2|    pub fn set_body_position(&mut self, id: BodyId, pos: Vec3) {
  883|      2|        if let Some(h) = self.handle_of(id) {
  884|      2|            if let Some(rb) = self.bodies.get_mut(h) {
  885|      2|                rb.set_translation(vector![pos.x, pos.y, pos.z], true);
  886|      2|            }
                          ^0
  887|      0|        }
  888|      2|    }
  889|       |
  890|    194|    pub fn enable_ccd(&mut self, id: BodyId) {
  891|    194|        if let Some(h) = self.handle_of(id) {
                                  ^193
  892|    193|            if let Some(rb) = self.bodies.get_mut(h) {
  893|    193|                rb.enable_ccd(true);
  894|    193|            }
                          ^0
  895|      1|        }
  896|    194|    }
  897|       |
  898|    171|    pub fn add_joint(&mut self, body1: BodyId, body2: BodyId, joint_type: JointType) -> JointId {
  899|    171|        let Some(handle1) = self.handle_of(body1) else {
                               ^170
  900|      1|            return JointId(0);
  901|       |        };
  902|    170|        let Some(handle2) = self.handle_of(body2) else {
                               ^169
  903|      1|            return JointId(0);
  904|       |        };
  905|       |
  906|    169|        let joint = match joint_type {
  907|      8|            JointType::Fixed => GenericJointBuilder::new(JointAxesMask::LOCKED_FIXED_AXES).build(),
  908|     60|            JointType::Revolute { axis, limits } => {
  909|     60|                let local_axis = UnitVector::new_normalize(vector![axis.x, axis.y, axis.z]);
  910|     60|                let mut builder = RevoluteJointBuilder::new(local_axis);
  911|     60|                if let Some((min, max)) = limits {
                                           ^54  ^54
  912|     54|                    builder = builder.limits([min, max]);
  913|     54|                }
                              ^6
  914|     60|                builder.build().into()
  915|       |            }
  916|      1|            JointType::Prismatic { axis, limits } => {
  917|      1|                let local_axis = UnitVector::new_normalize(vector![axis.x, axis.y, axis.z]);
  918|      1|                let mut builder = PrismaticJointBuilder::new(local_axis);
  919|      1|                if let Some((min, max)) = limits {
  920|      1|                    builder = builder.limits([min, max]);
  921|      1|                }
                              ^0
  922|      1|                builder.build().into()
  923|       |            }
  924|    100|            JointType::Spherical => SphericalJointBuilder::new().build().into(),
  925|       |        };
  926|       |
  927|    169|        self.joints.insert(handle1, handle2, joint, true);
  928|       |
  929|    169|        let joint_id = self.next_joint_id;
  930|    169|        self.next_joint_id += 1;
  931|    169|        JointId(joint_id)
  932|    171|    }
  933|       |
  934|      2|    pub fn get_debug_lines(&mut self) -> Vec<DebugLine> {
  935|      2|        let mut collector = LineCollector::new();
  936|      2|        self.debug_render_pipeline.render(
  937|      2|            &mut collector,
  938|      2|            &self.bodies,
  939|      2|            &self.colliders,
  940|      2|            &self.joints,
  941|      2|            &self.multibody_joints,
  942|      2|            &self.narrow_phase,
  943|       |        );
  944|      2|        collector.lines
  945|      2|    }
  946|       |}
  947|       |
  948|       |#[cfg(test)]
  949|       |mod tests {
  950|       |    use super::*;
  951|       |
  952|       |    #[test]
  953|      1|    fn character_position_updates() {
  954|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
  955|      1|        let _ground = pw.create_ground_plane(Vec3::new(10.0, 0.5, 10.0), 0.9);
  956|      1|        let char_id = pw.add_character(Vec3::new(0.0, 1.0, 0.0), Vec3::new(0.4, 0.9, 0.4));
  957|       |
  958|       |        // Check initial position
  959|      1|        let pos0 = pw.body_transform(char_id).unwrap().w_axis;
  960|      1|        assert!(
  961|      1|            (pos0.x - 0.0).abs() < 0.01,
  962|      0|            "initial x should be ~0, got {}",
  963|      0|            pos0.x
  964|       |        );
  965|       |
  966|       |        // Move once
  967|      1|        pw.control_character(char_id, Vec3::new(1.0, 0.0, 0.0), 1.0 / 60.0, false);
  968|      1|        pw.step();
  969|       |
  970|      1|        let pos1 = pw.body_transform(char_id).unwrap().w_axis;
  971|       |
  972|       |        // Move again
  973|      1|        pw.control_character(char_id, Vec3::new(1.0, 0.0, 0.0), 1.0 / 60.0, false);
  974|      1|        pw.step();
  975|       |
  976|      1|        let pos2 = pw.body_transform(char_id).unwrap().w_axis;
  977|       |
  978|       |        // Position should accumulate
  979|      1|        assert!(
  980|      1|            pos2.x > pos1.x,
  981|      0|            "x should increase: frame1={}, frame2={}",
  982|      0|            pos1.x,
  983|      0|            pos2.x
  984|       |        );
  985|      1|    }
  986|       |
  987|       |    #[test]
  988|      1|    fn character_moves_forward() {
  989|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
  990|      1|        let _ground = pw.create_ground_plane(Vec3::new(10.0, 0.5, 10.0), 0.9);
  991|      1|        let char_id = pw.add_character(Vec3::new(0.0, 1.0, 0.0), Vec3::new(0.4, 0.9, 0.4));
  992|     61|        for _ in 0..60 {
  993|     60|            pw.control_character(char_id, Vec3::new(1.0, 0.0, 0.0), 1.0 / 60.0, false);
  994|     60|            pw.step();
  995|     60|        }
  996|      1|        let x = pw.body_transform(char_id).unwrap().w_axis.x;
  997|      1|        assert!(x > 0.5, "character should have moved forward, x={}", x);
                                       ^0
  998|      1|    }
  999|       |
 1000|       |    // ===== PhysicsWorld Basic Tests =====
 1001|       |
 1002|       |    #[test]
 1003|      1|    fn test_physics_world_new() {
 1004|      1|        let pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1005|      1|        assert_eq!(pw.gravity.x, 0.0);
 1006|      1|        assert_eq!(pw.gravity.y, -9.8);
 1007|      1|        assert_eq!(pw.gravity.z, 0.0);
 1008|      1|        assert!(pw.bodies.is_empty());
 1009|      1|        assert!(pw.colliders.is_empty());
 1010|      1|    }
 1011|       |
 1012|       |    #[test]
 1013|      1|    fn test_physics_world_from_config() {
 1014|      1|        let config = PhysicsConfig {
 1015|      1|            gravity: Vec3::new(0.0, -10.0, 0.0),
 1016|      1|            time_step: 1.0 / 120.0,
 1017|      1|            ccd_enabled: false,
 1018|      1|            max_ccd_substeps: 1,
 1019|      1|            water_level: f32::NEG_INFINITY,
 1020|      1|            fluid_density: 1000.0,
 1021|      1|        };
 1022|      1|        let pw = PhysicsWorld::from_config(config);
 1023|      1|        assert_eq!(pw.gravity.y, -10.0);
 1024|      1|        assert_eq!(pw.integration.dt, 1.0 / 120.0);
 1025|      1|    }
 1026|       |
 1027|       |    #[test]
 1028|      1|    fn test_create_ground_plane() {
 1029|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1030|      1|        let ground = pw.create_ground_plane(Vec3::new(5.0, 0.5, 5.0), 0.8);
 1031|       |        
 1032|      1|        assert!(pw.body_transform(ground).is_some());
 1033|      1|        assert!(!pw.bodies.is_empty());
 1034|      1|        assert!(!pw.colliders.is_empty());
 1035|      1|    }
 1036|       |
 1037|       |    #[test]
 1038|      1|    fn test_add_dynamic_box() {
 1039|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1040|      1|        let box_id = pw.add_dynamic_box(
 1041|      1|            Vec3::new(0.0, 5.0, 0.0),
 1042|      1|            Vec3::new(0.5, 0.5, 0.5),
 1043|       |            1.0,
 1044|       |            Layers::DEFAULT,
 1045|       |        );
 1046|       |        
 1047|      1|        assert!(pw.body_transform(box_id).is_some());
 1048|       |        
 1049|       |        // Step physics - box should fall
 1050|     61|        for _ in 0..60 {
 1051|     60|            pw.step();
 1052|     60|        }
 1053|       |        
 1054|      1|        let y = pw.body_transform(box_id).unwrap().w_axis.y;
 1055|      1|        assert!(y < 5.0, "Box should have fallen, y={}", y);
                                       ^0
 1056|      1|    }
 1057|       |
 1058|       |    #[test]
 1059|      1|    fn test_apply_force() {
 1060|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1061|      1|        let _ground = pw.create_ground_plane(Vec3::new(10.0, 0.5, 10.0), 0.9);
 1062|      1|        let box_id = pw.add_dynamic_box(
 1063|      1|            Vec3::new(0.0, 2.0, 0.0),
 1064|      1|            Vec3::new(0.5, 0.5, 0.5),
 1065|       |            1.0,
 1066|       |            Layers::DEFAULT,
 1067|       |        );
 1068|       |        
 1069|      1|        pw.apply_force(box_id, Vec3::new(100.0, 0.0, 0.0));
 1070|      1|        pw.step();
 1071|       |        
 1072|      1|        let vel = pw.get_velocity(box_id).unwrap();
 1073|      1|        assert!(vel.x > 0.0, "Force should have applied positive x velocity");
                                           ^0
 1074|      1|    }
 1075|       |
 1076|       |    #[test]
 1077|      1|    fn test_apply_impulse() {
 1078|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1079|      1|        let box_id = pw.add_dynamic_box(
 1080|      1|            Vec3::new(0.0, 5.0, 0.0),
 1081|      1|            Vec3::new(0.5, 0.5, 0.5),
 1082|       |            1.0,
 1083|       |            Layers::DEFAULT,
 1084|       |        );
 1085|       |        
 1086|      1|        pw.apply_impulse(box_id, Vec3::new(0.0, 50.0, 0.0));
 1087|       |        
 1088|      1|        let vel = pw.get_velocity(box_id).unwrap();
 1089|      1|        assert!(vel.y > 0.0, "Impulse should have given upward velocity");
                                           ^0
 1090|      1|    }
 1091|       |
 1092|       |    #[test]
 1093|      1|    fn test_get_set_velocity() {
 1094|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1095|      1|        let box_id = pw.add_dynamic_box(
 1096|      1|            Vec3::new(0.0, 5.0, 0.0),
 1097|      1|            Vec3::new(0.5, 0.5, 0.5),
 1098|       |            1.0,
 1099|       |            Layers::DEFAULT,
 1100|       |        );
 1101|       |        
 1102|       |        // Get initial velocity
 1103|      1|        let initial_vel = pw.get_velocity(box_id).unwrap();
 1104|      1|        assert_eq!(initial_vel.x, 0.0);
 1105|       |        
 1106|       |        // Set velocity
 1107|      1|        pw.set_velocity(box_id, Vec3::new(10.0, 0.0, 5.0));
 1108|       |        
 1109|      1|        let new_vel = pw.get_velocity(box_id).unwrap();
 1110|      1|        assert_eq!(new_vel.x, 10.0);
 1111|      1|        assert_eq!(new_vel.z, 5.0);
 1112|      1|    }
 1113|       |
 1114|       |    #[test]
 1115|      1|    fn test_get_velocity_invalid_id() {
 1116|      1|        let pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1117|      1|        let vel = pw.get_velocity(9999);
 1118|      1|        assert!(vel.is_none());
 1119|      1|    }
 1120|       |
 1121|       |    #[test]
 1122|      1|    fn test_body_transform_invalid_id() {
 1123|      1|        let pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1124|      1|        let transform = pw.body_transform(9999);
 1125|      1|        assert!(transform.is_none());
 1126|      1|    }
 1127|       |
 1128|       |    // ===== Static Trimesh Tests =====
 1129|       |
 1130|       |    #[test]
 1131|      1|    fn test_add_static_trimesh() {
 1132|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1133|       |        
 1134|       |        // Create simple triangle
 1135|      1|        let vertices = vec![
 1136|      1|            Vec3::new(0.0, 0.0, 0.0),
 1137|      1|            Vec3::new(1.0, 0.0, 0.0),
 1138|      1|            Vec3::new(0.0, 0.0, 1.0),
 1139|       |        ];
 1140|      1|        let indices = vec![[0, 1, 2]];
 1141|       |        
 1142|      1|        let mesh_id = pw.add_static_trimesh(&vertices, &indices, Layers::DEFAULT);
 1143|      1|        assert!(pw.body_transform(mesh_id).is_some());
 1144|      1|    }
 1145|       |
 1146|       |    // ===== Character Controller Tests =====
 1147|       |
 1148|       |    #[test]
 1149|      1|    fn test_character_jump() {
 1150|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1151|      1|        let _ground = pw.create_ground_plane(Vec3::new(10.0, 0.5, 10.0), 0.9);
 1152|      1|        let char_id = pw.add_character(Vec3::new(0.0, 1.0, 0.0), Vec3::new(0.4, 0.9, 0.4));
 1153|       |        
 1154|       |        // Initial position
 1155|      1|        let y0 = pw.body_transform(char_id).unwrap().w_axis.y;
 1156|       |        
 1157|       |        // Jump
 1158|      1|        pw.jump(char_id, 2.0);
 1159|       |        
 1160|       |        // Run physics
 1161|     31|        for _ in 0..30 {
 1162|     30|            pw.control_character(char_id, Vec3::ZERO, 1.0 / 60.0, false);
 1163|     30|            pw.step();
 1164|     30|        }
 1165|       |        
 1166|      1|        let y1 = pw.body_transform(char_id).unwrap().w_axis.y;
 1167|       |        // After 30 frames of jump, character should have moved
 1168|      1|        assert!(y1 != y0, "Jump should change position");
                                        ^0
 1169|      1|    }
 1170|       |
 1171|       |    #[test]
 1172|      1|    fn test_control_character_invalid_id() {
 1173|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1174|       |        // Should not panic on invalid ID
 1175|      1|        pw.control_character(9999, Vec3::new(1.0, 0.0, 0.0), 1.0 / 60.0, false);
 1176|      1|    }
 1177|       |
 1178|       |    #[test]
 1179|      1|    fn test_jump_invalid_id() {
 1180|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1181|       |        // Should not panic on invalid ID
 1182|      1|        pw.jump(9999, 2.0);
 1183|      1|    }
 1184|       |
 1185|       |    // ===== Buoyancy & Environment Tests =====
 1186|       |
 1187|       |    #[test]
 1188|      1|    fn test_add_buoyancy() {
 1189|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1190|      1|        let box_id = pw.add_dynamic_box(
 1191|      1|            Vec3::new(0.0, 5.0, 0.0),
 1192|      1|            Vec3::new(0.5, 0.5, 0.5),
 1193|       |            1.0,
 1194|       |            Layers::DEFAULT,
 1195|       |        );
 1196|       |        
 1197|      1|        pw.add_buoyancy(box_id, 1.0, 0.5);
 1198|      1|        assert!(pw.buoyancy_bodies.contains_key(&box_id));
 1199|      1|    }
 1200|       |
 1201|       |    #[test]
 1202|      1|    fn test_set_wind() {
 1203|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1204|      1|        pw.set_wind(Vec3::new(1.0, 0.0, 0.0), 5.0);
 1205|       |        
 1206|       |        // set_wind stores dir * strength
 1207|      1|        assert_eq!(pw.wind.x, 5.0); // 1.0 * 5.0
 1208|      1|        assert_eq!(pw.wind.y, 0.0);
 1209|      1|        assert_eq!(pw.wind.z, 0.0);
 1210|      1|    }
 1211|       |
 1212|       |    // ===== Handle/ID Mapping Tests =====
 1213|       |
 1214|       |    #[test]
 1215|      1|    fn test_handle_of_valid() {
 1216|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1217|      1|        let box_id = pw.add_dynamic_box(
 1218|      1|            Vec3::new(0.0, 5.0, 0.0),
 1219|      1|            Vec3::new(0.5, 0.5, 0.5),
 1220|       |            1.0,
 1221|       |            Layers::DEFAULT,
 1222|       |        );
 1223|       |        
 1224|      1|        assert!(pw.handle_of(box_id).is_some());
 1225|      1|    }
 1226|       |
 1227|       |    #[test]
 1228|      1|    fn test_handle_of_invalid() {
 1229|      1|        let pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1230|      1|        assert!(pw.handle_of(9999).is_none());
 1231|      1|    }
 1232|       |
 1233|       |    // ===== ActorKind Tests =====
 1234|       |
 1235|       |    #[test]
 1236|      1|    fn test_actor_kind_variants() {
 1237|      1|        let _ = ActorKind::Static;
 1238|      1|        let _ = ActorKind::Dynamic;
 1239|      1|        let _ = ActorKind::Character;
 1240|      1|        let _ = ActorKind::Other;
 1241|      1|    }
 1242|       |
 1243|       |    // ===== Layers Tests =====
 1244|       |
 1245|       |    #[test]
 1246|      1|    fn test_layers_bits() {
 1247|      1|        assert_eq!(Layers::DEFAULT.bits(), 0b0001);
 1248|      1|        assert_eq!(Layers::CHARACTER.bits(), 0b0010);
 1249|      1|    }
 1250|       |
 1251|       |    #[test]
 1252|      1|    fn test_layers_all() {
 1253|      1|        let all = Layers::all();
 1254|      1|        assert!(all.contains(Layers::DEFAULT));
 1255|      1|        assert!(all.contains(Layers::CHARACTER));
 1256|      1|    }
 1257|       |
 1258|       |    // ===== PhysicsConfig Tests =====
 1259|       |
 1260|       |    #[test]
 1261|      1|    fn test_physics_config_default() {
 1262|      1|        let config = PhysicsConfig::default();
 1263|      1|        assert_eq!(config.time_step, 1.0 / 60.0);
 1264|      1|        assert_eq!(config.gravity.y, -9.81);
 1265|      1|    }
 1266|       |
 1267|       |    // ===== Debug Line Tests =====
 1268|       |
 1269|       |    #[test]
 1270|      1|    fn test_debug_line_creation() {
 1271|      1|        let line = DebugLine {
 1272|      1|            start: [0.0, 0.0, 0.0],
 1273|      1|            end: [1.0, 1.0, 1.0],
 1274|      1|            color: [1.0, 0.0, 0.0],
 1275|      1|        };
 1276|       |        
 1277|      1|        assert_eq!(line.start, [0.0, 0.0, 0.0]);
 1278|      1|        assert_eq!(line.color, [1.0, 0.0, 0.0]);
 1279|      1|    }
 1280|       |
 1281|       |    // ===== Multiple Bodies Tests =====
 1282|       |
 1283|       |    #[test]
 1284|      1|    fn test_multiple_bodies() {
 1285|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1286|      1|        let _ground = pw.create_ground_plane(Vec3::new(10.0, 0.5, 10.0), 0.9);
 1287|       |        
 1288|      1|        let box1 = pw.add_dynamic_box(Vec3::new(-2.0, 5.0, 0.0), Vec3::new(0.5, 0.5, 0.5), 1.0, Layers::DEFAULT);
 1289|      1|        let box2 = pw.add_dynamic_box(Vec3::new(2.0, 5.0, 0.0), Vec3::new(0.5, 0.5, 0.5), 1.0, Layers::DEFAULT);
 1290|      1|        let char1 = pw.add_character(Vec3::new(0.0, 1.0, 0.0), Vec3::new(0.4, 0.9, 0.4));
 1291|       |        
 1292|      1|        assert!(pw.body_transform(box1).is_some());
 1293|      1|        assert!(pw.body_transform(box2).is_some());
 1294|      1|        assert!(pw.body_transform(char1).is_some());
 1295|       |        
 1296|       |        // All should have different IDs
 1297|      1|        assert_ne!(box1, box2);
 1298|      1|        assert_ne!(box2, char1);
 1299|      1|    }
 1300|       |
 1301|       |    // ===== Step Integration Test =====
 1302|       |
 1303|       |    #[test]
 1304|      1|    fn test_physics_step_integration() {
 1305|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1306|      1|        let _ground = pw.create_ground_plane(Vec3::new(20.0, 0.5, 20.0), 0.9);
 1307|       |        
 1308|       |        // Add falling box
 1309|      1|        let box_id = pw.add_dynamic_box(
 1310|      1|            Vec3::new(0.0, 10.0, 0.0),
 1311|      1|            Vec3::new(0.5, 0.5, 0.5),
 1312|       |            1.0,
 1313|       |            Layers::DEFAULT,
 1314|       |        );
 1315|       |        
 1316|      1|        let y_start = pw.body_transform(box_id).unwrap().w_axis.y;
 1317|       |        
 1318|       |        // Step 120 frames (2 seconds)
 1319|    121|        for _ in 0..120 {
 1320|    120|            pw.step();
 1321|    120|        }
 1322|       |        
 1323|      1|        let y_end = pw.body_transform(box_id).unwrap().w_axis.y;
 1324|       |        
 1325|       |        // Box should have fallen significantly
 1326|      1|        assert!(y_end < y_start - 1.0, "Box should fall, start={}, end={}", y_start, y_end);
                                                     ^0
 1327|      1|    }
 1328|       |
 1329|       |    #[test]
 1330|      1|    fn test_apply_radial_impulse() {
 1331|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1332|      1|        let box_id = pw.add_dynamic_box(
 1333|      1|            Vec3::new(1.0, 1.0, 0.0),
 1334|      1|            Vec3::new(0.5, 0.5, 0.5),
 1335|       |            1.0,
 1336|       |            Layers::DEFAULT,
 1337|       |        );
 1338|       |        
 1339|      1|        let count = pw.apply_radial_impulse(
 1340|       |            Vec3::ZERO,
 1341|       |            5.0,
 1342|       |            100.0,
 1343|      1|            FalloffCurve::Linear,
 1344|       |            0.0,
 1345|       |        );
 1346|       |        
 1347|      1|        assert_eq!(count, 1);
 1348|      1|        let vel = pw.get_velocity(box_id).unwrap();
 1349|      1|        assert!(vel.length() > 0.0);
 1350|      1|    }
 1351|       |
 1352|       |    #[test]
 1353|      1|    fn test_raycast() {
 1354|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1355|      1|        let box_id = pw.add_dynamic_box(
 1356|      1|            Vec3::new(5.0, 0.0, 0.0),
 1357|      1|            Vec3::new(0.5, 0.5, 0.5),
 1358|       |            1.0,
 1359|       |            Layers::DEFAULT,
 1360|       |        );
 1361|      1|        pw.step(); // Update query pipeline
 1362|       |        
 1363|      1|        let hit = pw.raycast(Vec3::ZERO, Vec3::X, 10.0);
 1364|      1|        assert!(hit.is_some());
 1365|      1|        let (_, _, hit_id, _) = hit.unwrap();
 1366|      1|        assert_eq!(hit_id, Some(box_id));
 1367|      1|    }
 1368|       |
 1369|       |    #[test]
 1370|      1|    fn test_break_destructible() {
 1371|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1372|      1|        let box_id = pw.add_dynamic_box(
 1373|      1|            Vec3::new(0.0, 5.0, 0.0),
 1374|      1|            Vec3::new(0.5, 0.5, 0.5),
 1375|       |            1.0,
 1376|       |            Layers::DEFAULT,
 1377|       |        );
 1378|       |        
 1379|      1|        assert!(pw.handle_of(box_id).is_some());
 1380|      1|        pw.break_destructible(box_id);
 1381|      1|        assert!(pw.handle_of(box_id).is_none());
 1382|      1|    }
 1383|       |
 1384|       |    #[test]
 1385|      1|    fn test_add_joint() {
 1386|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1387|      1|        let b1 = pw.add_dynamic_box(Vec3::new(0.0, 5.0, 0.0), Vec3::new(0.5, 0.5, 0.5), 1.0, Layers::DEFAULT);
 1388|      1|        let b2 = pw.add_dynamic_box(Vec3::new(2.0, 5.0, 0.0), Vec3::new(0.5, 0.5, 0.5), 1.0, Layers::DEFAULT);
 1389|       |        
 1390|      1|        let j1 = pw.add_joint(b1, b2, JointType::Fixed);
 1391|      1|        assert_ne!(j1.0, 0);
 1392|       |        
 1393|      1|        let j2 = pw.add_joint(b1, b2, JointType::Revolute { axis: Vec3::Y, limits: None });
 1394|      1|        assert_ne!(j2.0, 0);
 1395|       |
 1396|      1|        let j3 = pw.add_joint(b1, b2, JointType::Prismatic { axis: Vec3::X, limits: Some((-1.0, 1.0)) });
 1397|      1|        assert_ne!(j3.0, 0);
 1398|       |
 1399|      1|        let j4 = pw.add_joint(b1, b2, JointType::Spherical);
 1400|      1|        assert_ne!(j4.0, 0);
 1401|      1|    }
 1402|       |
 1403|       |    #[test]
 1404|      1|    fn test_set_body_position() {
 1405|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1406|      1|        let box_id = pw.add_dynamic_box(Vec3::new(0.0, 5.0, 0.0), Vec3::new(0.5, 0.5, 0.5), 1.0, Layers::DEFAULT);
 1407|       |        
 1408|      1|        pw.set_body_position(box_id, Vec3::new(10.0, 10.0, 10.0));
 1409|      1|        let transform = pw.body_transform(box_id).unwrap();
 1410|      1|        assert!((transform.w_axis.x - 10.0).abs() < 0.01);
 1411|      1|    }
 1412|       |
 1413|       |    #[test]
 1414|      1|    fn test_enable_ccd() {
 1415|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1416|      1|        let box_id = pw.add_dynamic_box(Vec3::new(0.0, 5.0, 0.0), Vec3::new(0.5, 0.5, 0.5), 1.0, Layers::DEFAULT);
 1417|      1|        pw.enable_ccd(box_id);
 1418|      1|    }
 1419|       |
 1420|       |    #[test]
 1421|      1|    fn test_get_debug_lines() {
 1422|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1423|      1|        pw.add_dynamic_box(Vec3::new(0.0, 5.0, 0.0), Vec3::new(0.5, 0.5, 0.5), 1.0, Layers::DEFAULT);
 1424|      1|        let lines = pw.get_debug_lines();
 1425|      1|        assert!(!lines.is_empty());
 1426|      1|    }
 1427|       |
 1428|       |    #[test]
 1429|      1|    fn test_character_climb() {
 1430|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1431|      1|        let char_id = pw.add_character(Vec3::new(0.0, 1.0, 0.0), Vec3::new(0.4, 0.9, 0.4));
 1432|       |        
 1433|      1|        let y0 = pw.body_transform(char_id).unwrap().w_axis.y;
 1434|      1|        pw.control_character(char_id, Vec3::ZERO, 0.1, true);
 1435|      1|        pw.step();
 1436|       |        
 1437|      1|        let y1 = pw.body_transform(char_id).unwrap().w_axis.y;
 1438|      1|        assert!(y1 > y0);
 1439|      1|    }
 1440|       |
 1441|       |    #[test]
 1442|      1|    fn test_buoyancy_application() {
 1443|      1|        let mut pw = PhysicsWorld::new(Vec3::new(0.0, -9.8, 0.0));
 1444|      1|        pw.water_level = 10.0;
 1445|      1|        let box_id = pw.add_dynamic_box(Vec3::new(0.0, 5.0, 0.0), Vec3::new(0.5, 0.5, 0.5), 1.0, Layers::DEFAULT);
 1446|      1|        pw.add_buoyancy(box_id, 1.0, 0.5);
 1447|       |        
 1448|       |        // Step should apply buoyancy force
 1449|      1|        pw.step();
 1450|      1|        let vel = pw.get_velocity(box_id).unwrap();
 1451|      1|        assert!(vel.y > 0.0);
 1452|      1|    }
 1453|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-physics\src\projectile.rs:
    1|       |//! # Projectile System
    2|       |//!
    3|       |//! Lightweight projectile simulation optimized for games. Uses custom ballistic
    4|       |//! solving instead of full rigid body simulation for performance.
    5|       |//!
    6|       |//! ## Features
    7|       |//!
    8|       |//! - **Hitscan**: Instant raycast projectiles (bullets, lasers)
    9|       |//! - **Kinematic**: Physically simulated projectiles (grenades, arrows)
   10|       |//! - **Ballistics**: Gravity, drag, wind effects
   11|       |//! - **Collision**: Raycast/shapecast detection with penetration
   12|       |//! - **Explosions**: Radial impulse with falloff curves
   13|       |//!
   14|       |//! ## Usage
   15|       |//!
   16|       |//! ```rust
   17|       |//! use astraweave_physics::projectile::{ProjectileManager, ProjectileConfig, ProjectileKind};
   18|       |//! use glam::Vec3;
   19|       |//!
   20|       |//! let mut manager = ProjectileManager::new();
   21|       |//!
   22|       |//! // Spawn a grenade
   23|       |//! let config = ProjectileConfig {
   24|       |//!     kind: ProjectileKind::Kinematic,
   25|       |//!     position: Vec3::new(0.0, 1.0, 0.0),
   26|       |//!     velocity: Vec3::new(10.0, 5.0, 0.0),
   27|       |//!     gravity_scale: 1.0,
   28|       |//!     drag: 0.01,
   29|       |//!     radius: 0.1,
   30|       |//!     max_lifetime: 10.0,
   31|       |//!     ..Default::default()
   32|       |//! };
   33|       |//!
   34|       |//! let id = manager.spawn(config);
   35|       |//! ```
   36|       |
   37|       |use glam::Vec3;
   38|       |use std::collections::HashMap;
   39|       |
   40|       |/// Unique identifier for a projectile
   41|       |pub type ProjectileId = u64;
   42|       |
   43|       |/// Type of projectile simulation
   44|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
   45|       |pub enum ProjectileKind {
   46|       |    /// Instant raycast (bullets, lasers) - no travel time
   47|       |    Hitscan,
   48|       |    /// Physically simulated with ballistics (grenades, arrows)
   49|       |    #[default]
   50|       |    Kinematic,
   51|       |}
   52|       |
   53|       |/// Configuration for spawning a projectile
   54|       |#[derive(Debug, Clone)]
   55|       |pub struct ProjectileConfig {
   56|       |    /// Type of projectile
   57|       |    pub kind: ProjectileKind,
   58|       |    /// Initial world position
   59|       |    pub position: Vec3,
   60|       |    /// Initial velocity (direction * speed)
   61|       |    pub velocity: Vec3,
   62|       |    /// Gravity multiplier (0.0 = no gravity, 1.0 = normal, -1.0 = reverse)
   63|       |    pub gravity_scale: f32,
   64|       |    /// Air resistance coefficient (0.0 = none, higher = more drag)
   65|       |    pub drag: f32,
   66|       |    /// Collision radius for shapecast
   67|       |    pub radius: f32,
   68|       |    /// Maximum time before auto-despawn (seconds)
   69|       |    pub max_lifetime: f32,
   70|       |    /// Maximum bounces before despawn (0 = no bounce)
   71|       |    pub max_bounces: u32,
   72|       |    /// Bounciness factor (0.0 = no bounce, 1.0 = perfect elastic)
   73|       |    pub restitution: f32,
   74|       |    /// Penetration power (0.0 = no penetration)
   75|       |    pub penetration: f32,
   76|       |    /// Owner entity ID (for friendly fire detection)
   77|       |    pub owner: Option<u64>,
   78|       |    /// User data for game logic
   79|       |    pub user_data: u64,
   80|       |}
   81|       |
   82|       |impl Default for ProjectileConfig {
   83|     14|    fn default() -> Self {
   84|     14|        Self {
   85|     14|            kind: ProjectileKind::Kinematic,
   86|     14|            position: Vec3::ZERO,
   87|     14|            velocity: Vec3::ZERO,
   88|     14|            gravity_scale: 1.0,
   89|     14|            drag: 0.0,
   90|     14|            radius: 0.05,
   91|     14|            max_lifetime: 10.0,
   92|     14|            max_bounces: 0,
   93|     14|            restitution: 0.5,
   94|     14|            penetration: 0.0,
   95|     14|            owner: None,
   96|     14|            user_data: 0,
   97|     14|        }
   98|     14|    }
   99|       |}
  100|       |
  101|       |/// Active projectile state
  102|       |#[derive(Debug, Clone)]
  103|       |pub struct Projectile {
  104|       |    pub id: ProjectileId,
  105|       |    pub config: ProjectileConfig,
  106|       |    pub position: Vec3,
  107|       |    pub velocity: Vec3,
  108|       |    pub lifetime: f32,
  109|       |    pub bounces: u32,
  110|       |    pub active: bool,
  111|       |}
  112|       |
  113|       |impl Projectile {
  114|     14|    fn new(id: ProjectileId, config: ProjectileConfig) -> Self {
  115|     14|        let position = config.position;
  116|     14|        let velocity = config.velocity;
  117|     14|        Self {
  118|     14|            id,
  119|     14|            config,
  120|     14|            position,
  121|     14|            velocity,
  122|     14|            lifetime: 0.0,
  123|     14|            bounces: 0,
  124|     14|            active: true,
  125|     14|        }
  126|     14|    }
  127|       |}
  128|       |
  129|       |/// Result of a projectile hit
  130|       |#[derive(Debug, Clone)]
  131|       |pub struct ProjectileHit {
  132|       |    /// Projectile that hit
  133|       |    pub projectile_id: ProjectileId,
  134|       |    /// World position of impact
  135|       |    pub position: Vec3,
  136|       |    /// Surface normal at impact
  137|       |    pub normal: Vec3,
  138|       |    /// Body ID that was hit (if any)
  139|       |    pub body_id: Option<u64>,
  140|       |    /// Distance traveled to hit
  141|       |    pub distance: f32,
  142|       |    /// Whether the projectile penetrated
  143|       |    pub penetrated: bool,
  144|       |}
  145|       |
  146|       |/// Falloff curve for explosion damage/force
  147|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
  148|       |pub enum FalloffCurve {
  149|       |    /// Force = max * (1 - distance/radius)
  150|       |    #[default]
  151|       |    Linear,
  152|       |    /// Force = max * (1 - (distance/radius)^2)
  153|       |    Quadratic,
  154|       |    /// Force = max * e^(-distance/radius)
  155|       |    Exponential,
  156|       |    /// Force = max (no falloff)
  157|       |    Constant,
  158|       |}
  159|       |
  160|       |impl FalloffCurve {
  161|       |    /// Calculate falloff multiplier (0.0 to 1.0) given distance and radius
  162|     35|    pub fn calculate(&self, distance: f32, radius: f32) -> f32 {
  163|     35|        if distance >= radius {
  164|      6|            return 0.0;
  165|     29|        }
  166|     29|        if radius <= 0.0 {
  167|      0|            return 1.0;
  168|     29|        }
  169|     29|        let t = distance / radius;
  170|     29|        match self {
  171|     19|            FalloffCurve::Linear => 1.0 - t,
  172|      5|            FalloffCurve::Quadratic => 1.0 - t * t,
  173|      0|            FalloffCurve::Exponential => (-t * 3.0).exp(), // e^(-3t) gives ~5% at edge
  174|      5|            FalloffCurve::Constant => 1.0,
  175|       |        }
  176|     35|    }
  177|       |}
  178|       |
  179|       |/// Configuration for an explosion
  180|       |#[derive(Debug, Clone)]
  181|       |pub struct ExplosionConfig {
  182|       |    /// Center of explosion
  183|       |    pub center: Vec3,
  184|       |    /// Maximum radius of effect
  185|       |    pub radius: f32,
  186|       |    /// Maximum force at center
  187|       |    pub force: f32,
  188|       |    /// Force falloff curve
  189|       |    pub falloff: FalloffCurve,
  190|       |    /// Upward bias (0.0 = pure radial, 1.0 = pure upward)
  191|       |    pub upward_bias: f32,
  192|       |}
  193|       |
  194|       |impl Default for ExplosionConfig {
  195|      1|    fn default() -> Self {
  196|      1|        Self {
  197|      1|            center: Vec3::ZERO,
  198|      1|            radius: 5.0,
  199|      1|            force: 1000.0,
  200|      1|            falloff: FalloffCurve::Linear,
  201|      1|            upward_bias: 0.3,
  202|      1|        }
  203|      1|    }
  204|       |}
  205|       |
  206|       |/// Result of explosion affecting a body
  207|       |#[derive(Debug, Clone)]
  208|       |pub struct ExplosionResult {
  209|       |    /// Body that was affected
  210|       |    pub body_id: u64,
  211|       |    /// Impulse applied to body
  212|       |    pub impulse: Vec3,
  213|       |    /// Distance from explosion center
  214|       |    pub distance: f32,
  215|       |    /// Falloff multiplier applied
  216|       |    pub falloff_multiplier: f32,
  217|       |}
  218|       |
  219|       |/// Manages all active projectiles
  220|       |#[derive(Debug)]
  221|       |pub struct ProjectileManager {
  222|       |    projectiles: HashMap<ProjectileId, Projectile>,
  223|       |    next_id: ProjectileId,
  224|       |    /// Global wind vector affecting all projectiles
  225|       |    pub wind: Vec3,
  226|       |    /// Global gravity vector (default: -9.81 Y)
  227|       |    pub gravity: Vec3,
  228|       |    /// Pending hits from last update
  229|       |    hits: Vec<ProjectileHit>,
  230|       |}
  231|       |
  232|       |impl Default for ProjectileManager {
  233|      1|    fn default() -> Self {
  234|      1|        Self::new()
  235|      1|    }
  236|       |}
  237|       |
  238|       |impl ProjectileManager {
  239|       |    /// Create a new projectile manager
  240|     19|    pub fn new() -> Self {
  241|     19|        Self {
  242|     19|            projectiles: HashMap::new(),
  243|     19|            next_id: 1,
  244|     19|            wind: Vec3::ZERO,
  245|     19|            gravity: Vec3::new(0.0, -9.81, 0.0),
  246|     19|            hits: Vec::new(),
  247|     19|        }
  248|     19|    }
  249|       |
  250|       |    /// Spawn a new projectile
  251|     14|    pub fn spawn(&mut self, config: ProjectileConfig) -> ProjectileId {
  252|     14|        let id = self.next_id;
  253|     14|        self.next_id += 1;
  254|       |        
  255|     14|        let projectile = Projectile::new(id, config);
  256|     14|        self.projectiles.insert(id, projectile);
  257|     14|        id
  258|     14|    }
  259|       |
  260|       |    /// Despawn a projectile
  261|      3|    pub fn despawn(&mut self, id: ProjectileId) -> bool {
  262|      3|        self.projectiles.remove(&id).is_some()
  263|      3|    }
  264|       |
  265|       |    /// Get a projectile by ID
  266|     16|    pub fn get(&self, id: ProjectileId) -> Option<&Projectile> {
  267|     16|        self.projectiles.get(&id)
  268|     16|    }
  269|       |
  270|       |    /// Get a mutable reference to a projectile
  271|      1|    pub fn get_mut(&mut self, id: ProjectileId) -> Option<&mut Projectile> {
  272|      1|        self.projectiles.get_mut(&id)
  273|      1|    }
  274|       |
  275|       |    /// Get all active projectiles
  276|      1|    pub fn iter(&self) -> impl Iterator<Item = &Projectile> {
  277|      1|        self.projectiles.values().filter(|p| p.active)
  278|      1|    }
  279|       |
  280|       |    /// Get number of active projectiles
  281|      5|    pub fn count(&self) -> usize {
  282|      5|        self.projectiles.len()
  283|      5|    }
  284|       |
  285|       |    /// Get hits from last update (call after `update`)
  286|      2|    pub fn drain_hits(&mut self) -> Vec<ProjectileHit> {
  287|      2|        std::mem::take(&mut self.hits)
  288|      2|    }
  289|       |
  290|       |    /// Update all projectiles (call once per frame)
  291|       |    ///
  292|       |    /// # Arguments
  293|       |    /// * `dt` - Delta time in seconds
  294|       |    /// * `raycast_fn` - Function to perform raycasts: (origin, direction, max_dist) -> Option<(hit_pos, normal, body_id, dist)>
  295|    742|    pub fn update<F>(&mut self, dt: f32, mut raycast_fn: F)
  296|    742|    where
  297|    742|        F: FnMut(Vec3, Vec3, f32) -> Option<(Vec3, Vec3, Option<u64>, f32)>,
  298|       |    {
  299|    742|        let gravity = self.gravity;
  300|    742|        let wind = self.wind;
  301|    742|        let mut to_despawn = Vec::new();
  302|       |
  303|    742|        for projectile in self.projectiles.values_mut() {
                          ^609
  304|    609|            if !projectile.active {
  305|      0|                continue;
  306|    609|            }
  307|       |
  308|       |            // Update lifetime
  309|    609|            projectile.lifetime += dt;
  310|    609|            if projectile.lifetime >= projectile.config.max_lifetime {
  311|      2|                projectile.active = false;
  312|      2|                to_despawn.push(projectile.id);
  313|      2|                continue;
  314|    607|            }
  315|       |
  316|       |            // Skip hitscan (they resolve instantly on spawn)
  317|    607|            if projectile.config.kind == ProjectileKind::Hitscan {
  318|      1|                continue;
  319|    606|            }
  320|       |
  321|       |            // Store previous position for collision detection
  322|    606|            let prev_pos = projectile.position;
  323|       |
  324|       |            // Apply gravity
  325|    606|            let grav_accel = gravity * projectile.config.gravity_scale;
  326|    606|            projectile.velocity += grav_accel * dt;
  327|       |
  328|       |            // Apply drag: F_drag = -drag * v^2 * normalize(v)
  329|    606|            let speed = projectile.velocity.length();
  330|    606|            if speed > 0.001 && projectile.config.drag > 0.0 {
  331|     60|                let drag_force = projectile.config.drag * speed * speed;
  332|     60|                let drag_decel = (drag_force / 1.0) * dt; // Assume unit mass
  333|     60|                let decel = drag_decel.min(speed); // Don't reverse direction
  334|     60|                projectile.velocity -= projectile.velocity.normalize() * decel;
  335|    546|            }
  336|       |
  337|       |            // Apply wind
  338|    606|            projectile.velocity += wind * dt;
  339|       |
  340|       |            // Calculate new position
  341|    606|            let movement = projectile.velocity * dt;
  342|    606|            let new_pos = prev_pos + movement;
  343|       |
  344|       |            // Raycast for collision
  345|    606|            let move_dist = movement.length();
  346|    606|            if move_dist > 0.001 {
  347|    606|                let dir = movement.normalize();
  348|      6|                if let Some((hit_pos, normal, body_id, dist)) =
  349|    606|                    raycast_fn(prev_pos, dir, move_dist + projectile.config.radius)
  350|       |                {
  351|       |                    // Record hit
  352|      6|                    self.hits.push(ProjectileHit {
  353|      6|                        projectile_id: projectile.id,
  354|      6|                        position: hit_pos,
  355|      6|                        normal,
  356|      6|                        body_id,
  357|      6|                        distance: dist,
  358|      6|                        penetrated: projectile.config.penetration > 0.0,
  359|      6|                    });
  360|       |
  361|       |                    // Handle bounce
  362|      6|                    if projectile.bounces < projectile.config.max_bounces
  363|      5|                        && projectile.config.restitution > 0.0
  364|      5|                    {
  365|      5|                        // Reflect velocity
  366|      5|                        let reflect = projectile.velocity
  367|      5|                            - 2.0 * projectile.velocity.dot(normal) * normal;
  368|      5|                        projectile.velocity = reflect * projectile.config.restitution;
  369|      5|                        projectile.position = hit_pos + normal * 0.01; // Offset from surface
  370|      5|                        projectile.bounces += 1;
  371|      5|                    } else {
  372|      1|                        // Despawn on impact
  373|      1|                        projectile.active = false;
  374|      1|                        to_despawn.push(projectile.id);
  375|      1|                    }
  376|    600|                } else {
  377|    600|                    // No collision, update position
  378|    600|                    projectile.position = new_pos;
  379|    600|                }
  380|      0|            } else {
  381|      0|                projectile.position = new_pos;
  382|      0|            }
  383|       |        }
  384|       |
  385|       |        // Clean up despawned projectiles
  386|    745|        for id in to_despawn {
                          ^3
  387|      3|            self.projectiles.remove(&id);
  388|      3|        }
  389|    742|    }
  390|       |
  391|       |    /// Perform hitscan (instant raycast projectile)
  392|       |    ///
  393|       |    /// Returns hit result if something was hit.
  394|      2|    pub fn hitscan<F>(
  395|      2|        &mut self,
  396|      2|        origin: Vec3,
  397|      2|        direction: Vec3,
  398|      2|        max_distance: f32,
  399|      2|        mut raycast_fn: F,
  400|      2|    ) -> Option<ProjectileHit>
  401|      2|    where
  402|      2|        F: FnMut(Vec3, Vec3, f32) -> Option<(Vec3, Vec3, Option<u64>, f32)>,
  403|       |    {
  404|      2|        let dir = direction.normalize();
  405|      2|        raycast_fn(origin, dir, max_distance).map(|(hit_pos, normal, body_id, dist)| {
  406|      2|            ProjectileHit {
  407|      2|                projectile_id: 0, // Hitscan doesn't create persistent projectile
  408|      2|                position: hit_pos,
  409|      2|                normal,
  410|      2|                body_id,
  411|      2|                distance: dist,
  412|      2|                penetrated: false,
  413|      2|            }
  414|      2|        })
  415|      2|    }
  416|       |
  417|       |    /// Calculate explosion effects on nearby bodies
  418|       |    ///
  419|       |    /// # Arguments
  420|       |    /// * `config` - Explosion configuration
  421|       |    /// * `bodies` - Iterator of (body_id, position) pairs to check
  422|       |    ///
  423|       |    /// # Returns
  424|       |    /// Vector of bodies affected with impulse to apply
  425|      5|    pub fn calculate_explosion<I>(
  426|      5|        &self,
  427|      5|        config: &ExplosionConfig,
  428|      5|        bodies: I,
  429|      5|    ) -> Vec<ExplosionResult>
  430|      5|    where
  431|      5|        I: IntoIterator<Item = (u64, Vec3)>,
  432|       |    {
  433|      5|        let mut results = Vec::new();
  434|       |
  435|     11|        for (body_id, body_pos) in bodies {
                           ^6       ^6
  436|      6|            let to_body = body_pos - config.center;
  437|      6|            let distance = to_body.length();
  438|       |
  439|      6|            if distance >= config.radius {
  440|      1|                continue;
  441|      5|            }
  442|       |
  443|      5|            let falloff = config.falloff.calculate(distance, config.radius);
  444|      5|            let force_magnitude = config.force * falloff;
  445|       |
  446|       |            // Calculate direction with upward bias
  447|      5|            let radial_dir = if distance > 0.001 {
  448|      5|                to_body.normalize()
  449|       |            } else {
  450|      0|                Vec3::Y // Default to up if at center
  451|       |            };
  452|       |
  453|      5|            let biased_dir =
  454|      5|                (radial_dir * (1.0 - config.upward_bias) + Vec3::Y * config.upward_bias).normalize();
  455|       |
  456|      5|            let impulse = biased_dir * force_magnitude;
  457|       |
  458|      5|            results.push(ExplosionResult {
  459|      5|                body_id,
  460|      5|                impulse,
  461|      5|                distance,
  462|      5|                falloff_multiplier: falloff,
  463|      5|            });
  464|       |        }
  465|       |
  466|      5|        results
  467|      5|    }
  468|       |}
  469|       |
  470|       |/// Calculate projectile trajectory points (for prediction/visualization)
  471|       |///
  472|       |/// # Arguments
  473|       |/// * `start` - Starting position
  474|       |/// * `velocity` - Initial velocity
  475|       |/// * `gravity` - Gravity vector
  476|       |/// * `drag` - Drag coefficient
  477|       |/// * `dt` - Time step between points
  478|       |/// * `num_points` - Number of trajectory points
  479|      2|pub fn predict_trajectory(
  480|      2|    start: Vec3,
  481|      2|    velocity: Vec3,
  482|      2|    gravity: Vec3,
  483|      2|    drag: f32,
  484|      2|    dt: f32,
  485|      2|    num_points: usize,
  486|      2|) -> Vec<Vec3> {
  487|      2|    let mut points = Vec::with_capacity(num_points);
  488|      2|    let mut pos = start;
  489|      2|    let mut vel = velocity;
  490|       |
  491|      2|    points.push(pos);
  492|       |
  493|      2|    for _ in 1..num_points {
  494|       |        // Apply gravity
  495|     58|        vel += gravity * dt;
  496|       |
  497|       |        // Apply drag
  498|     58|        let speed = vel.length();
  499|     58|        if speed > 0.001 && drag > 0.0 {
  500|      0|            let drag_force = drag * speed * speed;
  501|      0|            let drag_decel = (drag_force / 1.0) * dt;
  502|      0|            let decel = drag_decel.min(speed);
  503|      0|            vel -= vel.normalize() * decel;
  504|     58|        }
  505|       |
  506|     58|        pos += vel * dt;
  507|     58|        points.push(pos);
  508|       |    }
  509|       |
  510|      2|    points
  511|      2|}
  512|       |
  513|       |#[cfg(test)]
  514|       |mod tests {
  515|       |    use super::*;
  516|       |
  517|       |    #[test]
  518|      1|    fn test_projectile_spawn() {
  519|      1|        let mut manager = ProjectileManager::new();
  520|      1|        let id = manager.spawn(ProjectileConfig::default());
  521|      1|        assert!(manager.get(id).is_some());
  522|      1|        assert_eq!(manager.count(), 1);
  523|      1|    }
  524|       |
  525|       |    #[test]
  526|      1|    fn test_projectile_despawn() {
  527|      1|        let mut manager = ProjectileManager::new();
  528|      1|        let id = manager.spawn(ProjectileConfig::default());
  529|      1|        assert!(manager.despawn(id));
  530|      1|        assert!(manager.get(id).is_none());
  531|      1|        assert_eq!(manager.count(), 0);
  532|      1|    }
  533|       |
  534|       |    #[test]
  535|      1|    fn test_projectile_gravity() {
  536|      1|        let mut manager = ProjectileManager::new();
  537|      1|        let config = ProjectileConfig {
  538|      1|            position: Vec3::new(0.0, 10.0, 0.0),
  539|      1|            velocity: Vec3::new(10.0, 0.0, 0.0),
  540|      1|            gravity_scale: 1.0,
  541|      1|            ..Default::default()
  542|      1|        };
  543|      1|        let id = manager.spawn(config);
  544|       |
  545|       |        // No-op raycast
  546|     60|        let raycast = |_: Vec3, _: Vec3, _: f32| -> Option<(Vec3, Vec3, Option<u64>, f32)> { None };
                          ^1
  547|       |
  548|       |        // Simulate 1 second
  549|     61|        for _ in 0..60 {
  550|     60|            manager.update(1.0 / 60.0, raycast);
  551|     60|        }
  552|       |
  553|      1|        let proj = manager.get(id).unwrap();
  554|       |        // Should have fallen ~4.9m (1/2 * 9.81 * 1^2)
  555|      1|        assert!(proj.position.y < 6.0, "Y should be < 6, got {}", proj.position.y);
                                                     ^0
  556|       |        // Should have moved ~10m horizontally
  557|      1|        assert!(proj.position.x > 9.0, "X should be > 9, got {}", proj.position.x);
                                                     ^0
  558|      1|    }
  559|       |
  560|       |    #[test]
  561|      1|    fn test_projectile_drag() {
  562|      1|        let mut manager = ProjectileManager::new();
  563|      1|        manager.gravity = Vec3::ZERO; // No gravity for this test
  564|       |
  565|      1|        let config = ProjectileConfig {
  566|      1|            position: Vec3::ZERO,
  567|      1|            velocity: Vec3::new(100.0, 0.0, 0.0),
  568|      1|            gravity_scale: 0.0,
  569|      1|            drag: 0.1,
  570|      1|            ..Default::default()
  571|      1|        };
  572|      1|        let id = manager.spawn(config);
  573|       |
  574|     60|        let raycast = |_: Vec3, _: Vec3, _: f32| -> Option<(Vec3, Vec3, Option<u64>, f32)> { None };
                          ^1
  575|       |
  576|       |        // Simulate 1 second
  577|     61|        for _ in 0..60 {
  578|     60|            manager.update(1.0 / 60.0, raycast);
  579|     60|        }
  580|       |
  581|      1|        let proj = manager.get(id).unwrap();
  582|       |        // With drag, should have slowed down significantly
  583|      1|        assert!(
  584|      1|            proj.velocity.x < 100.0,
  585|      0|            "Velocity should decrease with drag"
  586|       |        );
  587|      1|    }
  588|       |
  589|       |    #[test]
  590|      1|    fn test_projectile_bounce() {
  591|      1|        let mut manager = ProjectileManager::new();
  592|      1|        manager.gravity = Vec3::ZERO;
  593|       |
  594|      1|        let config = ProjectileConfig {
  595|      1|            position: Vec3::ZERO,
  596|      1|            velocity: Vec3::new(10.0, 0.0, 0.0),
  597|      1|            gravity_scale: 0.0,
  598|      1|            max_bounces: 3,
  599|      1|            restitution: 0.8,
  600|      1|            ..Default::default()
  601|      1|        };
  602|      1|        let id = manager.spawn(config);
  603|       |
  604|       |        // Simulate hitting a wall at X=5
  605|      1|        let raycast = |origin: Vec3, dir: Vec3, max: f32| -> Option<(Vec3, Vec3, Option<u64>, f32)> {
  606|      1|            if origin.x < 5.0 && dir.x > 0.0 {
  607|      1|                let dist = 5.0 - origin.x;
  608|      1|                if dist < max {
  609|      1|                    return Some((Vec3::new(5.0, 0.0, 0.0), Vec3::new(-1.0, 0.0, 0.0), Some(1), dist));
  610|      0|                }
  611|      0|            }
  612|      0|            None
  613|      1|        };
  614|       |
  615|       |        // First update should hit the wall
  616|      1|        manager.update(1.0, raycast);
  617|       |
  618|      1|        let proj = manager.get(id).unwrap();
  619|      1|        assert_eq!(proj.bounces, 1, "Should have bounced once");
                                                  ^0
  620|      1|        assert!(proj.velocity.x < 0.0, "Velocity should be reversed");
                                                     ^0
  621|      1|    }
  622|       |
  623|       |    #[test]
  624|      1|    fn test_projectile_lifetime() {
  625|      1|        let mut manager = ProjectileManager::new();
  626|      1|        let config = ProjectileConfig {
  627|      1|            max_lifetime: 0.5,
  628|      1|            ..Default::default()
  629|      1|        };
  630|      1|        let id = manager.spawn(config);
  631|       |
  632|     29|        let raycast = |_: Vec3, _: Vec3, _: f32| -> Option<(Vec3, Vec3, Option<u64>, f32)> { None };
                          ^1
  633|       |
  634|       |        // Simulate 1 second (projectile should despawn at 0.5s)
  635|     61|        for _ in 0..60 {
  636|     60|            manager.update(1.0 / 60.0, raycast);
  637|     60|        }
  638|       |
  639|      1|        assert!(manager.get(id).is_none(), "Projectile should have despawned");
                                                         ^0
  640|      1|    }
  641|       |
  642|       |    #[test]
  643|      1|    fn test_falloff_linear() {
  644|      1|        let curve = FalloffCurve::Linear;
  645|      1|        assert!((curve.calculate(0.0, 10.0) - 1.0).abs() < 0.001);
  646|      1|        assert!((curve.calculate(5.0, 10.0) - 0.5).abs() < 0.001);
  647|      1|        assert!((curve.calculate(10.0, 10.0) - 0.0).abs() < 0.001);
  648|      1|    }
  649|       |
  650|       |    #[test]
  651|      1|    fn test_falloff_quadratic() {
  652|      1|        let curve = FalloffCurve::Quadratic;
  653|      1|        assert!((curve.calculate(0.0, 10.0) - 1.0).abs() < 0.001);
  654|      1|        assert!((curve.calculate(5.0, 10.0) - 0.75).abs() < 0.001); // 1 - 0.5^2 = 0.75
  655|      1|        assert!((curve.calculate(10.0, 10.0) - 0.0).abs() < 0.001);
  656|      1|    }
  657|       |
  658|       |    #[test]
  659|      1|    fn test_explosion_radial() {
  660|      1|        let manager = ProjectileManager::new();
  661|      1|        let config = ExplosionConfig {
  662|      1|            center: Vec3::ZERO,
  663|      1|            radius: 10.0,
  664|      1|            force: 1000.0,
  665|      1|            falloff: FalloffCurve::Linear,
  666|      1|            upward_bias: 0.0,
  667|      1|        };
  668|       |
  669|      1|        let bodies = vec![
  670|      1|            (1, Vec3::new(5.0, 0.0, 0.0)),  // At half radius
  671|      1|            (2, Vec3::new(15.0, 0.0, 0.0)), // Outside radius
  672|       |        ];
  673|       |
  674|      1|        let results = manager.calculate_explosion(&config, bodies);
  675|       |
  676|      1|        assert_eq!(results.len(), 1, "Only one body should be affected");
                                                   ^0
  677|      1|        assert_eq!(results[0].body_id, 1);
  678|      1|        assert!((results[0].falloff_multiplier - 0.5).abs() < 0.01);
  679|      1|        assert!(results[0].impulse.x > 0.0, "Impulse should push away from center");
                                                          ^0
  680|      1|    }
  681|       |
  682|       |    #[test]
  683|      1|    fn test_explosion_upward_bias() {
  684|      1|        let manager = ProjectileManager::new();
  685|      1|        let config = ExplosionConfig {
  686|      1|            center: Vec3::ZERO,
  687|      1|            radius: 10.0,
  688|      1|            force: 1000.0,
  689|      1|            falloff: FalloffCurve::Constant,
  690|      1|            upward_bias: 1.0, // Full upward
  691|      1|        };
  692|       |
  693|      1|        let bodies = vec![(1, Vec3::new(5.0, 0.0, 0.0))];
  694|      1|        let results = manager.calculate_explosion(&config, bodies);
  695|       |
  696|      1|        assert_eq!(results.len(), 1);
  697|       |        // With full upward bias, impulse should be purely vertical
  698|      1|        assert!(results[0].impulse.y > 900.0, "Impulse should be mostly upward");
                                                            ^0
  699|      1|    }
  700|       |
  701|       |    #[test]
  702|      1|    fn test_predict_trajectory() {
  703|      1|        let points = predict_trajectory(
  704|      1|            Vec3::new(0.0, 0.0, 0.0),
  705|      1|            Vec3::new(10.0, 10.0, 0.0),
  706|      1|            Vec3::new(0.0, -9.81, 0.0),
  707|       |            0.0,
  708|       |            0.1,
  709|       |            10,
  710|       |        );
  711|       |
  712|      1|        assert_eq!(points.len(), 10);
  713|      1|        assert_eq!(points[0], Vec3::ZERO);
  714|       |        // Later points should show parabolic arc
  715|      1|        assert!(points[9].x > points[0].x, "Should move forward");
                                                         ^0
  716|      1|    }
  717|       |
  718|       |    #[test]
  719|      1|    fn test_hitscan() {
  720|      1|        let mut manager = ProjectileManager::new();
  721|       |
  722|       |        // Mock raycast that hits at distance 5
  723|      1|        let raycast = |_: Vec3, _: Vec3, _: f32| -> Option<(Vec3, Vec3, Option<u64>, f32)> {
  724|      1|            Some((Vec3::new(5.0, 0.0, 0.0), Vec3::new(-1.0, 0.0, 0.0), Some(1), 5.0))
  725|      1|        };
  726|       |
  727|      1|        let hit = manager.hitscan(Vec3::ZERO, Vec3::X, 100.0, raycast);
  728|       |
  729|      1|        assert!(hit.is_some());
  730|      1|        let hit = hit.unwrap();
  731|      1|        assert_eq!(hit.distance, 5.0);
  732|      1|        assert_eq!(hit.body_id, Some(1));
  733|      1|    }
  734|       |
  735|       |    #[test]
  736|      1|    fn test_wind_effect() {
  737|      1|        let mut manager = ProjectileManager::new();
  738|      1|        manager.gravity = Vec3::ZERO;
  739|      1|        manager.wind = Vec3::new(5.0, 0.0, 0.0); // Wind blowing +X
  740|       |
  741|      1|        let config = ProjectileConfig {
  742|      1|            position: Vec3::ZERO,
  743|      1|            velocity: Vec3::new(0.0, 0.0, 10.0), // Moving +Z
  744|      1|            gravity_scale: 0.0,
  745|      1|            ..Default::default()
  746|      1|        };
  747|      1|        let id = manager.spawn(config);
  748|       |
  749|     60|        let raycast = |_: Vec3, _: Vec3, _: f32| -> Option<(Vec3, Vec3, Option<u64>, f32)> { None };
                          ^1
  750|       |
  751|     61|        for _ in 0..60 {
  752|     60|            manager.update(1.0 / 60.0, raycast);
  753|     60|        }
  754|       |
  755|      1|        let proj = manager.get(id).unwrap();
  756|       |        // Wind should have pushed projectile in +X direction
  757|      1|        assert!(proj.position.x > 0.0, "Wind should affect trajectory");
                                                     ^0
  758|      1|    }
  759|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-physics\src\ragdoll.rs:
    1|       |//! # Ragdoll System
    2|       |//!
    3|       |//! Provides realistic ragdoll physics for character death animations,
    4|       |//! hit reactions, and procedural animations.
    5|       |//!
    6|       |//! ## Features
    7|       |//!
    8|       |//! - **Ragdoll Builder**: Create ragdolls from bone hierarchies
    9|       |//! - **State Management**: Smooth transitions between animated and physics states
   10|       |//! - **Impulse Propagation**: Realistic force distribution through joint chains
   11|       |//! - **Joint Limits**: Anatomically-correct constraints
   12|       |//!
   13|       |//! ## Usage
   14|       |//!
   15|       |//! ```rust
   16|       |//! use astraweave_physics::ragdoll::{RagdollBuilder, RagdollConfig, BoneShape};
   17|       |//! use glam::Vec3;
   18|       |//!
   19|       |//! // Define a simple humanoid skeleton
   20|       |//! let mut builder = RagdollBuilder::new(RagdollConfig::default());
   21|       |//!
   22|       |//! // Add bones (typically from skeleton data)
   23|       |//! builder.add_bone("pelvis", None, Vec3::ZERO, BoneShape::Capsule { radius: 0.15, half_height: 0.1 }, 2.0);
   24|       |//! builder.add_bone("spine", Some("pelvis"), Vec3::new(0.0, 0.2, 0.0), BoneShape::Capsule { radius: 0.12, half_height: 0.15 }, 1.5);
   25|       |//! builder.add_bone("head", Some("spine"), Vec3::new(0.0, 0.35, 0.0), BoneShape::Sphere { radius: 0.12 }, 1.0);
   26|       |//!
   27|       |//! // Build the ragdoll (requires PhysicsWorld)
   28|       |//! // let ragdoll = builder.build(&mut physics_world, spawn_position);
   29|       |//! ```
   30|       |
   31|       |use crate::{BodyId, JointId, JointType, Layers, PhysicsWorld};
   32|       |use glam::{Quat, Vec3};
   33|       |use std::collections::HashMap;
   34|       |
   35|       |/// Unique identifier for a ragdoll
   36|       |pub type RagdollId = u64;
   37|       |
   38|       |/// Shape of a bone's physics collider
   39|       |#[derive(Debug, Clone, Copy)]
   40|       |pub enum BoneShape {
   41|       |    /// Capsule shape (most common for limbs)
   42|       |    Capsule { radius: f32, half_height: f32 },
   43|       |    /// Sphere shape (good for head, hands)
   44|       |    Sphere { radius: f32 },
   45|       |    /// Box shape (good for torso, pelvis)
   46|       |    Box { half_extents: Vec3 },
   47|       |}
   48|       |
   49|       |impl BoneShape {
   50|       |    /// Get the approximate volume of this shape (for mass distribution)
   51|      3|    pub fn volume(&self) -> f32 {
   52|      3|        match self {
   53|      1|            BoneShape::Capsule { radius, half_height } => {
   54|      1|                let cylinder = std::f32::consts::PI * radius * radius * (half_height * 2.0);
   55|      1|                let sphere = (4.0 / 3.0) * std::f32::consts::PI * radius.powi(3);
   56|      1|                cylinder + sphere
   57|       |            }
   58|      1|            BoneShape::Sphere { radius } => {
   59|      1|                (4.0 / 3.0) * std::f32::consts::PI * radius.powi(3)
   60|       |            }
   61|      1|            BoneShape::Box { half_extents } => {
   62|      1|                half_extents.x * half_extents.y * half_extents.z * 8.0
   63|       |            }
   64|       |        }
   65|      3|    }
   66|       |}
   67|       |
   68|       |/// Joint constraint type for bones
   69|       |#[derive(Debug, Clone, Copy)]
   70|       |pub enum BoneJointType {
   71|       |    /// Ball-and-socket joint (shoulder, hip)
   72|       |    Spherical {
   73|       |        /// Cone limit in radians (how far the bone can swing)
   74|       |        swing_limit: Option<f32>,
   75|       |        /// Twist limit in radians (rotation around the bone's axis)
   76|       |        twist_limit: Option<(f32, f32)>,
   77|       |    },
   78|       |    /// Hinge joint (elbow, knee)
   79|       |    Hinge {
   80|       |        /// Axis of rotation (local to parent)
   81|       |        axis: Vec3,
   82|       |        /// Angle limits in radians (min, max)
   83|       |        limits: Option<(f32, f32)>,
   84|       |    },
   85|       |    /// Fixed joint (skull to spine, rigid connections)
   86|       |    Fixed,
   87|       |}
   88|       |
   89|       |/// Definition of a single bone in the ragdoll
   90|       |#[derive(Debug, Clone)]
   91|       |pub struct BoneDef {
   92|       |    /// Unique name of this bone
   93|       |    pub name: String,
   94|       |    /// Parent bone name (None for root)
   95|       |    pub parent: Option<String>,
   96|       |    /// Offset from parent bone (local space)
   97|       |    pub offset: Vec3,
   98|       |    /// Rotation offset from parent (local space)
   99|       |    pub rotation: Quat,
  100|       |    /// Physics shape for collision
  101|       |    pub shape: BoneShape,
  102|       |    /// Mass of this bone
  103|       |    pub mass: f32,
  104|       |    /// Joint type connecting to parent
  105|       |    pub joint_type: BoneJointType,
  106|       |}
  107|       |
  108|       |impl Default for BoneDef {
  109|    176|    fn default() -> Self {
  110|    176|        Self {
  111|    176|            name: String::new(),
  112|    176|            parent: None,
  113|    176|            offset: Vec3::ZERO,
  114|    176|            rotation: Quat::IDENTITY,
  115|    176|            shape: BoneShape::Capsule {
  116|    176|                radius: 0.05,
  117|    176|                half_height: 0.1,
  118|    176|            },
  119|    176|            mass: 1.0,
  120|    176|            joint_type: BoneJointType::Spherical {
  121|    176|                swing_limit: Some(std::f32::consts::FRAC_PI_4),
  122|    176|                twist_limit: None,
  123|    176|            },
  124|    176|        }
  125|    176|    }
  126|       |}
  127|       |
  128|       |/// Configuration for ragdoll behavior
  129|       |#[derive(Debug, Clone)]
  130|       |pub struct RagdollConfig {
  131|       |    /// Global mass multiplier
  132|       |    pub mass_scale: f32,
  133|       |    /// Joint stiffness (0.0 = floppy, 1.0 = stiff)
  134|       |    pub joint_stiffness: f32,
  135|       |    /// Joint damping (prevents oscillation)
  136|       |    pub joint_damping: f32,
  137|       |    /// Whether to enable CCD for fast-moving ragdolls
  138|       |    pub enable_ccd: bool,
  139|       |    /// Collision group for ragdoll bodies
  140|       |    pub collision_group: Layers,
  141|       |    /// Maximum angular velocity (prevents spinning out of control)
  142|       |    pub max_angular_velocity: f32,
  143|       |    /// Linear damping (air resistance)
  144|       |    pub linear_damping: f32,
  145|       |    /// Angular damping (rotational air resistance)
  146|       |    pub angular_damping: f32,
  147|       |}
  148|       |
  149|       |impl Default for RagdollConfig {
  150|     29|    fn default() -> Self {
  151|     29|        Self {
  152|     29|            mass_scale: 1.0,
  153|     29|            joint_stiffness: 0.5,
  154|     29|            joint_damping: 0.3,
  155|     29|            enable_ccd: true,
  156|     29|            collision_group: Layers::DEFAULT,
  157|     29|            max_angular_velocity: 20.0,
  158|     29|            linear_damping: 0.1,
  159|     29|            angular_damping: 0.5,
  160|     29|        }
  161|     29|    }
  162|       |}
  163|       |
  164|       |/// Ragdoll state
  165|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
  166|       |pub enum RagdollState {
  167|       |    /// Ragdoll is fully physics-driven
  168|       |    Active,
  169|       |    /// Ragdoll is blending from animation to physics
  170|       |    BlendingToPhysics {
  171|       |        /// Progress of blend (0.0 = animation, 1.0 = physics)
  172|       |        progress_percent: u8,
  173|       |    },
  174|       |    /// Ragdoll is blending from physics to animation
  175|       |    BlendingToAnimation {
  176|       |        /// Progress of blend (0.0 = physics, 1.0 = animation)
  177|       |        progress_percent: u8,
  178|       |    },
  179|       |    /// Ragdoll is disabled (using animation)
  180|       |    Disabled,
  181|       |}
  182|       |
  183|       |/// Instance of a spawned ragdoll
  184|       |#[derive(Debug)]
  185|       |pub struct Ragdoll {
  186|       |    /// Unique ID
  187|       |    pub id: RagdollId,
  188|       |    /// Current state
  189|       |    pub state: RagdollState,
  190|       |    /// Map of bone name to body ID
  191|       |    pub bone_bodies: HashMap<String, BodyId>,
  192|       |    /// Map of bone name to joint ID (joint connecting to parent)
  193|       |    pub bone_joints: HashMap<String, JointId>,
  194|       |    /// Root bone name
  195|       |    pub root_bone: String,
  196|       |    /// Configuration used to create this ragdoll
  197|       |    pub config: RagdollConfig,
  198|       |    /// Bone definitions (for reference)
  199|       |    bone_defs: Vec<BoneDef>,
  200|       |}
  201|       |
  202|       |impl Ragdoll {
  203|       |    /// Get the body ID for a bone by name
  204|     12|    pub fn get_bone_body(&self, name: &str) -> Option<BodyId> {
  205|     12|        self.bone_bodies.get(name).copied()
  206|     12|    }
  207|       |
  208|       |    /// Get all body IDs in this ragdoll
  209|      2|    pub fn all_bodies(&self) -> impl Iterator<Item = BodyId> + '_ {
  210|      2|        self.bone_bodies.values().copied()
  211|      2|    }
  212|       |
  213|       |    /// Get the root body ID
  214|      4|    pub fn root_body(&self) -> Option<BodyId> {
  215|      4|        self.bone_bodies.get(&self.root_bone).copied()
  216|      4|    }
  217|       |
  218|       |    /// Apply an impulse to a specific bone
  219|      1|    pub fn apply_impulse_to_bone(
  220|      1|        &self,
  221|      1|        physics: &mut PhysicsWorld,
  222|      1|        bone_name: &str,
  223|      1|        impulse: Vec3,
  224|      1|    ) -> bool {
  225|      1|        if let Some(body_id) = self.bone_bodies.get(bone_name) {
  226|      1|            physics.apply_impulse(*body_id, impulse);
  227|      1|            true
  228|       |        } else {
  229|      0|            false
  230|       |        }
  231|      1|    }
  232|       |
  233|       |    /// Apply an impulse to the ragdoll with propagation through joints
  234|       |    /// 
  235|       |    /// The impulse is applied at the specified position and propagates
  236|       |    /// through the joint chain with falloff based on distance.
  237|      2|    pub fn apply_impulse_with_propagation(
  238|      2|        &self,
  239|      2|        physics: &mut PhysicsWorld,
  240|      2|        hit_bone: &str,
  241|      2|        impulse: Vec3,
  242|      2|        propagation_factor: f32,
  243|      2|    ) {
  244|       |        // Apply full impulse to hit bone
  245|      2|        if let Some(body_id) = self.bone_bodies.get(hit_bone) {
  246|      2|            physics.apply_impulse(*body_id, impulse);
  247|      2|        }
                      ^0
  248|       |
  249|       |        // Find connected bones and apply reduced impulse
  250|      5|        if let Some(hit_def) = self.bone_defs.iter().find(|b| b.name == hit_bone) {
                                  ^2         ^2                    ^2
  251|       |            // Apply to parent (if any)
  252|      2|            if let Some(ref parent_name) = hit_def.parent {
  253|      2|                if let Some(parent_body) = self.bone_bodies.get(parent_name) {
  254|      2|                    physics.apply_impulse(*parent_body, impulse * propagation_factor);
  255|      2|                }
                              ^0
  256|      0|            }
  257|       |
  258|       |            // Apply to children
  259|     26|            for bone in &self.bone_defs {
                              ^24
  260|     24|                if bone.parent.as_ref() == Some(&hit_def.name) {
  261|      4|                    if let Some(child_body) = self.bone_bodies.get(&bone.name) {
  262|      4|                        physics.apply_impulse(*child_body, impulse * propagation_factor);
  263|      4|                    }
                                  ^0
  264|     20|                }
  265|       |            }
  266|      0|        }
  267|      2|    }
  268|       |
  269|       |    /// Get the center of mass of the ragdoll
  270|      6|    pub fn center_of_mass(&self, physics: &PhysicsWorld) -> Vec3 {
  271|      6|        let mut total_mass = 0.0f32;
  272|      6|        let mut weighted_pos = Vec3::ZERO;
  273|       |
  274|     52|        for (name, body_id) in &self.bone_bodies {
                           ^46   ^46
  275|     46|            if let Some(transform) = physics.body_transform(*body_id) {
  276|     46|                let pos = Vec3::new(transform.w_axis.x, transform.w_axis.y, transform.w_axis.z);
  277|     46|                let mass = self
  278|     46|                    .bone_defs
  279|     46|                    .iter()
  280|    266|                    .find(|b| &b.name == name)
                                   ^46
  281|     46|                    .map(|b| b.mass)
  282|     46|                    .unwrap_or(1.0);
  283|     46|                weighted_pos += pos * mass;
  284|     46|                total_mass += mass;
  285|      0|            }
  286|       |        }
  287|       |
  288|      6|        if total_mass > 0.0 {
  289|      6|            weighted_pos / total_mass
  290|       |        } else {
  291|      0|            Vec3::ZERO
  292|       |        }
  293|      6|    }
  294|       |
  295|       |    /// Check if the ragdoll is at rest (not moving significantly)
  296|      2|    pub fn is_at_rest(&self, physics: &PhysicsWorld, velocity_threshold: f32) -> bool {
  297|      2|        for body_id in self.bone_bodies.values() {
  298|      2|            if let Some(vel) = physics.get_velocity(*body_id) {
  299|      2|                if vel.length() > velocity_threshold {
  300|      0|                    return false;
  301|      2|                }
  302|      0|            }
  303|       |        }
  304|      2|        true
  305|      2|    }
  306|       |}
  307|       |
  308|       |/// Builder for creating ragdolls
  309|       |#[derive(Debug)]
  310|       |pub struct RagdollBuilder {
  311|       |    /// Configuration
  312|       |    pub config: RagdollConfig,
  313|       |    /// Bone definitions
  314|       |    bones: Vec<BoneDef>,
  315|       |    /// Next ragdoll ID
  316|       |    next_id: RagdollId,
  317|       |}
  318|       |
  319|       |impl RagdollBuilder {
  320|       |    /// Create a new ragdoll builder with the given configuration
  321|     28|    pub fn new(config: RagdollConfig) -> Self {
  322|     28|        Self {
  323|     28|            config,
  324|     28|            bones: Vec::new(),
  325|     28|            next_id: 1,
  326|     28|        }
  327|     28|    }
  328|       |
  329|       |    /// Add a bone to the ragdoll
  330|     42|    pub fn add_bone(
  331|     42|        &mut self,
  332|     42|        name: &str,
  333|     42|        parent: Option<&str>,
  334|     42|        offset: Vec3,
  335|     42|        shape: BoneShape,
  336|     42|        mass: f32,
  337|     42|    ) -> &mut Self {
  338|     42|        self.bones.push(BoneDef {
  339|     42|            name: name.to_string(),
  340|     42|            parent: parent.map(|s| s.to_string()),
                                                 ^15^15
  341|     42|            offset,
  342|     42|            shape,
  343|     42|            mass: mass * self.config.mass_scale,
  344|     42|            ..Default::default()
  345|       |        });
  346|     42|        self
  347|     42|    }
  348|       |
  349|       |    /// Add a bone with full configuration
  350|     24|    pub fn add_bone_full(&mut self, bone: BoneDef) -> &mut Self {
  351|     24|        let mut bone = bone;
  352|     24|        bone.mass *= self.config.mass_scale;
  353|     24|        self.bones.push(bone);
  354|     24|        self
  355|     24|    }
  356|       |
  357|       |    /// Add a hinge joint bone (elbow, knee)
  358|     49|    pub fn add_hinge_bone(
  359|     49|        &mut self,
  360|     49|        name: &str,
  361|     49|        parent: &str,
  362|     49|        offset: Vec3,
  363|     49|        shape: BoneShape,
  364|     49|        mass: f32,
  365|     49|        axis: Vec3,
  366|     49|        limits: Option<(f32, f32)>,
  367|     49|    ) -> &mut Self {
  368|     49|        self.bones.push(BoneDef {
  369|     49|            name: name.to_string(),
  370|     49|            parent: Some(parent.to_string()),
  371|     49|            offset,
  372|     49|            shape,
  373|     49|            mass: mass * self.config.mass_scale,
  374|     49|            joint_type: BoneJointType::Hinge { axis, limits },
  375|     49|            ..Default::default()
  376|     49|        });
  377|     49|        self
  378|     49|    }
  379|       |
  380|       |    /// Add a ball joint bone (shoulder, hip)
  381|     61|    pub fn add_ball_bone(
  382|     61|        &mut self,
  383|     61|        name: &str,
  384|     61|        parent: &str,
  385|     61|        offset: Vec3,
  386|     61|        shape: BoneShape,
  387|     61|        mass: f32,
  388|     61|        swing_limit: Option<f32>,
  389|     61|    ) -> &mut Self {
  390|     61|        self.bones.push(BoneDef {
  391|     61|            name: name.to_string(),
  392|     61|            parent: Some(parent.to_string()),
  393|     61|            offset,
  394|     61|            shape,
  395|     61|            mass: mass * self.config.mass_scale,
  396|     61|            joint_type: BoneJointType::Spherical {
  397|     61|                swing_limit,
  398|     61|                twist_limit: None,
  399|     61|            },
  400|     61|            ..Default::default()
  401|     61|        });
  402|     61|        self
  403|     61|    }
  404|       |
  405|       |    /// Build the ragdoll and spawn it in the physics world
  406|     22|    pub fn build(&mut self, physics: &mut PhysicsWorld, spawn_position: Vec3) -> Ragdoll {
  407|     22|        let mut bone_bodies = HashMap::new();
  408|     22|        let mut bone_joints = HashMap::new();
  409|     22|        let mut root_bone = String::new();
  410|       |
  411|       |        // First pass: create all bodies
  412|    195|        for bone in &self.bones {
                          ^173
  413|    173|            let bone_pos = if let Some(ref parent_name) = bone.parent {
                                                     ^151
  414|       |                // Calculate world position based on parent
  415|    151|                if let Some(&parent_body) = bone_bodies.get(parent_name) {
  416|    151|                    if let Some(transform) = physics.body_transform(parent_body) {
  417|    151|                        let parent_pos =
  418|    151|                            Vec3::new(transform.w_axis.x, transform.w_axis.y, transform.w_axis.z);
  419|    151|                        parent_pos + bone.offset
  420|       |                    } else {
  421|      0|                        spawn_position + bone.offset
  422|       |                    }
  423|       |                } else {
  424|      0|                    spawn_position + bone.offset
  425|       |                }
  426|       |            } else {
  427|       |                // Root bone
  428|     22|                root_bone = bone.name.clone();
  429|     22|                spawn_position
  430|       |            };
  431|       |
  432|       |            // Create the body based on shape
  433|    173|            let body_id = match bone.shape {
  434|    109|                BoneShape::Capsule { radius, half_height } => physics.add_dynamic_box(
  435|    109|                    bone_pos,
  436|    109|                    Vec3::new(radius, half_height, radius),
  437|    109|                    bone.mass,
  438|    109|                    self.config.collision_group,
  439|       |                ),
  440|     24|                BoneShape::Sphere { radius } => physics.add_dynamic_box(
  441|     24|                    bone_pos,
  442|     24|                    Vec3::splat(radius),
  443|     24|                    bone.mass,
  444|     24|                    self.config.collision_group,
  445|       |                ),
  446|     40|                BoneShape::Box { half_extents } => physics.add_dynamic_box(
  447|     40|                    bone_pos,
  448|     40|                    half_extents,
  449|     40|                    bone.mass,
  450|     40|                    self.config.collision_group,
  451|       |                ),
  452|       |            };
  453|       |
  454|       |            // Enable CCD if configured
  455|    173|            if self.config.enable_ccd {
  456|    173|                physics.enable_ccd(body_id);
  457|    173|            }
                          ^0
  458|       |
  459|    173|            bone_bodies.insert(bone.name.clone(), body_id);
  460|       |        }
  461|       |
  462|       |        // Second pass: create joints
  463|    195|        for bone in &self.bones {
                          ^173
  464|    173|            if let Some(ref parent_name) = bone.parent {
                                      ^151
  465|    151|                let Some(&parent_body) = bone_bodies.get(parent_name) else {
  466|      0|                    continue;
  467|       |                };
  468|    151|                let Some(&child_body) = bone_bodies.get(&bone.name) else {
  469|      0|                    continue;
  470|       |                };
  471|       |
  472|    151|                let joint_type = match bone.joint_type {
  473|      0|                    BoneJointType::Fixed => JointType::Fixed,
  474|     52|                    BoneJointType::Hinge { axis, limits } => JointType::Revolute { axis, limits },
  475|     99|                    BoneJointType::Spherical { .. } => JointType::Spherical,
  476|       |                };
  477|       |
  478|    151|                let joint_id = physics.add_joint(parent_body, child_body, joint_type);
  479|    151|                bone_joints.insert(bone.name.clone(), joint_id);
  480|     22|            }
  481|       |        }
  482|       |
  483|     22|        let id = self.next_id;
  484|     22|        self.next_id += 1;
  485|       |
  486|     22|        Ragdoll {
  487|     22|            id,
  488|     22|            state: RagdollState::Active,
  489|     22|            bone_bodies,
  490|     22|            bone_joints,
  491|     22|            root_bone,
  492|     22|            config: self.config.clone(),
  493|     22|            bone_defs: self.bones.clone(),
  494|     22|        }
  495|     22|    }
  496|       |
  497|       |    /// Clear all bones (for reuse)
  498|      1|    pub fn clear(&mut self) {
  499|      1|        self.bones.clear();
  500|      1|    }
  501|       |}
  502|       |
  503|       |/// Preset ragdoll templates
  504|       |pub struct RagdollPresets;
  505|       |
  506|       |impl RagdollPresets {
  507|       |    /// Create a simple humanoid ragdoll (10 bones)
  508|       |    /// 
  509|       |    /// Bones: pelvis, spine, chest, head, upper_arm_l/r, lower_arm_l/r, upper_leg_l/r, lower_leg_l/r
  510|     12|    pub fn humanoid(config: RagdollConfig) -> RagdollBuilder {
  511|     12|        let mut builder = RagdollBuilder::new(config);
  512|       |
  513|       |        // Torso chain
  514|     12|        builder.add_bone(
  515|     12|            "pelvis",
  516|     12|            None,
  517|       |            Vec3::ZERO,
  518|     12|            BoneShape::Box {
  519|     12|                half_extents: Vec3::new(0.15, 0.1, 0.1),
  520|     12|            },
  521|       |            4.0,
  522|       |        );
  523|       |
  524|     12|        builder.add_bone_full(BoneDef {
  525|     12|            name: "spine".to_string(),
  526|     12|            parent: Some("pelvis".to_string()),
  527|     12|            offset: Vec3::new(0.0, 0.15, 0.0),
  528|     12|            shape: BoneShape::Box {
  529|     12|                half_extents: Vec3::new(0.12, 0.12, 0.08),
  530|     12|            },
  531|     12|            mass: 3.0,
  532|     12|            joint_type: BoneJointType::Spherical {
  533|     12|                swing_limit: Some(0.3),
  534|     12|                twist_limit: Some((-0.2, 0.2)),
  535|     12|            },
  536|     12|            ..Default::default()
  537|     12|        });
  538|       |
  539|     12|        builder.add_bone_full(BoneDef {
  540|     12|            name: "chest".to_string(),
  541|     12|            parent: Some("spine".to_string()),
  542|     12|            offset: Vec3::new(0.0, 0.2, 0.0),
  543|     12|            shape: BoneShape::Box {
  544|     12|                half_extents: Vec3::new(0.14, 0.1, 0.09),
  545|     12|            },
  546|     12|            mass: 3.5,
  547|     12|            joint_type: BoneJointType::Spherical {
  548|     12|                swing_limit: Some(0.25),
  549|     12|                twist_limit: Some((-0.15, 0.15)),
  550|     12|            },
  551|     12|            ..Default::default()
  552|     12|        });
  553|       |
  554|     12|        builder.add_bone(
  555|     12|            "head",
  556|     12|            Some("chest"),
  557|     12|            Vec3::new(0.0, 0.2, 0.0),
  558|     12|            BoneShape::Sphere { radius: 0.1 },
  559|       |            1.5,
  560|       |        );
  561|       |
  562|       |        // Arms
  563|     24|        for (side, x_offset) in [("_l", -0.2), ("_r", 0.2)] {
                                               ^12           ^12
  564|     24|            let upper_arm = format!("upper_arm{}", side);
  565|     24|            let lower_arm = format!("lower_arm{}", side);
  566|     24|
  567|     24|            builder.add_ball_bone(
  568|     24|                &upper_arm,
  569|     24|                "chest",
  570|     24|                Vec3::new(x_offset, 0.05, 0.0),
  571|     24|                BoneShape::Capsule {
  572|     24|                    radius: 0.04,
  573|     24|                    half_height: 0.12,
  574|     24|                },
  575|     24|                1.2,
  576|     24|                Some(std::f32::consts::FRAC_PI_2),
  577|     24|            );
  578|     24|
  579|     24|            builder.add_hinge_bone(
  580|     24|                &lower_arm,
  581|     24|                &upper_arm,
  582|     24|                Vec3::new(0.0, -0.25, 0.0),
  583|     24|                BoneShape::Capsule {
  584|     24|                    radius: 0.035,
  585|     24|                    half_height: 0.11,
  586|     24|                },
  587|     24|                0.8,
  588|     24|                Vec3::X,
  589|     24|                Some((0.0, std::f32::consts::FRAC_PI_2 * 1.5)),
  590|     24|            );
  591|     24|        }
  592|       |
  593|       |        // Legs
  594|     24|        for (side, x_offset) in [("_l", -0.1), ("_r", 0.1)] {
                                               ^12           ^12
  595|     24|            let upper_leg = format!("upper_leg{}", side);
  596|     24|            let lower_leg = format!("lower_leg{}", side);
  597|     24|
  598|     24|            builder.add_ball_bone(
  599|     24|                &upper_leg,
  600|     24|                "pelvis",
  601|     24|                Vec3::new(x_offset, -0.15, 0.0),
  602|     24|                BoneShape::Capsule {
  603|     24|                    radius: 0.06,
  604|     24|                    half_height: 0.18,
  605|     24|                },
  606|     24|                3.0,
  607|     24|                Some(std::f32::consts::FRAC_PI_3),
  608|     24|            );
  609|     24|
  610|     24|            builder.add_hinge_bone(
  611|     24|                &lower_leg,
  612|     24|                &upper_leg,
  613|     24|                Vec3::new(0.0, -0.38, 0.0),
  614|     24|                BoneShape::Capsule {
  615|     24|                    radius: 0.05,
  616|     24|                    half_height: 0.17,
  617|     24|                },
  618|     24|                2.0,
  619|     24|                Vec3::X,
  620|     24|                Some((-std::f32::consts::FRAC_PI_2 * 1.5, 0.0)),
  621|     24|            );
  622|     24|        }
  623|       |
  624|     12|        builder
  625|     12|    }
  626|       |
  627|       |    /// Create a simple quadruped ragdoll (8 bones)
  628|       |    /// 
  629|       |    /// Bones: body, head, front_leg_l/r, back_leg_l/r
  630|      2|    pub fn quadruped(config: RagdollConfig) -> RagdollBuilder {
  631|      2|        let mut builder = RagdollBuilder::new(config);
  632|       |
  633|       |        // Body
  634|      2|        builder.add_bone(
  635|      2|            "body",
  636|      2|            None,
  637|       |            Vec3::ZERO,
  638|      2|            BoneShape::Box {
  639|      2|                half_extents: Vec3::new(0.2, 0.15, 0.4),
  640|      2|            },
  641|       |            8.0,
  642|       |        );
  643|       |
  644|       |        // Head
  645|      2|        builder.add_ball_bone(
  646|      2|            "head",
  647|      2|            "body",
  648|      2|            Vec3::new(0.0, 0.1, 0.35),
  649|      2|            BoneShape::Sphere { radius: 0.12 },
  650|       |            1.5,
  651|      2|            Some(std::f32::consts::FRAC_PI_4),
  652|       |        );
  653|       |
  654|       |        // Front legs
  655|      4|        for (side, x_offset) in [("_l", -0.15), ("_r", 0.15)] {
                                               ^2             ^2
  656|      4|            let leg_name = format!("front_leg{}", side);
  657|      4|            builder.add_ball_bone(
  658|      4|                &leg_name,
  659|      4|                "body",
  660|      4|                Vec3::new(x_offset, -0.2, 0.25),
  661|      4|                BoneShape::Capsule {
  662|      4|                    radius: 0.04,
  663|      4|                    half_height: 0.15,
  664|      4|                },
  665|      4|                1.0,
  666|      4|                Some(std::f32::consts::FRAC_PI_3),
  667|      4|            );
  668|      4|        }
  669|       |
  670|       |        // Back legs
  671|      4|        for (side, x_offset) in [("_l", -0.15), ("_r", 0.15)] {
                                               ^2             ^2
  672|      4|            let leg_name = format!("back_leg{}", side);
  673|      4|            builder.add_ball_bone(
  674|      4|                &leg_name,
  675|      4|                "body",
  676|      4|                Vec3::new(x_offset, -0.2, -0.25),
  677|      4|                BoneShape::Capsule {
  678|      4|                    radius: 0.04,
  679|      4|                    half_height: 0.15,
  680|      4|                },
  681|      4|                1.0,
  682|      4|                Some(std::f32::consts::FRAC_PI_3),
  683|      4|            );
  684|      4|        }
  685|       |
  686|       |        // Tail
  687|      2|        builder.add_ball_bone(
  688|      2|            "tail",
  689|      2|            "body",
  690|      2|            Vec3::new(0.0, 0.05, -0.45),
  691|      2|            BoneShape::Capsule {
  692|      2|                radius: 0.02,
  693|      2|                half_height: 0.15,
  694|      2|            },
  695|       |            0.3,
  696|      2|            Some(std::f32::consts::FRAC_PI_2),
  697|       |        );
  698|       |
  699|      2|        builder
  700|      2|    }
  701|       |}
  702|       |
  703|       |#[cfg(test)]
  704|       |mod tests {
  705|       |    use super::*;
  706|       |
  707|       |    #[test]
  708|      1|    fn test_bone_shape_volume() {
  709|      1|        let capsule = BoneShape::Capsule {
  710|      1|            radius: 1.0,
  711|      1|            half_height: 1.0,
  712|      1|        };
  713|      1|        assert!(capsule.volume() > 0.0);
  714|       |
  715|      1|        let sphere = BoneShape::Sphere { radius: 1.0 };
  716|      1|        let expected_sphere_vol = (4.0 / 3.0) * std::f32::consts::PI;
  717|      1|        assert!((sphere.volume() - expected_sphere_vol).abs() < 0.001);
  718|       |
  719|      1|        let box_shape = BoneShape::Box {
  720|      1|            half_extents: Vec3::ONE,
  721|      1|        };
  722|      1|        assert!((box_shape.volume() - 8.0).abs() < 0.001);
  723|      1|    }
  724|       |
  725|       |    #[test]
  726|      1|    fn test_ragdoll_builder_creation() {
  727|      1|        let config = RagdollConfig::default();
  728|      1|        let builder = RagdollBuilder::new(config);
  729|      1|        assert_eq!(builder.bones.len(), 0);
  730|      1|    }
  731|       |
  732|       |    #[test]
  733|      1|    fn test_ragdoll_builder_add_bones() {
  734|      1|        let mut builder = RagdollBuilder::new(RagdollConfig::default());
  735|       |
  736|      1|        builder.add_bone(
  737|      1|            "root",
  738|      1|            None,
  739|       |            Vec3::ZERO,
  740|      1|            BoneShape::Box {
  741|      1|                half_extents: Vec3::splat(0.1),
  742|      1|            },
  743|       |            1.0,
  744|       |        );
  745|       |
  746|      1|        builder.add_bone(
  747|      1|            "child",
  748|      1|            Some("root"),
  749|      1|            Vec3::new(0.0, 0.5, 0.0),
  750|      1|            BoneShape::Sphere { radius: 0.1 },
  751|       |            0.5,
  752|       |        );
  753|       |
  754|      1|        assert_eq!(builder.bones.len(), 2);
  755|      1|        assert_eq!(builder.bones[0].name, "root");
  756|      1|        assert!(builder.bones[0].parent.is_none());
  757|      1|        assert_eq!(builder.bones[1].name, "child");
  758|      1|        assert_eq!(builder.bones[1].parent, Some("root".to_string()));
  759|      1|    }
  760|       |
  761|       |    #[test]
  762|      1|    fn test_ragdoll_config_defaults() {
  763|      1|        let config = RagdollConfig::default();
  764|      1|        assert!((config.mass_scale - 1.0).abs() < 0.001);
  765|      1|        assert!(config.enable_ccd);
  766|      1|        assert!(config.max_angular_velocity > 0.0);
  767|      1|    }
  768|       |
  769|       |    #[test]
  770|      1|    fn test_ragdoll_state_enum() {
  771|      1|        assert_eq!(RagdollState::Active, RagdollState::Active);
  772|      1|        assert_ne!(RagdollState::Active, RagdollState::Disabled);
  773|       |
  774|      1|        let blending = RagdollState::BlendingToPhysics { progress_percent: 50 };
  775|      1|        match blending {
  776|      1|            RagdollState::BlendingToPhysics { progress_percent } => {
  777|      1|                assert_eq!(progress_percent, 50);
  778|       |            }
  779|      0|            _ => panic!("Wrong state"),
  780|       |        }
  781|      1|    }
  782|       |
  783|       |    #[test]
  784|      1|    fn test_humanoid_preset() {
  785|      1|        let builder = RagdollPresets::humanoid(RagdollConfig::default());
  786|       |        // Humanoid should have: pelvis, spine, chest, head, 
  787|       |        // upper_arm_l, upper_arm_r, lower_arm_l, lower_arm_r,
  788|       |        // upper_leg_l, upper_leg_r, lower_leg_l, lower_leg_r
  789|      1|        assert_eq!(builder.bones.len(), 12);
  790|      1|    }
  791|       |
  792|       |    #[test]
  793|      1|    fn test_quadruped_preset() {
  794|      1|        let builder = RagdollPresets::quadruped(RagdollConfig::default());
  795|       |        // Quadruped should have: body, head, 4 legs, tail
  796|      1|        assert_eq!(builder.bones.len(), 7);
  797|      1|    }
  798|       |
  799|       |    #[test]
  800|      1|    fn test_add_hinge_bone() {
  801|      1|        let mut builder = RagdollBuilder::new(RagdollConfig::default());
  802|       |
  803|      1|        builder.add_bone("parent", None, Vec3::ZERO, BoneShape::Sphere { radius: 0.1 }, 1.0);
  804|      1|        builder.add_hinge_bone(
  805|      1|            "child",
  806|      1|            "parent",
  807|       |            Vec3::Y,
  808|      1|            BoneShape::Capsule { radius: 0.05, half_height: 0.1 },
  809|       |            0.5,
  810|       |            Vec3::X,
  811|      1|            Some((0.0, std::f32::consts::PI)),
  812|       |        );
  813|       |
  814|      1|        assert_eq!(builder.bones.len(), 2);
  815|      1|        match builder.bones[1].joint_type {
  816|      1|            BoneJointType::Hinge { axis, limits } => {
  817|      1|                assert!((axis.x - 1.0).abs() < 0.001);
  818|      1|                assert!(limits.is_some());
  819|       |            }
  820|      0|            _ => panic!("Expected Hinge joint"),
  821|       |        }
  822|      1|    }
  823|       |
  824|       |    #[test]
  825|      1|    fn test_add_ball_bone() {
  826|      1|        let mut builder = RagdollBuilder::new(RagdollConfig::default());
  827|       |
  828|      1|        builder.add_bone("parent", None, Vec3::ZERO, BoneShape::Sphere { radius: 0.1 }, 1.0);
  829|      1|        builder.add_ball_bone(
  830|      1|            "child",
  831|      1|            "parent",
  832|       |            Vec3::Y,
  833|      1|            BoneShape::Sphere { radius: 0.08 },
  834|       |            0.5,
  835|      1|            Some(std::f32::consts::FRAC_PI_4),
  836|       |        );
  837|       |
  838|      1|        assert_eq!(builder.bones.len(), 2);
  839|      1|        match builder.bones[1].joint_type {
  840|      1|            BoneJointType::Spherical { swing_limit, .. } => {
  841|      1|                assert!(swing_limit.is_some());
  842|       |            }
  843|      0|            _ => panic!("Expected Spherical joint"),
  844|       |        }
  845|      1|    }
  846|       |
  847|       |    #[test]
  848|      1|    fn test_builder_clear() {
  849|      1|        let mut builder = RagdollBuilder::new(RagdollConfig::default());
  850|      1|        builder.add_bone("test", None, Vec3::ZERO, BoneShape::Sphere { radius: 0.1 }, 1.0);
  851|      1|        assert_eq!(builder.bones.len(), 1);
  852|       |
  853|      1|        builder.clear();
  854|      1|        assert_eq!(builder.bones.len(), 0);
  855|      1|    }
  856|       |
  857|       |    #[test]
  858|      1|    fn test_mass_scale() {
  859|      1|        let config = RagdollConfig {
  860|      1|            mass_scale: 2.0,
  861|      1|            ..Default::default()
  862|      1|        };
  863|      1|        let mut builder = RagdollBuilder::new(config);
  864|       |
  865|      1|        builder.add_bone("test", None, Vec3::ZERO, BoneShape::Sphere { radius: 0.1 }, 5.0);
  866|       |
  867|       |        // Mass should be scaled
  868|      1|        assert!((builder.bones[0].mass - 10.0).abs() < 0.001);
  869|      1|    }
  870|       |
  871|       |    #[test]
  872|      1|    fn test_ragdoll_build_simple() {
  873|      1|        let mut physics = PhysicsWorld::new(Vec3::new(0.0, -9.81, 0.0));
  874|      1|        let mut builder = RagdollBuilder::new(RagdollConfig::default());
  875|       |
  876|      1|        builder.add_bone(
  877|      1|            "root",
  878|      1|            None,
  879|       |            Vec3::ZERO,
  880|      1|            BoneShape::Sphere { radius: 0.2 },
  881|       |            2.0,
  882|       |        );
  883|      1|        builder.add_bone(
  884|      1|            "child",
  885|      1|            Some("root"),
  886|      1|            Vec3::new(0.0, 0.5, 0.0),
  887|      1|            BoneShape::Sphere { radius: 0.15 },
  888|       |            1.0,
  889|       |        );
  890|       |
  891|      1|        let ragdoll = builder.build(&mut physics, Vec3::new(0.0, 5.0, 0.0));
  892|       |
  893|      1|        assert_eq!(ragdoll.bone_bodies.len(), 2);
  894|      1|        assert_eq!(ragdoll.bone_joints.len(), 1); // Only child has joint
  895|      1|        assert_eq!(ragdoll.root_bone, "root");
  896|      1|        assert_eq!(ragdoll.state, RagdollState::Active);
  897|      1|    }
  898|       |
  899|       |    #[test]
  900|      1|    fn test_ragdoll_humanoid_build() {
  901|      1|        let mut physics = PhysicsWorld::new(Vec3::new(0.0, -9.81, 0.0));
  902|      1|        let mut builder = RagdollPresets::humanoid(RagdollConfig::default());
  903|       |
  904|      1|        let ragdoll = builder.build(&mut physics, Vec3::new(0.0, 2.0, 0.0));
  905|       |
  906|      1|        assert_eq!(ragdoll.bone_bodies.len(), 12);
  907|      1|        assert_eq!(ragdoll.bone_joints.len(), 11); // All except root
  908|      1|        assert_eq!(ragdoll.root_bone, "pelvis");
  909|      1|    }
  910|       |
  911|       |    #[test]
  912|      1|    fn test_ragdoll_get_bone_body() {
  913|      1|        let mut physics = PhysicsWorld::new(Vec3::new(0.0, -9.81, 0.0));
  914|      1|        let mut builder = RagdollPresets::humanoid(RagdollConfig::default());
  915|      1|        let ragdoll = builder.build(&mut physics, Vec3::ZERO);
  916|       |
  917|      1|        assert!(ragdoll.get_bone_body("pelvis").is_some());
  918|      1|        assert!(ragdoll.get_bone_body("head").is_some());
  919|      1|        assert!(ragdoll.get_bone_body("nonexistent").is_none());
  920|      1|    }
  921|       |
  922|       |    #[test]
  923|      1|    fn test_ragdoll_root_body() {
  924|      1|        let mut physics = PhysicsWorld::new(Vec3::new(0.0, -9.81, 0.0));
  925|      1|        let mut builder = RagdollPresets::humanoid(RagdollConfig::default());
  926|      1|        let ragdoll = builder.build(&mut physics, Vec3::ZERO);
  927|       |
  928|      1|        let root = ragdoll.root_body();
  929|      1|        assert!(root.is_some());
  930|      1|        assert_eq!(root, ragdoll.get_bone_body("pelvis"));
  931|      1|    }
  932|       |
  933|       |    #[test]
  934|      1|    fn test_ragdoll_all_bodies() {
  935|      1|        let mut physics = PhysicsWorld::new(Vec3::new(0.0, -9.81, 0.0));
  936|      1|        let mut builder = RagdollPresets::humanoid(RagdollConfig::default());
  937|      1|        let ragdoll = builder.build(&mut physics, Vec3::ZERO);
  938|       |
  939|      1|        let bodies: Vec<_> = ragdoll.all_bodies().collect();
  940|      1|        assert_eq!(bodies.len(), 12);
  941|      1|    }
  942|       |
  943|       |    #[test]
  944|      1|    fn test_ragdoll_center_of_mass() {
  945|      1|        let mut physics = PhysicsWorld::new(Vec3::new(0.0, -9.81, 0.0));
  946|      1|        let mut builder = RagdollBuilder::new(RagdollConfig::default());
  947|       |
  948|      1|        builder.add_bone("root", None, Vec3::ZERO, BoneShape::Sphere { radius: 0.2 }, 1.0);
  949|       |
  950|      1|        let ragdoll = builder.build(&mut physics, Vec3::new(0.0, 5.0, 0.0));
  951|      1|        let com = ragdoll.center_of_mass(&physics);
  952|       |
  953|       |        // Should be near spawn position
  954|      1|        assert!((com.y - 5.0).abs() < 1.0);
  955|      1|    }
  956|       |
  957|       |    #[test]
  958|      1|    fn test_ragdoll_is_at_rest() {
  959|      1|        let mut physics = PhysicsWorld::new(Vec3::new(0.0, -9.81, 0.0));
  960|      1|        let mut builder = RagdollBuilder::new(RagdollConfig::default());
  961|       |
  962|      1|        builder.add_bone("root", None, Vec3::ZERO, BoneShape::Sphere { radius: 0.2 }, 1.0);
  963|       |
  964|      1|        let ragdoll = builder.build(&mut physics, Vec3::new(0.0, 5.0, 0.0));
  965|       |
  966|       |        // Initially should be at rest (no steps taken)
  967|      1|        let at_rest = ragdoll.is_at_rest(&physics, 0.1);
  968|      1|        assert!(at_rest);
  969|      1|    }
  970|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-physics\src\spatial_hash.rs:
    1|       |/*!
    2|       |# Spatial Hash Grid for Broad-Phase Collision Detection
    3|       |
    4|       |Implements a grid-based spatial partitioning system to reduce collision detection
    5|       |from O(n²) to O(n log n) by only testing objects in nearby grid cells.
    6|       |
    7|       |## Performance
    8|       |
    9|       |**Baseline (Naive O(n²))**:
   10|       |- 1000 entities: ~500,000 collision pairs to test
   11|       |- Frame time: 548.5 µs (17.71% of frame)
   12|       |
   13|       |**With Spatial Hashing**:
   14|       |- 1000 entities: ~5,000-10,000 collision pairs (99% reduction)
   15|       |- Expected frame time: 250-330 µs (8-10% of frame)
   16|       |- **Improvement**: -40-55% collision detection time
   17|       |
   18|       |## Usage
   19|       |
   20|       |```rust
   21|       |use astraweave_physics::{SpatialHash, AABB};
   22|       |use glam::Vec3;
   23|       |
   24|       |// Create grid with 10-unit cells (adjust based on object sizes)
   25|       |let mut grid = SpatialHash::<u32>::new(10.0);
   26|       |
   27|       |// Insert objects
   28|       |let objects = vec![(1, AABB::from_sphere(Vec3::ZERO, 1.0))];
   29|       |for (id, aabb) in objects {
   30|       |    grid.insert(id, aabb);
   31|       |}
   32|       |
   33|       |// Query potential collisions for an object
   34|       |let aabb = AABB::from_sphere(Vec3::ZERO, 1.0);
   35|       |let candidates = grid.query(aabb);
   36|       |
   37|       |// Only test narrow-phase collision against candidates (not all objects)
   38|       |for candidate_id in candidates {
   39|       |    let candidate_aabb = AABB::from_sphere(Vec3::ZERO, 1.0); // Mock
   40|       |    if aabb.intersects(&candidate_aabb) {
   41|       |        // Handle collision
   42|       |    }
   43|       |}
   44|       |
   45|       |// Clear grid before next frame
   46|       |grid.clear();
   47|       |```
   48|       |
   49|       |## Cell Size Selection
   50|       |
   51|       |**Rule of Thumb**: Cell size should be ~2× the average object size
   52|       |
   53|       |- Too small: Objects span multiple cells, redundant queries
   54|       |- Too large: Too many objects per cell, approaches O(n²)
   55|       |- Optimal: Each object touches 1-4 cells
   56|       |
   57|       |**Example**:
   58|       |- Character radius: 1 unit → Cell size: 2-4 units
   59|       |- Small objects (0.5 radius) → Cell size: 1-2 units
   60|       |- Large objects (5 radius) → Cell size: 10-20 units
   61|       |*/
   62|       |
   63|       |use glam::Vec3;
   64|       |
   65|       |/// Axis-Aligned Bounding Box for collision detection
   66|       |#[derive(Debug, Clone, Copy)]
   67|       |pub struct AABB {
   68|       |    pub min: Vec3,
   69|       |    pub max: Vec3,
   70|       |}
   71|       |
   72|       |impl AABB {
   73|       |    /// Create AABB from center and half-extents
   74|    164|    pub fn from_center_extents(center: Vec3, half_extents: Vec3) -> Self {
   75|    164|        Self {
   76|    164|            min: center - half_extents,
   77|    164|            max: center + half_extents,
   78|    164|        }
   79|    164|    }
   80|       |
   81|       |    /// Create AABB from center and radius (sphere approximation)
   82|     58|    pub fn from_sphere(center: Vec3, radius: f32) -> Self {
   83|     58|        let half_extents = Vec3::splat(radius);
   84|     58|        Self::from_center_extents(center, half_extents)
   85|     58|    }
   86|       |
   87|       |    /// Check if two AABBs intersect
   88|     12|    pub fn intersects(&self, other: &AABB) -> bool {
   89|     12|        self.min.x <= other.max.x
   90|     12|            && self.max.x >= other.min.x
   91|      9|            && self.min.y <= other.max.y
   92|      9|            && self.max.y >= other.min.y
   93|      9|            && self.min.z <= other.max.z
   94|      9|            && self.max.z >= other.min.z
   95|     12|    }
   96|       |
   97|       |    /// Get center point of AABB
   98|      2|    pub fn center(&self) -> Vec3 {
   99|      2|        (self.min + self.max) * 0.5
  100|      2|    }
  101|       |
  102|       |    /// Get half-extents of AABB
  103|      1|    pub fn half_extents(&self) -> Vec3 {
  104|      1|        (self.max - self.min) * 0.5
  105|      1|    }
  106|       |}
  107|       |
  108|       |/// Grid cell coordinates (3D integer grid)
  109|       |type GridCell = (i32, i32, i32);
  110|       |
  111|       |/// Spatial hash grid for broad-phase collision detection
  112|       |///
  113|       |/// Uses a uniform grid to partition 3D space. Objects are inserted into grid cells
  114|       |/// based on their AABB. Queries return only objects in nearby cells, dramatically
  115|       |/// reducing the number of collision pairs to test.
  116|       |///
  117|       |/// **Phase B Optimization (Action 27)**: Uses FxHashMap for faster hashing.
  118|       |/// Week 9 testing confirmed FxHashMap provides better performance than SipHash
  119|       |/// for spatial grids (3.77ms vs 5.61ms with Tracy, 3.82ms without Tracy).
  120|       |#[derive(Debug)]
  121|       |pub struct SpatialHash<T> {
  122|       |    /// Grid cell size (world units)
  123|       |    cell_size: f32,
  124|       |
  125|       |    /// Inverse cell size (for faster division-free grid coordinate calculation)
  126|       |    inv_cell_size: f32,
  127|       |
  128|       |    /// Grid storage: (x, y, z) → [object IDs]
  129|       |    /// Uses FxHashMap for faster non-cryptographic hashing
  130|       |    grid: rustc_hash::FxHashMap<GridCell, Vec<T>>,
  131|       |
  132|       |    /// Total objects currently in grid
  133|       |    object_count: usize,
  134|       |}
  135|       |
  136|       |impl<T: Copy + Eq + Ord> SpatialHash<T> {
  137|       |    /// Create new spatial hash with specified cell size
  138|       |    ///
  139|       |    /// # Arguments
  140|       |    /// * `cell_size` - Grid cell size in world units (recommended: 2× average object size)
  141|       |    ///
  142|       |    /// # Example
  143|       |    /// ```
  144|       |    /// use astraweave_physics::SpatialHash;
  145|       |    /// let grid = SpatialHash::<u32>::new(10.0); // 10-unit cells
  146|       |    /// ```
  147|     23|    pub fn new(cell_size: f32) -> Self {
  148|     23|        assert!(cell_size > 0.0, "Cell size must be positive");
                                               ^1
  149|       |
  150|     22|        Self {
  151|     22|            cell_size,
  152|     22|            inv_cell_size: 1.0 / cell_size,
  153|     22|            grid: rustc_hash::FxHashMap::default(),
  154|     22|            object_count: 0,
  155|     22|        }
  156|     22|    }
  157|       |
  158|       |    /// Convert world position to grid cell coordinates
  159|       |    #[inline]
  160|    309|    fn world_to_cell(&self, pos: Vec3) -> GridCell {
  161|    309|        (
  162|    309|            (pos.x * self.inv_cell_size).floor() as i32,
  163|    309|            (pos.y * self.inv_cell_size).floor() as i32,
  164|    309|            (pos.z * self.inv_cell_size).floor() as i32,
  165|    309|        )
  166|    309|    }
  167|       |
  168|       |    /// Get all grid cells that an AABB overlaps
  169|    153|    fn get_overlapping_cells(&self, aabb: &AABB) -> Vec<GridCell> {
  170|    153|        let min_cell = self.world_to_cell(aabb.min);
  171|    153|        let max_cell = self.world_to_cell(aabb.max);
  172|       |
  173|    153|        let mut cells = Vec::new();
  174|       |
  175|       |        // Iterate over all cells that the AABB spans
  176|    171|        for x in min_cell.0..=max_cell.0 {
                               ^153         ^153
  177|    226|            for y in min_cell.1..=max_cell.1 {
                                   ^171         ^171
  178|    344|                for z in min_cell.2..=max_cell.2 {
                                       ^226         ^226
  179|    344|                    cells.push((x, y, z));
  180|    344|                }
  181|       |            }
  182|       |        }
  183|       |
  184|    153|        cells
  185|    153|    }
  186|       |
  187|       |    /// Insert object into grid based on its AABB
  188|       |    ///
  189|       |    /// Objects that span multiple cells are inserted into all overlapping cells.
  190|       |    ///
  191|       |    /// # Arguments
  192|       |    /// * `id` - Object identifier
  193|       |    /// * `aabb` - Object's axis-aligned bounding box
  194|       |    ///
  195|       |    /// # Example
  196|       |    /// ```
  197|       |    /// use astraweave_physics::{SpatialHash, AABB};
  198|       |    /// use glam::Vec3;
  199|       |    /// let mut grid = SpatialHash::<u32>::new(10.0);
  200|       |    /// let entity_id = 1;
  201|       |    /// let aabb = AABB::from_sphere(Vec3::new(5.0, 0.0, 5.0), 1.0);
  202|       |    /// grid.insert(entity_id, aabb);
  203|       |    /// ```
  204|    140|    pub fn insert(&mut self, id: T, aabb: AABB) {
  205|    140|        let cells = self.get_overlapping_cells(&aabb);
  206|       |
  207|    398|        for cell in cells {
                          ^258
  208|    258|            self.grid.entry(cell).or_default().push(id);
  209|    258|        }
  210|       |
  211|    140|        self.object_count += 1;
  212|    140|    }
  213|       |
  214|       |    /// Query potential collision candidates for an AABB
  215|       |    ///
  216|       |    /// Returns all objects in grid cells that overlap the query AABB.
  217|       |    /// Duplicates are possible if objects span multiple cells.
  218|       |    ///
  219|       |    /// # Arguments
  220|       |    /// * `aabb` - Query bounding box
  221|       |    ///
  222|       |    /// # Returns
  223|       |    /// Vec of object IDs that *might* collide (candidates for narrow-phase testing)
  224|       |    ///
  225|       |    /// # Example
  226|       |    /// ```
  227|       |    /// use astraweave_physics::{SpatialHash, AABB};
  228|       |    /// use glam::Vec3;
  229|       |    /// let mut grid = SpatialHash::<u32>::new(10.0);
  230|       |    /// let pos = Vec3::ZERO;
  231|       |    /// let radius = 1.0;
  232|       |    /// let query_aabb = AABB::from_sphere(pos, radius);
  233|       |    /// let candidates = grid.query(query_aabb);
  234|       |    ///
  235|       |    /// for &candidate_id in &candidates {
  236|       |    ///     // Perform detailed collision test with candidate
  237|       |    /// }
  238|       |    /// ```
  239|     13|    pub fn query(&self, aabb: AABB) -> Vec<T> {
  240|     13|        let cells = self.get_overlapping_cells(&aabb);
  241|     13|        let mut results = Vec::new();
  242|       |
  243|     99|        for cell in cells {
                          ^86
  244|     86|            if let Some(objects) = self.grid.get(&cell) {
                                      ^33
  245|     33|                results.extend_from_slice(objects);
  246|     53|            }
  247|       |        }
  248|       |
  249|     13|        results
  250|     13|    }
  251|       |
  252|       |    /// Query unique collision candidates (removes duplicates)
  253|       |    ///
  254|       |    /// Same as `query()` but deduplicates results. Slightly slower due to sorting,
  255|       |    /// but useful when duplicate checks are expensive.
  256|      2|    pub fn query_unique(&self, aabb: AABB) -> Vec<T> {
  257|      2|        let mut results = self.query(aabb);
  258|      2|        results.sort_unstable();
  259|      2|        results.dedup();
  260|      2|        results
  261|      2|    }
  262|       |
  263|       |    /// Clear all objects from grid
  264|       |    ///
  265|       |    /// Call this before rebuilding grid each frame (dynamic objects).
  266|      3|    pub fn clear(&mut self) {
  267|      3|        self.grid.clear();
  268|      3|        self.object_count = 0;
  269|      3|    }
  270|       |
  271|       |    /// Get number of objects in grid
  272|     10|    pub fn object_count(&self) -> usize {
  273|     10|        self.object_count
  274|     10|    }
  275|       |
  276|       |    /// Get number of occupied grid cells
  277|      9|    pub fn cell_count(&self) -> usize {
  278|      9|        self.grid.len()
  279|      9|    }
  280|       |
  281|       |    /// Get grid cell size
  282|      1|    pub fn cell_size(&self) -> f32 {
  283|      1|        self.cell_size
  284|      1|    }
  285|       |
  286|       |    /// Get average objects per cell (density metric)
  287|      1|    pub fn average_cell_density(&self) -> f32 {
  288|      1|        if self.grid.is_empty() {
  289|      0|            0.0
  290|       |        } else {
  291|      1|            self.object_count as f32 / self.grid.len() as f32
  292|       |        }
  293|      1|    }
  294|       |
  295|       |    /// Debug: Get grid statistics
  296|      2|    pub fn stats(&self) -> SpatialHashStats {
  297|      2|        let mut max_objects_per_cell = 0;
  298|      2|        let mut total_objects_in_cells = 0;
  299|       |
  300|      4|        for objects in self.grid.values() {
                                     ^2        ^2
  301|      4|            max_objects_per_cell = max_objects_per_cell.max(objects.len());
  302|      4|            total_objects_in_cells += objects.len();
  303|      4|        }
  304|       |
  305|       |        SpatialHashStats {
  306|      2|            object_count: self.object_count,
  307|      2|            cell_count: self.grid.len(),
  308|      2|            max_objects_per_cell,
  309|      2|            average_objects_per_cell: if self.grid.is_empty() {
  310|      0|                0.0
  311|       |            } else {
  312|      2|                total_objects_in_cells as f32 / self.grid.len() as f32
  313|       |            },
  314|      2|            cell_size: self.cell_size,
  315|       |        }
  316|      2|    }
  317|       |}
  318|       |
  319|       |/// Spatial hash statistics for debugging/profiling
  320|       |#[derive(Debug, Clone)]
  321|       |pub struct SpatialHashStats {
  322|       |    pub object_count: usize,
  323|       |    pub cell_count: usize,
  324|       |    pub max_objects_per_cell: usize,
  325|       |    pub average_objects_per_cell: f32,
  326|       |    pub cell_size: f32,
  327|       |}
  328|       |
  329|       |#[cfg(test)]
  330|       |mod tests {
  331|       |    use super::*;
  332|       |
  333|       |    #[test]
  334|      1|    fn test_aabb_intersection() {
  335|      1|        let aabb1 = AABB::from_sphere(Vec3::ZERO, 1.0);
  336|      1|        let aabb2 = AABB::from_sphere(Vec3::new(1.5, 0.0, 0.0), 1.0);
  337|      1|        let aabb3 = AABB::from_sphere(Vec3::new(5.0, 0.0, 0.0), 1.0);
  338|       |
  339|      1|        assert!(aabb1.intersects(&aabb2), "Adjacent AABBs should intersect");
                                                        ^0
  340|      1|        assert!(
  341|      1|            !aabb1.intersects(&aabb3),
  342|      0|            "Distant AABBs should not intersect"
  343|       |        );
  344|      1|    }
  345|       |
  346|       |    #[test]
  347|      1|    fn test_spatial_hash_insertion() {
  348|      1|        let mut grid = SpatialHash::<u32>::new(10.0);
  349|       |
  350|      1|        let aabb = AABB::from_sphere(Vec3::new(5.0, 0.0, 5.0), 1.0);
  351|      1|        grid.insert(1, aabb);
  352|       |
  353|      1|        assert_eq!(grid.object_count(), 1);
  354|      1|        assert!(grid.cell_count() > 0);
  355|      1|    }
  356|       |
  357|       |    #[test]
  358|      1|    fn test_spatial_hash_query() {
  359|      1|        let mut grid = SpatialHash::<u32>::new(10.0);
  360|       |
  361|       |        // Insert objects in different cells
  362|      1|        grid.insert(1, AABB::from_sphere(Vec3::new(5.0, 0.0, 5.0), 1.0));
  363|      1|        grid.insert(2, AABB::from_sphere(Vec3::new(15.0, 0.0, 5.0), 1.0));
  364|      1|        grid.insert(3, AABB::from_sphere(Vec3::new(25.0, 0.0, 5.0), 1.0));
  365|       |
  366|       |        // Query near object 1
  367|      1|        let results = grid.query(AABB::from_sphere(Vec3::new(5.0, 0.0, 5.0), 1.0));
  368|       |
  369|       |        // Should find object 1, but not objects 2 or 3 (in different cells)
  370|      1|        assert!(results.contains(&1));
  371|       |        // Note: Might find 2 if cells are adjacent, but definitely not 3
  372|      1|    }
  373|       |
  374|       |    #[test]
  375|      1|    fn test_spatial_hash_clear() {
  376|      1|        let mut grid = SpatialHash::<u32>::new(10.0);
  377|       |
  378|      1|        grid.insert(1, AABB::from_sphere(Vec3::ZERO, 1.0));
  379|      1|        assert_eq!(grid.object_count(), 1);
  380|       |
  381|      1|        grid.clear();
  382|      1|        assert_eq!(grid.object_count(), 0);
  383|      1|        assert_eq!(grid.cell_count(), 0);
  384|      1|    }
  385|       |
  386|       |    #[test]
  387|      1|    fn test_multi_cell_spanning() {
  388|      1|        let mut grid = SpatialHash::<u32>::new(10.0);
  389|       |
  390|       |        // Large AABB spanning multiple cells
  391|      1|        let large_aabb = AABB {
  392|      1|            min: Vec3::new(0.0, 0.0, 0.0),
  393|      1|            max: Vec3::new(25.0, 25.0, 25.0),
  394|      1|        };
  395|       |
  396|      1|        grid.insert(1, large_aabb);
  397|       |
  398|       |        // Object should be in multiple cells (3×3×3 = 27 cells)
  399|      1|        assert!(
  400|      1|            grid.cell_count() >= 27,
  401|      0|            "Large object should span multiple cells"
  402|       |        );
  403|      1|    }
  404|       |
  405|       |    #[test]
  406|      1|    fn test_query_unique_deduplication() {
  407|      1|        let mut grid = SpatialHash::<u32>::new(10.0);
  408|       |
  409|       |        // Insert object spanning multiple cells
  410|      1|        let large_aabb = AABB {
  411|      1|            min: Vec3::new(0.0, 0.0, 0.0),
  412|      1|            max: Vec3::new(15.0, 0.0, 0.0),
  413|      1|        };
  414|       |
  415|      1|        grid.insert(1, large_aabb);
  416|       |
  417|       |        // Query overlapping multiple cells
  418|      1|        let query_aabb = AABB {
  419|      1|            min: Vec3::new(0.0, 0.0, 0.0),
  420|      1|            max: Vec3::new(15.0, 0.0, 0.0),
  421|      1|        };
  422|       |
  423|      1|        let results = grid.query(query_aabb);
  424|      1|        let unique_results = grid.query_unique(query_aabb);
  425|       |
  426|       |        // query() may return duplicates, query_unique() should not
  427|      1|        assert!(unique_results.len() <= results.len());
  428|      1|        assert_eq!(unique_results.len(), 1, "Should find object 1 exactly once");
                                                          ^0
  429|      1|    }
  430|       |
  431|       |    #[test]
  432|      1|    fn test_cell_size_calculation() {
  433|      1|        let grid = SpatialHash::<u32>::new(5.0);
  434|       |
  435|      1|        let cell1 = grid.world_to_cell(Vec3::new(0.0, 0.0, 0.0));
  436|      1|        let cell2 = grid.world_to_cell(Vec3::new(4.9, 0.0, 0.0));
  437|      1|        let cell3 = grid.world_to_cell(Vec3::new(5.1, 0.0, 0.0));
  438|       |
  439|      1|        assert_eq!(
  440|       |            cell1, cell2,
  441|      0|            "Points in same cell should have same cell coords"
  442|       |        );
  443|      1|        assert_ne!(cell1, cell3, "Points in different cells should differ");
                                               ^0
  444|      1|    }
  445|       |
  446|       |    #[test]
  447|      1|    fn test_stats() {
  448|      1|        let mut grid = SpatialHash::<u32>::new(10.0);
  449|       |
  450|       |        // Insert 3 objects in same cell
  451|      4|        for i in 0..3 {
                          ^3
  452|      3|            grid.insert(i, AABB::from_sphere(Vec3::new(5.0, 0.0, 5.0), 0.5));
  453|      3|        }
  454|       |
  455|      1|        let stats = grid.stats();
  456|      1|        assert_eq!(stats.object_count, 3);
  457|      1|        assert!(stats.average_objects_per_cell >= 3.0);
  458|      1|    }
  459|       |}

C:\Users\pv2br\AstraWeave-AI-Native-Gaming-Engine\astraweave-physics\src\vehicle.rs:
    1|       |//! # Vehicle Physics System
    2|       |//!
    3|       |//! Provides realistic vehicle simulation including:
    4|       |//! - Raycast suspension (industry-standard approach)
    5|       |//! - Friction curves (Pacejka-inspired slip model)
    6|       |//! - Engine and transmission simulation
    7|       |//! - Steering mechanics
    8|       |//!
    9|       |//! ## Features
   10|       |//!
   11|       |//! - **Wheeled Vehicles**: Cars, trucks, motorcycles
   12|       |//! - **Suspension**: Spring-damper raycast system
   13|       |//! - **Friction**: Slip ratio and slip angle curves
   14|       |//! - **Drivetrain**: Engine torque, gear ratios, differential
   15|       |//!
   16|       |//! ## Usage
   17|       |//!
   18|       |//! ```rust
   19|       |//! use astraweave_physics::vehicle::{VehicleConfig, Vehicle, WheelConfig};
   20|       |//! use glam::Vec3;
   21|       |//!
   22|       |//! let config = VehicleConfig {
   23|       |//!     mass: 1500.0,
   24|       |//!     wheels: vec![
   25|       |//!         WheelConfig::front_left(Vec3::new(-0.8, 0.0, 1.2)),
   26|       |//!         WheelConfig::front_right(Vec3::new(0.8, 0.0, 1.2)),
   27|       |//!         WheelConfig::rear_left(Vec3::new(-0.8, 0.0, -1.2)),
   28|       |//!         WheelConfig::rear_right(Vec3::new(0.8, 0.0, -1.2)),
   29|       |//!     ],
   30|       |//!     ..Default::default()
   31|       |//! };
   32|       |//! ```
   33|       |
   34|       |use crate::{BodyId, PhysicsWorld};
   35|       |use glam::{Quat, Vec3};
   36|       |
   37|       |/// Unique identifier for a vehicle
   38|       |pub type VehicleId = u64;
   39|       |
   40|       |/// Wheel position preset
   41|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
   42|       |pub enum WheelPosition {
   43|       |    FrontLeft,
   44|       |    FrontRight,
   45|       |    RearLeft,
   46|       |    RearRight,
   47|       |    /// Custom position (e.g., for 6-wheeled trucks)
   48|       |    Custom(u8),
   49|       |}
   50|       |
   51|       |/// Configuration for a single wheel
   52|       |#[derive(Debug, Clone)]
   53|       |pub struct WheelConfig {
   54|       |    /// Position relative to vehicle center of mass
   55|       |    pub position: Vec3,
   56|       |    /// Wheel radius
   57|       |    pub radius: f32,
   58|       |    /// Wheel width (for friction calculation)
   59|       |    pub width: f32,
   60|       |    /// Whether this wheel can steer
   61|       |    pub steerable: bool,
   62|       |    /// Whether this wheel is driven (receives engine power)
   63|       |    pub driven: bool,
   64|       |    /// Suspension rest length
   65|       |    pub suspension_rest_length: f32,
   66|       |    /// Suspension spring stiffness (N/m)
   67|       |    pub suspension_stiffness: f32,
   68|       |    /// Suspension damping coefficient
   69|       |    pub suspension_damping: f32,
   70|       |    /// Maximum suspension compression
   71|       |    pub suspension_max_compression: f32,
   72|       |    /// Maximum suspension extension
   73|       |    pub suspension_max_extension: f32,
   74|       |    /// Wheel position identifier
   75|       |    pub position_id: WheelPosition,
   76|       |}
   77|       |
   78|       |impl Default for WheelConfig {
   79|    201|    fn default() -> Self {
   80|    201|        Self {
   81|    201|            position: Vec3::ZERO,
   82|    201|            radius: 0.35,
   83|    201|            width: 0.25,
   84|    201|            steerable: false,
   85|    201|            driven: false,
   86|    201|            suspension_rest_length: 0.3,
   87|    201|            suspension_stiffness: 35000.0,
   88|    201|            suspension_damping: 4500.0,
   89|    201|            suspension_max_compression: 0.1,
   90|    201|            suspension_max_extension: 0.2,
   91|    201|            position_id: WheelPosition::Custom(0),
   92|    201|        }
   93|    201|    }
   94|       |}
   95|       |
   96|       |impl WheelConfig {
   97|       |    /// Create a front-left wheel configuration
   98|     49|    pub fn front_left(position: Vec3) -> Self {
   99|     49|        Self {
  100|     49|            position,
  101|     49|            steerable: true,
  102|     49|            driven: false, // FWD would set this true
  103|     49|            position_id: WheelPosition::FrontLeft,
  104|     49|            ..Default::default()
  105|     49|        }
  106|     49|    }
  107|       |
  108|       |    /// Create a front-right wheel configuration
  109|     47|    pub fn front_right(position: Vec3) -> Self {
  110|     47|        Self {
  111|     47|            position,
  112|     47|            steerable: true,
  113|     47|            driven: false,
  114|     47|            position_id: WheelPosition::FrontRight,
  115|     47|            ..Default::default()
  116|     47|        }
  117|     47|    }
  118|       |
  119|       |    /// Create a rear-left wheel configuration (RWD driven)
  120|     47|    pub fn rear_left(position: Vec3) -> Self {
  121|     47|        Self {
  122|     47|            position,
  123|     47|            steerable: false,
  124|     47|            driven: true, // RWD
  125|     47|            position_id: WheelPosition::RearLeft,
  126|     47|            ..Default::default()
  127|     47|        }
  128|     47|    }
  129|       |
  130|       |    /// Create a rear-right wheel configuration (RWD driven)
  131|     47|    pub fn rear_right(position: Vec3) -> Self {
  132|     47|        Self {
  133|     47|            position,
  134|     47|            steerable: false,
  135|     47|            driven: true, // RWD
  136|     47|            position_id: WheelPosition::RearRight,
  137|     47|            ..Default::default()
  138|     47|        }
  139|     47|    }
  140|       |
  141|       |    /// Set as AWD (all-wheel drive)
  142|      6|    pub fn with_drive(mut self) -> Self {
  143|      6|        self.driven = true;
  144|      6|        self
  145|      6|    }
  146|       |
  147|       |    /// Set wheel radius
  148|      4|    pub fn with_radius(mut self, radius: f32) -> Self {
  149|      4|        self.radius = radius;
  150|      4|        self
  151|      4|    }
  152|       |
  153|       |    /// Set suspension parameters
  154|      4|    pub fn with_suspension(mut self, stiffness: f32, damping: f32, rest_length: f32) -> Self {
  155|      4|        self.suspension_stiffness = stiffness;
  156|      4|        self.suspension_damping = damping;
  157|      4|        self.suspension_rest_length = rest_length;
  158|      4|        self
  159|      4|    }
  160|       |}
  161|       |
  162|       |/// Drivetrain type
  163|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
  164|       |pub enum DrivetrainType {
  165|       |    /// Front-wheel drive
  166|       |    FWD,
  167|       |    /// Rear-wheel drive
  168|       |    #[default]
  169|       |    RWD,
  170|       |    /// All-wheel drive
  171|       |    AWD,
  172|       |}
  173|       |
  174|       |/// Engine configuration
  175|       |#[derive(Debug, Clone)]
  176|       |pub struct EngineConfig {
  177|       |    /// Maximum engine torque (Nm)
  178|       |    pub max_torque: f32,
  179|       |    /// RPM at which max torque is produced
  180|       |    pub max_torque_rpm: f32,
  181|       |    /// Maximum engine RPM
  182|       |    pub max_rpm: f32,
  183|       |    /// Idle RPM
  184|       |    pub idle_rpm: f32,
  185|       |    /// Engine braking coefficient
  186|       |    pub engine_braking: f32,
  187|       |}
  188|       |
  189|       |impl Default for EngineConfig {
  190|     47|    fn default() -> Self {
  191|     47|        Self {
  192|     47|            max_torque: 400.0,
  193|     47|            max_torque_rpm: 4500.0,
  194|     47|            max_rpm: 7000.0,
  195|     47|            idle_rpm: 800.0,
  196|     47|            engine_braking: 0.3,
  197|     47|        }
  198|     47|    }
  199|       |}
  200|       |
  201|       |impl EngineConfig {
  202|       |    /// Calculate torque at given RPM using simplified torque curve
  203|    255|    pub fn torque_at_rpm(&self, rpm: f32) -> f32 {
  204|    255|        if rpm < self.idle_rpm {
  205|      1|            return 0.0;
  206|    254|        }
  207|    254|        if rpm > self.max_rpm {
  208|      1|            return 0.0;
  209|    253|        }
  210|       |
  211|       |        // Simple parabolic torque curve
  212|    253|        let normalized = (rpm - self.idle_rpm) / (self.max_torque_rpm - self.idle_rpm);
  213|    253|        let falloff = (rpm - self.max_torque_rpm) / (self.max_rpm - self.max_torque_rpm);
  214|       |
  215|    253|        if rpm <= self.max_torque_rpm {
  216|       |            // Rising portion
  217|    156|            self.max_torque * (1.0 - (1.0 - normalized).powi(2))
  218|       |        } else {
  219|       |            // Falling portion
  220|     97|            self.max_torque * (1.0 - falloff.powi(2)).max(0.0)
  221|       |        }
  222|    255|    }
  223|       |}
  224|       |
  225|       |/// Transmission configuration
  226|       |#[derive(Debug, Clone)]
  227|       |pub struct TransmissionConfig {
  228|       |    /// Gear ratios (index 0 = 1st gear, etc.)
  229|       |    pub gear_ratios: Vec<f32>,
  230|       |    /// Reverse gear ratio
  231|       |    pub reverse_ratio: f32,
  232|       |    /// Final drive ratio (differential)
  233|       |    pub final_drive: f32,
  234|       |    /// Shift time in seconds
  235|       |    pub shift_time: f32,
  236|       |}
  237|       |
  238|       |impl Default for TransmissionConfig {
  239|     46|    fn default() -> Self {
  240|     46|        Self {
  241|     46|            gear_ratios: vec![3.5, 2.1, 1.4, 1.0, 0.8, 0.65],
  242|     46|            reverse_ratio: -3.2,
  243|     46|            final_drive: 3.7,
  244|     46|            shift_time: 0.2,
  245|     46|        }
  246|     46|    }
  247|       |}
  248|       |
  249|       |impl TransmissionConfig {
  250|       |    /// Get effective gear ratio for current gear
  251|    255|    pub fn effective_ratio(&self, gear: i32) -> f32 {
  252|    255|        let gear_ratio = if gear == 0 {
  253|      2|            0.0 // Neutral
  254|    253|        } else if gear < 0 {
  255|      2|            self.reverse_ratio
  256|       |        } else {
  257|    251|            self.gear_ratios
  258|    251|                .get((gear - 1) as usize)
  259|    251|                .copied()
  260|    251|                .unwrap_or(1.0)
  261|       |        };
  262|       |
  263|    255|        gear_ratio * self.final_drive
  264|    255|    }
  265|       |
  266|       |    /// Number of forward gears
  267|     19|    pub fn num_gears(&self) -> usize {
  268|     19|        self.gear_ratios.len()
  269|     19|    }
  270|       |}
  271|       |
  272|       |/// Friction curve parameters (simplified Pacejka)
  273|       |#[derive(Debug, Clone, Copy)]
  274|       |pub struct FrictionCurve {
  275|       |    /// Optimal slip ratio for maximum friction
  276|       |    pub optimal_slip: f32,
  277|       |    /// Friction coefficient at optimal slip
  278|       |    pub peak_friction: f32,
  279|       |    /// Friction coefficient at high slip (sliding)
  280|       |    pub sliding_friction: f32,
  281|       |    /// Curve stiffness
  282|       |    pub stiffness: f32,
  283|       |}
  284|       |
  285|       |impl Default for FrictionCurve {
  286|      3|    fn default() -> Self {
  287|      3|        Self {
  288|      3|            optimal_slip: 0.08,
  289|      3|            peak_friction: 1.2,
  290|      3|            sliding_friction: 0.8,
  291|      3|            stiffness: 10.0,
  292|      3|        }
  293|      3|    }
  294|       |}
  295|       |
  296|       |impl FrictionCurve {
  297|       |    /// Calculate friction coefficient at given slip ratio
  298|  1.94k|    pub fn friction_at_slip(&self, slip: f32) -> f32 {
  299|  1.94k|        let abs_slip = slip.abs();
  300|       |
  301|  1.94k|        if abs_slip < 0.001 {
  302|    115|            return 0.0;
  303|  1.82k|        }
  304|       |
  305|       |        // Simplified magic formula
  306|  1.82k|        let x = abs_slip / self.optimal_slip;
  307|  1.82k|        let peak = self.peak_friction;
  308|  1.82k|        let slide = self.sliding_friction;
  309|       |
  310|  1.82k|        if x <= 1.0 {
  311|       |            // Rising portion to peak
  312|    808|            peak * (1.0 - (-self.stiffness * x).exp())
  313|       |        } else {
  314|       |            // Falling portion after peak
  315|  1.01k|            let decay = ((x - 1.0) * 2.0).min(1.0);
  316|  1.01k|            peak - (peak - slide) * decay
  317|       |        }
  318|  1.94k|    }
  319|       |
  320|       |    /// Tarmac/asphalt friction curve
  321|     95|    pub fn tarmac() -> Self {
  322|     95|        Self {
  323|     95|            optimal_slip: 0.08,
  324|     95|            peak_friction: 1.2,
  325|     95|            sliding_friction: 0.9,
  326|     95|            stiffness: 12.0,
  327|     95|        }
  328|     95|    }
  329|       |
  330|       |    /// Gravel friction curve
  331|      5|    pub fn gravel() -> Self {
  332|      5|        Self {
  333|      5|            optimal_slip: 0.15,
  334|      5|            peak_friction: 0.8,
  335|      5|            sliding_friction: 0.6,
  336|      5|            stiffness: 6.0,
  337|      5|        }
  338|      5|    }
  339|       |
  340|       |    /// Ice friction curve
  341|      4|    pub fn ice() -> Self {
  342|      4|        Self {
  343|      4|            optimal_slip: 0.05,
  344|      4|            peak_friction: 0.3,
  345|      4|            sliding_friction: 0.15,
  346|      4|            stiffness: 20.0,
  347|      4|        }
  348|      4|    }
  349|       |
  350|       |    /// Mud friction curve
  351|      4|    pub fn mud() -> Self {
  352|      4|        Self {
  353|      4|            optimal_slip: 0.2,
  354|      4|            peak_friction: 0.5,
  355|      4|            sliding_friction: 0.4,
  356|      4|            stiffness: 4.0,
  357|      4|        }
  358|      4|    }
  359|       |}
  360|       |
  361|       |/// Vehicle configuration
  362|       |#[derive(Debug, Clone)]
  363|       |pub struct VehicleConfig {
  364|       |    /// Vehicle mass (kg)
  365|       |    pub mass: f32,
  366|       |    /// Wheel configurations
  367|       |    pub wheels: Vec<WheelConfig>,
  368|       |    /// Drivetrain type
  369|       |    pub drivetrain: DrivetrainType,
  370|       |    /// Engine configuration
  371|       |    pub engine: EngineConfig,
  372|       |    /// Transmission configuration
  373|       |    pub transmission: TransmissionConfig,
  374|       |    /// Longitudinal friction curve
  375|       |    pub friction_forward: FrictionCurve,
  376|       |    /// Lateral friction curve
  377|       |    pub friction_lateral: FrictionCurve,
  378|       |    /// Aerodynamic drag coefficient
  379|       |    pub drag_coefficient: f32,
  380|       |    /// Frontal area (m²)
  381|       |    pub frontal_area: f32,
  382|       |    /// Center of mass offset from geometric center
  383|       |    pub center_of_mass_offset: Vec3,
  384|       |    /// Maximum steering angle (radians)
  385|       |    pub max_steering_angle: f32,
  386|       |    /// Brake force (N)
  387|       |    pub brake_force: f32,
  388|       |    /// Handbrake force multiplier for rear wheels
  389|       |    pub handbrake_multiplier: f32,
  390|       |}
  391|       |
  392|       |impl Default for VehicleConfig {
  393|     43|    fn default() -> Self {
  394|     43|        Self {
  395|     43|            mass: 1500.0,
  396|     43|            wheels: vec![
  397|     43|                WheelConfig::front_left(Vec3::new(-0.8, 0.0, 1.2)),
  398|     43|                WheelConfig::front_right(Vec3::new(0.8, 0.0, 1.2)),
  399|     43|                WheelConfig::rear_left(Vec3::new(-0.8, 0.0, -1.2)),
  400|     43|                WheelConfig::rear_right(Vec3::new(0.8, 0.0, -1.2)),
  401|     43|            ],
  402|     43|            drivetrain: DrivetrainType::RWD,
  403|     43|            engine: EngineConfig::default(),
  404|     43|            transmission: TransmissionConfig::default(),
  405|     43|            friction_forward: FrictionCurve::tarmac(),
  406|     43|            friction_lateral: FrictionCurve::tarmac(),
  407|     43|            drag_coefficient: 0.35,
  408|     43|            frontal_area: 2.2,
  409|     43|            center_of_mass_offset: Vec3::new(0.0, -0.2, 0.0),
  410|     43|            max_steering_angle: 0.6, // ~35 degrees
  411|     43|            brake_force: 15000.0,
  412|     43|            handbrake_multiplier: 2.0,
  413|     43|        }
  414|     43|    }
  415|       |}
  416|       |
  417|       |/// Runtime state of a single wheel
  418|       |#[derive(Debug, Clone)]
  419|       |pub struct WheelState {
  420|       |    /// Current suspension compression (0 = rest, positive = compressed)
  421|       |    pub compression: f32,
  422|       |    /// Previous compression (for damping)
  423|       |    pub prev_compression: f32,
  424|       |    /// Current wheel rotation speed (rad/s)
  425|       |    pub rotation_speed: f32,
  426|       |    /// Current steering angle (radians)
  427|       |    pub steering_angle: f32,
  428|       |    /// Is the wheel touching the ground?
  429|       |    pub grounded: bool,
  430|       |    /// Ground contact point (world space)
  431|       |    pub contact_point: Vec3,
  432|       |    /// Ground normal at contact
  433|       |    pub contact_normal: Vec3,
  434|       |    /// Current slip ratio (longitudinal)
  435|       |    pub slip_ratio: f32,
  436|       |    /// Current slip angle (lateral, radians)
  437|       |    pub slip_angle: f32,
  438|       |    /// Force applied by this wheel
  439|       |    pub force: Vec3,
  440|       |    /// Suspension force magnitude
  441|       |    pub suspension_force: f32,
  442|       |}
  443|       |
  444|       |impl Default for WheelState {
  445|     35|    fn default() -> Self {
  446|     35|        Self {
  447|     35|            compression: 0.0,
  448|     35|            prev_compression: 0.0,
  449|     35|            rotation_speed: 0.0,
  450|     35|            steering_angle: 0.0,
  451|     35|            grounded: false,
  452|     35|            contact_point: Vec3::ZERO,
  453|     35|            contact_normal: Vec3::Y,
  454|     35|            slip_ratio: 0.0,
  455|     35|            slip_angle: 0.0,
  456|     35|            force: Vec3::ZERO,
  457|     35|            suspension_force: 0.0,
  458|     35|        }
  459|     35|    }
  460|       |}
  461|       |
  462|       |/// Vehicle input state
  463|       |#[derive(Debug, Clone, Copy, Default)]
  464|       |pub struct VehicleInput {
  465|       |    /// Throttle (0.0 to 1.0)
  466|       |    pub throttle: f32,
  467|       |    /// Brake (0.0 to 1.0)
  468|       |    pub brake: f32,
  469|       |    /// Steering (-1.0 left to 1.0 right)
  470|       |    pub steering: f32,
  471|       |    /// Handbrake (0.0 to 1.0)
  472|       |    pub handbrake: f32,
  473|       |    /// Clutch (0.0 engaged to 1.0 disengaged)
  474|       |    pub clutch: f32,
  475|       |    /// Gear shift request (-1 = down, 0 = none, 1 = up)
  476|       |    pub shift: i32,
  477|       |}
  478|       |
  479|       |/// Runtime state of a vehicle
  480|       |#[derive(Debug)]
  481|       |pub struct Vehicle {
  482|       |    /// Unique ID
  483|       |    pub id: VehicleId,
  484|       |    /// Physics body ID
  485|       |    pub body_id: BodyId,
  486|       |    /// Configuration
  487|       |    pub config: VehicleConfig,
  488|       |    /// Wheel states
  489|       |    pub wheels: Vec<WheelState>,
  490|       |    /// Current gear (0 = neutral, negative = reverse)
  491|       |    pub current_gear: i32,
  492|       |    /// Current engine RPM
  493|       |    pub engine_rpm: f32,
  494|       |    /// Time remaining in gear shift
  495|       |    pub shift_timer: f32,
  496|       |    /// Current speed (m/s)
  497|       |    pub speed: f32,
  498|       |    /// Current velocity (world space)
  499|       |    pub velocity: Vec3,
  500|       |    /// Forward direction (world space)
  501|       |    pub forward: Vec3,
  502|       |    /// Right direction (world space)
  503|       |    pub right: Vec3,
  504|       |    /// Up direction (world space)
  505|       |    pub up: Vec3,
  506|       |}
  507|       |
  508|       |impl Vehicle {
  509|       |    /// Create a new vehicle
  510|     33|    pub fn new(id: VehicleId, body_id: BodyId, config: VehicleConfig) -> Self {
  511|     33|        let num_wheels = config.wheels.len();
  512|     33|        Self {
  513|     33|            id,
  514|     33|            body_id,
  515|     33|            config,
  516|     33|            wheels: vec![WheelState::default(); num_wheels],
  517|     33|            current_gear: 1, // Start in 1st
  518|     33|            engine_rpm: 800.0, // Idle
  519|     33|            shift_timer: 0.0,
  520|     33|            speed: 0.0,
  521|     33|            velocity: Vec3::ZERO,
  522|     33|            forward: Vec3::Z,
  523|     33|            right: Vec3::X,
  524|     33|            up: Vec3::Y,
  525|     33|        }
  526|     33|    }
  527|       |
  528|       |    /// Update vehicle orientation from physics body
  529|    366|    pub fn update_orientation(&mut self, rotation: Quat) {
  530|    366|        self.forward = rotation * Vec3::Z;
  531|    366|        self.right = rotation * Vec3::X;
  532|    366|        self.up = rotation * Vec3::Y;
  533|    366|    }
  534|       |
  535|       |    /// Get speed in km/h
  536|      1|    pub fn speed_kmh(&self) -> f32 {
  537|      1|        self.speed * 3.6
  538|      1|    }
  539|       |
  540|       |    /// Get speed in mph
  541|      1|    pub fn speed_mph(&self) -> f32 {
  542|      1|        self.speed * 2.237
  543|      1|    }
  544|       |
  545|       |    /// Check if currently shifting gears
  546|    263|    pub fn is_shifting(&self) -> bool {
  547|    263|        self.shift_timer > 0.0
  548|    263|    }
  549|       |
  550|       |    /// Shift up a gear
  551|     15|    pub fn shift_up(&mut self) {
  552|     15|        let max_gear = self.config.transmission.num_gears() as i32;
  553|     15|        if self.current_gear < max_gear && !self.is_shifting() {
                                                         ^10
  554|      9|            self.current_gear += 1;
  555|      9|            self.shift_timer = self.config.transmission.shift_time;
  556|      9|        }
                      ^6
  557|     15|    }
  558|       |
  559|       |    /// Shift down a gear
  560|     13|    pub fn shift_down(&mut self) {
  561|     13|        if self.current_gear > -1 && !self.is_shifting() {
                                                   ^10
  562|     10|            self.current_gear -= 1;
  563|     10|            self.shift_timer = self.config.transmission.shift_time;
  564|     10|        }
                      ^3
  565|     13|    }
  566|       |
  567|       |    /// Get number of grounded wheels
  568|      7|    pub fn grounded_wheels(&self) -> usize {
  569|      7|        self.wheels.iter().filter(|w| w.grounded).count()
  570|      7|    }
  571|       |
  572|       |    /// Check if vehicle is airborne
  573|      3|    pub fn is_airborne(&self) -> bool {
  574|      3|        self.grounded_wheels() == 0
  575|      3|    }
  576|       |
  577|       |    /// Get total suspension force
  578|      3|    pub fn total_suspension_force(&self) -> f32 {
  579|      3|        self.wheels.iter().map(|w| w.suspension_force).sum()
  580|      3|    }
  581|       |
  582|       |    /// Get average slip ratio
  583|      6|    pub fn average_slip_ratio(&self) -> f32 {
  584|      6|        let grounded: Vec<_> = self.wheels.iter().filter(|w| w.grounded).collect();
  585|      6|        if grounded.is_empty() {
  586|      2|            return 0.0;
  587|      4|        }
  588|      9|        grounded.iter().map(|w| w.slip_ratio.abs()).sum::<f32>() / grounded.len() as f32
                      ^4              ^4                          ^4             ^4
  589|      6|    }
  590|       |
  591|       |    /// Get average slip angle
  592|      3|    pub fn average_slip_angle(&self) -> f32 {
  593|      3|        let grounded: Vec<_> = self.wheels.iter().filter(|w| w.grounded).collect();
  594|      3|        if grounded.is_empty() {
  595|      1|            return 0.0;
  596|      2|        }
  597|      5|        grounded.iter().map(|w| w.slip_angle.abs()).sum::<f32>() / grounded.len() as f32
                      ^2              ^2                          ^2             ^2
  598|      3|    }
  599|       |}
  600|       |
  601|       |/// Vehicle physics manager
  602|       |#[derive(Debug)]
  603|       |pub struct VehicleManager {
  604|       |    vehicles: Vec<Vehicle>,
  605|       |    next_id: VehicleId,
  606|       |}
  607|       |
  608|       |impl Default for VehicleManager {
  609|      2|    fn default() -> Self {
  610|      2|        Self::new()
  611|      2|    }
  612|       |}
  613|       |
  614|       |impl VehicleManager {
  615|       |    /// Create a new vehicle manager
  616|     13|    pub fn new() -> Self {
  617|     13|        Self {
  618|     13|            vehicles: Vec::new(),
  619|     13|            next_id: 1,
  620|     13|        }
  621|     13|    }
  622|       |
  623|       |    /// Spawn a vehicle
  624|     11|    pub fn spawn(&mut self, physics: &mut PhysicsWorld, position: Vec3, config: VehicleConfig) -> VehicleId {
  625|     11|        let body_id = physics.add_dynamic_box(
  626|     11|            position + config.center_of_mass_offset,
  627|     11|            Vec3::new(1.0, 0.5, 2.0), // Approximate vehicle half-extents
  628|     11|            config.mass,
  629|       |            crate::Layers::DEFAULT,
  630|       |        );
  631|       |
  632|       |        // Enable CCD for fast-moving vehicles
  633|     11|        physics.enable_ccd(body_id);
  634|       |
  635|     11|        let id = self.next_id;
  636|     11|        self.next_id += 1;
  637|       |
  638|     11|        let vehicle = Vehicle::new(id, body_id, config);
  639|     11|        self.vehicles.push(vehicle);
  640|       |
  641|     11|        id
  642|     11|    }
  643|       |
  644|       |    /// Get a vehicle by ID
  645|     10|    pub fn get(&self, id: VehicleId) -> Option<&Vehicle> {
  646|     10|        self.vehicles.iter().find(|v| v.id == id)
                                                    ^8      ^8
  647|     10|    }
  648|       |
  649|       |    /// Get a mutable vehicle by ID
  650|    243|    pub fn get_mut(&mut self, id: VehicleId) -> Option<&mut Vehicle> {
  651|    243|        self.vehicles.iter_mut().find(|v| v.id == id)
  652|    243|    }
  653|       |
  654|       |    /// Update all vehicles
  655|    121|    pub fn update(&mut self, physics: &mut PhysicsWorld, dt: f32) {
  656|    242|        for vehicle in &mut self.vehicles {
                          ^121
  657|    121|            Self::update_vehicle(vehicle, physics, dt);
  658|    121|        }
  659|    121|    }
  660|       |
  661|       |    /// Update vehicle with input
  662|    242|    pub fn update_with_input(&mut self, id: VehicleId, physics: &mut PhysicsWorld, input: &VehicleInput, dt: f32) {
  663|    242|        if let Some(vehicle) = self.get_mut(id) {
  664|       |            // Handle gear shifts
  665|    242|            if input.shift > 0 {
  666|      1|                vehicle.shift_up();
  667|    241|            } else if input.shift < 0 {
  668|      0|                vehicle.shift_down();
  669|    241|            }
  670|       |
  671|       |            // Update shift timer
  672|    242|            if vehicle.shift_timer > 0.0 {
  673|      1|                vehicle.shift_timer = (vehicle.shift_timer - dt).max(0.0);
  674|    241|            }
  675|       |
  676|       |            // Apply steering
  677|    968|            for (i, wheel) in vehicle.wheels.iter_mut().enumerate() {
                                            ^242                      ^242
  678|    968|                if vehicle.config.wheels[i].steerable {
  679|    484|                    wheel.steering_angle = input.steering * vehicle.config.max_steering_angle;
  680|    484|                }
  681|       |            }
  682|       |
  683|    242|            Self::update_vehicle(vehicle, physics, dt);
  684|    242|            Self::apply_forces(vehicle, physics, input, dt);
  685|      0|        }
  686|    242|    }
  687|       |
  688|    363|    fn update_vehicle(vehicle: &mut Vehicle, physics: &PhysicsWorld, _dt: f32) {
  689|       |        // Get vehicle transform
  690|    363|        if let Some(transform) = physics.body_transform(vehicle.body_id) {
  691|    363|            let position = Vec3::new(transform.w_axis.x, transform.w_axis.y, transform.w_axis.z);
  692|       |
  693|       |            // Extract rotation (simplified - assumes orthonormal)
  694|    363|            let rotation = Quat::from_mat4(&transform);
  695|    363|            vehicle.update_orientation(rotation);
  696|       |
  697|       |            // Get velocity
  698|    363|            if let Some(vel) = physics.get_velocity(vehicle.body_id) {
  699|    363|                vehicle.velocity = vel;
  700|    363|                vehicle.speed = vel.length();
  701|    363|            }
                          ^0
  702|       |
  703|       |            // Update wheel states with raycasts
  704|  1.45k|            for (i, wheel_config) in vehicle.config.wheels.iter().enumerate() {
                                                   ^363                         ^363
  705|  1.45k|                let wheel_state = &mut vehicle.wheels[i];
  706|       |
  707|       |                // Calculate wheel world position
  708|  1.45k|                let wheel_pos = position + rotation * wheel_config.position;
  709|       |
  710|       |                // Raycast downward from wheel
  711|  1.45k|                let ray_origin = wheel_pos + vehicle.up * wheel_config.suspension_max_extension;
  712|  1.45k|                let ray_length = wheel_config.suspension_rest_length
  713|  1.45k|                    + wheel_config.suspension_max_compression
  714|  1.45k|                    + wheel_config.suspension_max_extension
  715|  1.45k|                    + wheel_config.radius;
  716|       |
  717|       |                // Perform raycast
  718|  1.44k|                if let Some((hit_point, hit_normal, _body_id, _distance)) =
  719|  1.45k|                    physics.raycast(ray_origin, -vehicle.up, ray_length)
  720|  1.44k|                {
  721|  1.44k|                    wheel_state.grounded = true;
  722|  1.44k|                    wheel_state.contact_point = hit_point;
  723|  1.44k|                    wheel_state.contact_normal = hit_normal;
  724|  1.44k|
  725|  1.44k|                    // Calculate suspension compression
  726|  1.44k|                    let suspension_length = (wheel_pos - hit_point).length() - wheel_config.radius;
  727|  1.44k|                    wheel_state.prev_compression = wheel_state.compression;
  728|  1.44k|                    wheel_state.compression =
  729|  1.44k|                        wheel_config.suspension_rest_length - suspension_length;
  730|  1.44k|                } else {
  731|     12|                    wheel_state.grounded = false;
  732|     12|                    wheel_state.prev_compression = wheel_state.compression;
  733|     12|                    wheel_state.compression = -wheel_config.suspension_max_extension;
  734|     12|                }
  735|       |            }
  736|      0|        }
  737|    363|    }
  738|       |
  739|    242|    fn apply_forces(vehicle: &mut Vehicle, physics: &mut PhysicsWorld, input: &VehicleInput, dt: f32) {
  740|    242|        let mut total_force = Vec3::ZERO;
  741|    242|        let mut total_torque = Vec3::ZERO;
  742|       |
  743|       |        // Get vehicle transform for force application points
  744|    242|        let Some(transform) = physics.body_transform(vehicle.body_id) else {
  745|      0|            return;
  746|       |        };
  747|    242|        let position = Vec3::new(transform.w_axis.x, transform.w_axis.y, transform.w_axis.z);
  748|    242|        let rotation = Quat::from_mat4(&transform);
  749|       |
  750|       |        // Calculate engine torque
  751|    242|        let effective_throttle = if vehicle.is_shifting() { 0.0 } else { input.throttle };
                                                                          ^1           ^241
  752|    242|        let gear_ratio = vehicle.config.transmission.effective_ratio(vehicle.current_gear);
  753|    242|        let engine_torque = vehicle.config.engine.torque_at_rpm(vehicle.engine_rpm) * effective_throttle;
  754|    242|        let wheel_torque = engine_torque * gear_ratio;
  755|       |
  756|       |        // Count driven wheels
  757|    242|        let driven_count = vehicle.config.wheels.iter().filter(|w| w.driven).count() as f32;
  758|       |
  759|    968|        for (i, wheel_config) in vehicle.config.wheels.iter().enumerate() {
                                               ^242                         ^242
  760|    968|            let wheel_state = &mut vehicle.wheels[i];
  761|       |
  762|    968|            if !wheel_state.grounded {
  763|      8|                continue;
  764|    960|            }
  765|       |
  766|    960|            let wheel_world_pos = position + rotation * wheel_config.position;
  767|       |
  768|       |            // Suspension force (spring + damper)
  769|    960|            let spring_force = wheel_state.compression * wheel_config.suspension_stiffness;
  770|    960|            let damper_velocity = (wheel_state.compression - wheel_state.prev_compression) / dt;
  771|    960|            let damper_force = damper_velocity * wheel_config.suspension_damping;
  772|    960|            let suspension_force = (spring_force + damper_force).max(0.0);
  773|    960|            wheel_state.suspension_force = suspension_force;
  774|       |
  775|       |            // Normal force on this wheel
  776|    960|            let normal_force = suspension_force;
  777|       |
  778|       |            // Calculate wheel direction with steering
  779|    960|            let steer_rotation = Quat::from_rotation_y(wheel_state.steering_angle);
  780|    960|            let wheel_forward = rotation * steer_rotation * Vec3::Z;
  781|    960|            let wheel_right = rotation * steer_rotation * Vec3::X;
  782|       |
  783|       |            // Velocity at wheel contact point
  784|    960|            let contact_velocity = vehicle.velocity; // Simplified - ignores angular velocity
  785|       |
  786|       |            // Longitudinal velocity (along wheel forward)
  787|    960|            let long_velocity = contact_velocity.dot(wheel_forward);
  788|       |
  789|       |            // Lateral velocity (perpendicular to wheel forward)
  790|    960|            let lat_velocity = contact_velocity.dot(wheel_right);
  791|       |
  792|       |            // Calculate slip ratio
  793|    960|            let wheel_speed = wheel_state.rotation_speed * wheel_config.radius;
  794|    960|            let slip_ratio = if long_velocity.abs() > 0.5 {
  795|    912|                (wheel_speed - long_velocity) / long_velocity.abs()
  796|     48|            } else if wheel_speed.abs() > 0.1 {
  797|     16|                wheel_speed.signum()
  798|       |            } else {
  799|     32|                0.0
  800|       |            };
  801|    960|            wheel_state.slip_ratio = slip_ratio.clamp(-1.0, 1.0);
  802|       |
  803|       |            // Calculate slip angle
  804|    960|            let slip_angle = if long_velocity.abs() > 0.5 {
  805|    912|                (-lat_velocity / long_velocity.abs()).atan()
  806|       |            } else {
  807|     48|                0.0
  808|       |            };
  809|    960|            wheel_state.slip_angle = slip_angle;
  810|       |
  811|       |            // Friction forces
  812|    960|            let long_friction = vehicle.config.friction_forward.friction_at_slip(slip_ratio);
  813|    960|            let lat_friction = vehicle.config.friction_lateral.friction_at_slip(slip_angle.abs());
  814|       |
  815|       |            // Longitudinal force (drive/brake)
  816|    960|            let mut long_force = 0.0;
  817|       |
  818|       |            // Drive force
  819|    960|            if wheel_config.driven && driven_count > 0.0 {
                                                    ^480
  820|    480|                let torque_per_wheel = wheel_torque / driven_count;
  821|    480|                let max_friction_force = normal_force * long_friction;
  822|    480|                let drive_force = (torque_per_wheel / wheel_config.radius).min(max_friction_force);
  823|    480|                long_force += drive_force * effective_throttle;
  824|    480|            }
  825|       |
  826|       |            // Brake force
  827|    960|            let brake_input = if wheel_config.position_id == WheelPosition::RearLeft
  828|    720|                || wheel_config.position_id == WheelPosition::RearRight
  829|       |            {
  830|    480|                input.brake + input.handbrake * vehicle.config.handbrake_multiplier
  831|       |            } else {
  832|    480|                input.brake
  833|       |            };
  834|       |
  835|    960|            if brake_input > 0.0 {
  836|    240|                let max_brake = vehicle.config.brake_force * brake_input;
  837|    240|                let brake_friction_limit = normal_force * long_friction;
  838|    240|                let brake_force = max_brake.min(brake_friction_limit);
  839|    240|                long_force -= brake_force * long_velocity.signum();
  840|    720|            }
  841|       |
  842|       |            // Lateral force (cornering)
  843|    960|            let lat_force = -lat_velocity.signum() * normal_force * lat_friction;
  844|       |
  845|       |            // Total wheel force
  846|    960|            let wheel_force = wheel_forward * long_force + wheel_right * lat_force + wheel_state.contact_normal * suspension_force;
  847|    960|            wheel_state.force = wheel_force;
  848|       |
  849|       |            // Accumulate forces
  850|    960|            total_force += wheel_force;
  851|       |
  852|       |            // Calculate torque from force application point
  853|    960|            let force_arm = wheel_world_pos - position;
  854|    960|            total_torque += force_arm.cross(wheel_force);
  855|       |
  856|       |            // Update wheel rotation
  857|    960|            let angular_accel = if wheel_config.driven && driven_count > 0.0 {
                                                                        ^480
  858|    480|                let torque_per_wheel = wheel_torque / driven_count;
  859|    480|                let wheel_inertia = 0.5 * 10.0 * wheel_config.radius.powi(2); // Simplified
  860|    480|                (torque_per_wheel - long_force * wheel_config.radius) / wheel_inertia
  861|       |            } else {
  862|    480|                -long_force * wheel_config.radius / (0.5 * 10.0 * wheel_config.radius.powi(2))
  863|       |            };
  864|    960|            wheel_state.rotation_speed += angular_accel * dt;
  865|       |
  866|       |            // Apply friction to slow wheel when not driven
  867|    960|            if !wheel_config.driven || effective_throttle < 0.01 {
                                                     ^480
  868|    600|                wheel_state.rotation_speed *= 0.99; // Rolling resistance
  869|    600|            }
                          ^360
  870|       |        }
  871|       |
  872|       |        // Aerodynamic drag
  873|    242|        let speed_sq = vehicle.speed * vehicle.speed;
  874|    242|        let drag_force = 0.5 * 1.225 * vehicle.config.drag_coefficient * vehicle.config.frontal_area * speed_sq;
  875|    242|        total_force -= vehicle.forward * drag_force * vehicle.velocity.dot(vehicle.forward).signum();
  876|       |
  877|       |        // Apply forces to physics body
  878|    242|        physics.apply_force(vehicle.body_id, total_force);
  879|       |
  880|       |        // Update engine RPM based on throttle and wheel load
  881|       |        // Engine revs up with throttle input
  882|    242|        let throttle_rpm_target = vehicle.config.engine.idle_rpm + 
  883|    242|            input.throttle * (vehicle.config.engine.max_rpm - vehicle.config.engine.idle_rpm) * 0.8;
  884|       |        
  885|    242|        if gear_ratio.abs() > 0.01 && driven_count > 0.0 {
  886|    242|            let avg_wheel_rpm: f32 = vehicle
  887|    242|                .wheels
  888|    242|                .iter()
  889|    242|                .enumerate()
  890|    968|                .filter(|(i, _)| vehicle.config.wheels[*i].driven)
                               ^242
  891|    484|                .map(|(_, w)| w.rotation_speed.abs() * 60.0 / (2.0 * std::f32::consts::PI))
                               ^242
  892|    242|                .sum::<f32>()
  893|    242|                / driven_count;
  894|       |
  895|    242|            let wheel_target_rpm = avg_wheel_rpm * gear_ratio.abs();
  896|       |            
  897|       |            // Engine RPM is influenced by both throttle and wheel feedback
  898|       |            // Throttle pulls RPM up, wheel speed provides load feedback
  899|    242|            let load_factor = (vehicle.speed / 20.0).clamp(0.0, 0.5); // More wheel influence at speed
  900|    242|            let target_rpm = throttle_rpm_target * (1.0 - load_factor) + 
  901|    242|                wheel_target_rpm.max(throttle_rpm_target * 0.3) * load_factor;
  902|       |            
  903|       |            // Smooth RPM changes
  904|    242|            vehicle.engine_rpm = vehicle.engine_rpm * 0.85 + target_rpm * 0.15;
  905|      0|        } else {
  906|      0|            // No gear engaged - free rev
  907|      0|            vehicle.engine_rpm = vehicle.engine_rpm * 0.85 + throttle_rpm_target * 0.15;
  908|      0|        }
  909|       |
  910|       |        // Clamp engine RPM
  911|    242|        vehicle.engine_rpm = vehicle.engine_rpm.clamp(
  912|    242|            vehicle.config.engine.idle_rpm,
  913|    242|            vehicle.config.engine.max_rpm,
  914|    242|        );
  915|    242|    }
  916|       |
  917|       |    /// Remove a vehicle
  918|      2|    pub fn remove(&mut self, id: VehicleId) -> bool {
  919|      2|        if let Some(pos) = self.vehicles.iter().position(|v| v.id == id) {
                                  ^1                                       ^1      ^1
  920|      1|            self.vehicles.remove(pos);
  921|      1|            true
  922|       |        } else {
  923|      1|            false
  924|       |        }
  925|      2|    }
  926|       |
  927|       |    /// Get all vehicles
  928|      7|    pub fn vehicles(&self) -> &[Vehicle] {
  929|      7|        &self.vehicles
  930|      7|    }
  931|       |}
  932|       |
  933|       |#[cfg(test)]
  934|       |mod tests {
  935|       |    use super::*;
  936|       |
  937|       |    #[test]
  938|      1|    fn test_wheel_config_defaults() {
  939|      1|        let wheel = WheelConfig::default();
  940|      1|        assert!((wheel.radius - 0.35).abs() < 0.01);
  941|      1|        assert!(wheel.suspension_stiffness > 0.0);
  942|      1|    }
  943|       |
  944|       |    #[test]
  945|      1|    fn test_wheel_config_presets() {
  946|      1|        let fl = WheelConfig::front_left(Vec3::new(-1.0, 0.0, 1.5));
  947|      1|        assert!(fl.steerable);
  948|      1|        assert!(!fl.driven);
  949|      1|        assert_eq!(fl.position_id, WheelPosition::FrontLeft);
  950|       |
  951|      1|        let rr = WheelConfig::rear_right(Vec3::new(1.0, 0.0, -1.5));
  952|      1|        assert!(!rr.steerable);
  953|      1|        assert!(rr.driven);
  954|      1|        assert_eq!(rr.position_id, WheelPosition::RearRight);
  955|      1|    }
  956|       |
  957|       |    #[test]
  958|      1|    fn test_wheel_config_awd() {
  959|      1|        let wheel = WheelConfig::front_left(Vec3::ZERO).with_drive();
  960|      1|        assert!(wheel.driven);
  961|      1|    }
  962|       |
  963|       |    #[test]
  964|      1|    fn test_engine_torque_curve() {
  965|      1|        let engine = EngineConfig::default();
  966|       |
  967|       |        // Below idle: no torque
  968|      1|        assert!((engine.torque_at_rpm(500.0)).abs() < 0.01);
  969|       |
  970|       |        // At max torque RPM: should be near max
  971|      1|        let torque_at_peak = engine.torque_at_rpm(engine.max_torque_rpm);
  972|      1|        assert!((torque_at_peak - engine.max_torque).abs() < 50.0);
  973|       |
  974|       |        // Above max RPM: no torque
  975|      1|        assert!((engine.torque_at_rpm(8000.0)).abs() < 0.01);
  976|      1|    }
  977|       |
  978|       |    #[test]
  979|      1|    fn test_transmission_gear_ratios() {
  980|      1|        let trans = TransmissionConfig::default();
  981|       |
  982|       |        // Neutral
  983|      1|        assert!((trans.effective_ratio(0)).abs() < 0.01);
  984|       |
  985|       |        // First gear should have highest ratio
  986|      1|        let first = trans.effective_ratio(1);
  987|      1|        let second = trans.effective_ratio(2);
  988|      1|        assert!(first > second);
  989|       |
  990|       |        // Reverse should be negative
  991|      1|        assert!(trans.effective_ratio(-1) < 0.0);
  992|      1|    }
  993|       |
  994|       |    #[test]
  995|      1|    fn test_friction_curve_tarmac() {
  996|      1|        let curve = FrictionCurve::tarmac();
  997|       |
  998|       |        // Zero slip: zero friction
  999|      1|        assert!(curve.friction_at_slip(0.0).abs() < 0.01);
 1000|       |
 1001|       |        // Optimal slip: peak friction
 1002|      1|        let peak = curve.friction_at_slip(curve.optimal_slip);
 1003|      1|        assert!(peak > 1.0, "Peak friction should exceed 1.0 on tarmac");
                                          ^0
 1004|       |
 1005|       |        // High slip: reduced friction
 1006|      1|        let slide = curve.friction_at_slip(0.5);
 1007|      1|        assert!(slide < peak, "Sliding friction should be less than peak");
                                            ^0
 1008|      1|    }
 1009|       |
 1010|       |    #[test]
 1011|      1|    fn test_friction_curve_ice() {
 1012|      1|        let ice = FrictionCurve::ice();
 1013|      1|        let tarmac = FrictionCurve::tarmac();
 1014|       |
 1015|      1|        let ice_friction = ice.friction_at_slip(ice.optimal_slip);
 1016|      1|        let tarmac_friction = tarmac.friction_at_slip(tarmac.optimal_slip);
 1017|       |
 1018|      1|        assert!(ice_friction < tarmac_friction, "Ice should have less grip than tarmac");
                                                              ^0
 1019|      1|    }
 1020|       |
 1021|       |    #[test]
 1022|      1|    fn test_vehicle_config_default() {
 1023|      1|        let config = VehicleConfig::default();
 1024|      1|        assert_eq!(config.wheels.len(), 4);
 1025|      1|        assert!((config.mass - 1500.0).abs() < 0.1);
 1026|      1|    }
 1027|       |
 1028|       |    #[test]
 1029|      1|    fn test_vehicle_creation() {
 1030|      1|        let config = VehicleConfig::default();
 1031|      1|        let vehicle = Vehicle::new(1, 42, config);
 1032|       |
 1033|      1|        assert_eq!(vehicle.id, 1);
 1034|      1|        assert_eq!(vehicle.body_id, 42);
 1035|      1|        assert_eq!(vehicle.wheels.len(), 4);
 1036|      1|        assert_eq!(vehicle.current_gear, 1);
 1037|      1|    }
 1038|       |
 1039|       |    #[test]
 1040|      1|    fn test_vehicle_speed_conversion() {
 1041|      1|        let config = VehicleConfig::default();
 1042|      1|        let mut vehicle = Vehicle::new(1, 42, config);
 1043|      1|        vehicle.speed = 27.78; // ~100 km/h
 1044|       |
 1045|      1|        let kmh = vehicle.speed_kmh();
 1046|      1|        assert!((kmh - 100.0).abs() < 1.0);
 1047|       |
 1048|      1|        let mph = vehicle.speed_mph();
 1049|      1|        assert!((mph - 62.1).abs() < 1.0);
 1050|      1|    }
 1051|       |
 1052|       |    #[test]
 1053|      1|    fn test_vehicle_shifting() {
 1054|      1|        let config = VehicleConfig::default();
 1055|      1|        let mut vehicle = Vehicle::new(1, 42, config);
 1056|       |
 1057|      1|        assert_eq!(vehicle.current_gear, 1);
 1058|       |
 1059|      1|        vehicle.shift_up();
 1060|      1|        assert_eq!(vehicle.current_gear, 2);
 1061|      1|        assert!(vehicle.is_shifting());
 1062|       |
 1063|       |        // Can't shift while already shifting
 1064|      1|        vehicle.shift_up();
 1065|      1|        assert_eq!(vehicle.current_gear, 2);
 1066|       |
 1067|       |        // Clear shift timer
 1068|      1|        vehicle.shift_timer = 0.0;
 1069|       |
 1070|      1|        vehicle.shift_down();
 1071|      1|        assert_eq!(vehicle.current_gear, 1);
 1072|      1|    }
 1073|       |
 1074|       |    #[test]
 1075|      1|    fn test_vehicle_grounded_wheels() {
 1076|      1|        let config = VehicleConfig::default();
 1077|      1|        let mut vehicle = Vehicle::new(1, 42, config);
 1078|       |
 1079|       |        // Initially no wheels grounded
 1080|      1|        assert_eq!(vehicle.grounded_wheels(), 0);
 1081|      1|        assert!(vehicle.is_airborne());
 1082|       |
 1083|       |        // Ground some wheels
 1084|      1|        vehicle.wheels[0].grounded = true;
 1085|      1|        vehicle.wheels[1].grounded = true;
 1086|      1|        assert_eq!(vehicle.grounded_wheels(), 2);
 1087|      1|        assert!(!vehicle.is_airborne());
 1088|      1|    }
 1089|       |
 1090|       |    #[test]
 1091|      1|    fn test_vehicle_manager_creation() {
 1092|      1|        let manager = VehicleManager::new();
 1093|      1|        assert_eq!(manager.vehicles().len(), 0);
 1094|      1|    }
 1095|       |
 1096|       |    #[test]
 1097|      1|    fn test_vehicle_input_default() {
 1098|      1|        let input = VehicleInput::default();
 1099|      1|        assert!((input.throttle).abs() < 0.01);
 1100|      1|        assert!((input.brake).abs() < 0.01);
 1101|      1|        assert!((input.steering).abs() < 0.01);
 1102|      1|    }
 1103|       |
 1104|       |    #[test]
 1105|      1|    fn test_wheel_state_default() {
 1106|      1|        let state = WheelState::default();
 1107|      1|        assert!(!state.grounded);
 1108|      1|        assert!((state.compression).abs() < 0.01);
 1109|      1|        assert!((state.rotation_speed).abs() < 0.01);
 1110|      1|    }
 1111|       |
 1112|       |    #[test]
 1113|      1|    fn test_drivetrain_types() {
 1114|      1|        assert_eq!(DrivetrainType::default(), DrivetrainType::RWD);
 1115|      1|    }
 1116|       |
 1117|       |    #[test]
 1118|      1|    fn test_suspension_force_calculation() {
 1119|      1|        let wheel = WheelConfig::default();
 1120|      1|        let compression = 0.05; // 5cm compressed
 1121|       |
 1122|      1|        let spring_force = compression * wheel.suspension_stiffness;
 1123|      1|        assert!(spring_force > 0.0);
 1124|      1|        assert!(spring_force < wheel.suspension_stiffness); // Sanity check
 1125|      1|    }
 1126|       |
 1127|       |    #[test]
 1128|      1|    fn test_vehicle_orientation() {
 1129|      1|        let config = VehicleConfig::default();
 1130|      1|        let mut vehicle = Vehicle::new(1, 42, config);
 1131|       |
 1132|       |        // Default orientation
 1133|      1|        vehicle.update_orientation(Quat::IDENTITY);
 1134|      1|        assert!((vehicle.forward - Vec3::Z).length() < 0.01);
 1135|      1|        assert!((vehicle.right - Vec3::X).length() < 0.01);
 1136|      1|        assert!((vehicle.up - Vec3::Y).length() < 0.01);
 1137|       |
 1138|       |        // Rotated 90 degrees around Y
 1139|      1|        let rotation = Quat::from_rotation_y(std::f32::consts::FRAC_PI_2);
 1140|      1|        vehicle.update_orientation(rotation);
 1141|      1|        assert!((vehicle.forward - Vec3::X).length() < 0.1);
 1142|      1|    }
 1143|       |
 1144|       |    #[test]
 1145|      1|    fn test_total_suspension_force() {
 1146|      1|        let config = VehicleConfig::default();
 1147|      1|        let mut vehicle = Vehicle::new(1, 42, config);
 1148|       |
 1149|       |        // Set suspension forces on wheels
 1150|      1|        vehicle.wheels[0].suspension_force = 1000.0;
 1151|      1|        vehicle.wheels[1].suspension_force = 1000.0;
 1152|      1|        vehicle.wheels[2].suspension_force = 800.0;
 1153|      1|        vehicle.wheels[3].suspension_force = 800.0;
 1154|       |
 1155|      1|        let total = vehicle.total_suspension_force();
 1156|      1|        assert!((total - 3600.0).abs() < 0.01);
 1157|      1|    }
 1158|       |
 1159|       |    #[test]
 1160|      1|    fn test_average_slip_ratio_all_grounded() {
 1161|      1|        let config = VehicleConfig::default();
 1162|      1|        let mut vehicle = Vehicle::new(1, 42, config);
 1163|       |
 1164|       |        // Ground all wheels and set slip ratios
 1165|      4|        for (i, wheel) in vehicle.wheels.iter_mut().enumerate() {
                                        ^1                        ^1
 1166|      4|            wheel.grounded = true;
 1167|      4|            wheel.slip_ratio = (i as f32 + 1.0) * 0.1; // 0.1, 0.2, 0.3, 0.4
 1168|      4|        }
 1169|       |
 1170|      1|        let avg = vehicle.average_slip_ratio();
 1171|       |        // Average of 0.1 + 0.2 + 0.3 + 0.4 = 1.0 / 4 = 0.25
 1172|      1|        assert!((avg - 0.25).abs() < 0.01);
 1173|      1|    }
 1174|       |
 1175|       |    #[test]
 1176|      1|    fn test_average_slip_ratio_some_airborne() {
 1177|      1|        let config = VehicleConfig::default();
 1178|      1|        let mut vehicle = Vehicle::new(1, 42, config);
 1179|       |
 1180|       |        // Only ground front wheels
 1181|      1|        vehicle.wheels[0].grounded = true;
 1182|      1|        vehicle.wheels[0].slip_ratio = 0.2;
 1183|      1|        vehicle.wheels[1].grounded = true;
 1184|      1|        vehicle.wheels[1].slip_ratio = 0.4;
 1185|      1|        vehicle.wheels[2].grounded = false;
 1186|      1|        vehicle.wheels[3].grounded = false;
 1187|       |
 1188|      1|        let avg = vehicle.average_slip_ratio();
 1189|       |        // Average of 0.2 + 0.4 = 0.6 / 2 = 0.3
 1190|      1|        assert!((avg - 0.3).abs() < 0.01);
 1191|      1|    }
 1192|       |
 1193|       |    #[test]
 1194|      1|    fn test_average_slip_ratio_airborne() {
 1195|      1|        let config = VehicleConfig::default();
 1196|      1|        let vehicle = Vehicle::new(1, 42, config);
 1197|       |
 1198|       |        // All wheels airborne by default
 1199|      1|        let avg = vehicle.average_slip_ratio();
 1200|      1|        assert!((avg).abs() < 0.01);
 1201|      1|    }
 1202|       |
 1203|       |    #[test]
 1204|      1|    fn test_average_slip_angle() {
 1205|      1|        let config = VehicleConfig::default();
 1206|      1|        let mut vehicle = Vehicle::new(1, 42, config);
 1207|       |
 1208|       |        // Ground all wheels and set slip angles
 1209|      4|        for (i, wheel) in vehicle.wheels.iter_mut().enumerate() {
                                        ^1                        ^1
 1210|      4|            wheel.grounded = true;
 1211|      4|            wheel.slip_angle = (i as f32 + 1.0) * 0.05; // 0.05, 0.10, 0.15, 0.20
 1212|      4|        }
 1213|       |
 1214|      1|        let avg = vehicle.average_slip_angle();
 1215|       |        // Average of 0.05 + 0.10 + 0.15 + 0.20 = 0.50 / 4 = 0.125
 1216|      1|        assert!((avg - 0.125).abs() < 0.01);
 1217|      1|    }
 1218|       |
 1219|       |    #[test]
 1220|      1|    fn test_friction_curve_gravel() {
 1221|      1|        let curve = FrictionCurve::gravel();
 1222|       |        
 1223|      1|        assert!((curve.optimal_slip - 0.15).abs() < 0.01);
 1224|      1|        assert!(curve.peak_friction < FrictionCurve::tarmac().peak_friction);
 1225|      1|    }
 1226|       |
 1227|       |    #[test]
 1228|      1|    fn test_friction_curve_mud() {
 1229|      1|        let curve = FrictionCurve::mud();
 1230|       |        
 1231|      1|        assert!((curve.optimal_slip - 0.2).abs() < 0.01);
 1232|      1|        assert!(curve.peak_friction < FrictionCurve::gravel().peak_friction);
 1233|      1|    }
 1234|       |
 1235|       |    #[test]
 1236|      1|    fn test_friction_curve_defaults() {
 1237|      1|        let curve = FrictionCurve::default();
 1238|       |        
 1239|      1|        assert!(curve.optimal_slip > 0.0);
 1240|      1|        assert!(curve.peak_friction > 0.0);
 1241|      1|        assert!(curve.sliding_friction > 0.0);
 1242|      1|        assert!(curve.stiffness > 0.0);
 1243|      1|    }
 1244|       |
 1245|       |    #[test]
 1246|      1|    fn test_friction_rising_portion() {
 1247|      1|        let curve = FrictionCurve::tarmac();
 1248|       |        
 1249|       |        // Below optimal slip, friction should be increasing
 1250|      1|        let f1 = curve.friction_at_slip(0.02);
 1251|      1|        let f2 = curve.friction_at_slip(0.05);
 1252|      1|        assert!(f2 > f1);
 1253|      1|    }
 1254|       |
 1255|       |    #[test]
 1256|      1|    fn test_friction_falling_portion() {
 1257|      1|        let curve = FrictionCurve::tarmac();
 1258|       |        
 1259|       |        // Well above optimal slip, friction should be lower than peak
 1260|      1|        let peak = curve.friction_at_slip(curve.optimal_slip);
 1261|      1|        let high_slip = curve.friction_at_slip(0.5);
 1262|      1|        assert!(high_slip < peak);
 1263|      1|    }
 1264|       |
 1265|       |    #[test]
 1266|      1|    fn test_wheel_config_with_radius() {
 1267|      1|        let wheel = WheelConfig::default().with_radius(0.5);
 1268|      1|        assert!((wheel.radius - 0.5).abs() < 0.01);
 1269|      1|    }
 1270|       |
 1271|       |    #[test]
 1272|      1|    fn test_wheel_config_with_suspension() {
 1273|      1|        let wheel = WheelConfig::default().with_suspension(40000.0, 5000.0, 0.35);
 1274|      1|        assert!((wheel.suspension_stiffness - 40000.0).abs() < 0.01);
 1275|      1|        assert!((wheel.suspension_damping - 5000.0).abs() < 0.01);
 1276|      1|        assert!((wheel.suspension_rest_length - 0.35).abs() < 0.01);
 1277|      1|    }
 1278|       |
 1279|       |    #[test]
 1280|      1|    fn test_wheel_position_custom() {
 1281|      1|        let wheel = WheelConfig {
 1282|      1|            position_id: WheelPosition::Custom(5),
 1283|      1|            ..Default::default()
 1284|      1|        };
 1285|      1|        assert_eq!(wheel.position_id, WheelPosition::Custom(5));
 1286|      1|    }
 1287|       |
 1288|       |    #[test]
 1289|      1|    fn test_vehicle_config_mass() {
 1290|      1|        let config = VehicleConfig::default();
 1291|      1|        assert!(config.mass > 0.0);
 1292|      1|        assert!((config.mass - 1500.0).abs() < 0.1);
 1293|      1|    }
 1294|       |
 1295|       |    #[test]
 1296|      1|    fn test_vehicle_config_drag() {
 1297|      1|        let config = VehicleConfig::default();
 1298|      1|        assert!(config.drag_coefficient > 0.0);
 1299|      1|        assert!(config.frontal_area > 0.0);
 1300|      1|    }
 1301|       |
 1302|       |    #[test]
 1303|      1|    fn test_vehicle_config_brake_force() {
 1304|      1|        let config = VehicleConfig::default();
 1305|      1|        assert!(config.brake_force > 0.0);
 1306|      1|        assert!(config.handbrake_multiplier > 1.0);
 1307|      1|    }
 1308|       |
 1309|       |    #[test]
 1310|      1|    fn test_transmission_num_gears() {
 1311|      1|        let trans = TransmissionConfig::default();
 1312|      1|        assert_eq!(trans.num_gears(), 6);
 1313|      1|    }
 1314|       |
 1315|       |    #[test]
 1316|      1|    fn test_engine_idle_torque() {
 1317|      1|        let engine = EngineConfig::default();
 1318|      1|        let torque = engine.torque_at_rpm(engine.idle_rpm);
 1319|      1|        assert!(torque >= 0.0);
 1320|      1|    }
 1321|       |
 1322|       |    #[test]
 1323|      1|    fn test_vehicle_manager_get_nonexistent() {
 1324|      1|        let manager = VehicleManager::new();
 1325|      1|        assert!(manager.get(999).is_none());
 1326|      1|    }
 1327|       |
 1328|       |    #[test]
 1329|      1|    fn test_vehicle_shift_to_neutral() {
 1330|      1|        let config = VehicleConfig::default();
 1331|      1|        let mut vehicle = Vehicle::new(1, 42, config);
 1332|       |
 1333|       |        // Start in 1st, shift to neutral (0)
 1334|      1|        assert_eq!(vehicle.current_gear, 1);
 1335|      1|        vehicle.shift_down();
 1336|      1|        vehicle.shift_timer = 0.0; // Clear shift timer
 1337|      1|        assert_eq!(vehicle.current_gear, 0);
 1338|      1|    }
 1339|       |
 1340|       |    #[test]
 1341|      1|    fn test_vehicle_shift_to_reverse() {
 1342|      1|        let config = VehicleConfig::default();
 1343|      1|        let mut vehicle = Vehicle::new(1, 42, config);
 1344|       |
 1345|       |        // Shift from 1st to neutral to reverse
 1346|      1|        vehicle.shift_down();
 1347|      1|        vehicle.shift_timer = 0.0;
 1348|      1|        vehicle.shift_down();
 1349|      1|        vehicle.shift_timer = 0.0;
 1350|       |        
 1351|      1|        assert_eq!(vehicle.current_gear, -1);
 1352|      1|    }
 1353|       |
 1354|       |    #[test]
 1355|      1|    fn test_vehicle_shift_down_limit() {
 1356|      1|        let config = VehicleConfig::default();
 1357|      1|        let mut vehicle = Vehicle::new(1, 42, config);
 1358|       |
 1359|       |        // Shift all the way down
 1360|      6|        for _ in 0..5 {
 1361|      5|            vehicle.shift_down();
 1362|      5|            vehicle.shift_timer = 0.0;
 1363|      5|        }
 1364|       |
 1365|       |        // Should not go below -1
 1366|      1|        assert!(vehicle.current_gear >= -1);
 1367|      1|    }
 1368|       |
 1369|       |    #[test]
 1370|      1|    fn test_vehicle_shift_up_limit() {
 1371|      1|        let config = VehicleConfig::default();
 1372|      1|        let mut vehicle = Vehicle::new(1, 42, config);
 1373|       |
 1374|       |        // Shift all the way up
 1375|     11|        for _ in 0..10 {
 1376|     10|            vehicle.shift_up();
 1377|     10|            vehicle.shift_timer = 0.0;
 1378|     10|        }
 1379|       |
 1380|       |        // Should not exceed max gears
 1381|      1|        let max_gear = vehicle.config.transmission.num_gears() as i32;
 1382|      1|        assert!(vehicle.current_gear <= max_gear);
 1383|      1|    }
 1384|       |
 1385|       |    #[test]
 1386|      1|    fn test_vehicle_input_creation() {
 1387|      1|        let input = VehicleInput {
 1388|      1|            throttle: 0.8,
 1389|      1|            brake: 0.0,
 1390|      1|            steering: -0.5,
 1391|      1|            handbrake: 0.0,
 1392|      1|            clutch: 0.0,
 1393|      1|            shift: 1,
 1394|      1|        };
 1395|       |
 1396|      1|        assert!((input.throttle - 0.8).abs() < 0.01);
 1397|      1|        assert!((input.steering - -0.5).abs() < 0.01);
 1398|      1|        assert_eq!(input.shift, 1);
 1399|      1|    }
 1400|       |
 1401|       |    #[test]
 1402|      1|    fn test_wheel_state_contact_normal() {
 1403|      1|        let mut state = WheelState::default();
 1404|      1|        state.contact_normal = Vec3::new(0.0, 1.0, 0.0);
 1405|       |        
 1406|      1|        assert!((state.contact_normal.y - 1.0).abs() < 0.01);
 1407|      1|    }
 1408|       |
 1409|       |    #[test]
 1410|      1|    fn test_vehicle_manager_default() {
 1411|      1|        let manager = VehicleManager::default();
 1412|      1|        assert!(manager.vehicles().is_empty());
 1413|      1|    }
 1414|       |
 1415|       |    #[test]
 1416|      1|    fn test_vehicle_config_center_of_mass() {
 1417|      1|        let config = VehicleConfig::default();
 1418|       |        // Center of mass should be slightly below geometric center
 1419|      1|        assert!(config.center_of_mass_offset.y < 0.0);
 1420|      1|    }
 1421|       |
 1422|       |    #[test]
 1423|      1|    fn test_vehicle_config_steering_angle() {
 1424|      1|        let config = VehicleConfig::default();
 1425|       |        // Max steering angle should be reasonable (e.g., 30-45 degrees)
 1426|      1|        assert!(config.max_steering_angle > 0.4);
 1427|      1|        assert!(config.max_steering_angle < 1.0);
 1428|      1|    }
 1429|       |
 1430|       |    #[test]
 1431|      1|    fn test_vehicle_manager_spawn_and_get() {
 1432|      1|        let mut physics = PhysicsWorld::new(Vec3::new(0.0, -9.81, 0.0));
 1433|      1|        let mut manager = VehicleManager::new();
 1434|      1|        let config = VehicleConfig::default();
 1435|       |        
 1436|      1|        let id = manager.spawn(&mut physics, Vec3::ZERO, config);
 1437|      1|        assert_eq!(manager.vehicles().len(), 1);
 1438|      1|        assert!(manager.get(id).is_some());
 1439|      1|        assert!(manager.get_mut(id).is_some());
 1440|      1|    }
 1441|       |
 1442|       |    #[test]
 1443|      1|    fn test_vehicle_orientation_update() {
 1444|      1|        let config = VehicleConfig::default();
 1445|      1|        let mut vehicle = Vehicle::new(1, 42, config);
 1446|       |        
 1447|      1|        let rotation = Quat::from_rotation_y(std::f32::consts::FRAC_PI_2);
 1448|      1|        vehicle.update_orientation(rotation);
 1449|       |        
 1450|       |        // Forward should now be along X axis
 1451|      1|        assert!(vehicle.forward.x > 0.9);
 1452|      1|    }
 1453|       |
 1454|       |    #[test]
 1455|      1|    fn test_vehicle_slip_averages() {
 1456|      1|        let config = VehicleConfig::default();
 1457|      1|        let mut vehicle = Vehicle::new(1, 42, config);
 1458|       |        
 1459|       |        // Airborne case
 1460|      1|        assert_eq!(vehicle.average_slip_ratio(), 0.0);
 1461|      1|        assert_eq!(vehicle.average_slip_angle(), 0.0);
 1462|       |        
 1463|       |        // Grounded case
 1464|      1|        vehicle.wheels[0].grounded = true;
 1465|      1|        vehicle.wheels[0].slip_ratio = 0.5;
 1466|      1|        vehicle.wheels[0].slip_angle = 0.1;
 1467|       |        
 1468|      1|        assert!((vehicle.average_slip_ratio() - 0.5).abs() < 0.01);
 1469|      1|        assert!((vehicle.average_slip_angle() - 0.1).abs() < 0.01);
 1470|      1|    }
 1471|       |
 1472|       |    #[test]
 1473|      1|    fn test_engine_torque_falling_curve() {
 1474|      1|        let engine = EngineConfig {
 1475|      1|            max_torque: 400.0,
 1476|      1|            max_torque_rpm: 4000.0,
 1477|      1|            max_rpm: 6000.0,
 1478|      1|            idle_rpm: 1000.0,
 1479|      1|            ..Default::default()
 1480|      1|        };
 1481|       |        
 1482|       |        // In falling portion (between 4000 and 6000)
 1483|      1|        let torque = engine.torque_at_rpm(5000.0);
 1484|      1|        assert!(torque > 0.0 && torque < 400.0);
 1485|      1|    }
 1486|       |
 1487|       |    #[test]
 1488|      1|    fn test_vehicle_manager_update_logic() {
 1489|      1|        let mut physics = PhysicsWorld::new(Vec3::new(0.0, -9.81, 0.0));
 1490|      1|        let mut manager = VehicleManager::new();
 1491|      1|        let id = manager.spawn(&mut physics, Vec3::ZERO, VehicleConfig::default());
 1492|       |        
 1493|       |        // Update without input
 1494|      1|        manager.update(&mut physics, 0.016);
 1495|       |        
 1496|       |        // Update with input
 1497|      1|        let input = VehicleInput {
 1498|      1|            throttle: 1.0,
 1499|      1|            steering: 0.5,
 1500|      1|            shift: 1,
 1501|      1|            ..Default::default()
 1502|      1|        };
 1503|      1|        manager.update_with_input(id, &mut physics, &input, 0.016);
 1504|       |        
 1505|      1|        let vehicle = manager.get(id).unwrap();
 1506|      1|        assert_eq!(vehicle.current_gear, 2);
 1507|      1|    }
 1508|       |
 1509|       |    #[test]
 1510|      1|    fn test_vehicle_suspension_force() {
 1511|      1|        let config = VehicleConfig::default();
 1512|      1|        let mut vehicle = Vehicle::new(1, 42, config);
 1513|      1|        vehicle.wheels[0].suspension_force = 1000.0;
 1514|      1|        assert_eq!(vehicle.total_suspension_force(), 1000.0);
 1515|      1|    }
 1516|       |
 1517|       |    #[test]
 1518|      1|    fn test_friction_curves_all() {
 1519|      1|        let _ = FrictionCurve::gravel();
 1520|      1|        let _ = FrictionCurve::mud();
 1521|      1|        let _ = FrictionCurve::default();
 1522|      1|    }
 1523|       |
 1524|       |    #[test]
 1525|      1|    fn test_wheel_config_setters() {
 1526|      1|        let wheel = WheelConfig::default()
 1527|      1|            .with_radius(0.5)
 1528|      1|            .with_suspension(40000.0, 5000.0, 0.4);
 1529|      1|        assert_eq!(wheel.radius, 0.5);
 1530|      1|        assert_eq!(wheel.suspension_stiffness, 40000.0);
 1531|      1|    }
 1532|       |}

